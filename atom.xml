<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wxzhou&#39;s blog</title>
  
  <subtitle>Record some technical posts.</subtitle>
  <link href="https://wxzhou.top/atom.xml" rel="self"/>
  
  <link href="https://wxzhou.top/"/>
  <updated>2024-02-12T11:56:31.000Z</updated>
  <id>https://wxzhou.top/</id>
  
  <author>
    <name>wxzhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux云服务器故障排查（内存优化）</title>
    <link href="https://wxzhou.top/2023/08/20/Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5(%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96)/"/>
    <id>https://wxzhou.top/2023/08/20/Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5(%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96)/</id>
    <published>2023-08-20T07:51:44.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-内存占用"><a href="#1-内存占用" class="headerlink" title="1. 内存占用"></a>1. 内存占用</h2><ul><li>执行 <code>top</code> 命令查看系统的实时负载，进入 top 的实时界面后，默认按照 CPU 的使用率排序</li><li>通过 <code>shift + m</code> 按键将进程按照内存使用情况从大到小排序</li></ul><h2 id="2-Mysql-内存优化"><a href="#2-Mysql-内存优化" class="headerlink" title="2. Mysql 内存优化"></a>2. Mysql 内存优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL 在启动的时候，会占用一部分的内存来作为缓冲区，这样做的原因是可以优化查询速度，我们可以发现只要查询过一次 MySQL，</span><br><span class="line">然后用相同的语句再次查询，第二次查询会比第一次更快，这其中就用到了 MySQL 自身的缓存系统。</span><br><span class="line"></span><br><span class="line">MySQL 的缓存机制是当某一个连接访问某张表时，MySQL 会先检查访问的表是否在缓存区中，如果这张表已经在缓存区中打开，</span><br><span class="line">那就会直接访问缓存区从而加快查询速度，如果这张表不在缓存区，那就会从实际的数据库文件进行查询，然后再把这张表加入缓存区，以便后续查询加快速度。</span><br><span class="line"></span><br><span class="line">由于这个机制我们的 MySQL 在运行过程占用的内存会逐渐增加，而本系统查询频率并不多，我们要做的就是去掉 MySQL 用来加快查询的各种机制。</span><br></pre></td></tr></table></figure><h3 id="2-1-修改-my-cnf"><a href="#2-1-修改-my-cnf" class="headerlink" title="2.1 修改 my.cnf"></a>2.1 修改 my.cnf</h3><ul><li>可以使用 <code>mysql --help | grep &#39;my.cnf&#39;</code> 来查看默认加载的 <code>my.cnf</code> 目录，排序前的优先</li><li>使用vim打开排在第一个的<code>my.cnf</code>，加入如下内容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table_open_cache=200</span><br><span class="line">table_definition_cache=400</span><br><span class="line">performance_schema_max_table_instances=400</span><br><span class="line">performance_schema=off</span><br></pre></td></tr></table></figure></li><li>重启 MySQL：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Java-内存优化"><a href="#3-Java-内存优化" class="headerlink" title="3. Java 内存优化"></a>3. Java 内存优化</h2><h3 id="3-1-规定内存大小"><a href="#3-1-规定内存大小" class="headerlink" title="3.1 规定内存大小"></a>3.1 规定内存大小</h3><p>可以在 tomcat &#x2F;bin 目录下的 catalina.sh，设置 JAVA_OPTS 参数规定运行时内存使用情况。<br>因为 tomcat 容器里的 java 都是一些小项目和 demo，用不着分配这么多内存，所以只需分配很小内存即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot;$JAVA_OPTS -Xms64m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m&quot;</span><br></pre></td></tr></table></figure><p>参数详解：</p><ul><li>Xms：Java 虚拟机堆区内存初始内存分配的大小</li><li>Xmx：Java 虚拟机堆区内存初始内存分配的最大上限</li><li>Xmn：Java 虚拟机堆区内存初始内存分配的最小值</li><li>XX:PermSize：非堆区初始化内存分配大小</li><li>XX:MaxPermSize：非堆区分配的内存的最大上限</li><li>XX:MaxNewSize：新生代可被分配的内存的最大上限</li></ul><h3 id="3-2-回收-buffer-x2F-cache"><a href="#3-2-回收-buffer-x2F-cache" class="headerlink" title="3.2 回收 buffer&#x2F;cache"></a>3.2 回收 buffer&#x2F;cache</h3><ul><li>创建脚本 cleanCache.sh</li><li>添加内容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;开始清除缓存&quot;</span><br><span class="line">sync;sync;sync # 写入硬盘，防止数据丢失</span><br><span class="line">sleep 10 # 延迟10秒</span><br><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">echo 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure></li><li>打开权限：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x cleanCache.sh</span><br></pre></td></tr></table></figure></li><li>打开定时任务配置文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e # 弹出配置文件</span><br></pre></td></tr></table></figure></li><li>添加定时任务，每两小时执行一次<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 分　 时　 日　 月　 周　 命令</span><br><span class="line">0 */2 * * * ./cleanCache.sh</span><br></pre></td></tr></table></figure></li><li>设置 crond 启动以及开机自启<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start crond.service</span><br><span class="line">systemctl enable crond.service</span><br></pre></td></tr></table></figure></li><li>查看定时任务是否被执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/cron | grep cleanCache</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-内存占用&quot;&gt;&lt;a href=&quot;#1-内存占用&quot; class=&quot;headerlink&quot; title=&quot;1. 内存占用&quot;&gt;&lt;/a&gt;1. 内存占用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;执行 &lt;code&gt;top&lt;/code&gt; 命令查看系统的实时负载，进入 top 的实时界面后，</summary>
      
    
    
    
    <category term="Linux" scheme="https://wxzhou.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://wxzhou.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>解决IDEA配置.gitignore不生效的问题</title>
    <link href="https://wxzhou.top/2023/07/20/%E8%A7%A3%E5%86%B3IDEA%E9%85%8D%E7%BD%AE-gitignore%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://wxzhou.top/2023/07/20/%E8%A7%A3%E5%86%B3IDEA%E9%85%8D%E7%BD%AE-gitignore%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-07-20T11:05:29.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>当使用IDEA提交项目数据到git时, 即使配置了提交忽略文件.gitignore,也无法生效,提交文件中会出现杂乱配置文件,不知道你自己所更改了哪些项目位置,查看比较麻烦</p><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h3><p>.gitignore只能忽略未被track的文件，而git本地缓存。如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。</p><h3 id="3-解决方案："><a href="#3-解决方案：" class="headerlink" title="3. 解决方案："></a>3. 解决方案：</h3><p>解决方法就是先把本地缓存删除（改变成未track状态），然后再提交。使用以下几个命令即可快速解决</p><p>注意:以下命令需要在你项目中右键点击 Git Bash Here进行命令窗口输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;update .gitignore&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1. 问题&quot;&gt;&lt;/a&gt;1. 问题&lt;/h3&gt;&lt;p&gt;当使用IDEA提交项目数据到git时, 即使配置了提交忽略文件.gitignore,也无法生效,提交文件中会出现杂乱配置</summary>
      
    
    
    
    <category term="GIT" scheme="https://wxzhou.top/categories/GIT/"/>
    
    
    <category term="IDEA" scheme="https://wxzhou.top/tags/IDEA/"/>
    
    <category term="GIT" scheme="https://wxzhou.top/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>查看一台服务器上所有显卡上的使用者和GPU占用情况</title>
    <link href="https://wxzhou.top/2023/02/18/%E6%9F%A5%E7%9C%8B%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%89%80%E6%9C%89%E6%98%BE%E5%8D%A1%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%85%E5%92%8CGPU%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/"/>
    <id>https://wxzhou.top/2023/02/18/%E6%9F%A5%E7%9C%8B%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%89%80%E6%9C%89%E6%98%BE%E5%8D%A1%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%85%E5%92%8CGPU%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/</id>
    <published>2023-02-18T04:34:49.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装gpustat"><a href="#1-安装gpustat" class="headerlink" title="1.安装gpustat"></a>1.安装gpustat</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gpustat</span><br></pre></td></tr></table></figure><h2 id="2-安装完成后使用下面命令即可"><a href="#2-安装完成后使用下面命令即可" class="headerlink" title="2.安装完成后使用下面命令即可"></a>2.安装完成后使用下面命令即可</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n <span class="number">2</span> --color gpustat --c</span><br></pre></td></tr></table></figure><h2 id="3-查看显卡使用情况"><a href="#3-查看显卡使用情况" class="headerlink" title="3.查看显卡使用情况"></a>3.查看显卡使用情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-安装gpustat&quot;&gt;&lt;a href=&quot;#1-安装gpustat&quot; class=&quot;headerlink&quot; title=&quot;1.安装gpustat&quot;&gt;&lt;/a&gt;1.安装gpustat&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="Python" scheme="https://wxzhou.top/categories/Python/"/>
    
    
    <category term="Python" scheme="https://wxzhou.top/tags/Python/"/>
    
    <category term="Server" scheme="https://wxzhou.top/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>Linux下在文件夹所有文件中查找相关内容</title>
    <link href="https://wxzhou.top/2023/02/15/Linux%E4%B8%8B%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>https://wxzhou.top/2023/02/15/Linux%E4%B8%8B%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</id>
    <published>2023-02-15T07:51:44.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-使用grep"><a href="#1-使用grep" class="headerlink" title="1. 使用grep"></a>1. 使用grep</h2><h3 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h3><p>grep是在使用Linux时经常会用到的一个命令了，这个命令平时大都主要用来进行对一段输出的关键字定位，但是这个命令也可以通过使用某些参数来达到文件夹文件内容遍历的效果</p><h3 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -nr <span class="string">&quot;str&quot;</span> path</span><br></pre></td></tr></table></figure><h3 id="1-3-参数"><a href="#1-3-参数" class="headerlink" title="1.3 参数"></a>1.3 参数</h3><ul><li>grep: 就是grep命令</li><li>-nr: n是line number行号，r是recursive，可以理解为遍历文件文件夹</li><li>“str”: 双引号里面的str就是要查找的内容，用双引号何以使用空格和一些字符进行查找</li><li>path: path就是查找路径，默认是.&#x2F;，也就是当前目录开始，也可以手动指定目录</li></ul><h3 id="1-4-实例"><a href="#1-4-实例" class="headerlink" title="1.4 实例"></a>1.4 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -nr <span class="string">&quot;Welcome to the exchange link&quot;</span> /home/wxzhou/project/PhaGCN2/z2/hexo</span><br></pre></td></tr></table></figure><h3 id="1-5-优缺点"><a href="#1-5-优缺点" class="headerlink" title="1.5 优缺点"></a>1.5 优缺点</h3><ul><li>优点：命令简单方便，简短</li><li>缺点：会遍历所有文件，效率较低</li></ul><h2 id="2-使用find、xargs和grep配合"><a href="#2-使用find、xargs和grep配合" class="headerlink" title="2. 使用find、xargs和grep配合"></a>2. 使用find、xargs和grep配合</h2><h3 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h3><p>find是查找指令，用来查找文件的；xargs可以将标准输入作为另一个命令的参数；grep上面已经解释过了。那么，如果使用find来循环查找文件，使用他输出的文件名作为参数给xargs，xargs再将文件名作为grep的参数输入，使用grep来查找文件内容进行定位不久可以实现文件内容查找了吗</p><h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find path -name <span class="string">&quot;PATTEN&quot;</span> | xargs grep -n <span class="string">&quot;str&quot;</span> | grep <span class="string">&quot;str&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-参数"><a href="#2-3-参数" class="headerlink" title="2.3 参数"></a>2.3 参数</h3><ul><li>find、xargs、grep：上面已经讲过，分别是三个软件</li><li>name：就是通过名字查找，后面跟着的参数可以通过正则表达式类似的方法限定文件名</li><li>其他grep或者类似的参数据不赘述了</li></ul><h3 id="2-4-实例"><a href="#2-4-实例" class="headerlink" title="2.4 实例"></a>2.4 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/$USER/.config -name <span class="string">&quot;*.sh&quot;</span> | xargs grep <span class="string">&quot;/bin/bash&quot;</span> | grep <span class="string">&quot;/bin/bash&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-优缺点"><a href="#2-5-优缺点" class="headerlink" title="2.5 优缺点"></a>2.5 优缺点</h3><ul><li>优点：可以通过-name来限定文件名，从而减少grep查看文件内容的次数，提高效率</li><li>缺点：命令冗长，难记</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-使用grep&quot;&gt;&lt;a href=&quot;#1-使用grep&quot; class=&quot;headerlink&quot; title=&quot;1. 使用grep&quot;&gt;&lt;/a&gt;1. 使用grep&lt;/h2&gt;&lt;h3 id=&quot;1-1-说明&quot;&gt;&lt;a href=&quot;#1-1-说明&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Linux" scheme="https://wxzhou.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://wxzhou.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器环境安装</title>
    <link href="https://wxzhou.top/2023/02/15/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <id>https://wxzhou.top/2023/02/15/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</id>
    <published>2023-02-15T07:51:44.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux安装部署启动"><a href="#linux安装部署启动" class="headerlink" title="linux安装部署启动"></a>linux安装部署启动</h2><ul><li><p>系统环境需求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">阿里云CentOS8.2</span><br><span class="line">JDK &gt;= 1.8</span><br><span class="line">Tomcat &gt;= 9.0</span><br><span class="line">MySQL &gt;= 5.7</span><br><span class="line">Maven &gt;= 3.0</span><br><span class="line">Redis</span><br><span class="line">Node.js</span><br><span class="line">Nginx</span><br></pre></td></tr></table></figure></li><li><p>新建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#tmp存放临时安装包</span><br><span class="line">mkdir -p /data/tmp</span><br><span class="line"></span><br><span class="line">#service存放软件环境</span><br><span class="line">mkdir -p /data/service</span><br><span class="line"></span><br><span class="line">#gitee存放代码版本控制库</span><br><span class="line">mkdir -p /data/git</span><br><span class="line"></span><br><span class="line">#app存放部署程序</span><br><span class="line">mkdir -p /data/app</span><br></pre></td></tr></table></figure></li><li><p>开放 8080 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 检查防火墙状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"># running 表示防火墙是开启的，如果你看到的是 not running，防火墙关闭，需要开启</span><br><span class="line">systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line"># 开放 8080 端口</span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line"># 重新载入配置</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>JDK安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#将jdk安装包上传到/data/tmp文件夹中</span><br><span class="line">#进入安装包目录，解压</span><br><span class="line">cd /data/tmp</span><br><span class="line">tar -zxvf jdk-8u261-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">#把解压出来的文件夹转移到统一的地方</span><br><span class="line">mv /data/tmp/jdk1.8.0_261 /data/service/jdk1.8.0_261</span><br><span class="line"></span><br><span class="line">#修改环境变量/etc/profile，JAVA_HOME修改为自己的jdk路径。</span><br><span class="line">vim /etc/profile</span><br><span class="line">export JAVA_HOME=/data/service/jdk1.8.0_261</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">#使环境变量生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">#检查是否配置成功</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure></li><li><p>Tomcat安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#将Tomcat安装包上传到/data/tmp文件夹中</span><br><span class="line">#进入安装包目录，解压</span><br><span class="line">cd /data/tmp</span><br><span class="line">tar -zxvf apache-tomcat-9.0.34.tar.gz</span><br><span class="line"></span><br><span class="line">#把解压出来的文件夹转移到统一的地方</span><br><span class="line">mv /data/tmp/apache-tomcat-9.0.34 /data/service/apache-tomcat-9.0.34</span><br><span class="line"></span><br><span class="line">#启动Tomcat：进入目录/data/service/apache-tomcat-9.0.34/bin</span><br><span class="line">./startup.sh</span><br><span class="line"></span><br><span class="line">#关闭Tomcat</span><br><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure></li><li><p>Maven安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#进入安装包目录，解压</span><br><span class="line">cd /data/tmp</span><br><span class="line">tar -zxvf apache-maven-3.9.3-bin.tar.gz</span><br><span class="line">mv apache-maven-3.9.3 /data/service/</span><br><span class="line"></span><br><span class="line">#修改环境变量/etc/profile，MAVEN_HOME修改为自己的路径。</span><br><span class="line">vim /etc/profile</span><br><span class="line">export MAVEN_HOME=/data/service/apache-maven-3.9.3</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line"></span><br><span class="line">#使环境变量生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">#检查是否配置成功</span><br><span class="line">mvn -v</span><br></pre></td></tr></table></figure></li><li><p>Git安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 获取github最新的Git安装包下载链接，进入Linux服务器，执行下载，命令为： </span><br><span class="line">cd /data/tmp/</span><br><span class="line">wget https://github.com/git/git/archive/v2.17.0.tar.gz</span><br><span class="line"></span><br><span class="line"># 压缩包解压，命令为： </span><br><span class="line">tar -zxvf git-2.17.0.tar.gz</span><br><span class="line"></span><br><span class="line"># 移动文件夹</span><br><span class="line">mv /data/tmp/git-2.17.0 /data/service/git-2.17.0</span><br><span class="line"></span><br><span class="line"># 安装编译源码所需依赖，命令为：</span><br><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker </span><br><span class="line"></span><br><span class="line"># 安装依赖时，yum自动安装了Git，需要卸载旧版本Git，命令为： </span><br><span class="line">yum remove git</span><br><span class="line"></span><br><span class="line"># 进入解压后的文件夹，命令 </span><br><span class="line">cd /data/service/git-2.17.0 </span><br><span class="line"></span><br><span class="line"># 然后执行编译，命令为 </span><br><span class="line">make prefix=/usr/local/git all </span><br><span class="line"></span><br><span class="line"># 安装Git至/usr/local/git路径，命令为 </span><br><span class="line">make prefix=/usr/local/git install</span><br><span class="line"></span><br><span class="line"># 打开环境变量配置文件，命令 </span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"># 添加内容</span><br><span class="line"># git</span><br><span class="line">export GIT_HOME=/usr/local/git/</span><br><span class="line">export PATH=$PATH:$GIT_HOME/bin</span><br><span class="line"></span><br><span class="line"># 然后保存，退出，刷新</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">#检查是否配置成功</span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C &quot;wxzhou20@qq.com&quot;</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>MySQL安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 上传MySQL安装包到/data/tmp中</span><br><span class="line"># 解压缩</span><br><span class="line">tar -xvf mysql-8.0.20-1.el7.x86_64.rpm-bundle.tar</span><br><span class="line"> </span><br><span class="line"># 删除自带的 mariadb</span><br><span class="line">rpm -qa | grep mariadb</span><br><span class="line">rpm -e mariadb-libs-5.5.65-1.el7.x86_64 --nodeps</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">rpm -ivh mysql-community-common-8.0.20-1.el7.x86_64.rpm --nodeps --force</span><br><span class="line">rpm -ivh mysql-community-libs-8.0.20-1.el7.x86_64.rpm --nodeps --force</span><br><span class="line">rpm -ivh mysql-community-client-8.0.20-1.el7.x86_64.rpm --nodeps --force</span><br><span class="line">rpm -ivh mysql-community-server-8.0.20-1.el7.x86_64.rpm --nodeps --force</span><br><span class="line"></span><br><span class="line"># 初始化Mysql</span><br><span class="line">yum install -y libaio</span><br><span class="line">mysqld --initialize</span><br><span class="line"></span><br><span class="line"># 如果MySQL没有开启，可以使用如下代码开启</span><br><span class="line">service mysqld start</span><br><span class="line"></span><br><span class="line"># 授权防火墙</span><br><span class="line">chown mysql:mysql /var/lib/mysql -R;</span><br><span class="line">systemctl start mysqld.service;</span><br><span class="line">systemctl enable mysqld;</span><br><span class="line"></span><br><span class="line"># 查看数据库的初始化密码</span><br><span class="line">cat /var/log/mysqld.log | grep password</span><br><span class="line"></span><br><span class="line"># 登录数据库</span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"># 修改密码</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line"># 开启远程访问</span><br><span class="line">create user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 开放 3306 端口</span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">systemctl restart firewalld.service</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>Node.js安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar xf node-v14.15.4-linux-x64.tar.xz       // 解压</span><br><span class="line">cd node-v14.15.4-linux-x64/                 // 进入解压目录</span><br><span class="line">./bin/node -v                               // 执行node命令 查看版本</span><br><span class="line"></span><br><span class="line">//解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接：</span><br><span class="line">mv /data/tmp/node-v14.15.4-linux-x64 /data/service/</span><br><span class="line">ln -s /data/service/node-v14.15.4-linux-x64/bin/npm   /usr/local/bin/</span><br><span class="line">ln -s /data/service/node-v14.15.4-linux-x64/bin/node   /usr/local/bin/</span><br></pre></td></tr></table></figure></li><li><p>Nginx 安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#首先安装nginx前置软件</span><br><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br><span class="line"></span><br><span class="line">#下载nginx软件安装包</span><br><span class="line">cd /data/tmp</span><br><span class="line">wget http://nginx.org/download/nginx-1.19.6.tar.gz</span><br><span class="line">tar -zxvf nginx-1.19.6.tar.gz</span><br><span class="line">cd nginx-1.19.6</span><br><span class="line"></span><br><span class="line">#设置安装目录为/usr/local/nginx</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"># 启动nginx</span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>Redis 安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#下载Redis软件安装包</span><br><span class="line">cd /data/tmp</span><br><span class="line">wget http://download.redis.io/releases/redis-3.2.10.tar.gz</span><br><span class="line">tar -xzvf redis-3.2.10.tar.gz</span><br><span class="line">mv /data/tmp/redis-3.2.10 /data/service/redis-3.2.10</span><br><span class="line">cd /data/service/redis-3.2.10</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">make</span><br><span class="line">vim ./redis.conf</span><br><span class="line">(改动的位置：</span><br><span class="line"># 注释掉172.0.0.1（默认redis是只能内网127.0.0.1访问，如果想外网访问需要修改绑定的地址）</span><br><span class="line">61行：# bind 127.0.0.1</span><br><span class="line"># 关闭保护模式</span><br><span class="line">80行：protected-mode no</span><br><span class="line"># 设置redis可以一直在后台运行，以守护进程方式运行，即关闭SSH工具程序也在运行。</span><br><span class="line">128行：daemonize yes</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 启动redis服务</span><br><span class="line">/data/service/redis-3.2.10/src/redis-server /data/service/redis-3.2.10/redis.conf</span><br><span class="line"># 查看redis服务是否启动</span><br><span class="line">ps -ef | grep redis</span><br><span class="line"># 关闭redis进程</span><br><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure></li><li><p>Docker 安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 1、yum 包更新到最新 </span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"># 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"># 3、 设置yum源</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 4、 安装docker，出现输入的界面都按 y</span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"># 5、 查看docker版本，验证是否验证成功</span><br><span class="line">docker -v</span><br><span class="line"></span><br><span class="line"># 6. nacos安装</span><br><span class="line"># docker拉取镜像 </span><br><span class="line">docker pull nacos/nacos-server:1.2.0</span><br><span class="line"># 创建容器</span><br><span class="line">docker run -e JVM_XMS=100m -e JVM_XMX=100m -e MODE=standalone --name nacos --restart=always -d -p 8848:8848 nacos/nacos-server:1.2.0</span><br><span class="line"></span><br><span class="line"># 7. zookeeper安装</span><br><span class="line">docker pull zookeeper:3.4.14</span><br><span class="line">docker run --name zookeeper --restart=always -d -p 2181:2181 zookeeper:3.4.14</span><br><span class="line"></span><br><span class="line"># 8. kafka安装</span><br><span class="line">docker pull wurstmeister/kafka:2.12-2.3.1</span><br><span class="line"></span><br><span class="line">docker run -d --name kafka \</span><br><span class="line">--env KAFKA_ADVERTISED_HOST_NAME=47.114.141.103 \</span><br><span class="line">--env KAFKA_ZOOKEEPER_CONNECT=47.114.141.103:2181 \</span><br><span class="line">--env KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://47.114.141.103:9092 \</span><br><span class="line">--env KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \</span><br><span class="line">--env KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms256M&quot; \</span><br><span class="line">-p 9092:9092 wurstmeister/kafka:2.12-2.3.1</span><br><span class="line"></span><br><span class="line"># 9. es安装</span><br><span class="line">docker pull elasticsearch:7.4.0</span><br><span class="line">docker run -id --name elasticsearch -d --restart=always -p 9200:9200 -p 9300:9300 -v /usr/share/elasticsearch/plugins:/usr/share/elasticsearch/plugins -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; elasticsearch:7.4.0</span><br><span class="line"></span><br><span class="line"># 10. MongoDB安装</span><br><span class="line">docker pull mongo</span><br><span class="line"></span><br><span class="line">docker run -di --name mongo-service --restart=always -p 27017:27017 -v ~/data/mongodata:/data mongo</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 常见命令：</span><br><span class="line"># 如果docker没启动，使用下面命令启动</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 查看当前有些什么images</span><br><span class="line">docker images</span><br><span class="line"># 删除images（镜像）</span><br><span class="line">docker rmi &lt;image id&gt;</span><br><span class="line"></span><br><span class="line"># 查看所有运行或者不运行容器</span><br><span class="line">docker ps -a</span><br><span class="line"># 停止、启动、杀死、重启、删除一个容器</span><br><span class="line">docker stop Name或者ID  </span><br><span class="line">docker start Name或者ID  </span><br><span class="line">docker kill Name或者ID  </span><br><span class="line">docker restart name或者ID</span><br><span class="line">docker rm ID</span><br></pre></td></tr></table></figure></li><li><p>jenkins安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install daemonize</span><br><span class="line"></span><br><span class="line">cd /data/tmp/</span><br><span class="line">wget https://get.jenkins.io/redhat-stable/jenkins-2.319.3-1.1.noarch.rpm</span><br><span class="line">rpm -ivh jenkins-2.319.3-1.1.noarch.rpm</span><br><span class="line"></span><br><span class="line"># 修改Jenkins配置</span><br><span class="line">vim /etc/sysconfig/jenkins</span><br><span class="line"></span><br><span class="line"># jdk目录</span><br><span class="line">JENKINS_JAVA_CMD=&quot;/data/service/jdk1.8.0_261/bin/java&quot;</span><br><span class="line"># jenkins用户</span><br><span class="line">JENKINS_USER=&quot;root&quot;</span><br><span class="line"># jenkins端口</span><br><span class="line">JENKINS_PORT=&quot;16060&quot;</span><br><span class="line"></span><br><span class="line"># 设置权限</span><br><span class="line">chown -R root:root /var/lib/jenkins</span><br><span class="line">chown -R root:root /var/cache/jenkins</span><br><span class="line">chown -R root:root /var/log/jenkins</span><br><span class="line">        </span><br><span class="line"># 启动Jenkins</span><br><span class="line">systemctl start jenkins</span><br><span class="line">systemctl status jenkins</span><br><span class="line"></span><br><span class="line"># 获取账号密码</span><br><span class="line">cat /var/lib/jenkins/secrets/initialAdminPassword</span><br><span class="line"></span><br><span class="line"># 卸载</span><br><span class="line">rpm -e jenkins</span><br><span class="line">rm -rf /etc/sysconfig/jenkins.rpmsave</span><br><span class="line">rm -rf /var/cache/jenkins/</span><br><span class="line">rm -rf /var/lib/jenkins/</span><br><span class="line">rm -rf /var/log/jenkins</span><br><span class="line">rm -rf /usr/lib/jenkins</span><br><span class="line"></span><br><span class="line"># 插件网站</span><br><span class="line">http://updates.jenkins-ci.org/download/plugins/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;linux安装部署启动&quot;&gt;&lt;a href=&quot;#linux安装部署启动&quot; class=&quot;headerlink&quot; title=&quot;linux安装部署启动&quot;&gt;&lt;/a&gt;linux安装部署启动&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;系统环境需求&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="Linux" scheme="https://wxzhou.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://wxzhou.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch安装torch-geometric</title>
    <link href="https://wxzhou.top/2022/05/09/Pytorch%E5%AE%89%E8%A3%85torch-geometric/"/>
    <id>https://wxzhou.top/2022/05/09/Pytorch%E5%AE%89%E8%A3%85torch-geometric/</id>
    <published>2022-05-09T08:55:27.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步：在Pytorch中下载需要的版本"><a href="#第一步：在Pytorch中下载需要的版本" class="headerlink" title="第一步：在Pytorch中下载需要的版本"></a>第一步：在Pytorch中下载需要的版本</h2><p>链接：<a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a><br><code>e.g. torch == 1.7.1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CUDA 11.0</span></span><br><span class="line">pip install torch==<span class="number">1.7</span><span class="number">.1</span>+cu110 torchvision==<span class="number">0.8</span><span class="number">.2</span>+cu110 torchaudio==<span class="number">0.7</span><span class="number">.2</span> -f https://download.pytorch.org/whl/torch_stable.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># CUDA 10.2</span></span><br><span class="line">pip install torch==<span class="number">1.7</span><span class="number">.1</span> torchvision==<span class="number">0.8</span><span class="number">.2</span> torchaudio==<span class="number">0.7</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CUDA 10.1</span></span><br><span class="line">pip install torch==<span class="number">1.7</span><span class="number">.1</span>+cu101 torchvision==<span class="number">0.8</span><span class="number">.2</span>+cu101 torchaudio==<span class="number">0.7</span><span class="number">.2</span> -f https://download.pytorch.org/whl/torch_stable.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># CUDA 9.2</span></span><br><span class="line">pip install torch==<span class="number">1.7</span><span class="number">.1</span>+cu92 torchvision==<span class="number">0.8</span><span class="number">.2</span>+cu92 torchaudio==<span class="number">0.7</span><span class="number">.2</span> -f https://download.pytorch.org/whl/torch_stable.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU only</span></span><br><span class="line">pip install torch==<span class="number">1.7</span><span class="number">.1</span>+cpu torchvision==<span class="number">0.8</span><span class="number">.2</span>+cpu torchaudio==<span class="number">0.7</span><span class="number">.2</span> -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure><h2 id="第二步：根据自己下载的Torch、cuda、python版本，下载对应的torch-geometric-torch-sparse-torch-scatter-torch-cluster-torch-spline-conv。"><a href="#第二步：根据自己下载的Torch、cuda、python版本，下载对应的torch-geometric-torch-sparse-torch-scatter-torch-cluster-torch-spline-conv。" class="headerlink" title="第二步：根据自己下载的Torch、cuda、python版本，下载对应的torch-geometric, torch-sparse, torch-scatter, torch-cluster, torch-spline-conv。"></a>第二步：根据自己下载的Torch、cuda、python版本，下载对应的torch-geometric, torch-sparse, torch-scatter, torch-cluster, torch-spline-conv。</h2><p>链接：<a href="https://data.pyg.org/whl/">https://data.pyg.org/whl/</a><br><code>e.g. </code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果在第一步下载了torch==1.7.1+cu110，python=3.7，那么就在上述链接中选择对应版本的torch，然后再选择对应的包下载</span></span><br><span class="line"><span class="comment"># 下载之后尽可以进行安装</span></span><br><span class="line">pip install torch_cluster-<span class="number">1.5</span><span class="number">.8</span>-cp37-cp37m-linux_x86_64.whl</span><br><span class="line">pip install torch_scatter-<span class="number">2.0</span><span class="number">.5</span>-cp37-cp37m-linux_x86_64.whl</span><br><span class="line">pip install torch_sparse-<span class="number">0.6</span><span class="number">.8</span>-cp37-cp37m-linux_x86_64.whl</span><br><span class="line">pip install torch_spline_conv-<span class="number">1.2</span><span class="number">.0</span>-cp37-cp37m-linux_x86_64.whl</span><br><span class="line">pip install torch_geometric==<span class="number">1.7</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>完成！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一步：在Pytorch中下载需要的版本&quot;&gt;&lt;a href=&quot;#第一步：在Pytorch中下载需要的版本&quot; class=&quot;headerlink&quot; title=&quot;第一步：在Pytorch中下载需要的版本&quot;&gt;&lt;/a&gt;第一步：在Pytorch中下载需要的版本&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="Python" scheme="https://wxzhou.top/categories/Python/"/>
    
    
    <category term="Python" scheme="https://wxzhou.top/tags/Python/"/>
    
    <category term="Pytorch" scheme="https://wxzhou.top/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Pycharm远程debug服务器python</title>
    <link href="https://wxzhou.top/2022/04/29/Pycharm%E8%BF%9C%E7%A8%8Bdebug%E6%9C%8D%E5%8A%A1%E5%99%A8python/"/>
    <id>https://wxzhou.top/2022/04/29/Pycharm%E8%BF%9C%E7%A8%8Bdebug%E6%9C%8D%E5%8A%A1%E5%99%A8python/</id>
    <published>2022-04-29T03:03:06.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-第一步：设置服务器中的解释器"><a href="#1-第一步：设置服务器中的解释器" class="headerlink" title="1. 第一步：设置服务器中的解释器"></a>1. 第一步：设置服务器中的解释器</h2><h2 id="2-第二步：在服务器中安装pydevd"><a href="#2-第二步：在服务器中安装pydevd" class="headerlink" title="2. 第二步：在服务器中安装pydevd"></a>2. 第二步：在服务器中安装pydevd</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pydevd</span><br></pre></td></tr></table></figure><h2 id="3-第三步：在本地设置监听配置"><a href="#3-第三步：在本地设置监听配置" class="headerlink" title="3. 第三步：在本地设置监听配置"></a>3. 第三步：在本地设置监听配置</h2><p>run -&gt; Edit Configurations -&gt; “+” -&gt; Python Debug Server<br>右侧具体信息中填写三项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IDE host name: 本地IPv4的地址</span><br><span class="line">Port: 随便填一个，比如<span class="number">10000</span></span><br><span class="line">Path mapping: 本地对应服务器的映射</span><br><span class="line">最后Apply</span><br></pre></td></tr></table></figure><h2 id="4-第四步：将如下代码插入至远程计算机的应用程序中"><a href="#4-第四步：将如下代码插入至远程计算机的应用程序中" class="headerlink" title="4. 第四步：将如下代码插入至远程计算机的应用程序中"></a>4. 第四步：将如下代码插入至远程计算机的应用程序中</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入位置为需要Debug的地方</span></span><br><span class="line"><span class="keyword">import</span> pydevd</span><br><span class="line">    pydevd.settrace(<span class="string">&#x27;172.*.*.*&#x27;</span>, port=<span class="number">10000</span>, stdoutToServer=<span class="literal">True</span>, stderrToServer=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="5-第五步：在PyCharm中启动Debug-Server"><a href="#5-第五步：在PyCharm中启动Debug-Server" class="headerlink" title="5. 第五步：在PyCharm中启动Debug Server"></a>5. 第五步：在PyCharm中启动Debug Server</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-第一步：设置服务器中的解释器&quot;&gt;&lt;a href=&quot;#1-第一步：设置服务器中的解释器&quot; class=&quot;headerlink&quot; title=&quot;1. 第一步：设置服务器中的解释器&quot;&gt;&lt;/a&gt;1. 第一步：设置服务器中的解释器&lt;/h2&gt;&lt;h2 id=&quot;2-第二步：在</summary>
      
    
    
    
    <category term="Python" scheme="https://wxzhou.top/categories/Python/"/>
    
    
    <category term="Python" scheme="https://wxzhou.top/tags/Python/"/>
    
    <category term="Server" scheme="https://wxzhou.top/tags/Server/"/>
    
    <category term="Pycharm" scheme="https://wxzhou.top/tags/Pycharm/"/>
    
  </entry>
  
  <entry>
    <title>实验室服务器安装Anaconda环境</title>
    <link href="https://wxzhou.top/2022/02/09/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Anaconda%E7%8E%AF%E5%A2%83/"/>
    <id>https://wxzhou.top/2022/02/09/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Anaconda%E7%8E%AF%E5%A2%83/</id>
    <published>2022-02-09T05:56:25.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-使用MobaXterm登入"><a href="#1-使用MobaXterm登入" class="headerlink" title="1.使用MobaXterm登入"></a>1.使用MobaXterm登入</h2><p>下载软件，连接服务器之后，进入下一步。</p><h2 id="2-安装Anaconda"><a href="#2-安装Anaconda" class="headerlink" title="2.安装Anaconda"></a>2.安装Anaconda</h2><h3 id="（1）我们需要在官网上查找自己需要的版本，地址链接在下面"><a href="#（1）我们需要在官网上查找自己需要的版本，地址链接在下面" class="headerlink" title="（1）我们需要在官网上查找自己需要的版本，地址链接在下面:"></a>（1）我们需要在官网上查找自己需要的版本，地址链接在下面:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://repo.anaconda.com/archive/</span><br></pre></td></tr></table></figure><p>找到后进行安装（以我的为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><h3 id="（2）下载完成之后，进行安装，依次输入下面两条命令："><a href="#（2）下载完成之后，进行安装，依次输入下面两条命令：" class="headerlink" title="（2）下载完成之后，进行安装，依次输入下面两条命令："></a>（2）下载完成之后，进行安装，依次输入下面两条命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x Anaconda3-2020.11-Linux-x86_64.sh</span><br><span class="line">./Anaconda3-2020.11-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><h3 id="（3）点击enter，一直出现yes-or-no，输入yes；后面安装提示进行操作。"><a href="#（3）点击enter，一直出现yes-or-no，输入yes；后面安装提示进行操作。" class="headerlink" title="（3）点击enter，一直出现yes or no，输入yes；后面安装提示进行操作。"></a>（3）点击enter，一直出现yes or no，输入yes；后面安装提示进行操作。</h3><h3 id="（4）配置路径添加环境变量，依次输入下面两条命令："><a href="#（4）配置路径添加环境变量，依次输入下面两条命令：" class="headerlink" title="（4）配置路径添加环境变量，依次输入下面两条命令："></a>（4）配置路径添加环境变量，依次输入下面两条命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/$HOME/anaconda3/bin:$PATH&quot;</span><br><span class="line">export PATH=&quot;$PATH:$HOME/anaconda/bin&quot;</span><br></pre></td></tr></table></figure><h3 id="（5）检查是否安装完成："><a href="#（5）检查是否安装完成：" class="headerlink" title="（5）检查是否安装完成："></a>（5）检查是否安装完成：</h3><p>如图所示：</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd anaconda3</span><br><span class="line"># 切换到anaconda3目录下</span><br><span class="line">conda -V</span><br><span class="line"># 查看conda版本</span><br><span class="line">python -V</span><br><span class="line"># 查看python版本</span><br></pre></td></tr></table></figure><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><h3 id="（1）新建一个环境，设定python-version是3-8"><a href="#（1）新建一个环境，设定python-version是3-8" class="headerlink" title="（1）新建一个环境，设定python version是3.8"></a>（1）新建一个环境，设定python version是3.8</h3><p><code>conda create -n rl python=3.8</code></p><h3 id="（2）查看环境，激活环境，退出环境："><a href="#（2）查看环境，激活环境，退出环境：" class="headerlink" title="（2）查看环境，激活环境，退出环境："></a>（2）查看环境，激活环境，退出环境：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看环境</span><br><span class="line">conda info --envs</span><br><span class="line"># 激活环境</span><br><span class="line">conda activate rl</span><br><span class="line"># 退出环境</span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-使用MobaXterm登入&quot;&gt;&lt;a href=&quot;#1-使用MobaXterm登入&quot; class=&quot;headerlink&quot; title=&quot;1.使用MobaXterm登入&quot;&gt;&lt;/a&gt;1.使用MobaXterm登入&lt;/h2&gt;&lt;p&gt;下载软件，连接服务器之后，进入下一步</summary>
      
    
    
    
    <category term="Python" scheme="https://wxzhou.top/categories/Python/"/>
    
    
    <category term="Python" scheme="https://wxzhou.top/tags/Python/"/>
    
    <category term="Server" scheme="https://wxzhou.top/tags/Server/"/>
    
    <category term="Anaconda" scheme="https://wxzhou.top/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>kafka-01-概念</title>
    <link href="https://wxzhou.top/2021/06/08/kafka-01-%E6%A6%82%E5%BF%B5/"/>
    <id>https://wxzhou.top/2021/06/08/kafka-01-%E6%A6%82%E5%BF%B5/</id>
    <published>2021-06-08T11:50:53.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-kafka是什么，应用场景有哪些"><a href="#1-kafka是什么，应用场景有哪些" class="headerlink" title="1. kafka是什么，应用场景有哪些"></a>1. kafka是什么，应用场景有哪些</h2><h3 id="1-1-Kafka是一个分布式流式处理平台。"><a href="#1-1-Kafka是一个分布式流式处理平台。" class="headerlink" title="1.1 Kafka是一个分布式流式处理平台。"></a>1.1 Kafka是一个分布式流式处理平台。</h3><p>流平台具有三个关键功能：</p><ul><li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息<br>队列的原因。</li><li><strong>容错的持久方式存储记录消息流</strong>： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的<br>风险。</li><li><strong>流式处理平台</strong>： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li></ul><h3 id="1-2-Kafka主要有两大应用场景："><a href="#1-2-Kafka主要有两大应用场景：" class="headerlink" title="1.2 Kafka主要有两大应用场景："></a>1.2 Kafka主要有两大应用场景：</h3><ul><li><strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li><strong>数据处理</strong>： 构建实时的流数据处理程序来转换或处理数据流。</li></ul><h2 id="2-和其他消息队列相比-Kafka-的优势在哪里？"><a href="#2-和其他消息队列相比-Kafka-的优势在哪里？" class="headerlink" title="2. 和其他消息队列相比,Kafka 的优势在哪里？"></a>2. 和其他消息队列相比,Kafka 的优势在哪里？</h2><ul><li><strong>极致的性能</strong>：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li><li><strong>生态系统兼容性无可匹敌</strong>：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li></ul><h2 id="3-什么是-Producer、Consumer、Broker、Topic、Partition？"><a href="#3-什么是-Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="3. 什么是 Producer、Consumer、Broker、Topic、Partition？"></a>3. 什么是 Producer、Consumer、Broker、Topic、Partition？</h2><h3 id="3-1-几个概念："><a href="#3-1-几个概念：" class="headerlink" title="3.1 几个概念："></a>3.1 几个概念：</h3><ul><li><strong>Producer</strong>（生产者）: 产生消息的一方。</li><li><strong>Consumer</strong>（消费者）: 消费消息的一方。</li><li><strong>Broker</strong>（代理）: 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个Kafka Cluster。</li><li><strong>Topic</strong>（主题）: Producer 将消息发送到特定的主题，Consumer 通过订阅特定的Topic(主题) 来消费消息。</li><li><strong>Partition</strong>（分区） : Partition 属于 Topic 的一部分。一个 Topic 可以有多个Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一<br>个 Topic 可以横跨多个Broker 。这正如我上面所画的图一样。</li></ul><h3 id="3-2-大概流程："><a href="#3-2-大概流程：" class="headerlink" title="3.2 大概流程："></a>3.2 大概流程：</h3><ul><li>Kafka 将生产者发布的消息发送到Topic（主题）中，需要这些消息的消费者可以订阅这些Topic（主题）;</li><li>每个Topic被切分成若干个part放入不同的分区中，比如Topic A分成A1、A2、A3分成三部分，分别放入放入P1、P2、P3中;</li><li>不同的分区可以存放在不同的Broker中，也可以存放在相同的Broker中，比如{“B1”:”P1”, “B2”:”P2,P3”}、{“B1”:”P1,P2”, “B2”:”P3”}等；</li><li>同一个分区有多个副本（Replica），这些副本都是相同的，每个Broker中存放一个分区的副本；</li><li>同一个分区的副本可以分为两种：leader副本、follower副本（又可以分为ISR副本和普通副本），我们发送的消息会被发送到<br>leader副本，然后follower副本才能从leader副本中拉取消息进行保存，ISR是同步保存leader副本，普通副本是异步保存leader副本。</li></ul><p><img src="/2021/06/08/kafka-01-%E6%A6%82%E5%BF%B5/1.png"></p><h2 id="4-Kafka-的多副本机制"><a href="#4-Kafka-的多副本机制" class="headerlink" title="4. Kafka 的多副本机制"></a>4. Kafka 的多副本机制</h2><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。<br>分区（Partition）中的多个副本之间一个叫做 leader，其他副本称为follower。<br>我们发送的消息会被发送到leader 副本，然后follower副本才能从 leader 副本中拉取消息进行保存同步。<br>生产者和消费者只与leader副本交互。其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。<br>当leader副本发生故障时会从follower中选举出一个leader，优先从ISR中选举一个follower为leader。</p><h2 id="5-Kafka-的多分区（Partition）以及多副本（Replica）机制有什么好处呢？"><a href="#5-Kafka-的多分区（Partition）以及多副本（Replica）机制有什么好处呢？" class="headerlink" title="5. Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？"></a>5. Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</h2><ul><li>Kafka通过给特定Topic指定多个Partition, 而各个Partition可以分布在不同的Broker上, 这样便能提供比较好的并发能力（负载均衡）。</li><li>Partition可以指定对应的Replica数量, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ul><h2 id="6-Kafka-如何保证消息的消费顺序？"><a href="#6-Kafka-如何保证消息的消费顺序？" class="headerlink" title="6. Kafka 如何保证消息的消费顺序？"></a>6. Kafka 如何保证消息的消费顺序？</h2><p>这个问题可以从两个方面来回答：kafka 为什么会存在无序消费、kafka 如何保证有序消费。</p><p>首先，在 kafka 的架构里面，用到了 Partition 分区机制来实现消息的物理存储，<br>在同一个 topic 下面，可以维护多个 partition 来实现消息的分片。<br>生产者在发送消息的时候，会根据消息的 key 进行取模，来决定把当前消息存储到哪个 partition 里面，<br>并且消息是按照先后顺序有序存储到 partition 里面的。<br>在这种情况下，假设有一个 topic 存在三个 partition，消息的消费顺序不是按照发送顺序来实现的，从而导致乱序的问题。</p><p>第一种保证消息消费顺序的方法：1 个Topic只对应一个Partition。</p><p>第二种保证消息消费顺序的方法：Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key, data（数据） 4 个参数。<br>如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。</p><p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p><ul><li>1 个 Topic 只对应一个 Partition。</li><li>发送消息的时候指定 key&#x2F;Partition。</li></ul><h2 id="7-kafka-如何保证消息不丢失？"><a href="#7-kafka-如何保证消息不丢失？" class="headerlink" title="7. kafka 如何保证消息不丢失？"></a>7. kafka 如何保证消息不丢失？</h2><ul><li>kafka 是一个用来实现异步消息通信的中间件，它的整个架构由Producer、Consumer、Broker 组成。所以，对于 kafka 如何保证消息不丢失这个问题，可以从三个方面来考虑和实现。</li><li>首先是 <strong>Producer</strong> 端，需要确保消息能够到达 Broker 并实现消息存储，在这个层面，有可能出现网络问题，导致消息发送失败，所以，针对 Producer 端，可以通过2种方式来避免消息丢失<ul><li>Producer 默认是异步发送消息，这种情况下要确保消息发送成功，有两个方法<ul><li>把异步发送改成同步发送，这样 producer 就能实时知道消息发送的结果。</li><li>添加异步回调函数来监听消息发送的结果，如果发送失败，可以在回调中重试。</li></ul></li><li>Producer 本身提供了一个重试参数 retries，如果因为网络问题或者Broker 故障导致发送失败，Producer 会自动重试。</li></ul></li><li>然后是 <strong>Broker</strong> 端，Broker 需要确保 Producer 发送过来的消息不会丢失，也就是只需要把消息持久化到磁盘就可以了。</li><li>最后是 <strong>Consumer</strong> 端，消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。<br>偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。<br>Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。<br>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有<br>一个问题，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息<br>实际上并没有被消费，但是 offset 却被自动提交了。<br>解决办法是，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己<br>手动提交 offset。 但是，这样会带来消息被重新消费的问题。比如<br>消费者刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费<br>两次。</li></ul><h2 id="8-Kafka-中一个-Topic-有三个Partition，同一个消费组中两个消费者如何消费的？"><a href="#8-Kafka-中一个-Topic-有三个Partition，同一个消费组中两个消费者如何消费的？" class="headerlink" title="8. Kafka 中一个 Topic 有三个Partition，同一个消费组中两个消费者如何消费的？"></a>8. Kafka 中一个 Topic 有三个Partition，同一个消费组中两个消费者如何消费的？</h2><p>这个问题涉及到Kafka里面的Consumer Group Coordinator ，也就是消费组协调器。<br>它会根据消费者订阅的 Topic 中的 partition 数量、和消费组中的消费者实例数量来决定每个消费者消费哪些 Partition。<br>这个算法会在消费组中选择一个消费者实例作为 Leader，Leader 负责分配 Partition 给消费者实例，<br>并协调消费者实例之间的Partition分配和reblance。<br>当一个消费者实例加入或离开消费组的时候，协调器会触发 Partition 的重新分配，<br>确保所有 Partition 都能被消费者实例均匀地消费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-kafka是什么，应用场景有哪些&quot;&gt;&lt;a href=&quot;#1-kafka是什么，应用场景有哪些&quot; class=&quot;headerlink&quot; title=&quot;1. kafka是什么，应用场景有哪些&quot;&gt;&lt;/a&gt;1. kafka是什么，应用场景有哪些&lt;/h2&gt;&lt;h3 id=</summary>
      
    
    
    
    <category term="kafka" scheme="https://wxzhou.top/categories/kafka/"/>
    
    
    <category term="kafka" scheme="https://wxzhou.top/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>面试-kafka</title>
    <link href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-kafka/"/>
    <id>https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-kafka/</id>
    <published>2021-06-08T11:50:53.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-kafka是什么，应用场景有哪些"><a href="#1-kafka是什么，应用场景有哪些" class="headerlink" title="1. kafka是什么，应用场景有哪些"></a>1. kafka是什么，应用场景有哪些</h2><h3 id="1-1-Kafka是一个分布式流式处理平台。"><a href="#1-1-Kafka是一个分布式流式处理平台。" class="headerlink" title="1.1 Kafka是一个分布式流式处理平台。"></a>1.1 Kafka是一个分布式流式处理平台。</h3><p>流平台具有三个关键功能：</p><ul><li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息<br>队列的原因。</li><li><strong>容错的持久方式存储记录消息流</strong>： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的<br>风险。</li><li><strong>流式处理平台</strong>： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li></ul><h3 id="1-2-Kafka主要有两大应用场景："><a href="#1-2-Kafka主要有两大应用场景：" class="headerlink" title="1.2 Kafka主要有两大应用场景："></a>1.2 Kafka主要有两大应用场景：</h3><ul><li><strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li><strong>数据处理</strong>： 构建实时的流数据处理程序来转换或处理数据流。</li></ul><h2 id="2-和其他消息队列相比-Kafka-的优势在哪里？"><a href="#2-和其他消息队列相比-Kafka-的优势在哪里？" class="headerlink" title="2. 和其他消息队列相比,Kafka 的优势在哪里？"></a>2. 和其他消息队列相比,Kafka 的优势在哪里？</h2><ul><li><strong>极致的性能</strong>：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li><li><strong>生态系统兼容性无可匹敌</strong>：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li></ul><h2 id="3-什么是-Producer、Consumer、Broker、Topic、Partition？"><a href="#3-什么是-Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="3. 什么是 Producer、Consumer、Broker、Topic、Partition？"></a>3. 什么是 Producer、Consumer、Broker、Topic、Partition？</h2><h3 id="3-1-几个概念："><a href="#3-1-几个概念：" class="headerlink" title="3.1 几个概念："></a>3.1 几个概念：</h3><ul><li><strong>Producer</strong>（生产者）: 产生消息的一方。</li><li><strong>Consumer</strong>（消费者）: 消费消息的一方。</li><li><strong>Broker</strong>（代理）: 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个Kafka Cluster。</li><li><strong>Topic</strong>（主题）: Producer 将消息发送到特定的主题，Consumer 通过订阅特定的Topic(主题) 来消费消息。</li><li><strong>Partition</strong>（分区） : Partition 属于 Topic 的一部分。一个 Topic 可以有多个Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一<br>个 Topic 可以横跨多个Broker 。这正如我上面所画的图一样。</li></ul><h3 id="3-2-大概流程："><a href="#3-2-大概流程：" class="headerlink" title="3.2 大概流程："></a>3.2 大概流程：</h3><ul><li>Kafka 将生产者发布的消息发送到Topic（主题）中，需要这些消息的消费者可以订阅这些Topic（主题）;</li><li>每个Topic被切分成若干个part放入不同的分区中，比如Topic A分成A1、A2、A3分成三部分，分别放入放入P1、P2、P3中;</li><li>不同的分区可以存放在不同的Broker中，也可以存放在相同的Broker中，比如{“B1”:”P1”, “B2”:”P2,P3”}、{“B1”:”P1,P2”, “B2”:”P3”}等；</li><li>同一个分区有多个副本（Replica），这些副本都是相同的，每个Broker中存放一个分区的副本；</li><li>同一个分区的副本可以分为两种：leader副本、follower副本（又可以分为ISR副本和普通副本），我们发送的消息会被发送到<br>leader副本，然后follower副本才能从leader副本中拉取消息进行保存，ISR是同步保存leader副本，普通副本是异步保存leader副本。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-kafka/1.png"></p><h2 id="4-Kafka-的多副本机制"><a href="#4-Kafka-的多副本机制" class="headerlink" title="4. Kafka 的多副本机制"></a>4. Kafka 的多副本机制</h2><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。<br>分区（Partition）中的多个副本之间一个叫做 leader，其他副本称为follower。<br>我们发送的消息会被发送到leader 副本，然后follower副本才能从 leader 副本中拉取消息进行保存同步。<br>生产者和消费者只与leader副本交互。其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。<br>当leader副本发生故障时会从follower中选举出一个leader，优先从ISR中选举一个follower为leader。</p><h2 id="5-Kafka-的多分区（Partition）以及多副本（Replica）机制有什么好处呢？"><a href="#5-Kafka-的多分区（Partition）以及多副本（Replica）机制有什么好处呢？" class="headerlink" title="5. Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？"></a>5. Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</h2><ul><li>Kafka通过给特定Topic指定多个Partition, 而各个Partition可以分布在不同的Broker上, 这样便能提供比较好的并发能力（负载均衡）。</li><li>Partition可以指定对应的Replica数量, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ul><h2 id="6-Kafka-如何保证消息的消费顺序？"><a href="#6-Kafka-如何保证消息的消费顺序？" class="headerlink" title="6. Kafka 如何保证消息的消费顺序？"></a>6. Kafka 如何保证消息的消费顺序？</h2><p>这个问题可以从两个方面来回答：kafka 为什么会存在无序消费、kafka 如何保证有序消费。</p><p>首先，在 kafka 的架构里面，用到了 Partition 分区机制来实现消息的物理存储，<br>在同一个 topic 下面，可以维护多个 partition 来实现消息的分片。<br>生产者在发送消息的时候，会根据消息的 key 进行取模，来决定把当前消息存储到哪个 partition 里面，<br>并且消息是按照先后顺序有序存储到 partition 里面的。<br>在这种情况下，假设有一个 topic 存在三个 partition，消息的消费顺序不是按照发送顺序来实现的，从而导致乱序的问题。</p><p>第一种保证消息消费顺序的方法：1 个Topic只对应一个Partition。</p><p>第二种保证消息消费顺序的方法：Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key, data（数据） 4 个参数。<br>如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。</p><p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p><ul><li>1 个 Topic 只对应一个 Partition。</li><li>发送消息的时候指定 key&#x2F;Partition。</li></ul><h2 id="7-kafka-如何保证消息不丢失？"><a href="#7-kafka-如何保证消息不丢失？" class="headerlink" title="7. kafka 如何保证消息不丢失？"></a>7. kafka 如何保证消息不丢失？</h2><ul><li>kafka 是一个用来实现异步消息通信的中间件，它的整个架构由Producer、Consumer、Broker 组成。所以，对于 kafka 如何保证消息不丢失这个问题，可以从三个方面来考虑和实现。</li><li>首先是 <strong>Producer</strong> 端，需要确保消息能够到达 Broker 并实现消息存储，在这个层面，有可能出现网络问题，导致消息发送失败，所以，针对 Producer 端，可以通过2种方式来避免消息丢失<ul><li>Producer 默认是异步发送消息，这种情况下要确保消息发送成功，有两个方法<ul><li>把异步发送改成同步发送，这样 producer 就能实时知道消息发送的结果。</li><li>添加异步回调函数来监听消息发送的结果，如果发送失败，可以在回调中重试。</li></ul></li><li>Producer 本身提供了一个重试参数 retries，如果因为网络问题或者Broker 故障导致发送失败，Producer 会自动重试。</li></ul></li><li>然后是 <strong>Broker</strong> 端，Broker 需要确保 Producer 发送过来的消息不会丢失，也就是只需要把消息持久化到磁盘就可以了。</li><li>最后是 <strong>Consumer</strong> 端，消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。<br>偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。<br>Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。<br>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有<br>一个问题，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息<br>实际上并没有被消费，但是 offset 却被自动提交了。<br>解决办法是，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己<br>手动提交 offset。 但是，这样会带来消息被重新消费的问题。比如<br>消费者刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费<br>两次。</li></ul><h2 id="8-Kafka-中一个-Topic-有三个Partition，同一个消费组中两个消费者如何消费的？"><a href="#8-Kafka-中一个-Topic-有三个Partition，同一个消费组中两个消费者如何消费的？" class="headerlink" title="8. Kafka 中一个 Topic 有三个Partition，同一个消费组中两个消费者如何消费的？"></a>8. Kafka 中一个 Topic 有三个Partition，同一个消费组中两个消费者如何消费的？</h2><p>这个问题涉及到Kafka里面的Consumer Group Coordinator ，也就是消费组协调器。<br>它会根据消费者订阅的 Topic 中的 partition 数量、和消费组中的消费者实例数量来决定每个消费者消费哪些 Partition。<br>这个算法会在消费组中选择一个消费者实例作为 Leader，Leader 负责分配 Partition 给消费者实例，<br>并协调消费者实例之间的Partition分配和reblance。<br>当一个消费者实例加入或离开消费组的时候，协调器会触发 Partition 的重新分配，<br>确保所有 Partition 都能被消费者实例均匀地消费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-kafka是什么，应用场景有哪些&quot;&gt;&lt;a href=&quot;#1-kafka是什么，应用场景有哪些&quot; class=&quot;headerlink&quot; title=&quot;1. kafka是什么，应用场景有哪些&quot;&gt;&lt;/a&gt;1. kafka是什么，应用场景有哪些&lt;/h2&gt;&lt;h3 id=</summary>
      
    
    
    
    <category term="面试" scheme="https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试-Java</title>
    <link href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/"/>
    <id>https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/</id>
    <published>2021-06-08T11:50:53.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java-语言的特点"><a href="#1-Java-语言的特点" class="headerlink" title="1. Java 语言的特点"></a>1. Java 语言的特点</h2><ul><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>支持多线程；</li><li>可靠性（具备异常处理和自动内存管理机制）；</li><li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；</li><li>高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；</li><li>支持网络编程并且很方便；</li><li>编译与解释并存；</li><li>强大的生态；</li></ul><h2 id="2-JVM、-JDK、-JRE"><a href="#2-JVM、-JDK、-JRE" class="headerlink" title="2. JVM、 JDK、 JRE"></a>2. JVM、 JDK、 JRE</h2><h3 id="2-1-JVM：Java-Virtual-Machine，Java虚拟机"><a href="#2-1-JVM：Java-Virtual-Machine，Java虚拟机" class="headerlink" title="2.1 JVM：Java Virtual Machine，Java虚拟机"></a>2.1 JVM：Java Virtual Machine，Java虚拟机</h3><ul><li>JVM是Java程序的运行环境，它能够执行Java程序编译后的字节码文件。JVM是运行Java程序的核心，因为Java程序必须在JVM上运行才能执行。</li><li>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言“一次编译，随处可以运行”(Write Once, Run Anywhere)的关键所在。</li></ul><h3 id="2-1-JDK：Java-Development-Kit"><a href="#2-1-JDK：Java-Development-Kit" class="headerlink" title="2.1 JDK：Java Development Kit"></a>2.1 JDK：Java Development Kit</h3><ul><li>它是功能齐全的 Java SDK，是提供给开发者使用的，能够创建和编译 Java 程序。</li><li>JDK包含了JRE，同时还包含了javac（编译 java 源码的编译器）、javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</li></ul><h3 id="2-3-JRE（Java-Runtime-Environment）"><a href="#2-3-JRE（Java-Runtime-Environment）" class="headerlink" title="2.3 JRE（Java Runtime Environment）"></a>2.3 JRE（Java Runtime Environment）</h3><ul><li>JRE是 Java 运行时环境。</li><li>它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/1.png"></p><h2 id="3-字节码"><a href="#3-字节码" class="headerlink" title="3. 字节码"></a>3. 字节码</h2><ul><li><strong>JVM可以理解的代码</strong>就叫做字节码（即扩展名为 <strong>.class</strong> 的文件），它不面向任何特定的处理器，<strong>只面向虚拟机</strong>。</li><li>Java 语言通过字节码的方式，在一定程度上<strong>解决了传统解释型语言执行效率低</strong>的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的，而且，由于字节码并不针对一种特定的机器，因此，Java 程序<strong>无须重新编译便可在多种不同操作系统的计算机上运行</strong>。</li><li>.class -&gt; 机器码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</span><br><span class="line">而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，</span><br><span class="line">所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。</span><br><span class="line">当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</span><br></pre></td></tr></table></figure><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/2.png"></li></ul><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h2><ul><li>单行注释：通常用于解释方法内某单行代码的作用。</li><li>多行注释：通常用于解释一段代码的作用。</li><li>文档注释：通常用于生成 Java 开发文档。</li></ul><h2 id="5-标识符和关键字"><a href="#5-标识符和关键字" class="headerlink" title="5. 标识符和关键字"></a>5. 标识符和关键字</h2><ul><li>标识符：就是一个名字，比如为程序、类、变量、方法等取名字；</li><li>关键字：被赋予特殊含义的标识符，比如private、protected、public等。</li></ul><h2 id="6-自增自减运算符"><a href="#6-自增自减运算符" class="headerlink" title="6. 自增自减运算符"></a>6. 自增自减运算符</h2><ul><li>自增运算符(++)和自减运算符(–)</li><li>当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。</li></ul><h2 id="7-移位运算符"><a href="#7-移位运算符" class="headerlink" title="7. 移位运算符"></a>7. 移位运算符</h2><ul><li>&lt;&lt; : 左移运算符，向左移若干位，高位丢弃，低位补零。x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下)。</li><li><blockquote><blockquote><p>: 带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x &gt;&gt; 1,相当于 x 除以 2。</p></blockquote></blockquote></li><li><blockquote><blockquote><blockquote><p>: 无符号右移，忽略符号位，空位都以 0 补齐。</p></blockquote></blockquote></blockquote></li></ul><h2 id="8-continue、break-和-return-的区别"><a href="#8-continue、break-和-return-的区别" class="headerlink" title="8. continue、break 和 return 的区别"></a>8. continue、break 和 return 的区别</h2><ul><li>continue：指跳出当前的这一次循环，继续下一次循环。</li><li>break：指跳出整个循环体，继续执行循环下面的语句。</li><li>return：用于跳出所在方法，结束该方法的运行。</li></ul><h2 id="9-基本数据类型"><a href="#9-基本数据类型" class="headerlink" title="9. 基本数据类型"></a>9. 基本数据类型</h2><p><strong>8 种基本数据类型</strong></p><ul><li>6 种数字类型：<ul><li>4 种整数型：byte(1)、short(2)、int(4)、long(8)</li><li>2 种浮点型：float(4)、double(8)</li></ul></li><li>1 种字符类型：char(2)</li><li>1 种布尔型：boolean</li></ul><h2 id="10-基本类型和包装类型的区别"><a href="#10-基本类型和包装类型的区别" class="headerlink" title="10. 基本类型和包装类型的区别"></a>10. 基本类型和包装类型的区别</h2><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型），基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是null。</li><li><strong>比较方式</strong>：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。</li></ul><h2 id="11-包装类型的缓存机制"><a href="#11-包装类型的缓存机制" class="headerlink" title="11. 包装类型的缓存机制"></a>11. 包装类型的缓存机制</h2><ul><li>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</li><li>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据；</li><li>Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False；</li><li>两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。</li></ul><h2 id="12-自动装箱与拆箱是什么，原理是什么"><a href="#12-自动装箱与拆箱是什么，原理是什么" class="headerlink" title="12. 自动装箱与拆箱是什么，原理是什么"></a>12. 自动装箱与拆箱是什么，原理是什么</h2><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 10;  //装箱</span><br><span class="line">int n = i;   //拆箱</span><br></pre></td></tr></table></figure></li><li>原理：从字节码中，我们发现<strong>装箱</strong>其实就是调用了包装类的valueOf()方法，<strong>拆箱</strong>其实就是调用了 xxxValue()方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 10 等价于 Integer i = Integer.valueOf(10)</span><br><span class="line">int n = i 等价于 int n = i.intValue();</span><br></pre></td></tr></table></figure></li><li>注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</li></ul><h2 id="13-为什么浮点数运算的时候会有精度丢失的风险"><a href="#13-为什么浮点数运算的时候会有精度丢失的风险" class="headerlink" title="13. 为什么浮点数运算的时候会有精度丢失的风险"></a>13. 为什么浮点数运算的时候会有精度丢失的风险</h2><p>这个和计算机保存浮点数的机制有很大关系。<br>我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h2 id="14-如何解决浮点数运算的精度丢失问题"><a href="#14-如何解决浮点数运算的精度丢失问题" class="headerlink" title="14. 如何解决浮点数运算的精度丢失问题"></a>14. 如何解决浮点数运算的精度丢失问题</h2><ul><li><p>BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。</p></li><li><p>通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));         <span class="comment">// 1.9</span></span><br><span class="line">System.out.println(a.subtract(b));    <span class="comment">// 0.1</span></span><br><span class="line">System.out.println(a.multiply(b));    <span class="comment">// 0.90</span></span><br><span class="line">System.out.println(a.divide(b));      <span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="15-超过-long-整型的数据应该如何表示"><a href="#15-超过-long-整型的数据应该如何表示" class="headerlink" title="15. 超过 long 整型的数据应该如何表示"></a>15. 超过 long 整型的数据应该如何表示</h2><ul><li>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。在 Java 中，64 位 long 整型是最大的整数类型。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l = Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + 1); // -9223372036854775808</span><br><span class="line">System.out.println(l + 1 == Long.MIN_VALUE); // true</span><br></pre></td></tr></table></figure></li><li>此时要使用BigInteger类进行操作，BigInteger内部使用int[]数组来存储任意大小的整形数据。相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi1 = new BigInteger(&quot;123456789&quot;) ;// 声明BigInteger对象</span><br><span class="line">Integer bi2 = new BigInteger(&quot;987654321&quot;) ;// 声明BigInteger对象</span><br><span class="line">tem.out.println(&quot;加法操作：&quot; + bi2.add(bi1)) ;// 加法操作</span><br><span class="line">System.out.println(&quot;减法操作：&quot; + bi2.subtract(bi1)) ;// 减法操作</span><br><span class="line">System.out.println(&quot;乘法操作：&quot; + bi2.multiply(bi1)) ;// 乘法操作</span><br><span class="line">System.out.println(&quot;除法操作：&quot; + bi2.divide(bi1)) ;// 除法操作</span><br><span class="line">System.out.println(&quot;最大数：&quot; + bi2.max(bi1)) ; // 求出最大数</span><br><span class="line">System.out.println(&quot;最小数：&quot; + bi2.min(bi1)) ; // 求出最小数</span><br><span class="line">BigInteger result[] = bi2.divideAndRemainder(bi1) ;// 求出余数的除法操作</span><br><span class="line">System.out.println(&quot;商是：&quot; + result[0] + &quot;；余数是：&quot; + result[1]) ;</span><br></pre></td></tr></table></figure></li></ul><h2 id="16-成员变量与局部变量的区别"><a href="#16-成员变量与局部变量的区别" class="headerlink" title="16. 成员变量与局部变量的区别"></a>16. 成员变量与局部变量的区别</h2><ul><li>语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li>默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h2 id="17-静态变量有什么作用"><a href="#17-静态变量有什么作用" class="headerlink" title="17. 静态变量有什么作用"></a>17. 静态变量有什么作用</h2><ul><li>静态变量也就是被 static 关键字修饰的变量。</li><li>它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。</li><li>也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</li></ul><h2 id="18-字符型常量和字符串常量的区别"><a href="#18-字符型常量和字符串常量的区别" class="headerlink" title="18. 字符型常量和字符串常量的区别"></a>18. 字符型常量和字符串常量的区别</h2><ul><li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li><li><strong>含义</strong> : 字符常量相当于一个整型值(ASCII值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ul><h2 id="19-静态方法为什么不能调用非静态成员"><a href="#19-静态方法为什么不能调用非静态成员" class="headerlink" title="19. 静态方法为什么不能调用非静态成员"></a>19. 静态方法为什么不能调用非静态成员</h2><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul><h2 id="20-静态方法和实例方法有何不同"><a href="#20-静态方法和实例方法有何不同" class="headerlink" title="20. 静态方法和实例方法有何不同"></a>20. 静态方法和实例方法有何不同</h2><h3 id="20-1-调用方式"><a href="#20-1-调用方式" class="headerlink" title="20.1 调用方式"></a>20.1 调用方式</h3><ul><li>在外部调用静态方法时，可以使用<code>类名.方法名</code>的方式，也可以使用<code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>不过，需要注意的是一般不建议使用<code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。因此，一般建议使用<code>类名.方法名</code>的方式来调用静态方法。</li></ul><h3 id="20-2-访问类成员是否存在限制"><a href="#20-2-访问类成员是否存在限制" class="headerlink" title="20.2 访问类成员是否存在限制"></a>20.2 访问类成员是否存在限制</h3><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h2 id="21-重载和重写有什么区别"><a href="#21-重载和重写有什么区别" class="headerlink" title="21. 重载和重写有什么区别"></a>21. 重载和重写有什么区别</h2><ul><li>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</li><li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写，遵循”两同两小一大”<ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul></li></ul><h2 id="22-可变长参数"><a href="#22-可变长参数" class="headerlink" title="22. 可变长参数"></a>22. 可变长参数</h2><ul><li>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void method1(String... args) &#123;</span><br><span class="line">  //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void method2(String arg1, String... args) &#123;</span><br><span class="line">  //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方法重载会优先匹配固定参数的方法，因为固定参数的方法匹配度更高<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class VariableLengthArgument &#123;</span><br><span class="line"></span><br><span class="line">  public static void printVariable(String... args) &#123;</span><br><span class="line">      for (String s : args) &#123;</span><br><span class="line">          System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void printVariable(String arg1, String arg2) &#123;</span><br><span class="line">      System.out.println(arg1 + arg2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      printVariable(&quot;a&quot;, &quot;b&quot;);</span><br><span class="line">      printVariable(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Java 的可变参数编译后实际会被转换成一个数组</li></ul><h2 id="23-面向对象和面向过程的区别"><a href="#23-面向对象和面向过程的区别" class="headerlink" title="23. 面向对象和面向过程的区别"></a>23. 面向对象和面向过程的区别</h2><ul><li>两者的主要区别在于解决问题的方式不同：</li><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。 </li><li>面向对象开发的程序一般更易维护、易复用、易扩展</li></ul><h2 id="24-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#24-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="24. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>24. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><ul><li>new 运算符，new 创建对象实例（对象实例在 内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</li><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li><li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><h2 id="25-对象的相等和引用相等的区别"><a href="#25-对象的相等和引用相等的区别" class="headerlink" title="25. 对象的相等和引用相等的区别"></a>25. 对象的相等和引用相等的区别</h2><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h2 id="26-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#26-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="26. 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>26. 如果一个类没有声明构造方法，该程序能正确执行吗?</h2><ul><li>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</li><li>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li><li>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</li></ul><h2 id="27-构造方法有哪些特点？是否可被-override"><a href="#27-构造方法有哪些特点？是否可被-override" class="headerlink" title="27. 构造方法有哪些特点？是否可被 override"></a>27. 构造方法有哪些特点？是否可被 override</h2><h3 id="27-1-特点："><a href="#27-1-特点：" class="headerlink" title="27.1 特点："></a>27.1 特点：</h3><ul><li>名字与类名相同</li><li>没有返回值，但不能用 void 声明构造函数</li><li>生成类的对象时自动执行，无需调用</li></ul><h3 id="27-2-是否可被重写"><a href="#27-2-是否可被重写" class="headerlink" title="27.2 是否可被重写"></a>27.2 是否可被重写</h3><ul><li>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</li></ul><h2 id="28-面向对象三大特征"><a href="#28-面向对象三大特征" class="headerlink" title="28. 面向对象三大特征"></a>28. 面向对象三大特征</h2><ul><li>封装：一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些可以被外界访问的方法来操作属性。</li><li>继承：通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</li><li>多态：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</li></ul><h2 id="29-接口和抽象类有什么共同点和区别"><a href="#29-接口和抽象类有什么共同点和区别" class="headerlink" title="29. 接口和抽象类有什么共同点和区别"></a>29. 接口和抽象类有什么共同点和区别</h2><h3 id="29-1-共同点："><a href="#29-1-共同点：" class="headerlink" title="29.1 共同点："></a>29.1 共同点：</h3><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</li></ul><h3 id="29-2-区别："><a href="#29-2-区别：" class="headerlink" title="29.2 区别："></a>29.2 区别：</h3><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h2 id="30-深拷贝和浅拷贝区别了解吗？什么是引用拷贝"><a href="#30-深拷贝和浅拷贝区别了解吗？什么是引用拷贝" class="headerlink" title="30. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝"></a>30. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝</h2><ul><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 实现了 Cloneable 接口，并重写了 clone() 方法</span><br><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">  private String name;</span><br><span class="line">  // 省略构造函数、Getter&amp;Setter方法</span><br><span class="line">  @Override</span><br><span class="line">  public Address clone() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          return (Address) super.clone();</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          throw new AssertionError();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">  private Address address;</span><br><span class="line">  // 省略构造函数、Getter&amp;Setter方法</span><br><span class="line">  @Override</span><br><span class="line">  public Person clone() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          Person person = (Person) super.clone();</span><br><span class="line">          return person;</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          throw new AssertionError();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress()); // true</span><br><span class="line">// 从输出结构就可以看出， person1 的克隆对象和 person1 使用的仍然是同一个 Address 对象。</span><br></pre></td></tr></table></figure></li><li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">  private Address address;</span><br><span class="line">  // 省略构造函数、Getter&amp;Setter方法</span><br><span class="line">  @Override</span><br><span class="line">  public Person clone() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          Person person = (Person) super.clone();</span><br><span class="line">          person.setAddress(person.getAddress().clone());</span><br><span class="line">          return person;</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          throw new AssertionError();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress()); // false</span><br><span class="line">// 从输出结构就可以看出，显然 person1 的克隆对象和 person1 包含的 Address 对象已经是不同的了。</span><br></pre></td></tr></table></figure></li><li>引用拷贝：两个不同的引用指向同一个对象</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/3.png"></p><h2 id="31-Object-类的常见方法有哪些"><a href="#31-Object-类的常见方法有哪些" class="headerlink" title="31. Object 类的常见方法有哪些"></a>31. Object 类的常见方法有哪些</h2><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="32-x3D-x3D-和-equals-的区别"><a href="#32-x3D-x3D-和-equals-的区别" class="headerlink" title="32. &#x3D;&#x3D; 和 equals() 的区别"></a>32. &#x3D;&#x3D; 和 equals() 的区别</h2><h3 id="32-1-x3D-x3D"><a href="#32-1-x3D-x3D" class="headerlink" title="32.1 &#x3D;&#x3D;"></a>32.1 &#x3D;&#x3D;</h3><ul><li>对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。</li><li>对于引用数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。</li></ul><h3 id="32-2-equals"><a href="#32-2-equals" class="headerlink" title="32.2 equals()"></a>32.2 equals()</h3><ul><li>equals()不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。</li><li>equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。</li></ul><h2 id="33-hashCode-有什么用"><a href="#33-hashCode-有什么用" class="headerlink" title="33. hashCode() 有什么用"></a>33. hashCode() 有什么用</h2><ul><li>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</li><li>hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</li><li>另外需要注意的是：Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的。</li></ul><h2 id="34-为什么要有-hashCode"><a href="#34-为什么要有-hashCode" class="headerlink" title="34. 为什么要有 hashCode"></a>34. 为什么要有 hashCode</h2><ul><li>hashCode() 和 equals()都是用于比较两个对象是否相等。</li><li>在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程）</li><li>如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的 hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li><li>如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h2 id="35-为什么重写-equals-时必须重写-hashCode-方法"><a href="#35-为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="35. 为什么重写 equals() 时必须重写 hashCode() 方法"></a>35. 为什么重写 equals() 时必须重写 hashCode() 方法</h2><ul><li>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</li><li>如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。</li></ul><h2 id="36-String、StringBuffer、StringBuilder-的区别"><a href="#36-String、StringBuffer、StringBuilder-的区别" class="headerlink" title="36. String、StringBuffer、StringBuilder 的区别"></a>36. String、StringBuffer、StringBuilder 的区别</h2><h3 id="36-1-可变性"><a href="#36-1-可变性" class="headerlink" title="36.1 可变性"></a>36.1 可变性</h3><ul><li>String 是不可变的。</li><li>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</li></ul><h3 id="36-2-线程安全性"><a href="#36-2-线程安全性" class="headerlink" title="36.2 线程安全性"></a>36.2 线程安全性</h3><ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</li><li>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li></ul><h3 id="36-3-性能"><a href="#36-3-性能" class="headerlink" title="36.3 性能"></a>36.3 性能</h3><ul><li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</li><li>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</li><li>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><h3 id="36-4-总结"><a href="#36-4-总结" class="headerlink" title="36.4 总结"></a>36.4 总结</h3><ul><li>操作少量的数据: 适用 String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ul><h2 id="37-String-为什么是不可变的"><a href="#37-String-为什么是不可变的" class="headerlink" title="37. String 为什么是不可变的"></a>37. String 为什么是不可变的</h2><ul><li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li></ul><h2 id="38-字符串拼接用“-”-还是-StringBuilder"><a href="#38-字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="38. 字符串拼接用“+” 还是 StringBuilder"></a>38. 字符串拼接用“+” 还是 StringBuilder</h2><h3 id="38-1"><a href="#38-1" class="headerlink" title="38.1 +"></a>38.1 +</h3><ul><li>字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;he&quot;;</span><br><span class="line">String str2 = &quot;llo&quot;;</span><br><span class="line">String str3 = &quot;world&quot;;</span><br><span class="line">String str4 = str1 + str2 + str3;</span><br></pre></td></tr></table></figure></li><li>在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;&#125;;</span><br><span class="line">String s = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure></li></ul><h3 id="38-2-StringBuilder"><a href="#38-2-StringBuilder" class="headerlink" title="38.2 StringBuilder"></a>38.2 StringBuilder</h3><ul><li>如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;&#125;;</span><br><span class="line">StringBuilder s = new StringBuilder();</span><br><span class="line">for (String value : arr) &#123;</span><br><span class="line">  s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure></li></ul><h2 id="39-String-equals-和-Object-equals-有何区别"><a href="#39-String-equals-和-Object-equals-有何区别" class="headerlink" title="39. String#equals() 和 Object#equals() 有何区别"></a>39. String#equals() 和 Object#equals() 有何区别</h2><ul><li>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 </li><li>Object 的 equals 方法是比较的对象的内存地址。</li></ul><h2 id="40-字符串常量池的作用了解吗"><a href="#40-字符串常量池的作用了解吗" class="headerlink" title="40. 字符串常量池的作用了解吗"></a>40. 字符串常量池的作用了解吗</h2><ul><li>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域.</li><li>主要目的是为了避免字符串的重复创建。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在常量池中创建字符串对象”ab“</span><br><span class="line">String aa = &quot;ab&quot;;</span><br><span class="line">// 直接返回常量池中字符串”ab“的引用</span><br><span class="line">String bb = &quot;ab&quot;;</span><br><span class="line">System.out.println(aa==bb); // true</span><br></pre></td></tr></table></figure></li></ul><h2 id="41-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#41-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="41. String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>41. String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h2><ul><li>会创建 1 或 2 个字符串对象。</li><li>如果字符串常量池中不存在字符串“abc”:<ul><li>首先在字符串常量池中创建一个”abc”对象</li><li>然后在堆内存中创建1个对象指向字符串常量池中的”abc”，因此将创建总共 2 个字符串对象。</li></ul></li><li>如果常量池中已存在字符串“abc”，则只会在堆中创建一个对象指向字符串常量池中的”abc”</li></ul><h2 id="42-String-intern-方法有什么作用"><a href="#42-String-intern-方法有什么作用" class="headerlink" title="42. String#intern 方法有什么作用"></a>42. String#intern 方法有什么作用</h2><ul><li>String.intern() 是一个 native（本地）方法，可以简单分为两种情况：<ul><li>如果字符串常量池中保存了对应的字符串，就直接返回该字符串的引用。</li><li>如果字符串常量池中没有保存对应的字符串，那就在常量池中创建一个该字符串的对象并返回。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 在字符串常量池中创建一个&quot;Java&quot;对象</span><br><span class="line">String s1 = &quot;Java&quot;;</span><br><span class="line">// 直接返回字符串常量池中字符串对象”Java“</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">// 会在堆中在单独创建一个字符串对象，指向常量池中”Java“对象</span><br><span class="line">String s3 = new String(&quot;Java&quot;);</span><br><span class="line">// 直接返回字符串常量池中字符串对象”Java“</span><br><span class="line">String s4 = s3.intern();</span><br><span class="line">// s1 和 s2 指向的是常量池中的同一个对象</span><br><span class="line">System.out.println(s1 == s2); // true</span><br><span class="line">// s3 和 s4 指向的是不同的对象，s3指向的是堆中的一个字符串对象，s4指向的是常量池中的”Java“对象</span><br><span class="line">System.out.println(s3 == s4); // false</span><br><span class="line">// s1 和 s4 指向的是常量池中的同一个”Java“对象</span><br><span class="line">System.out.println(s1 == s4); //true</span><br></pre></td></tr></table></figure><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/4.jpg"></li></ul></li></ul><h2 id="43-Exception-和-Error-有什么区别？"><a href="#43-Exception-和-Error-有什么区别？" class="headerlink" title="43. Exception 和 Error 有什么区别？"></a>43. Exception 和 Error 有什么区别？</h2><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:</p><ul><li>Exception: 程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>Error：Error 属于程序无法处理的错误 ，不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h2 id="44-Checked-Exception-和-Unchecked-Exception-有什么区别"><a href="#44-Checked-Exception-和-Unchecked-Exception-有什么区别" class="headerlink" title="44. Checked Exception 和 Unchecked Exception 有什么区别"></a>44. Checked Exception 和 Unchecked Exception 有什么区别</h2><ul><li>Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。</li><li>Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</li></ul><h2 id="45-Throwable-类常用方法有哪些？"><a href="#45-Throwable-类常用方法有哪些？" class="headerlink" title="45. Throwable 类常用方法有哪些？"></a>45. Throwable 类常用方法有哪些？</h2><ul><li>String getMessage(): 返回异常发生时的简要描述</li><li>String toString(): 返回异常发生时的详细信息</li><li>String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</li><li>void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息</li></ul><h2 id="46-try-catch-finally-如何使用？"><a href="#46-try-catch-finally-如何使用？" class="headerlink" title="46. try-catch-finally 如何使用？"></a>46. try-catch-finally 如何使用？</h2><ul><li>try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li><li>catch块：用于处理 try 捕获到的异常。</li><li>finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;Try to do something&quot;);</span><br><span class="line">    throw new RuntimeException(&quot;RuntimeException&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;Catch Exception -&gt; &quot; + e.getMessage());</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System.out.println(&quot;Finally&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure></li></ul><h2 id="47-finally-中的代码一定会执行吗？"><a href="#47-finally-中的代码一定会执行吗？" class="headerlink" title="47. finally 中的代码一定会执行吗？"></a>47. finally 中的代码一定会执行吗？</h2><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><ul><li>finally执行之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ul><h2 id="48-如何使用-try-with-resources-代替try-catch-finally"><a href="#48-如何使用-try-with-resources-代替try-catch-finally" class="headerlink" title="48. 如何使用 try-with-resources 代替try-catch-finally"></a>48. 如何使用 try-with-resources 代替try-catch-finally</h2><ul><li>Java 中类似于InputStream、OutputStream、Scanner、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//读取文本文件的内容</span><br><span class="line">Scanner scanner = null;</span><br><span class="line">try &#123;</span><br><span class="line">  scanner = new Scanner(new File(&quot;D://read.txt&quot;));</span><br><span class="line">  while (scanner.hasNext()) &#123;</span><br><span class="line">    System.out.println(scanner.nextLine());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  if (scanner != null) &#123;</span><br><span class="line">    scanner.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 Java 7 之后的 try-with-resources 语句改造上面的代码:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try (Scanner scanner = new Scanner(new File(&quot;test.txt&quot;))) &#123;</span><br><span class="line">  while (scanner.hasNext()) &#123;</span><br><span class="line">      System.out.println(scanner.nextLine());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (FileNotFoundException fnfe) &#123;</span><br><span class="line">  fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;)));</span><br><span class="line">     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;</span><br><span class="line">  int b;</span><br><span class="line">  while ((b = bin.read()) != -1) &#123;</span><br><span class="line">      bout.write(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="49-异常使用有哪些需要注意的地方？"><a href="#49-异常使用有哪些需要注意的地方？" class="headerlink" title="49. 异常使用有哪些需要注意的地方？"></a>49. 异常使用有哪些需要注意的地方？</h2><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常，比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。</li><li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）</li></ul><h2 id="50-什么是泛型？有什么作用？"><a href="#50-什么是泛型？有什么作用？" class="headerlink" title="50. 什么是泛型？有什么作用？"></a>50. 什么是泛型？有什么作用？</h2><ul><li>泛型（Generics）是 JDK5 中引入的一个新特性。</li><li>使用泛型参数，可以增强代码的<strong>可读性</strong>以及<strong>稳定性</strong>。</li><li>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList<Person> persons &#x3D; new ArrayList<Person>() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。</Person></Person></li></ul><h2 id="51-泛型的使用方式有哪几种？"><a href="#51-泛型的使用方式有哪几种？" class="headerlink" title="51. 泛型的使用方式有哪几种？"></a>51. 泛型的使用方式有哪几种？</h2><ul><li>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</li><li>泛型类：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="line">// 在实例化泛型类时，必须指定T的具体类型</span><br><span class="line">public class Generic&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public Generic(T key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getKey()&#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 实例化泛型类</span><br><span class="line">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</span><br></pre></td></tr></table></figure></li><li>泛型接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">  public T method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 实现泛型接口，不指定类型：</span><br><span class="line">class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public T method() &#123;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现泛型接口，指定类型：</span><br><span class="line">class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public String method() &#123;</span><br><span class="line">      return &quot;hello&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>泛型方法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void printArray(E[] inputArray)&#123;</span><br><span class="line">  for (E element : inputArray )&#123;</span><br><span class="line">    System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="52-何谓注解"><a href="#52-何谓注解" class="headerlink" title="52. 何谓注解"></a>52. 何谓注解</h2><ul><li>Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</li><li>注解本质是一个继承了Annotation 的特殊接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Override extends Annotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="53-注解的解析方法有哪几种"><a href="#53-注解的解析方法有哪几种" class="headerlink" title="53. 注解的解析方法有哪几种"></a>53. 注解的解析方法有哪几种</h2><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li>编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li>运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。</li></ul><h2 id="54-Java-值传递"><a href="#54-Java-值传递" class="headerlink" title="54. Java 值传递"></a>54. Java 值传递</h2><p>Java 中将实参传递给方法（或函数）的方式是值传递：</p><ul><li>如果参数是基本类型：传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型：传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h2 id="55-什么是序列化和反序列化"><a href="#55-什么是序列化和反序列化" class="headerlink" title="55. 什么是序列化和反序列化?"></a>55. 什么是序列化和反序列化?</h2><h3 id="55-1-定义"><a href="#55-1-定义" class="headerlink" title="55.1 定义"></a>55.1 定义</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><h3 id="55-2-区别"><a href="#55-2-区别" class="headerlink" title="55.2 区别"></a>55.2 区别</h3><ul><li>序列化：serialization, 将数据结构或对象转换成二进制字节流的过程，主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h3 id="55-3-应用场景"><a href="#55-3-应用场景" class="headerlink" title="55.3 应用场景"></a>55.3 应用场景</h3><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><h3 id="55-4-序列化协议对应于-TCP-x2F-IP-4-层模型的哪一层"><a href="#55-4-序列化协议对应于-TCP-x2F-IP-4-层模型的哪一层" class="headerlink" title="55.4 序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层"></a>55.4 序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层</h3><ul><li>TCP&#x2F;IP 四层模型是：应用层、传输层、网络层、网络接口层</li><li>序列化协议属于 TCP&#x2F;IP 协议应用层的一部分</li></ul><h2 id="56-常见序列化协议有哪些"><a href="#56-常见序列化协议有哪些" class="headerlink" title="56. 常见序列化协议有哪些"></a>56. 常见序列化协议有哪些</h2><h3 id="56-1-JDK-自带的序列化方式"><a href="#56-1-JDK-自带的序列化方式" class="headerlink" title="56.1 JDK 自带的序列化方式"></a>56.1 JDK 自带的序列化方式</h3><ul><li>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Getter</span><br><span class="line">@Builder</span><br><span class="line">@ToString</span><br><span class="line">public class RpcRequest implements Serializable &#123;</span><br><span class="line">  private static final long serialVersionUID = 1905122041950251207L;</span><br><span class="line">  private String requestId;</span><br><span class="line">  private String interfaceName;</span><br><span class="line">  private String methodName;</span><br><span class="line">  private Object[] parameters;</span><br><span class="line">  private Class&lt;?&gt;[] paramTypes;</span><br><span class="line">  private RpcMessageTypeEnum rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>为什么不推荐使用 JDK 自带的序列化?<ul><li>不支持跨语言调用</li><li>性能差</li><li>存在安全问题</li></ul></li></ul><h3 id="56-2-其他序列化协议"><a href="#56-2-其他序列化协议" class="headerlink" title="56.2 其他序列化协议"></a>56.2 其他序列化协议</h3><ul><li>有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</li></ul><h2 id="57-何为反射？"><a href="#57-何为反射？" class="headerlink" title="57. 何为反射？"></a>57. 何为反射？</h2><ul><li>反射（Reflection） 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查.</li><li>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性</li></ul><h2 id="58-反射的应用场景了解么"><a href="#58-反射的应用场景了解么" class="headerlink" title="58. 反射的应用场景了解么"></a>58. 反射的应用场景了解么</h2><ul><li>平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景;</li><li>像Spring&#x2F;Spring Boot、MyBatis等框架中大量使用了动态代理，而动态代理的实现依赖反射。</li></ul><h2 id="59-反射机制的优缺点"><a href="#59-反射机制的优缺点" class="headerlink" title="59. 反射机制的优缺点"></a>59. 反射机制的优缺点</h2><ul><li>优点：<ul><li>可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li></ul></li><li>缺点：<ul><li>安全问题：比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</li><li>性能问题：反射的性能要稍差点，但是对于框架来说实际是影响不大。</li></ul></li></ul><h2 id="60-获取-Class-对象的四种方式"><a href="#60-获取-Class-对象的四种方式" class="headerlink" title="60. 获取 Class 对象的四种方式"></a>60. 获取 Class 对象的四种方式</h2><ul><li>知道具体类的情况下可以使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;</span><br></pre></td></tr></table></figure></li><li>通过 Class.forName()传入类的全路径获取：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(&quot;cn.javaguide.TargetObject&quot;);</span><br></pre></td></tr></table></figure></li><li>通过对象实例instance.getClass()获取：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TargetObject o = new TargetObject();</span><br><span class="line">Class alunbarClass2 = o.getClass();</span><br></pre></td></tr></table></figure></li><li></li><li>通过类加载器xxxClassLoader.loadClass()传入类路径获取:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(&quot;cn.javaguide.TargetObject&quot;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="61-反射的一些基本操作"><a href="#61-反射的一些基本操作" class="headerlink" title="61. 反射的一些基本操作"></a>61. 反射的一些基本操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个我们要使用反射操作的类 TargetObject</span><br><span class="line">public class TargetObject &#123;</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    public TargetObject() &#123;</span><br><span class="line">        value = &quot;JavaGuide&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void publicMethod(String s) &#123;</span><br><span class="line">        System.out.println(&quot;I love &quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void privateMethod() &#123;</span><br><span class="line">        System.out.println(&quot;value is &quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用反射操作这个类的方法以及参数</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(&quot;cn.javaguide.TargetObject&quot;);</span><br><span class="line">        TargetObject targetObject = (TargetObject) targetClass.newInstance();</span><br><span class="line">        /**</span><br><span class="line">         * 获取 TargetObject 类中定义的所有方法</span><br><span class="line">         */</span><br><span class="line">        Method[] methods = targetClass.getDeclaredMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 获取指定方法并调用</span><br><span class="line">         */</span><br><span class="line">        Method publicMethod = targetClass.getDeclaredMethod(&quot;publicMethod&quot;,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, &quot;JavaGuide&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 获取指定参数并对参数进行修改</span><br><span class="line">         */</span><br><span class="line">        Field field = targetClass.getDeclaredField(&quot;value&quot;);</span><br><span class="line">        //为了对类中的参数进行修改我们取消安全检查</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(targetObject, &quot;JavaGuide&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 调用 private 方法</span><br><span class="line">         */</span><br><span class="line">        Method privateMethod = targetClass.getDeclaredMethod(&quot;privateMethod&quot;);</span><br><span class="line">        //为了调用private方法我们取消安全检查</span><br><span class="line">        privateMethod.setAccessible(true);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure><h2 id="62-代理模式"><a href="#62-代理模式" class="headerlink" title="62. 代理模式"></a>62. 代理模式</h2><h3 id="62-1-概念："><a href="#62-1-概念：" class="headerlink" title="62.1 概念："></a>62.1 概念：</h3><ul><li>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</li><li>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</li></ul><h3 id="62-2-静态代理"><a href="#62-2-静态代理" class="headerlink" title="62.2 静态代理"></a>62.2 静态代理</h3><ul><li>静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改），且麻烦(需要对每个目标类都单独写一个代理类）。</li><li>从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</li><li>实现步骤：<ul><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义发送短信的接口</span><br><span class="line">public interface SmsService &#123;</span><br><span class="line">  String send(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 实现发送短信的接口</span><br><span class="line">public class SmsServiceImpl implements SmsService &#123;</span><br><span class="line">  public String send(String message) &#123;</span><br><span class="line">      System.out.println(&quot;send message:&quot; + message);</span><br><span class="line">      return message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 创建代理类并同样实现发送短信的接口</span><br><span class="line">public class SmsProxy implements SmsService &#123;</span><br><span class="line">  private final SmsService smsService;</span><br><span class="line">  public SmsProxy(SmsService smsService) &#123;</span><br><span class="line">      this.smsService = smsService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String send(String message) &#123;</span><br><span class="line">      //调用方法之前，我们可以添加自己的操作</span><br><span class="line">      System.out.println(&quot;before method send()&quot;);</span><br><span class="line">      smsService.send(message);</span><br><span class="line">      //调用方法之后，我们同样可以添加自己的操作</span><br><span class="line">      System.out.println(&quot;after method send()&quot;);</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 实际使用</span><br><span class="line">public class Main &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      SmsService smsService = new SmsServiceImpl();</span><br><span class="line">      SmsProxy smsProxy = new SmsProxy(smsService);</span><br><span class="line">      smsProxy.send(&quot;java&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5. 运行上述代码之后，控制台打印出：</span><br><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="62-3-动态代理"><a href="#62-3-动态代理" class="headerlink" title="62.3 动态代理"></a>62.3 动态代理</h3><ul><li><p>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p></li><li><p>实现步骤</p><ul><li>定义一个接口及其实现类；</li><li>创建动态代理类，实现InvocationHandler接口，重写invoke方法，在 invoke 方法中调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>创建代理对象的工厂类，通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义发送短信的接口</span><br><span class="line">public interface SmsService &#123;</span><br><span class="line">  String send(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 实现发送短信的接口</span><br><span class="line">public class SmsServiceImpl implements SmsService &#123;</span><br><span class="line">  public String send(String message) &#123;</span><br><span class="line">      System.out.println(&quot;send message:&quot; + message);</span><br><span class="line">      return message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 定义一个 JDK 动态代理类</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class DebugInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">  /**</span><br><span class="line">  * 代理类中的真实对象</span><br><span class="line">  */</span><br><span class="line">  private final Object target;</span><br><span class="line">  public DebugInvocationHandler(Object target) &#123;</span><br><span class="line">    this.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      //调用方法之前，我们可以添加自己的操作</span><br><span class="line">      System.out.println(&quot;before method &quot; + method.getName());</span><br><span class="line">      Object result = method.invoke(target, args);</span><br><span class="line">      //调用方法之后，我们同样可以添加自己的操作</span><br><span class="line">      System.out.println(&quot;after method &quot; + method.getName());</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 获取代理对象的工厂类</span><br><span class="line">public class JdkProxyFactory &#123;</span><br><span class="line">  // 主要通过Proxy.newProxyInstance（）方法获取某个类的代理对象</span><br><span class="line">  public static Object getProxy(Object target) &#123;</span><br><span class="line">      return Proxy.newProxyInstance(</span><br><span class="line">              target.getClass().getClassLoader(), // 目标类的类加载器</span><br><span class="line">              target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个</span><br><span class="line">              new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5. 实际使用</span><br><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());</span><br><span class="line">smsService.send(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">// 6. 运行上述代码之后，控制台打印出：</span><br><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="62-4-静态代理和动态代理的对比"><a href="#62-4-静态代理和动态代理的对比" class="headerlink" title="62.4 静态代理和动态代理的对比"></a>62.4 静态代理和动态代理的对比</h3><ul><li>灵活性：<ul><li>静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，非常麻烦</li><li>动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。</li></ul></li><li>JVM 层面：<ul><li>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</li><li>而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul></li></ul><h2 id="63-SPI"><a href="#63-SPI" class="headerlink" title="63. SPI"></a>63. SPI</h2><h3 id="63-1-SPI和API的区别"><a href="#63-1-SPI和API的区别" class="headerlink" title="63.1 SPI和API的区别"></a>63.1 SPI和API的区别</h3><ul><li>实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</li><li>当接口存在于调用方这边时，就是SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</li><li>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/5.png"></li></ul><h3 id="63-2-应用场景"><a href="#63-2-应用场景" class="headerlink" title="63.2 应用场景"></a>63.2 应用场景</h3><p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p><h2 id="64-语法糖"><a href="#64-语法糖" class="headerlink" title="64. 语法糖"></a>64. 语法糖</h2><h3 id="64-1-定义"><a href="#64-1-定义" class="headerlink" title="64.1 定义"></a>64.1 定义</h3><ul><li>语法糖（Syntactic Sugar） 也称糖衣语法。</li><li>指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。</li><li>简而言之，语法糖让程序更加简洁，有更高的可读性。</li></ul><h3 id="64-2-switch-支持-String"><a href="#64-2-switch-支持-String" class="headerlink" title="64.2 switch 支持 String"></a>64.2 switch 支持 String</h3><ul><li>switch自身<strong>原本</strong>就支持基本类型。比如int、char等。<ul><li>对于int类型，直接进行数值的比较。</li><li>对于char类型则是比较其 ascii 码。</li><li>所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。</li></ul></li><li>Java 7 中switch开始支持String<ul><li>字符串的 switch 是通过equals()和hashCode()方法来实现的</li></ul></li></ul><h3 id="64-3-泛型"><a href="#64-3-泛型" class="headerlink" title="64.3 泛型"></a>64.3 泛型</h3><ul><li>对于JVM来说，他根本不认识Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 原来的代码：</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(&quot;name&quot;, &quot;hollis&quot;);</span><br><span class="line">map.put(&quot;wechat&quot;, &quot;Hollis&quot;);</span><br><span class="line">map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</span><br><span class="line"></span><br><span class="line">// 解语法糖之后会变成：</span><br><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(&quot;name&quot;, &quot;hollis&quot;);</span><br><span class="line">map.put(&quot;wechat&quot;, &quot;Hollis&quot;);</span><br><span class="line">map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="64-4-自动装箱与拆箱"><a href="#64-4-自动装箱与拆箱" class="headerlink" title="64.4 自动装箱与拆箱"></a>64.4 自动装箱与拆箱</h3><ul><li>装箱过程是通过调用包装器的 valueOf 方法实现的，</li><li>拆箱过程是通过调用包装器的 xxxValue 方法实现的。</li></ul><h3 id="64-5-可变长参数"><a href="#64-5-可变长参数" class="headerlink" title="64.5 可变长参数"></a>64.5 可变长参数</h3><p>可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p><h3 id="64-6-断言"><a href="#64-6-断言" class="headerlink" title="64.6 断言"></a>64.6 断言</h3><p>断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertionError 来打断程序的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> a == b;</span><br><span class="line">        System.out.println(<span class="string">&quot;公众号：Hollis&quot;</span>);</span><br><span class="line">        <span class="keyword">assert</span> a != b : <span class="string">&quot;Hollis&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="64-7-数值字面量"><a href="#64-7-数值字面量" class="headerlink" title="64.7 数值字面量"></a>64.7 数值字面量</h3><p>编译器并不认识在数字字面量中的_，需要在编译阶段把他去掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。</span></span><br><span class="line"><span class="comment">// 这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10_000</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="64-8-for-each"><a href="#64-8-for-each" class="headerlink" title="64.8 for-each"></a>64.8 for-each</h3><p>for-each 的实现原理其实就是使用了普通的 for 循环和迭代器</p><h3 id="64-9-try-with-resource"><a href="#64-9-try-with-resource" class="headerlink" title="64.9 try-with-resource"></a>64.9 try-with-resource</h3><p>背后的原理很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。</p><h2 id="65-集合概述"><a href="#65-集合概述" class="headerlink" title="65. 集合概述"></a>65. 集合概述</h2><h3 id="65-1-集合概览"><a href="#65-1-集合概览" class="headerlink" title="65.1 集合概览"></a>65.1 集合概览</h3><p>集合，也叫作容器，主要是由两大接口派生而来：</p><ul><li><code>Collection</code>接口，主要用于存放单一元素，包含三个主要子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</li><li><code>Map</code> 接口，主要用于存放键值对。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/6.png" alt="Java 集合框架概览"></p><h3 id="65-2-说说-List-Set-Queue-Map-四者的区别？"><a href="#65-2-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="65.2 说说 List, Set, Queue, Map 四者的区别？"></a>65.2 说说 List, Set, Queue, Map 四者的区别？</h3><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序、可重复、有索引。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序、不可重复、无索引。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="65-3-集合框架底层数据结构总结"><a href="#65-3-集合框架底层数据结构总结" class="headerlink" title="65.3 集合框架底层数据结构总结"></a>65.3 集合框架底层数据结构总结</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li><code>ArrayList</code>：<code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> （JDK8以前：数组+链表，JDK8以后：数组+链表+红黑树）实现的，底层采用 <code>HashMap</code> 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，基于HashMap来实现，每个元素额外多了一个双链表记录前后元素的位置。</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）</li></ul><h3 id="65-4-如何选用集合"><a href="#65-4-如何选用集合" class="headerlink" title="65.4 如何选用集合?"></a>65.4 如何选用集合?</h3><p>我们主要根据集合的特点来选择合适的集合。比如：</p><ul><li>我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，<ul><li>需要排序时选择 <code>TreeMap</code></li><li>不需要排序时就选择 <code>HashMap</code></li><li>需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li></ul></li><li>我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合<ul><li>需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，</li><li>不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code></li></ul></li></ul><h3 id="65-5-为什么要使用集合？"><a href="#65-5-为什么要使用集合？" class="headerlink" title="65.5 为什么要使用集合？"></a>65.5 为什么要使用集合？</h3><ul><li>数组：<ul><li>当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。</li><li>但是，使用数组存储对象存在一些不足：存储类型固定，长度固定。</li></ul></li><li>集合：<ul><li>集合的优势在于它们的大小可变、支持泛型等。</li><li>集合提高了数据的存储和处理灵活性。</li></ul></li></ul><h2 id="66-List"><a href="#66-List" class="headerlink" title="66. List"></a>66. List</h2><h3 id="66-1-ArrayList底层的原理"><a href="#66-1-ArrayList底层的原理" class="headerlink" title="66.1 ArrayList底层的原理"></a>66.1 ArrayList底层的原理</h3><ul><li>利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组</li><li>添加第一个元素时，底层会创建一个新的长度为10的数组</li><li>存满时，会扩容1.5倍</li><li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li></ul><h3 id="66-2-ArrayList-和-Array（数组）的区别？"><a href="#66-2-ArrayList-和-Array（数组）的区别？" class="headerlink" title="66.2 ArrayList 和 Array（数组）的区别？"></a>66.2 ArrayList 和 Array（数组）的区别？</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Array</span><br><span class="line">// 初始化一个 String 类型的数组</span><br><span class="line">String[] stringArr = new String[]&#123;&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;&#125;;</span><br><span class="line">// 修改数组元素的值</span><br><span class="line">stringArr[0] = &quot;goodbye&quot;;</span><br><span class="line">System.out.println(Arrays.toString(stringArr));// [goodbye, world, !]</span><br><span class="line">// 删除数组中的元素，需要手动移动后面的元素</span><br><span class="line">for (int i = 0; i &lt; stringArr.length - 1; i++) &#123;</span><br><span class="line">   stringArr[i] = stringArr[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">stringArr[stringArr.length - 1] = null;</span><br><span class="line">System.out.println(Arrays.toString(stringArr));// [world, !, null]</span><br><span class="line">      </span><br><span class="line">ArrayList</span><br><span class="line">// 初始化一个 String 类型的 ArrayList</span><br><span class="line">ArrayList&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;));</span><br><span class="line">// 添加元素到 ArrayList 中</span><br><span class="line">stringList.add(&quot;goodbye&quot;);</span><br><span class="line">System.out.println(stringList);// [hello, world, !, goodbye]</span><br><span class="line">// 修改 ArrayList 中的元素</span><br><span class="line">stringList.set(0, &quot;hi&quot;);</span><br><span class="line">System.out.println(stringList);// [hi, world, !, goodbye]</span><br><span class="line">// 删除 ArrayList 中的元素</span><br><span class="line">stringList.remove(0);</span><br><span class="line">System.out.println(stringList); // [world, !, goodbye]</span><br></pre></td></tr></table></figure><h3 id="66-3-ArrayList-可以添加-null-值吗？"><a href="#66-3-ArrayList-可以添加-null-值吗？" class="headerlink" title="66.3 ArrayList 可以添加 null 值吗？"></a>66.3 ArrayList 可以添加 null 值吗？</h3><ul><li><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。</li><li>不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; listOfStrings = new ArrayList&lt;&gt;();</span><br><span class="line">listOfStrings.add(null);</span><br><span class="line">listOfStrings.add(&quot;java&quot;);</span><br><span class="line">System.out.println(listOfStrings);</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">[null, java]</span><br></pre></td></tr></table></figure><h3 id="66-4-ArrayList-插入和删除元素的时间复杂度？"><a href="#66-4-ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="66.4 ArrayList 插入和删除元素的时间复杂度？"></a>66.4 ArrayList 插入和删除元素的时间复杂度？</h3><ul><li><p>插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 **O(n)**。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 **O(1)**，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 **O(n)**。</li></ul></li><li><p>删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 **O(n)**。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 **O(1)**。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul></li></ul><h3 id="66-5-LinkedList-插入和删除元素的时间复杂度？"><a href="#66-5-LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="66.5 LinkedList 插入和删除元素的时间复杂度？"></a>66.5 LinkedList 插入和删除元素的时间复杂度？</h3><ul><li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 **O(1)**。</li><li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 **O(1)**。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul><h3 id="66-6-LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#66-6-LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="66.6 LinkedList 为什么不能实现 RandomAccess 接口？"></a>66.6 LinkedList 为什么不能实现 RandomAccess 接口？</h3><ul><li><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。</li><li>由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</li></ul><h3 id="66-7-ArrayList-与-LinkedList-区别"><a href="#66-7-ArrayList-与-LinkedList-区别" class="headerlink" title="66.7 ArrayList 与 LinkedList 区别?"></a>66.7 ArrayList 与 LinkedList 区别?</h3><ul><li><strong>是否保证线程安全：</strong><ul><li><code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，不保证线程安全；</li></ul></li><li><strong>底层数据结构：</strong><ul><li><code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；</li><li><code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</li></ul></li><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 </li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <ul><li><code>ArrayList</code>实现了 <code>RandomAccess</code> 接口， 支持随机访问。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)</li><li><code>LinkedList</code> 不支持高效的随机元素访问。</li></ul></li><li><strong>内存空间占用：</strong><ul><li><code>ArrayList</code> 的空间浪费主要体现在 list 列表的结尾会预留一定的容量空间;</li><li><code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul></li><li><strong>应用：</strong><ul><li>我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！</li></ul></li></ul><h2 id="67-Set"><a href="#67-Set" class="headerlink" title="67. Set"></a>67. Set</h2><h3 id="67-1-HashSet底层原理"><a href="#67-1-HashSet底层原理" class="headerlink" title="67.1 HashSet底层原理"></a>67.1 HashSet底层原理</h3><ul><li>HashSet集合底层是基于<strong>哈希表</strong>实现的，哈希表根据JDK版本的不同，也是有点区别的</li><li>JDK8以前：哈希表 &#x3D; 数组+链表<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/7.png"></li><li>JDK8以后：哈希表 &#x3D; 数组+链表+红黑树<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/8.png"></li></ul><h3 id="67-2-LinkedHashSet底层原理"><a href="#67-2-LinkedHashSet底层原理" class="headerlink" title="67.2 LinkedHashSet底层原理"></a>67.2 LinkedHashSet底层原理</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/9.png"></p><h3 id="67-3-Comparable-和-Comparator-的区别"><a href="#67-3-Comparable-和-Comparator-的区别" class="headerlink" title="67.3 Comparable 和 Comparator 的区别"></a>67.3 Comparable 和 Comparator 的区别</h3><ul><li><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</li><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包，它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包，它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><h4 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始数组:&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.reverse(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.sort(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后：&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">原始数组:</span><br><span class="line">[-<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, -<span class="number">9</span>, -<span class="number">7</span>]</span><br><span class="line">Collections.reverse(arrayList):</span><br><span class="line">[-<span class="number">7</span>, -<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-<span class="number">9</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line">定制排序后：</span><br><span class="line">[<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">7</span>, -<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h4 id="重写-compareTo-方法实现按年龄来排序"><a href="#重写-compareTo-方法实现按年龄来排序" class="headerlink" title="重写 compareTo 方法实现按年龄来排序"></a>重写 compareTo 方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Person, String&gt;();</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>), <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>), <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">10</span>), <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">5</span>), <span class="string">&quot;xiaohong&quot;</span>);</span><br><span class="line">    <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">    Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Person key : keys) &#123;</span><br><span class="line">        System.out.println(key.getAge() + <span class="string">&quot;-&quot;</span> + key.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output：</span></span><br><span class="line"><span class="number">5</span>-小红</span><br><span class="line"><span class="number">10</span>-王五</span><br><span class="line"><span class="number">20</span>-李四</span><br><span class="line"><span class="number">30</span>-张三</span><br></pre></td></tr></table></figure><h3 id="67-4-无序性和不可重复性的含义是什么"><a href="#67-4-无序性和不可重复性的含义是什么" class="headerlink" title="67.4 无序性和不可重复性的含义是什么"></a>67.4 无序性和不可重复性的含义是什么</h3><ul><li>无序性不等于随机性.</li><li>无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h3 id="67-5-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#67-5-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="67.5 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>67.5 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li>相同点：都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>不同点：主要区别在于底层数据结构不同。<ul><li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li><li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li><li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li></ul></li></ul><h3 id="68-Queue-与-Deque-的区别"><a href="#68-Queue-与-Deque-的区别" class="headerlink" title="68. Queue 与 Deque 的区别"></a>68. Queue 与 Deque 的区别</h3><ul><li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，遵循 <strong>先进先出（FIFO）</strong> 规则。</li><li><code>Deque</code> (Double Ended Queue)是双端队列，在队列的两端均可以插入或删除元素。</li></ul><h3 id="69-集合判空"><a href="#69-集合判空" class="headerlink" title="69. 集合判空"></a>69. 集合判空</h3><ul><li><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></li><li>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</li></ul><h2 id="80-集合遍历"><a href="#80-集合遍历" class="headerlink" title="80. 集合遍历"></a>80. 集合遍历</h2><ul><li><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></li></ul><h2 id="81-集合数组互转"><a href="#81-集合数组互转" class="headerlink" title="81. 集合数组互转"></a>81. 集合数组互转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 数组转集合</span><br><span class="line">String[] myArray = &#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line">//上面两个语句等价于下面一条语句</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;,&quot;Banana&quot;, &quot;Orange&quot;);</span><br><span class="line"></span><br><span class="line">// 集合转数组（没有指定类型的话会报错）</span><br><span class="line">String[] s = list.toArray(new String[0]);</span><br></pre></td></tr></table></figure><h2 id="82-乐观锁和悲观锁"><a href="#82-乐观锁和悲观锁" class="headerlink" title="82. 乐观锁和悲观锁"></a>82. 乐观锁和悲观锁</h2><h3 id="82-1-基本概念"><a href="#82-1-基本概念" class="headerlink" title="82.1 基本概念"></a>82.1 基本概念</h3><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><ul><li>乐观锁：在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li><li>悲观锁：在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其它线程阻塞，其他人不能修改数据。</li></ul><h3 id="83-2-实现方式"><a href="#83-2-实现方式" class="headerlink" title="83.2 实现方式"></a>83.2 实现方式</h3><ul><li>乐观锁的实现方式主要有两种：版本号机制和CAS机制<ul><li><p>版本号机制：一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**举一个简单的例子**：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ `balance` ）为 \$100 。</span><br><span class="line"></span><br><span class="line">1. 操作员 A 此时将其读出（ `version`=1 ），并从其帐户余额中扣除 $50（ $100-\$50 ）。</span><br><span class="line">2. 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ `version`=1 ），并从其帐户余额中扣除 $20 （ $100-\$20 ）。</span><br><span class="line">3. 操作员 A 完成了修改工作，将数据版本号（ `version`=1 ），连同帐户扣除后余额（ `balance`=\$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 `version` 更新为 2 。</span><br><span class="line">4. 操作员 B 完成了操作，也将版本号（ `version`=1 ）试图向数据库提交数据（ `balance`=\$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</span><br><span class="line"></span><br><span class="line">这样就避免了操作员 B 用基于 `version`=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</span><br></pre></td></tr></table></figure></li><li><p>CAS 算法： </p><ul><li>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</li><li>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。（<strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。）</li><li>CAS 涉及到三个操作数：V、E、N。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。<ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**举一个简单的例子**：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</span><br><span class="line">1. i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</span><br><span class="line">2. i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</span><br><span class="line">当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。</li></ul><h3 id="83-3-优缺点和应用场景"><a href="#83-3-优缺点和应用场景" class="headerlink" title="83.3 优缺点和应用场景"></a>83.3 优缺点和应用场景</h3><ul><li>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。</li><li>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</li></ul><h3 id="83-4-乐观锁加锁吗"><a href="#83-4-乐观锁加锁吗" class="headerlink" title="83.4 乐观锁加锁吗"></a>83.4 乐观锁加锁吗</h3><ul><li>乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子。</li><li>有时乐观锁可能与加锁操作合作，但是不能改变“乐观锁本身不加锁”这一事实。</li></ul><h3 id="83-4-CAS有哪些缺点"><a href="#83-4-CAS有哪些缺点" class="headerlink" title="83.4 CAS有哪些缺点"></a>83.4 CAS有哪些缺点</h3><ul><li>ABA问题：<ul><li>定义：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></li><li>解决思路：ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。</li></ul></li><li>高竞争下的开销问题：<ul><li>定义：在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。</li><li>解决思路：针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。</li></ul></li><li>功能限制：<ul><li>例如CAS只能保证单个变量（或者说单个内存值）操作的原子性，当操作涉及跨多个共享变量时 CAS 无效。</li></ul></li></ul><h3 id="83-5-总结"><a href="#83-5-总结" class="headerlink" title="83.5 总结"></a>83.5 总结</h3><ul><li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</li><li>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。</li><li>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</li><li>乐观锁的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。</li></ul><h2 id="84-JMM-Java-Memory-Model"><a href="#84-JMM-Java-Memory-Model" class="headerlink" title="84. JMM(Java Memory Model)"></a>84. JMM(Java Memory Model)</h2><h3 id="84-1-什么是-JMM？为什么需要-JMM？"><a href="#84-1-什么是-JMM？为什么需要-JMM？" class="headerlink" title="84.1 什么是 JMM？为什么需要 JMM？"></a>84.1 什么是 JMM？为什么需要 JMM？</h3><ul><li>Java内存模型即Java Memory Model，简称JMM。用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能够达到一致的内存访问效果。</li><li>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/10.jpg"></p><h3 id="84-2-多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。"><a href="#84-2-多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。" class="headerlink" title="84.2 多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。"></a>84.2 多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。</h3><ol><li><p>线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。</p></li><li><p>线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。</p></li></ol><h3 id="84-3-Java-内存区域和-JMM-有何区别？"><a href="#84-3-Java-内存区域和-JMM-有何区别？" class="headerlink" title="84.3 Java 内存区域和 JMM 有何区别？"></a>84.3 Java 内存区域和 JMM 有何区别？</h3><ul><li><strong>Java 内存区域和内存模型是完全不一样的两个东西</strong>：</li><li>Java 内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分，就比如说堆主要用于存放对象实例。</li><li>Java 内存模型抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</li></ul><h3 id="84-4-happens-before-是什么？"><a href="#84-4-happens-before-是什么？" class="headerlink" title="84.4 happens-before 是什么？"></a>84.4 happens-before 是什么？</h3><ul><li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见（保障可见性），并且第一个操作的执行顺序排在第二个操作之前（JMM对程序员做出的一个逻辑保障，并不是代码真正的执行保障）。</li><li>即使两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。只要不改变程序的执行结果，编译器、处理器怎么优化都可以。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int userNum = getUserNum();         // 1</span><br><span class="line">int teacherNum = getTeacherNum();    // 2</span><br><span class="line">int totalNum = userNum + teacherNum;// 3</span><br><span class="line"></span><br><span class="line">- 1 happens-before 2</span><br><span class="line">- 2 happens-before 3</span><br><span class="line">- 1 happens-before 3</span><br></pre></td></tr></table></figure><p>虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</p><p><strong>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></p><h3 id="84-5-happens-before-原则：（一共8条，重点是下面5条）"><a href="#84-5-happens-before-原则：（一共8条，重点是下面5条）" class="headerlink" title="84.5 happens-before 原则：（一共8条，重点是下面5条）"></a>84.5 happens-before 原则：（一共8条，重点是下面5条）</h3><ol><li><strong>程序顺序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</li><li><strong>解锁规则</strong>：解锁 happens-before 于加锁；</li><li><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</li><li><strong>传递规则</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li><li><strong>线程启动规则</strong>：Thread 对象的 <code>start()</code>方法 happens-before 于此线程的每一个动作。</li></ol><h3 id="84-6-并发编程三个重要特性"><a href="#84-6-并发编程三个重要特性" class="headerlink" title="84.6 并发编程三个重要特性"></a>84.6 并发编程三个重要特性</h3><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="84-7-volatile关键字"><a href="#84-7-volatile关键字" class="headerlink" title="84.7 volatile关键字"></a>84.7 volatile关键字</h3><ul><li>在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li><li>防止 JVM 的指令重排序。如果将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</li><li>volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</li></ul><h3 id="84-8-synchronized关键字"><a href="#84-8-synchronized关键字" class="headerlink" title="84.8 synchronized关键字"></a>84.8 synchronized关键字</h3><ul><li><p>概念：</p><ul><li>synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</li></ul></li><li><p>使用：</p><ul><li>修饰实例方法 （锁当前对象实例）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized void method() &#123;</span><br><span class="line">  //业务代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>修饰静态方法 （锁当前类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized static void method() &#123;</span><br><span class="line">  //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 定义类</span><br><span class="line">class SyncThread implements Runnable &#123;</span><br><span class="line">  private static int count;</span><br><span class="line"></span><br><span class="line">  public SyncThread() &#123;</span><br><span class="line">    count = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized static void method() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void run() &#123;</span><br><span class="line">    method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码调用</span><br><span class="line">SyncThread syncThread1 = new SyncThread();</span><br><span class="line">SyncThread syncThread2 = new SyncThread();</span><br><span class="line">Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);</span><br><span class="line">Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"></span><br><span class="line">// 结果如下：</span><br><span class="line">SyncThread1:0</span><br><span class="line">SyncThread1:1</span><br><span class="line">SyncThread1:2</span><br><span class="line">SyncThread1:3</span><br><span class="line">SyncThread1:4</span><br><span class="line">SyncThread2:5</span><br><span class="line">SyncThread2:6</span><br><span class="line">SyncThread2:7</span><br><span class="line">SyncThread2:8</span><br><span class="line">SyncThread2:9</span><br></pre></td></tr></table></figure></li><li>修饰代码块 （锁指定对象&#x2F;类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(this) &#123;</span><br><span class="line">  //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>底层原理：</p><ul><li>javac在编译时，会生成对应的<code>monitorenter</code>和<code>monitorexit</code>指令分别对应<code>synchronized</code>同步块的进入和退出.</li><li>有两个<code>monitorexit</code>指令的原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用<code>monitorexit</code>命令释放锁。</li></ul></li><li><p>构造方法可以用 synchronized 修饰么?</p><ul><li>构造方法不能使用 synchronized 关键字修饰。</li><li>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</li></ul></li><li><p>synchronized 和 volatile 有什么区别？</p><ul><li>volatile 关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好。</li><li>volatile 关键字只能用于变量，而 synchronized 关键字可以修饰方法以及代码块。</li><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul></li></ul><h2 id="85-线程"><a href="#85-线程" class="headerlink" title="85. 线程"></a>85. 线程</h2><h3 id="85-1-创建线程的方式（三种）"><a href="#85-1-创建线程的方式（三种）" class="headerlink" title="85.1 创建线程的方式（三种）"></a>85.1 创建线程的方式（三种）</h3><ul><li><code>Thread</code><ul><li>继承<code>Thread</code>类，重写<code>run</code>方法，run方法代表线程要完成的任务，</li><li>调用线程实例对象的<code>start()</code>方法来启动该线程.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo1 extends Thread&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run()&#123;</span><br><span class="line">      System.out.println(&quot;线程的第一种创建方式&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main方法调用</span><br><span class="line">ThreadDemo1 demo1 = new ThreadDemo1();</span><br><span class="line">demo1.start();</span><br></pre></td></tr></table></figure></li></ul></li><li><code>runnable</code><ul><li>实现<code>runnable</code>接口，重写该接口的<code>run()</code>方法，run方法代表线程要完成的任务，调用线程实例对象的start()方法来启动该线程</li><li>创建<code>Runnable</code>实现类的实例，并依此实例作为Thread的target来创建Thread对象，该<code>Thread</code>对象才是真正的线程对象。</li><li>调用<code>Thread</code>线程对象的start()方法来启动该线程。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo2 implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      System.out.println(&quot;线程的第二种创建方式-实现runnable接口&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// main方法调用</span><br><span class="line">ThreadDemo2 demo2 = new ThreadDemo2();</span><br><span class="line">new Thread(demo2).start();</span><br></pre></td></tr></table></figure></li></ul></li><li><code>Callable</code><ul><li>实现<code>Callable</code>接口，重写<code>call()</code>方法，该<code>call()</code>方法将作为线程执行体，并且有返回值；</li><li>创建<code>Callable</code>实现类的实例对象，使用<code>FutureTask</code>类来包装<code>Callable</code>对象，该<code>FutureTask</code>对象封装了该<code>Callable</code>对象的<code>call()</code>方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo3 implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">  private int i =0;</span><br><span class="line">  @Override</span><br><span class="line">  public Integer call() throws Exception &#123;</span><br><span class="line">      for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">          this.i+=i;</span><br><span class="line">      &#125;</span><br><span class="line">      return i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//main调用</span><br><span class="line">ThreadDemo3 demo3 = new ThreadDemo3();</span><br><span class="line">FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(demo3);</span><br><span class="line">new Thread(task).start();</span><br><span class="line">try &#123;</span><br><span class="line">  System.out.println(task.get());</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="85-2-Java对象引用级别"><a href="#85-2-Java对象引用级别" class="headerlink" title="85.2 Java对象引用级别"></a>85.2 Java对象引用级别</h3><ul><li>JDK把对象的引用级别由高到低分为强引用、软引用、弱引用、虚引用四种级别<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/11.png"></li><li>强引用 StrongReference：属于不可回收资源，GC绝对不会回收它，即使是内存不足，JVM宁愿抛出OutOfMemoryError异常，使程序终止，也不会来回收强引用对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure></li><li>软引用 SoftReference：它的性质属于可有可无，因为内存空间充足的情况下，GC不会回收它，但是内存空间紧张，GC发现它仅有软引用，就会回收该对象，所以软引用对象适合作为内存敏感的缓存对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;User&gt; soft = new SoftReference&lt;&gt;(new User(&quot;Tom&quot;));</span><br></pre></td></tr></table></figure></li><li>弱引用 WeakReference：弱引用对象相对软引用对象具有更短暂的生命周期，只要GC发现它仅有弱引用，不管内存空间是否充足，都会回收它，不过GC是一个优先级很低的线程，因此不一定会很快发现那些仅有弱引用的对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weak = new WeakReference&lt;&gt;(new User(&quot;Tom&quot;));</span><br></pre></td></tr></table></figure></li></ul><h3 id="85-3-ThreadLocal"><a href="#85-3-ThreadLocal" class="headerlink" title="85.3 ThreadLocal"></a>85.3 ThreadLocal</h3><ul><li><p>概念：创建了一个ThreadLocal变量，它是线程隔离的，访问这个变量的每个线程都会有这个变量的本地副本。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p></li><li><p>使用：</p><ul><li>get() </li><li>set() </li><li>remove()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class ThreadLocalExample implements Runnable&#123;</span><br><span class="line">  // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span><br><span class="line">  private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;));</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">      ThreadLocalExample obj = new ThreadLocalExample();</span><br><span class="line">      for(int i=0 ; i&lt;10; i++)&#123;</span><br><span class="line">          Thread t = new Thread(obj, &quot;&quot;+i);</span><br><span class="line">          Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">          t.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; default Formatter = &quot;+formatter.get().toPattern());</span><br><span class="line">      try &#123;</span><br><span class="line">          Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      //formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span><br><span class="line">      formatter.set(new SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; formatter = &quot;+formatter.get().toPattern());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">Thread Name= 0 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 0 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 1 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 2 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 1 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 3 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 2 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 4 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 3 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 4 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 5 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 5 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 6 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 6 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 7 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 7 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 8 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 9 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 8 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 9 formatter = yy-M-d ah:mm</span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理：</p><ul><li>ThreadLocal底层是ThreadLocalMap。 每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key ，Object对象为 value 的键值对。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">  // 与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br><span class="line">  ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ThreadLocal的set()方法：调用的是ThreadLocalMap的set方法将(ThreadLocal, value)存储到ThreadLocalMap<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">  //获取当前请求的线程</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  //取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  if (map != null)&#123;</span><br><span class="line">    // 将需要存储的值放入到这个哈希表中</span><br><span class="line">    map.set(this, value);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/12.png"></p></li><li><p>内存泄露问题是怎么导致的？</p><ul><li><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用，所以在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li>这样，<code>ThreadLocalMap</code> 中就会出现 <code>key</code> 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</li><li>解决方案：使用完<code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</li></ul></li></ul><h3 id="85-4-线程池"><a href="#85-4-线程池" class="headerlink" title="85.4 线程池"></a>85.4 线程池</h3><ul><li><p>概念：为了避免频繁重复的创建和销毁线程，我们可以让这些线程进行复用。而线程池是将创建的线程存储到一个池中，在需要使用时从池中去拿，使用完之后再将线程归还到池中，下一次接着使用。</p></li><li><p>如何创建线程池：通过<code>ThreadPoolExecutor</code>构造函数来创建</p></li><li><p>线程池常见参数有哪些？如何解释？  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="line">*/</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量</span><br><span class="line">                          int maximumPoolSize,//线程池的最大线程数</span><br><span class="line">                          long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="line">                          TimeUnit unit,//时间单位</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="line">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="line">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="line">                           ) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul></li><li><code>ThreadPoolExecutor</code>其他常见参数 :<ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/13.png"></li></ul></li></ul></li><li><p>线程池的饱和策略有哪些？</p><ul><li>接口<code>RejectedExecutionHandler</code>定义了饱和策略，所有的饱和策略都需要实现该接口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RejectedExecutionHandler &#123;</span><br><span class="line">  void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 拒绝处理，抛出<code>RejectedExecutionException</code>异常</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 由创建该线程的线程（main）执行</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 丢弃，不抛出异常</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 和最早创建的线程进行竞争，不抛出异常</li></ul></li></ul><h2 id="86-AQS"><a href="#86-AQS" class="headerlink" title="86. AQS"></a>86. AQS</h2><h3 id="86-1-概述"><a href="#86-1-概述" class="headerlink" title="86.1 概述"></a>86.1 概述</h3><ul><li>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。</li><li>这个类在 <code>java.util.concurrent.locks</code> 包下面。</li><li>AQS 是一个抽象类，主要用来构建<strong>锁</strong>和<strong>同步器</strong>。</li></ul><h3 id="86-2-自旋锁和非自旋锁"><a href="#86-2-自旋锁和非自旋锁" class="headerlink" title="86.2 自旋锁和非自旋锁"></a>86.2 自旋锁和非自旋锁</h3><ul><li>什么是自旋锁：<ul><li>它并不会放弃CPU时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止；</li></ul></li><li>什么是非自旋锁：<ul><li>如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁</li><li>非自旋锁和自旋锁最大的区别，在非自旋锁遇到拿不到锁的情况，它会把线程阻塞，直到被唤醒。而自旋锁会不停地尝试。</li></ul></li></ul><h3 id="86-3-CLH锁"><a href="#86-3-CLH锁" class="headerlink" title="86.3 CLH锁"></a>86.3 CLH锁</h3><ul><li>CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。</li><li>在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</li><li>CLH 队列结构如下图所示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/16.png"></li></ul><h3 id="86-4-AQS原理"><a href="#86-4-AQS原理" class="headerlink" title="86.4 AQS原理"></a>86.4 AQS原理</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。</p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/14.png"></p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/15.png"></p><h2 id="87-IO"><a href="#87-IO" class="headerlink" title="87. IO"></a>87. IO</h2><h3 id="87-1-IO流简介"><a href="#87-1-IO流简介" class="headerlink" title="87.1 IO流简介"></a>87.1 IO流简介</h3><ul><li>概念：IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</li><li>分类：IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</li><li>4个抽象类基类：Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。<ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul></li></ul><h3 id="87-2-字节流"><a href="#87-2-字节流" class="headerlink" title="87.2 字节流"></a>87.2 字节流</h3><ul><li><p>InputStream（字节输入流）（抽象类）</p><ul><li>FileInputStream（子类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 目标：掌握文件字节输入流，每次读取一个字节。</span><br><span class="line">*/</span><br><span class="line">public class FileInputStreamTest1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       // 1、创建文件字节输入流管道，与源文件接通。</span><br><span class="line">       InputStream is = new FileInputStream((&quot;file-io-app\\src\\itheima01.txt&quot;));</span><br><span class="line">  </span><br><span class="line">       // 2、开始读取文件的字节数据。</span><br><span class="line">       // public int read():每次读取一个字节返回，如果没有数据了，返回-1.</span><br><span class="line">       int b; // 用于记住读取的字节。</span><br><span class="line">       while ((b = is.read()) != -1)&#123;</span><br><span class="line">           System.out.print((char) b);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //3、流使用完毕之后，必须关闭！释放系统资源！</span><br><span class="line">       is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>BufferedInputStream（字节缓冲输入流）：缓冲流的底层自己封装了一个长度为<strong>8KB（8129byte）的字节数组</strong>，但是缓冲流不能单独使用，它需要依赖于原始流。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedInputStreamTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            InputStream is = new FileInputStream(&quot;io-app2/src/itheima01.txt&quot;);</span><br><span class="line">            // 1、定义一个字节缓冲输入流包装原始的字节输入流</span><br><span class="line">            InputStream bis = new BufferedInputStream(is);</span><br><span class="line">            </span><br><span class="line">            OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima01_bak.txt&quot;);</span><br><span class="line">            // 2、定义一个字节缓冲输出流包装原始的字节输出流</span><br><span class="line">            OutputStream bos = new BufferedOutputStream(os);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            byte[] buffer = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line">            while ((len = bis.read(buffer)) != -1)&#123;</span><br><span class="line">                bos.write(buffer, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;复制完成！！&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>OutputStream（字节输出流）（抽象类）</p><ul><li>FileOutputStream（子类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 目标：掌握文件字节输出流FileOutputStream的使用。</span><br><span class="line">*/</span><br><span class="line">public class FileOutputStreamTest4 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">         // 1、创建一个字节输出流管道与目标文件接通。</span><br><span class="line">         // 覆盖管道：覆盖之前的数据</span><br><span class="line">         //  OutputStream os = new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;);</span><br><span class="line">         // 追加数据的管道</span><br><span class="line">         OutputStream os = new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;, true);</span><br><span class="line">    </span><br><span class="line">         // 2、开始写字节数据出去了</span><br><span class="line">         os.write(97);         // 97就是一个字节，代表a</span><br><span class="line">         os.write(&#x27;b&#x27;);       // &#x27;b&#x27;也是一个字节</span><br><span class="line">         // os.write(&#x27;磊&#x27;);   // [ooo] 默认只能写出去一个字节</span><br><span class="line">    </span><br><span class="line">         byte[] bytes = &quot;我爱你中国abc&quot;.getBytes();</span><br><span class="line">         os.write(bytes);</span><br><span class="line">    </span><br><span class="line">         os.write(bytes, 0, 15);</span><br><span class="line">    </span><br><span class="line">         // 换行符</span><br><span class="line">         os.write(&quot;\r\n&quot;.getBytes());</span><br><span class="line">    </span><br><span class="line">         os.close(); // 关闭流</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>BufferedOutputStream（字节缓冲输出流）</li></ul></li></ul><h3 id="87-3-字符流"><a href="#87-3-字符流" class="headerlink" title="87.3 字符流"></a>87.3 字符流</h3><ul><li><p>Reader（字符输入流）（抽象类）</p><ul><li>FileReader（子类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 目标：掌握文件字符输入流。</span><br><span class="line">*/</span><br><span class="line">public class FileReaderTest1 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个文件字符输入流管道与源文件接通</span><br><span class="line">            Reader fr = new FileReader(&quot;io-app2\\src\\itheima01.txt&quot;);</span><br><span class="line">        )&#123;</span><br><span class="line">            // 2、每次读取多个字符。</span><br><span class="line">            char[] buffer = new char[3];</span><br><span class="line">            int len; // 记住每次读取了多少个字符。</span><br><span class="line">            while ((len = fr.read(buffer)) != -1)&#123;</span><br><span class="line">                // 读取多少倒出多少</span><br><span class="line">                System.out.print(new String(buffer, 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BufferedReader（字符缓冲输入流）：它底层也会有一个<strong>8KB的字符数组</strong>。字符缓冲流也不能单独使用，它需要依赖于原始字符流一起使用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedReaderTest2 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        try (</span><br><span class="line">            Reader fr = new FileReader(&quot;io-app2\\src\\itheima04.txt&quot;);</span><br><span class="line">            // 创建一个字符缓冲输入流包装原始的字符输入流</span><br><span class="line">            BufferedReader br = new BufferedReader(fr);</span><br><span class="line">        )&#123;</span><br><span class="line">            String line; // 记住每次读取的一行数据</span><br><span class="line">            while ((line = br.readLine()) != null)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>InputStreamReader（转换流）：<ul><li>FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码。转换流可以将字节流转换为字符流，并且可以指定编码方案。</li><li>InputStreamReader类表示可以把InputStream转换为Reader，它是字符输入流。</li><li>InputStreamReader也是不能单独使用的，它内部需要封装一个InputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InputStreamReaderTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、得到文件的原始字节流（GBK的字节流形式）</span><br><span class="line">            InputStream is = new FileInputStream(&quot;io-app2/src/itheima06.txt&quot;);</span><br><span class="line">            // 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流</span><br><span class="line">            Reader isr = new InputStreamReader(is, &quot;GBK&quot;);</span><br><span class="line">            // 3、把字符输入流包装成缓冲字符输入流</span><br><span class="line">            BufferedReader br = new BufferedReader(isr);</span><br><span class="line">        )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = br.readLine()) != null)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>Writer（字符输出流）（抽象类）</p><ul><li>FileWriter（子类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 目标：掌握文件字符输出流：写字符数据出去</span><br><span class="line">*/</span><br><span class="line">public class FileWriterTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 0、创建一个文件字符输出流管道与目标文件接通。</span><br><span class="line">            // 覆盖管道</span><br><span class="line">            // Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;);</span><br><span class="line">            // 追加数据的管道</span><br><span class="line">            Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;, true);</span><br><span class="line">        )&#123;</span><br><span class="line">            // 1、public void write(int c): 写一个字符出去</span><br><span class="line">            fw.write(&#x27;a&#x27;);</span><br><span class="line">            fw.write(97);</span><br><span class="line">            fw.write(&#x27;磊&#x27;);        // 写一个字符出去</span><br><span class="line">            fw.write(&quot;\r\n&quot;);     // 换行    </span><br><span class="line">            // 2、public void write(String c): 写一个字符串出去</span><br><span class="line">            fw.write(&quot;我爱你中国abc&quot;);</span><br><span class="line">            fw.write(&quot;\r\n&quot;);    </span><br><span class="line">            // 3、public void write(String c ,int pos ,int len): 写字符串的一部分出去</span><br><span class="line">            fw.write(&quot;我爱你中国abc&quot;, 0, 5);</span><br><span class="line">            fw.write(&quot;\r\n&quot;);    </span><br><span class="line">            // 4、public void write(char[] buffer): 写一个字符数组出去</span><br><span class="line">            char[] buffer = &#123;&#x27;黑&#x27;, &#x27;马&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span><br><span class="line">            fw.write(buffer);</span><br><span class="line">            fw.write(&quot;\r\n&quot;);    </span><br><span class="line">            // 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span><br><span class="line">            fw.write(buffer, 0, 2);</span><br><span class="line">            fw.write(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>BufferedWriter（字符缓冲输出流）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedWriterTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            Writer fw = new FileWriter(&quot;io-app2/src/itheima05out.txt&quot;, true);</span><br><span class="line">            // 创建一个字符缓冲输出流管道包装原始的字符输出流</span><br><span class="line">            BufferedWriter bw = new BufferedWriter(fw);</span><br><span class="line">        )&#123;</span><br><span class="line">            bw.write(&#x27;a&#x27;);</span><br><span class="line">            bw.write(97);</span><br><span class="line">            bw.write(&#x27;磊&#x27;);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">            bw.write(&quot;我爱你中国abc&quot;);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>OutputStreamWriter（转换流）<ul><li>OutputStreamWriter类表示可以把OutputStream转换为Writer，它是字符输出流。</li><li>OutputStreamReader也是不能单独使用的，它内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class OutputStreamWriterTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 指定写出去的字符编码。</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个文件字节输出流</span><br><span class="line">            OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima07out.txt&quot;);</span><br><span class="line">            // 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。</span><br><span class="line">            Writer osw = new OutputStreamWriter(os, &quot;GBK&quot;);</span><br><span class="line">            // 3、把字符输出流包装成缓冲字符输出流</span><br><span class="line">            BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line">        )&#123;</span><br><span class="line">            bw.write(&quot;我是中国人abc&quot;);</span><br><span class="line">            bw.write(&quot;我爱你中国123&quot;);</span><br><span class="line">    </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="87-4-打印流"><a href="#87-4-打印流" class="headerlink" title="87.4 打印流"></a>87.4 打印流</h3><ul><li>PrintStream：字节打印流<ul><li>System.out 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。</li><li>PrintStream 是 OutputStream 的子类</li></ul></li><li>PrintWriter：字符打印流<ul><li>PrintWriter 是 Writer 的子类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class PrintTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个打印流管道</span><br><span class="line">            // PrintStream ps = new PrintStream(&quot;io-app2/src/itheima08.txt&quot;, Charset.forName(&quot;GBK&quot;));</span><br><span class="line">            // PrintStream ps = new PrintStream(&quot;io-app2/src/itheima08.txt&quot;);</span><br><span class="line">            PrintWriter ps = new PrintWriter(new FileOutputStream(&quot;io-app2/src/itheima08.txt&quot;, true));</span><br><span class="line">        )&#123;</span><br><span class="line">            ps.print(97);//文件中显示的就是:97</span><br><span class="line">            ps.print(&#x27;a&#x27;); //文件中显示的就是:a</span><br><span class="line">            ps.println(&quot;我爱你中国abc&quot;);//文件中显示的就是:我爱你中国abc</span><br><span class="line">            ps.println(true);//文件中显示的就是:true</span><br><span class="line">            ps.println(99.5);//文件中显示的就是99.5</span><br><span class="line">            </span><br><span class="line">            ps.write(97); //文件中显示a，发现和前面println方法的区别了吗？</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="87-5-序列化流"><a href="#87-5-序列化流" class="headerlink" title="87.5 序列化流"></a>87.5 序列化流</h3><ul><li><p>ObjectInputStream</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 注意：对象如果需要序列化，必须实现序列化接口。</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private String loginName;</span><br><span class="line">    private String userName;</span><br><span class="line">    private int age;</span><br><span class="line">    // transient 这个成员变量将不参与序列化。</span><br><span class="line">    private transient String passWord;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String loginName, String userName, int age, String passWord) &#123;</span><br><span class="line">        this.loginName = loginName;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;loginName=&#x27;&quot; + loginName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, userName=&#x27;&quot; + userName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, passWord=&#x27;&quot; + passWord + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test2ObjectInputStream &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个对象字节输入流管道，包装 低级的字节输入流与源文件接通</span><br><span class="line">            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;io-app2/src/itheima11out.txt&quot;));</span><br><span class="line">        )&#123;</span><br><span class="line">            // 2. 读取object对象</span><br><span class="line">            User u = (User) input.readObject();</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ObjectOutputStream</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test1ObjectOutputStream &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个对象字节输出流包装原始的字节 输出流。</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;io-app2/src/itheima11out.txt&quot;));</span><br><span class="line">                )&#123;</span><br><span class="line">            // 2、创建一个Java对象。</span><br><span class="line">            User u = new User(&quot;admin&quot;, &quot;张三&quot;, 32, &quot;666888xyz&quot;);</span><br><span class="line"></span><br><span class="line">            // 3、序列化对象到文件中去</span><br><span class="line">            oos.writeObject(u);</span><br><span class="line">            System.out.println(&quot;序列化对象成功！！&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="87-6-IO-设计模式"><a href="#87-6-IO-设计模式" class="headerlink" title="87.6 IO 设计模式"></a>87.6 IO 设计模式</h3><ul><li><p>装饰器模式：</p><ul><li>概念：Decorator Pattern，可以在不改变原有对象的情况下拓展其功能。装饰器模式通过组合，替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 例子：</span><br><span class="line">try (BufferedInputStream input = new BufferedInputStream(new FileInputStream(&quot;input.txt&quot;))) &#123;</span><br><span class="line">  int content;</span><br><span class="line">  long skip = input.skip(2);</span><br><span class="line">  while ((content = input.read()) != -1) &#123;</span><br><span class="line">      System.out.print((char) content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思考：为什么不直接弄一个<code>BufferedFileInputStream</code>（字符缓冲文件输入流）呢？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedFileInputStream bfis = new BufferedFileInputStream(&quot;input.txt&quot;);</span><br></pre></td></tr></table></figure><ul><li>InputStream的子类实在太多，继承关系也非常复杂。如果为每一个子类都定制一个对应的缓冲输入流，非常麻烦。</li><li>通过装饰器模式代替继承可以扩展原始类的功能。</li></ul></li></ul></li><li><p>适配器模式：</p><ul><li>概念：Adapter Pattern，主要用于接口互不兼容的类的协调工作。被适配的对象或者类称为适配者(Adaptee)，作用于适配者的对象或者类称为适配器(Adapter) 。</li><li>适配器：<code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code>（流解码器）对字节进行解码，实现字节流到字符流的转换， <code>OutputStreamWriter</code> 使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换。</li><li>适配者：InputStream 和 OutputStream 的子类是适配者。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span><br><span class="line">InputStreamReader input = new InputStreamReader(new FileInputStream(fileName), &quot;UTF-8&quot;);</span><br><span class="line">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span><br><span class="line">BufferedReader bufferedReader = new BufferedReader(input);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="88-IO模型"><a href="#88-IO模型" class="headerlink" title="88. IO模型"></a>88. IO模型</h2><h3 id="88-1-BIO-Blocking-I-x2F-O"><a href="#88-1-BIO-Blocking-I-x2F-O" class="headerlink" title="88.1 BIO (Blocking I&#x2F;O)"></a>88.1 BIO (Blocking I&#x2F;O)</h3><ul><li>定义：<ul><li>BIO 属于同步阻塞 IO 模型 。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</li></ul></li><li>缺点：<ul><li>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</li></ul></li></ul><h3 id="88-2-NIO-Non-blocking-x2F-New-I-x2F-O"><a href="#88-2-NIO-Non-blocking-x2F-New-I-x2F-O" class="headerlink" title="88.2 NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>88.2 NIO (Non-blocking&#x2F;New I&#x2F;O)</h3><ul><li>定义：<ul><li>NIO 属于同步非阻塞 IO 模型。同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</li></ul></li></ul><h3 id="88-3-AIO-Asynchronous-I-x2F-O"><a href="#88-3-AIO-Asynchronous-I-x2F-O" class="headerlink" title="88.3 AIO (Asynchronous I&#x2F;O)"></a>88.3 AIO (Asynchronous I&#x2F;O)</h3><ul><li>定义：<ul><li>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是异步 IO 模型。</li></ul></li></ul><h2 id="89-JVM-内存区域"><a href="#89-JVM-内存区域" class="headerlink" title="89. JVM 内存区域"></a>89. JVM 内存区域</h2><h3 id="89-1-概述"><a href="#89-1-概述" class="headerlink" title="89.1 概述"></a>89.1 概述</h3><ul><li>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</li><li>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/17.png"></p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/18.png"></p><ul><li><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul></li></ul><h3 id="89-2-线程私有：程序计数器-Program-Counter-Register"><a href="#89-2-线程私有：程序计数器-Program-Counter-Register" class="headerlink" title="89.2 线程私有：程序计数器(Program Counter Register)"></a>89.2 线程私有：程序计数器(Program Counter Register)</h3><ul><li>概念：<ul><li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li></ul></li><li>特点：<ul><li>线程私有</li><li>生命周期：与线程共存亡</li><li>一块较小的内存空间,存储字节码行号；</li><li>是唯一一块不会出现OutOfMemoryError的内存区域；</li></ul></li><li>作用：<ul><li>字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，从而实现代码的流程控制；</li><li>多线程情况下，用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了。</li></ul></li></ul><h3 id="89-3-线程私有：Java-虚拟机栈"><a href="#89-3-线程私有：Java-虚拟机栈" class="headerlink" title="89.3 线程私有：Java 虚拟机栈"></a>89.3 线程私有：Java 虚拟机栈</h3><ul><li>概念：<ul><li>描述的是Java方法执行的线程内存模型：每个方法被执行时，Java虚拟机都会同步创建一个栈帧（用于存储局部变量表、操作数栈、动态链接、方法返回地址），每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/19.png"></li></ul></li><li>特点：<ul><li>线程私有</li><li>生命周期：与线程共存亡</li><li>栈帧中存储局部变量表、操作数栈、动态链接、方法返回地址</li><li>会出现两种错误：<ul><li>StackOverFlowError：（stack内存不允许动态扩展时）当线程请求的栈的深度超过当前Java虚拟机栈的最大深度时报错；</li><li>OutOfMemoryError：（stack内存允许动态扩展时）如果虚拟机的动态扩展栈时无法申请到足够的空间，则报异常。(HotSpot虚拟机是不支持动态扩展的，但如果是手动申请栈空间失败了也会报OOM异常)</li></ul></li></ul></li></ul><h3 id="89-4-线程私有：本地方法栈"><a href="#89-4-线程私有：本地方法栈" class="headerlink" title="89.4 线程私有：本地方法栈"></a>89.4 线程私有：本地方法栈</h3><ul><li>概念：<ul><li>基本功能和Java虚拟机栈基本一样。</li></ul></li><li>和Java虚拟机栈的区别是：<ul><li>Java虚拟机栈描述Java方法的执行；</li><li>本地方法栈描述Native方法的执行。</li></ul></li></ul><h3 id="89-5-线程共享：堆"><a href="#89-5-线程共享：堆" class="headerlink" title="89.5 线程共享：堆"></a>89.5 线程共享：堆</h3><ul><li><p>特点：</p><ul><li>唯一目的：存放实例对象（几乎所有的实例对象和数组都在这里分配内存）</li><li>线程共享</li><li>生命周期：与虚拟机共存亡</li><li>Java虚拟机所管制内存中最大的一块</li><li>GC的主要区域</li><li>最容易出现OutOfMemoryError错误</li></ul></li><li><p>堆内存划分：</p><ul><li>更好地回收内存，更快的分配内存。</li><li>不同版本堆内存划分：<ul><li>在 JDK 7 版本及之前版本，堆内存被通常分为下面三部分：<ul><li>新生代内存(Young Generation)(Eden 区、两个 Survivor 区 S0 和 S1 )</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ul></li><li>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/20.png"></li></ul></li></ul></li><li><p>年轻代（Eden、S0、S1）、老年代</p><ul><li>默认情况下，年轻代与老年代比例为1:2，可以通过参数 -xx:NewRatio 修改，NewRatio默认值是2</li><li>默认情况下Eden、S0、S1的比例是8:1:1，可以通过参数 -xx:SurvivorRatio 修改，SurvivorRatio默认值是8<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/22.png"></li></ul></li></ul><h3 id="89-6-线程共享：方法区"><a href="#89-6-线程共享：方法区" class="headerlink" title="89.6 线程共享：方法区"></a>89.6 线程共享：方法区</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/23.png"></p><ul><li><p>概念：</p><ul><li>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</li></ul></li><li><p>特点：</p><ul><li>线程共享</li><li>存储：已被虚拟机加载的类信息、静态变量、常量、即时编译器编译后的代码等数据</li><li>GC较少出现，但并非不出现</li></ul></li><li><p>方法区和永久代的关系</p><ul><li>方法区：是一个概念，并没有具体的实现（类似于接口）</li><li>永久代：是HotSpot虚拟机中对方法区的一种实现方式 （类似于接口的实现类）<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/21.png"></li></ul></li><li><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><ul><li>永久代有JVM本身设置的固定内存大小上限，而元空间使用直接内存，受本机可用内存的限制，使得溢出的几率减小。</li><li>Java虚拟机能够加载多少类可直接由系统的实际可用空间来控制，使得能够加载更多的类。</li></ul></li></ul><h3 id="89-7-线程共享：运行时常量池"><a href="#89-7-线程共享：运行时常量池" class="headerlink" title="89.7 线程共享：运行时常量池"></a>89.7 线程共享：运行时常量池</h3><ul><li><p>特点：</p><ul><li>方法区的一部分；</li><li>常量池将在类加载后存放到方法区的运行时常量池中；</li><li>当常量池无法再申请到内存时会抛出OutOfMemoryError错误</li></ul></li><li><p>方法区的Class文件信息，Class常量池和运行时常量池的三者关系</p></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/24.png"></p><h3 id="89-8-线程共享：字符串常量池"><a href="#89-8-线程共享：字符串常量池" class="headerlink" title="89.8 线程共享：字符串常量池"></a>89.8 线程共享：字符串常量池</h3><ul><li><p>概念：</p><ul><li><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在堆中创建字符串对象”ab“</span><br><span class="line">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="line">String aa = &quot;ab&quot;;</span><br><span class="line">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="line">String bb = &quot;ab&quot;;</span><br><span class="line">System.out.println(aa==bb); // true</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><ul><li>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</li></ul></li></ul><h3 id="89-9-线程共享：直接内存"><a href="#89-9-线程共享：直接内存" class="headerlink" title="89.9 线程共享：直接内存"></a>89.9 线程共享：直接内存</h3><ul><li>不是虚拟机运行时数据区的一部分</li><li>会导致OutOfMemoryError错误出现</li><li>本机直接内存的分配不会受到Java堆的限制，但是既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</li></ul><h2 id="90-HotSpot虚拟机对象"><a href="#90-HotSpot虚拟机对象" class="headerlink" title="90. HotSpot虚拟机对象"></a>90. HotSpot虚拟机对象</h2><h3 id="90-1-对象的创建"><a href="#90-1-对象的创建" class="headerlink" title="90.1 对象的创建"></a>90.1 对象的创建</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/25.png"></p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/26.png"></p><ul><li><p>Step1:类加载检查</p><ul><li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li></ul></li><li><p>Step2:分配内存</p><ul><li><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p></li><li><p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li><ol><li>指针碰撞：</li></ol><ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li><ol start="2"><li>空闲列表：</li></ol><ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul></li><li><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p></li><li><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><ul><li>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</li><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul></li></ul></li><li><p>Step3:初始化零值</p><ul><li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li></ul></li><li><p>Step4:设置对象头</p><ul><li>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li></ul></li><li><p>Step5:执行 init 方法</p><ul><li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul></li></ul><h3 id="90-2-对象的访问定位"><a href="#90-2-对象的访问定位" class="headerlink" title="90.2 对象的访问定位"></a>90.2 对象的访问定位</h3><ul><li>概念：<ul><li>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</li></ul></li><li>分类：<ul><li>句柄：<ul><li>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li></ul></li><li>直接指针<ul><li>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</li></ul></li></ul></li><li>两种分类的优缺点：<ul><li>这两种对象访问方式各有优势。</li><li>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li><li>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</li></ul></li></ul><h2 id="90-JVM垃圾回收"><a href="#90-JVM垃圾回收" class="headerlink" title="90. JVM垃圾回收"></a>90. JVM垃圾回收</h2><h3 id="90-1-垃圾回收机制"><a href="#90-1-垃圾回收机制" class="headerlink" title="90.1 垃圾回收机制"></a>90.1 垃圾回收机制</h3><ul><li><ol><li>所有的对象首先会在Eden区进行分配，当Eden区满了之后会进行第1次Minor GC；</li></ol></li><li><ol start="2"><li>第1次GC之后仍然存活的对象，会复制到Survivor S0，同时对象年龄+1(此时年龄&#x3D;1)，然后清理其之前占用的内存；</li></ol></li><li><ol start="3"><li>第2次会对Eden+S0同时进行GC，仍然存活的对象会复制到Survivor S1，年龄+1，同时清理之前占用的内存(此时S0区会变成空)；</li></ol></li><li><ol start="4"><li>以此类推，每次都有一个Survivor区是空的；</li></ol></li><li><ol start="5"><li>当Survivor区域对象的年龄达到 -xx:MaxTenuringThreshold 设定的值(默认15)，会将此对象移到老年代，同时清空他们在年轻代占用的内存空间；</li></ol></li><li><ol start="6"><li>当老年代空间不够用了，会发生Full GC (回收整个堆内存)；</li></ol></li><li><ol start="7"><li>当某些大对象需要分配一块较大的连续空间时会直接进入老年代，而不会经过以上步骤。</li></ol></li></ul><h3 id="90-2-死亡对象判断方法"><a href="#90-2-死亡对象判断方法" class="headerlink" title="90.2 死亡对象判断方法"></a>90.2 死亡对象判断方法</h3><ul><li><p>引用计数法：</p><ul><li>概念：给对象中添加一个引用计数器：每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</li><li>缺点：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</li></ul></li><li><p>可达性分析算法：</p><ul><li>概念：目前的主流算法。这个算法的基本思想就是通过一系列被称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/27.png"></li><li>对象可以被回收，就代表一定会被回收吗？<ul><li>被判定为需要回收的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</li></ul></li></ul></li></ul><h3 id="90-3-垃圾回收算法"><a href="#90-3-垃圾回收算法" class="headerlink" title="90.3 垃圾回收算法"></a>90.3 垃圾回收算法</h3><ul><li>标记-清除算法<ul><li>它的思想就是先标记（两次标记），再清除。</li><li>缺点：<ul><li>效率不高（标记和清除两个过程效率都不高。）</li><li>会产生大量内存碎片（内存碎片是指内存的空间比较零碎，缺少大段的连续空间。这样假如突然来了一个大对象，会找不到足够大的连续空间来存放，于是不得不再触发一次gc。）<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/28.png"></li></ul></li></ul></li><li>复制算法<ul><li>概念：为了解决标记-清除算法的效率和内存碎片问题，复制算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</li><li>缺点：<ul><li>可用内存变小：可用内存缩小为原来的一半。</li><li>不适合老年代：如果存活对象数量比较大，复制性能会变得很差。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/29.png"></li></ul></li></ul></li><li>标记-整理算法<ul><li>概念：标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</li><li>缺点：<ul><li>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</li></ul></li></ul></li><li>分代回收算法<ul><li>概念：当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li></ul></li></ul><h2 id="91-类加载器"><a href="#91-类加载器" class="headerlink" title="91. 类加载器"></a>91. 类加载器</h2><h3 id="91-1-类加载过程"><a href="#91-1-类加载过程" class="headerlink" title="91.1 类加载过程"></a>91.1 类加载过程</h3><ul><li><p>类的生命周期：</p><ul><li>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：<ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）（验证、准备和解析这三个阶段可以统称为连接（Linking））</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/30.png"></li></ul></li></ul></li><li><p>类加载过程：</p><ul><li>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/31.png"></li></ul></li></ul><h3 id="91-1-类加载器"><a href="#91-1-类加载器" class="headerlink" title="91.1 类加载器"></a>91.1 类加载器</h3><ul><li><p>作用：</p><ul><li><strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序（<code>.java</code>文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</li><li>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。</li></ul></li><li><p>类加载器加载规则</p><ul><li>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</li><li>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</li></ul></li><li><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ul><li>**<code>Bootstrap ClassLoader</code>(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li>**<code>Extension ClassLoader</code>(扩展类加载器)**：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li>**<code>Application Classloader</code>(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ul></li></ul><h3 id="91-2-双亲委派模型"><a href="#91-2-双亲委派模型" class="headerlink" title="91.2 双亲委派模型"></a>91.2 双亲委派模型</h3><ul><li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li></ul><h3 id="91-3-双亲委派模型的好处"><a href="#91-3-双亲委派模型的好处" class="headerlink" title="91.3 双亲委派模型的好处"></a>91.3 双亲委派模型的好处</h3><ul><li>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</li><li>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</li></ul><h2 id="92-排查-OOM"><a href="#92-排查-OOM" class="headerlink" title="92. 排查 OOM"></a>92. 排查 OOM</h2><h3 id="92-1-常见的-OOM-异常情况有两种"><a href="#92-1-常见的-OOM-异常情况有两种" class="headerlink" title="92.1 常见的 OOM 异常情况有两种"></a>92.1 常见的 OOM 异常情况有两种</h3><ul><li>堆内存溢出</li><li>方法区溢出</li></ul><h3 id="92-2-堆内存溢出"><a href="#92-2-堆内存溢出" class="headerlink" title="92.2 堆内存溢出"></a>92.2 堆内存溢出</h3><ul><li>java.lang.OutOfMemoryError: Java heap space ——&gt;java 堆内存溢出，</li><li>此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。</li><li>对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx 来修改。</li></ul><h3 id="92-3-方法区溢出"><a href="#92-3-方法区溢出" class="headerlink" title="92.3 方法区溢出"></a>92.3 方法区溢出</h3><ul><li>java.lang.OutOfMemoryError: PermGen space 或 java.lang.OutOfMemoryError：MetaSpace ——&gt;java 方法区溢出</li><li>一般出现在大量 Class、或者采用 cglib 等反射机制的情况，因为这些情况会产生大量的 Class 信息存储于方法区。过多的常量尤其是字符串也会导致方法区溢出。</li><li>这种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m -XX:MaxPermSize&#x3D;256m 的形式修改。</li></ul><h3 id="92-4-排查方式："><a href="#92-4-排查方式：" class="headerlink" title="92.4 排查方式："></a>92.4 排查方式：</h3><ul><li>先获取内存的 Dump 文件，Dump 文件有两种方式来生成：<ul><li>第一种是配置 JVM 启动参数，当触发了 OOM 异常的时候自动生成，</li><li>第二种是使用 jmap 工具来生成。</li></ul></li><li>然后使用 MAT 工具来分析 Dump 文件。<ul><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类信息和 GC Roots 引用链的信息，就可以比较准确地定位泄漏代码的位置。</li><li>如果是普通的内存溢出，确实有很多占用内存的对象，那就只需要提升堆内存空间即可。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Java-语言的特点&quot;&gt;&lt;a href=&quot;#1-Java-语言的特点&quot; class=&quot;headerlink&quot; title=&quot;1. Java 语言的特点&quot;&gt;&lt;/a&gt;1. Java 语言的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简单易学；&lt;/li&gt;
&lt;li&gt;面向对象（封装</summary>
      
    
    
    
    <category term="面试" scheme="https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试-算法</title>
    <link href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/"/>
    <id>https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/</id>
    <published>2021-06-08T11:50:53.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要总结算法的模板题</span><br></pre></td></tr></table></figure><h2 id="1-输入输出"><a href="#1-输入输出" class="headerlink" title="1. 输入输出"></a>1. 输入输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常用的数据输入方法有两种，Scanner和BufferedReader。</span><br><span class="line">BufferedReader可以读一行，速度比Scanner快，所以数据较多的时候使用。</span><br><span class="line">注意BufferedReader用完记得关。</span><br></pre></td></tr></table></figure><h3 id="1-1-输入"><a href="#1-1-输入" class="headerlink" title="1.1 输入"></a>1.1 输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入包</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="comment">//2. 抛出IOException异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 3. 定义BufferedReader类</span></span><br><span class="line">        <span class="comment">// 最后不要忘了关闭reader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 只读取一行字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="comment">// 连续读取多行字符串</span></span><br><span class="line">        String string2;</span><br><span class="line">        <span class="keyword">while</span>((str = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果不为空，才进行下述操作</span></span><br><span class="line">            System.out.println(string2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * char</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 一行一个char</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ca</span> <span class="operator">=</span> reader.readLine().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 一行一个char数组</span></span><br><span class="line">        <span class="type">char</span>[] charArray = reader.readLine().toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 整型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 一行一个整数</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">short1</span> <span class="operator">=</span> Short.parseShort(reader.readLine());</span><br><span class="line">        <span class="type">int</span> <span class="variable">int1</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="type">long</span> <span class="variable">long1</span> <span class="operator">=</span> Long.parseLong(reader.readLine());</span><br><span class="line">        <span class="comment">// 一行多个整数</span></span><br><span class="line">        String[] sList = reader.readLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">//用空格分割，也可以用逗号分割</span></span><br><span class="line">        <span class="keyword">for</span> (String s : sList)&#123;</span><br><span class="line">            <span class="comment">// String转为整数</span></span><br><span class="line">            System.out.println(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转化为int数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[s.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            arr[i] = Integer.parseInt(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 浮点型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// float</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(reader.readLine());</span><br><span class="line">        <span class="comment">// double</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(reader.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(reader.readLine());</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(reader.readLine());</span><br><span class="line">        <span class="comment">// 加</span></span><br><span class="line">        System.out.println(bigInteger1.add(bigInteger2));</span><br><span class="line">        <span class="comment">// 减 </span></span><br><span class="line">        System.out.println(bigInteger1.subtract(bigInteger2));</span><br><span class="line">        <span class="comment">// 乘</span></span><br><span class="line">        System.out.println(bigInteger1.multiply(bigInteger2));</span><br><span class="line">        <span class="comment">// 除</span></span><br><span class="line">        System.out.println(bigInteger1.divide(bigInteger2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 高精度浮点数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(reader.readLine());</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(reader.readLine());</span><br><span class="line">        <span class="comment">// 加</span></span><br><span class="line">        System.out.println(bigDecimal1.add(bigDecimal2));</span><br><span class="line">        <span class="comment">// 减</span></span><br><span class="line">        System.out.println(bigDecimal1.subtract(bigDecimal2));</span><br><span class="line">        <span class="comment">// 乘</span></span><br><span class="line">        System.out.println(bigDecimal1.multiply(bigDecimal2));</span><br><span class="line">        <span class="comment">// 除</span></span><br><span class="line">        System.out.println(bigDecimal1.divide(bigDecimal2, <span class="number">3</span>, RoundingMode.HALF_UP)); <span class="comment">// 第二个参数：保留小数位数；第三位参数：四舍五入模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进制</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 字符串转2进制int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">int2</span> <span class="operator">=</span> Integer.parseInt(reader.readLine(), <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 字符串转2进制大数</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(reader.readLine(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * double格式化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 导入包：import java.text.*;</span></span><br><span class="line">        NumberFormat formatter;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">1234.567</span>;</span><br><span class="line">        <span class="comment">// 强制在整数部分加0：0，多几位就多几个0</span></span><br><span class="line">        formatter = <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000000&quot;</span>);</span><br><span class="line">        s = formatter.format(d);</span><br><span class="line">        System.out.println(s);                  <span class="comment">// -001235</span></span><br><span class="line">        formatter = <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00&quot;</span>);</span><br><span class="line">        s = formatter.format(d);</span><br><span class="line">        System.out.println(s);                  <span class="comment">// -1235</span></span><br><span class="line">        <span class="comment">// 强制保留小数部分：0，有几个0就保留几位小数</span></span><br><span class="line">        formatter = <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000000.00&quot;</span>);</span><br><span class="line">        s = formatter.format(d);</span><br><span class="line">        System.out.println(s);                  <span class="comment">// -001235.57</span></span><br><span class="line">        formatter = <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;.00&quot;</span>);</span><br><span class="line">        s = formatter.format(d);</span><br><span class="line">        System.out.println(s);                  <span class="comment">// -1235.57</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;array默认升序_________________________________________________&quot;</span>);</span><br><span class="line">        <span class="comment">//默认升序，从小到大</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;array降序_______________________________________________&quot;</span>);</span><br><span class="line">        Integer[] arr2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">// 只支持包装类元素逆序</span></span><br><span class="line">        Arrays.sort(arr2,Collections.reverseOrder());</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;List默认升序_______________________________________________&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; arrList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrList.add(<span class="number">1</span>);arrList.add(<span class="number">4</span>);arrList.add(<span class="number">2</span>);arrList.add(<span class="number">78</span>);arrList.add(<span class="number">23</span>);</span><br><span class="line">        <span class="comment">//集合工具类Collections，对集合进行升序排序</span></span><br><span class="line">        Collections.sort(arrList);</span><br><span class="line">        System.out.println(Arrays.toString(arrList.toArray()));</span><br><span class="line">        System.out.println(<span class="string">&quot;List降序__________________________________________________&quot;</span>);</span><br><span class="line">        Collections.sort(arrList,Collections.reverseOrder());</span><br><span class="line">        System.out.println(Arrays.toString(arrList.toArray()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭reader</span></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-输出"><a href="#1-2-输出" class="headerlink" title="1.2 输出"></a>1.2 输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1. 单行输出</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">// 2. 多行输出</span><br><span class="line">System.out.println(result1);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">System.out.println(result3);</span><br><span class="line"></span><br><span class="line">// 3. 格式化输出</span><br><span class="line">System.out.printf(&quot;Formatted result: %.2f&quot;, floatValue);</span><br><span class="line"></span><br><span class="line">// 4. 输出数组或集合</span><br><span class="line">int[] array = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int num : array) &#123;</span><br><span class="line">    System.out.print(num + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5. 特殊字符输出</span><br><span class="line">System.out.println(&quot;Line 1\nLine 2\tTabbed&quot;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2. 排序算法"></a>2. 排序算法</h2><h3 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A(排序) --&gt; B(内部排序)</span><br><span class="line">A(排序) --&gt; C(外部排序)</span><br><span class="line"></span><br><span class="line">B --&gt; D(选择排序)</span><br><span class="line">B --&gt; E(插入排序)</span><br><span class="line">B --&gt; F(交换排序)</span><br><span class="line">B --&gt; G(归并排序)</span><br><span class="line">B --&gt; H(桶排序)</span><br><span class="line"></span><br><span class="line">C --&gt; I(多路归并)</span><br><span class="line">C --&gt; J(败者树)</span><br><span class="line"></span><br><span class="line">D --&gt; K(直接选择排序)</span><br><span class="line">D --&gt; L(堆排序)</span><br><span class="line"></span><br><span class="line">E --&gt; M(直接插入排序)</span><br><span class="line">E --&gt; N(希尔排序)</span><br><span class="line"></span><br><span class="line">F --&gt; O(冒泡排序)</span><br><span class="line">F --&gt; P(快速排序)</span><br><span class="line"></span><br><span class="line">H --&gt; Q(计数排序)</span><br><span class="line">H --&gt; R(基数排序)</span><br></pre></td></tr></table></figure><h3 id="2-2-时间复杂度和空间复杂度"><a href="#2-2-时间复杂度和空间复杂度" class="headerlink" title="2.2 时间复杂度和空间复杂度"></a>2.2 时间复杂度和空间复杂度</h3><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>最好时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>直接选择排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n<sup>2</sup>)</td><td>O(nlogn)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(ns)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(N*M)</td><td>O(N*M)</td><td>O(N*M)</td><td>O(M)</td><td>稳定</td></tr></tbody></table><p><strong>注</strong>：基数排序: 基数排序时间复杂度为O(N*M)，其中N为数据个数，M为数据位数。</p><p><strong>记忆</strong>：</p><ul><li>时间复杂度：<ul><li>冒泡、选择、插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)）（一遍找元素O(n)，一遍找位置O(n)）</li><li>快速、堆、希尔、归并基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）</li></ul></li><li>稳定性：<ul><li>“快希选堆”（快牺牲稳定性）</li><li>排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。</li></ul></li></ul><h3 id="2-3-原理"><a href="#2-3-原理" class="headerlink" title="2.3 原理"></a>2.3 原理</h3><ul><li><p>冒泡排序</p><ul><li>原理：从数组最左端开始向右遍历，依次比较相邻元素大小，如果”左元素 &gt; 右元素”就交换它俩。遍历完成后，最大的元素会被移动到数组的最右端。</li><li>算法流程：<ul><li>首先，对n个元素执行”冒泡”，将数组的最大元素交换至正确位置，</li><li>接下来，对剩余n-1个元素执行”冒泡”，将第二大元素交换至正确位置。</li><li>以此类推，经过n-1轮”冒泡”后，前n-1大的元素都被交换至正确位置。</li><li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li></ul></li><li>图示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/1.png"></li><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 冒泡排序 */</span><br><span class="line">void bubbleSort(int[] nums) &#123;</span><br><span class="line">    // 外循环：未排序区间为 [0, i]</span><br><span class="line">    for (int i = nums.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 </span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[j] &gt; nums[j + 1]) &#123;</span><br><span class="line">                // 交换 nums[j] 与 nums[j + 1]</span><br><span class="line">                int tmp = nums[j];</span><br><span class="line">                nums[j] = nums[j + 1];</span><br><span class="line">                nums[j + 1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>选择排序：</p><ul><li>原理：轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</li><li>算法流程：<ul><li>初始状态下，所有元素未排序，即未排序（索引）区间为[0,n-1]。</li><li>选取区间[0,n-1]中的最小元素，将其与索引0处元素交换。完成后，数组前1个元素已排序。</li><li>选取区间[1,n-1]中的最小元素，将其与索引1处元素交换。完成后，数组前2个元素已排序。</li><li>以此类推。经过n-1轮选择与交换后，数组前n-1个元素已排序。</li><li>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。</li></ul></li><li>图示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/2.png"></li><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 选择排序 */</span><br><span class="line">void selectionSort(int[] nums) &#123;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    // 外循环：未排序区间为 [i, n-1]</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        // 内循环：找到未排序区间内的最小元素</span><br><span class="line">        int k = i;</span><br><span class="line">        for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[k])</span><br><span class="line">                k = j; // 记录最小元素的索引</span><br><span class="line">        &#125;</span><br><span class="line">        // 将该最小元素与未排序区间的首个元素交换</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        nums[i] = nums[k];</span><br><span class="line">        nums[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>插入排序</p><ul><li>原理：在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</li><li>算法流程：<ul><li>初始状态下，数组的第1个元素已完成排序。</li><li>选取数组的第2个元素作为base，将其插入到正确位置后，数组的前2个元素已排序。</li><li>选取第3个元素作为base，将其插入到正确位置后，数组的前3个元素已排序。</li><li>以此类推，在最后一轮中，选取最后一个元素作为base，将其插入到正确位置后，所有元素均已排序。</li></ul></li><li>图示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/3.png"></li><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 插入排序 */</span><br><span class="line">void insertionSort(int[] nums) &#123;</span><br><span class="line">    // 外循环：已排序元素数量为 1, 2, ..., n</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int base = nums[i], j = i - 1;</span><br><span class="line">        // 内循环：将 base 插入到已排序部分的正确位置</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + 1] = base;        // 将 base 赋值到正确位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>快速排序：</p><ul><li>原理：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</li><li>算法流程：<ul><li>选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端。</li><li>设置一个循环，在每轮中使用i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li><li>循环执行步骤2，直到i和j相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ul></li><li>图示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/4.png"></li><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* 元素交换 */</span><br><span class="line">void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 哨兵划分 */</span><br><span class="line">int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 以 nums[left] 作为基准数</span><br><span class="line">    int i = left, j = right;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])</span><br><span class="line">            j--;          // 从右向左找首个小于基准数的元素</span><br><span class="line">        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])</span><br><span class="line">            i++;          // 从左向右找首个大于基准数的元素</span><br><span class="line">        swap(nums, i, j); // 交换这两个元素</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, left);  // 将基准数交换至两子数组的分界线</span><br><span class="line">    return i;             // 返回基准数的索引</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 快速排序 */</span><br><span class="line">void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 子数组长度为 1 时终止递归</span><br><span class="line">    if (left &gt;= right)</span><br><span class="line">        return;</span><br><span class="line">    // 哨兵划分</span><br><span class="line">    int pivot = partition(nums, left, right);</span><br><span class="line">    // 递归左子数组、右子数组</span><br><span class="line">    quickSort(nums, left, pivot - 1);</span><br><span class="line">    quickSort(nums, pivot + 1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h2><h3 id="3-1-读取链表"><a href="#3-1-读取链表" class="headerlink" title="3.1 读取链表"></a>3.1 读取链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">// 如果第一行表示节点个数，那就读取n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        String[] s = reader.readLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">//用空格分割，也可以用逗号分割</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 创建当前指针</span></span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 当前值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Integer.parseInt(s[i]);</span><br><span class="line">            <span class="comment">// 创建当前指针的后继</span></span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line">            <span class="comment">// 指针向后移一位</span></span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// current指针最后指向null</span></span><br><span class="line">        current.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// head指针为虚拟头节点的直接后继</span></span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">head</span> <span class="operator">=</span> dummy.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出链表，仅为演示，实际问题中可能要根据题目要求进行输出</span></span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助类：构建一个节点类，用于链表构建</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-插入节点"><a href="#3-2-插入节点" class="headerlink" title="3.2 插入节点"></a>3.2 插入节点</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8_1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 在链表的节点 n0 之后插入节点 P */</span><br><span class="line">void insert(ListNode n0, ListNode P) &#123;</span><br><span class="line">    ListNode n1 = n0.next;</span><br><span class="line">    P.next = n1;</span><br><span class="line">    n0.next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-删除节点"><a href="#3-3-删除节点" class="headerlink" title="3.3 删除节点"></a>3.3 删除节点</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8_2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 删除链表的节点 n0 之后的首个节点 */</span><br><span class="line">void remove(ListNode n0) &#123;</span><br><span class="line">    if (n0.next == null)</span><br><span class="line">        return;</span><br><span class="line">    // n0 -&gt; P -&gt; n1</span><br><span class="line">    // n0.next = n0.next.next;</span><br><span class="line">    ListNode P = n0.next;</span><br><span class="line">    ListNode n1 = P.next;</span><br><span class="line">    n0.next = n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-访问节点"><a href="#3-4-访问节点" class="headerlink" title="3.4 访问节点"></a>3.4 访问节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 访问链表中索引为 index 的节点 */</span><br><span class="line">ListNode access(ListNode head, int index) &#123;</span><br><span class="line">    for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">        if (head == null)</span><br><span class="line">            return null;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-查找节点"><a href="#3-5-查找节点" class="headerlink" title="3.5 查找节点"></a>3.5 查找节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 在链表中查找值为 target 的首个节点 */</span><br><span class="line">int find(ListNode head, int target) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    while (head != null) &#123;</span><br><span class="line">        if (head.val == target)</span><br><span class="line">            return index;</span><br><span class="line">        head = head.next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-模板题"><a href="#3-6-模板题" class="headerlink" title="3.6 模板题"></a>3.6 模板题</h3><ul><li><a href="https://leetcode.cn/problems/remove-linked-list-elements/">移除链表元素</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        if (head == null) return head;</span><br><span class="line">        // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span><br><span class="line">        ListNode dummy = new ListNode(-1, head);</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            if (cur.val == val) &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.cn/problems/design-linked-list/">设计链表:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList&#123;</span><br><span class="line">    // 定义节点</span><br><span class="line">    class Node&#123;</span><br><span class="line">        // 节点值</span><br><span class="line">        int val;</span><br><span class="line">        // 下一节点的地址</span><br><span class="line">        Node next;</span><br><span class="line">        // 构造器</span><br><span class="line">        public Node(int val)&#123;</span><br><span class="line">            this.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 链表的长度</span><br><span class="line">    int size;</span><br><span class="line">    // 虚拟头节点</span><br><span class="line">    Node head;</span><br><span class="line">    </span><br><span class="line">    // 1、初始化链表</span><br><span class="line">    public MyLinkedList()&#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        // 定义这个虚拟头节点的值为0</span><br><span class="line">        head =  new Node(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. addAtIndex方法</span><br><span class="line">    public void addAtIndex(int index, int val)&#123;</span><br><span class="line">        // 当index大于size</span><br><span class="line">        if (index&gt;size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 当index小于0</span><br><span class="line">        if (index&lt;0)&#123;</span><br><span class="line">            index=0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // current指针移动到index的前一个</span><br><span class="line">        Node current = head;</span><br><span class="line">        for (int i=0; i&lt;index; i++)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入的节点</span><br><span class="line">        Node addNode = new Node(val);</span><br><span class="line">        addNode.next = current.next;</span><br><span class="line">        current.next = addNode;</span><br><span class="line">        </span><br><span class="line">        // 链表总数+1</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3. addAtHead方法</span><br><span class="line">    public void addAtHead(int val)&#123;</span><br><span class="line">        addAtIndex(0, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. addAtTail方法</span><br><span class="line">    public void addAtTail(int val)&#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 5. get方法</span><br><span class="line">    public int get(int index)&#123;</span><br><span class="line">        // 逻辑判断</span><br><span class="line">        if (index&lt;0 || index&gt;size-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历每个节点</span><br><span class="line">        Node current = head;</span><br><span class="line">        for (int i=0; i&lt;=index; i++)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return current.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 6. deleteAtIndex方法</span><br><span class="line">    public void deleteAtIndex(int index)&#123;</span><br><span class="line">        // 逻辑判断</span><br><span class="line">        if (index&lt;0 || index&gt;size-1)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">        Node current = head;</span><br><span class="line">        for (int i=0; i&lt;index; i++)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = current.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode tem = null;</span><br><span class="line">        while (cur!=null)&#123;</span><br><span class="line">            // 保存下一个节点</span><br><span class="line">            tem = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            // 两个指针都往后移一位</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        // 0/1个节点的情况</span><br><span class="line">        if (head==null || head.next==null) return head;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode cur = head.next;</span><br><span class="line">        while (cur!=null)&#123;</span><br><span class="line">            int tem = pre.val;</span><br><span class="line">            pre.val = cur.val;</span><br><span class="line">            cur.val = tem;</span><br><span class="line">            if (cur.next==null || cur.next.next==null) return head;</span><br><span class="line">            pre = pre.next.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第N个节点:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        // 虚拟指针</span><br><span class="line">        ListNode dummy = new ListNode(0, head);</span><br><span class="line">        // 双指针</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        // current指针往前先移动n个</span><br><span class="line">        for (int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // pre和cur同时往后移动</span><br><span class="line">        while (cur.next!=null)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 删除节点</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">链表相交:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        // 虚拟头节点</span><br><span class="line">        ListNode dummyA = new ListNode(0);</span><br><span class="line">        dummyA.next = headA;</span><br><span class="line">        ListNode dummyB = new ListNode(0);</span><br><span class="line">        dummyB.next = headB;</span><br><span class="line">        // 长度</span><br><span class="line">        int lenA = 0;</span><br><span class="line">        int lenB = 0;</span><br><span class="line"></span><br><span class="line">        // 计算两个链表的长度</span><br><span class="line">        ListNode tmpA = dummyA;</span><br><span class="line">        ListNode tmpB = dummyB;</span><br><span class="line">        while (tmpA.next!=null)&#123;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (tmpB.next!=null)&#123;</span><br><span class="line">            tmpB = tmpB.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将最长的链表的指针往前移动|lenA-lenB|</span><br><span class="line">        ListNode tmpA1 = dummyA;</span><br><span class="line">        ListNode tmpB1 = dummyB;</span><br><span class="line">        if (lenA&gt;lenB)&#123;</span><br><span class="line">            int step = lenA - lenB;</span><br><span class="line">            for (int i=0; i&lt;step; i++)&#123;</span><br><span class="line">                tmpA1 = tmpA1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int step = lenB - lenA;</span><br><span class="line">            for (int i=0; i&lt;step; i++)&#123;</span><br><span class="line">                tmpB1 = tmpB1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // tmpA1和tmpB1依次往后移动</span><br><span class="line">        while (tmpA1!=null &amp;&amp; tmpB1!=null)&#123;</span><br><span class="line">            if (tmpA1==tmpB1)&#123;</span><br><span class="line">                return tmpA1;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpA1 = tmpA1.next;</span><br><span class="line">            tmpB1 = tmpB1.next;</span><br><span class="line">        &#125; </span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表II:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        // 定义一个hashmap</span><br><span class="line">        HashMap&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        // 定义一个虚拟头节点</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        // 定义索引</span><br><span class="line">        int index = 0;</span><br><span class="line"></span><br><span class="line">        // 循环</span><br><span class="line">        while (dummy.next!=null)&#123;</span><br><span class="line">            if (map.containsValue(dummy))&#123;</span><br><span class="line">                return dummy;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(index, dummy);</span><br><span class="line">                index++;</span><br><span class="line">                dummy = dummy.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h2><h3 id="4-1-读取数组"><a href="#4-1-读取数组" class="headerlink" title="4.1 读取数组"></a>4.1 读取数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">// 如果第一行表示节点个数，那就读取n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        String[] s = reader.readLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">//用空格分割，也可以用逗号分割</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[s.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            nums[i] = Integer.parseInt(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-访问元素"><a href="#4-2-访问元素" class="headerlink" title="4.2 访问元素"></a>4.2 访问元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 访问元素 */</span><br><span class="line">int access(int[] nums, int index) &#123;</span><br><span class="line">    // 获取并返回随机元素</span><br><span class="line">    return nums[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-插入元素"><a href="#4-3-插入元素" class="headerlink" title="4.3 插入元素"></a>4.3 插入元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 在数组的索引 index 处插入元素 num */</span><br><span class="line">void insert(int[] nums, int num, int index) &#123;</span><br><span class="line">    // 把索引 index 以及之后的所有元素向后移动一位</span><br><span class="line">    for (int i = nums.length - 1; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    // 将 num 赋给 index 处元素</span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-删除元素"><a href="#4-4-删除元素" class="headerlink" title="4.4 删除元素"></a>4.4 删除元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 删除索引 index 处元素 */</span><br><span class="line">void remove(int[] nums, int index) &#123;</span><br><span class="line">    // 把索引 index 之后的所有元素向前移动一位</span><br><span class="line">    for (int i = index; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-遍历数组"><a href="#4-5-遍历数组" class="headerlink" title="4.5 遍历数组"></a>4.5 遍历数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 遍历数组 */</span><br><span class="line">void traverse(int[] nums) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    // 通过索引遍历数组</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 直接遍历数组</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure><h3 id="4-6-查找元素"><a href="#4-6-查找元素" class="headerlink" title="4.6 查找元素"></a>4.6 查找元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 在数组中查找指定元素 */</span><br><span class="line">int find(int[] nums, int target) &#123;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] == target)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-扩容数组"><a href="#4-7-扩容数组" class="headerlink" title="4.7 扩容数组"></a>4.7 扩容数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 扩展数组长度 */</span><br><span class="line">int[] extend(int[] nums, int enlarge) &#123;</span><br><span class="line">    // 初始化一个扩展长度后的数组</span><br><span class="line">    int[] res = new int[nums.length + enlarge];</span><br><span class="line">    // 将原数组中的所有元素复制到新数组</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回扩展后的新数组</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-模板题"><a href="#4-8-模板题" class="headerlink" title="4.8 模板题"></a>4.8 模板题</h3><ul><li><p><a href="https://leetcode.cn/problems/binary-search/">二分查找:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        // 左</span><br><span class="line">        int left = 0;</span><br><span class="line">        // 右</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        while (left&lt;=right)&#123;</span><br><span class="line">            // 中间</span><br><span class="line">            int middle = left + (right - left) / 2;</span><br><span class="line">            if (nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/remove-element/">移除元素:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        // 1. 定义两个指针fast, slow</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast=0; fast&lt;=nums.length-1; fast++)&#123;</span><br><span class="line">            if (nums[fast] != val)&#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        // 双向双指针</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        int index = nums.length - 1;</span><br><span class="line">        int[] result = new int[nums.length];</span><br><span class="line">        while (left &lt;= right)&#123;</span><br><span class="line">            if (nums[right]*nums[right] &gt; nums[left]*nums[left])&#123;</span><br><span class="line">                result[index--] = nums[right]*nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result[index--] = nums[left]*nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minSubArrayLen(int target, int[] nums) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int len = Integer.MAX_VALUE;</span><br><span class="line">        for (int right=0; right&lt;nums.length; right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            while (sum&gt;=target)&#123;</span><br><span class="line">                len = Math.min(len, right-left+1);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len == Integer.MAX_VALUE ? 0 : len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        // 定义左右上下</span><br><span class="line">        int left = 0, right = n-1, top = 0, bottom = n-1;</span><br><span class="line">        // 定义填充的总数和正填充的计数</span><br><span class="line">        int count = 1, target = n*n;</span><br><span class="line">        // 定义返回的数组</span><br><span class="line">        int[][] returnList = new int[n][n];</span><br><span class="line"></span><br><span class="line">        // i表示遍历行，j表示遍历列</span><br><span class="line">        while (count&lt;=target)&#123;</span><br><span class="line">            // 从左到右</span><br><span class="line">            for (int j=left; j&lt;=right; j++)&#123;</span><br><span class="line">                returnList[top][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            // 从上往下</span><br><span class="line">            for (int i=top; i&lt;=bottom; i++)&#123;</span><br><span class="line">                returnList[i][right] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            // 从右往左</span><br><span class="line">            for (int j=right; j&gt;=left; j--)&#123;</span><br><span class="line">                returnList[bottom][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            // 从下往上</span><br><span class="line">            for (int i=bottom; i&gt;=top; i--)&#123;</span><br><span class="line">                returnList[i][left] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return returnList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-栈"><a href="#5-栈" class="headerlink" title="5. 栈"></a>5. 栈</h2><h3 id="5-1-基本操作"><a href="#5-1-基本操作" class="headerlink" title="5.1 基本操作"></a>5.1 基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化栈 */</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 元素入栈 */</span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);</span><br><span class="line"></span><br><span class="line">/* 访问栈顶元素 */</span><br><span class="line">int peek = stack.peek();</span><br><span class="line"></span><br><span class="line">/* 元素出栈 */</span><br><span class="line">int pop = stack.pop();</span><br><span class="line"></span><br><span class="line">/* 获取栈的长度 */</span><br><span class="line">int size = stack.size();</span><br><span class="line"></span><br><span class="line">/* 判断是否为空 */</span><br><span class="line">boolean isEmpty = stack.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="5-2-基于链表实现栈"><a href="#5-2-基于链表实现栈" class="headerlink" title="5.2 基于链表实现栈"></a>5.2 基于链表实现栈</h3><ul><li>push：链表头插法</li><li>pop：删除头节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的栈 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode stackPeek; <span class="comment">// 将头节点作为栈顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stkSize</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 栈的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stackPeek = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取栈的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stkSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        node.next = stackPeek;</span><br><span class="line">        stackPeek = node;</span><br><span class="line">        stkSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> peek();</span><br><span class="line">        stackPeek = stackPeek.next;</span><br><span class="line">        stkSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> stackPeek.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 List 转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> stackPeek;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-基于数组实现栈"><a href="#5-3-基于数组实现栈" class="headerlink" title="5.3 基于数组实现栈"></a>5.3 基于数组实现栈</h3><ul><li>push：插入到数组尾部</li><li>pop：删除数组尾元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于数组实现的栈 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化列表（动态数组）</span></span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取栈的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        stack.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> stack.remove(size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> stack.get(size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 List 转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-模板题"><a href="#5-4-模板题" class="headerlink" title="5.4 模板题"></a>5.4 模板题</h3><ul><li><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">    // 定义两个栈</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    // 构造函数</span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        stackIn = new Stack&lt;&gt;();</span><br><span class="line">        stackOut = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 入队列</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 出队列</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回队列开头元素</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断队列是否为空</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return stackIn.isEmpty() &amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中</span><br><span class="line">    public void dumpstackIn()&#123;</span><br><span class="line">        // 出队列：判断stackOut是否为空，不为空就返回</span><br><span class="line">        if (!stackOut.isEmpty())return;</span><br><span class="line">        while (!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">用队列实现栈:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    // 定义两个队列</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    // 构造器</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        queue1 = new LinkedList&lt;&gt;();</span><br><span class="line">        queue2 = new LinkedList&lt;&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 入栈流程是：</span><br><span class="line">    // 入栈元素放入queue2中</span><br><span class="line">    // 然后将queue1元素全部放入queue2中</span><br><span class="line">    // 最后queue1和queue2互换</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        queue2.offer(x); // 先放在辅助队列中</span><br><span class="line">        while (!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queueTemp;</span><br><span class="line">        queueTemp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 出栈</span><br><span class="line">    // queue2</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回栈顶元素</span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断是否为空</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        // if (s.length()%2!=0) return false;</span><br><span class="line"></span><br><span class="line">        // 定义一个栈</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 循环</span><br><span class="line">        for (int i=0; i&lt;=s.length()-1; i++)&#123;</span><br><span class="line">            if (s.charAt(i) == &#x27;(&#x27;)&#123;</span><br><span class="line">                stack.push(&#x27;)&#x27;);</span><br><span class="line">            &#125;else if (s.charAt(i) == &#x27;&#123;&#x27;)&#123;</span><br><span class="line">                stack.push(&#x27;&#125;&#x27;);</span><br><span class="line">            &#125;else if (s.charAt(i) == &#x27;[&#x27;)&#123;</span><br><span class="line">                stack.push(&#x27;]&#x27;);</span><br><span class="line">            &#125;else if (stack.isEmpty() || stack.peek()!=s.charAt(i))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Character&gt; stack1 = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;=s.length()-1; i++)&#123;</span><br><span class="line">            if (stack.isEmpty() || stack.peek()!=s.charAt(i))&#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        while (!stack1.isEmpty())&#123;</span><br><span class="line">            sb.append(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        // 1. 定义一个栈</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        // 2. 定义运算的两个变量</span><br><span class="line">        int a;</span><br><span class="line">        int b;</span><br><span class="line"></span><br><span class="line">        // 3. 对tokens进行遍历</span><br><span class="line">        for (String s : tokens)&#123;</span><br><span class="line">            if (s.equals(&quot;+&quot;))&#123;</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                stack.push(a+b);</span><br><span class="line">            &#125;else if (s.equals(&quot;-&quot;))&#123;</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                stack.push(a-b);</span><br><span class="line">            &#125;else if (s.equals(&quot;*&quot;))&#123;</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                stack.push(a*b);</span><br><span class="line">            &#125;else if (s.equals(&quot;/&quot;))&#123;</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                stack.push(a/b);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        if(nums.length == 0 || k == 0) return new int[0];</span><br><span class="line">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">        int[] res = new int[nums.length - k + 1];</span><br><span class="line">        for(int j = 0, i = 1 - k; j &lt; nums.length; i++, j++) &#123;</span><br><span class="line">            // 删除 deque 中对应的 nums[i-1]</span><br><span class="line">            if(i &gt; 0 &amp;&amp; deque.peekFirst() == nums[i - 1])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            // 保持 deque 递减</span><br><span class="line">            while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line">            // 记录窗口最大值</span><br><span class="line">            if(i &gt;= 0)</span><br><span class="line">                res[i] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 K 个高频元素:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        // 优先级队列，为了避免复杂 api 操作，pq 存储数组</span><br><span class="line">        // lambda 表达式设置优先级队列从大到小存储 o1 - o2 为从大到小，o2 - o1 反之</span><br><span class="line">        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[1] - o2[1]);</span><br><span class="line">        int[] res = new int[k]; // 答案数组为 k 个元素</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 记录元素出现次数</span><br><span class="line">        for(int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);</span><br><span class="line">        for(var x : map.entrySet()) &#123; // entrySet 获取 k-v Set 集合</span><br><span class="line">            // 将 kv 转化成数组</span><br><span class="line">            int[] tmp = new int[2];</span><br><span class="line">            tmp[0] = x.getKey();</span><br><span class="line">            tmp[1] = x.getValue();</span><br><span class="line">            pq.offer(tmp);</span><br><span class="line">            if(pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; k; i ++) &#123;</span><br><span class="line">            res[i] = pq.poll()[0]; // 获取优先队列里的元素</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-队列"><a href="#6-队列" class="headerlink" title="6. 队列"></a>6. 队列</h2><h3 id="6-1-队列常用操作"><a href="#6-1-队列常用操作" class="headerlink" title="6.1 队列常用操作"></a>6.1 队列常用操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化队列 */</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 元素入队 */</span><br><span class="line">queue.offer(1);</span><br><span class="line">queue.offer(2);</span><br><span class="line"></span><br><span class="line">/* 访问队首元素 */</span><br><span class="line">int peek = queue.peek();</span><br><span class="line"></span><br><span class="line">/* 元素出队 */</span><br><span class="line">int pop = queue.poll();</span><br><span class="line"></span><br><span class="line">/* 获取队列的长度 */</span><br><span class="line">int size = queue.size();</span><br><span class="line"></span><br><span class="line">/* 判断队列是否为空 */</span><br><span class="line">boolean isEmpty = queue.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="6-2-基于链表实现队列"><a href="#6-2-基于链表实现队列" class="headerlink" title="6.2 基于链表实现队列"></a>6.2 基于链表实现队列</h3><ul><li>push：添加到链表尾部</li><li>pop：删除链表头节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode front, rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 尾节点后添加 num</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        <span class="comment">// 如果队列为空，则令头、尾节点都指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) &#123;</span><br><span class="line">            front = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        <span class="comment">// 如果队列不为空，则将该节点添加到尾节点后</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rear.next = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        &#125;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> peek();</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        front = front.next;</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> front.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将链表转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3-双向队列常用操作"><a href="#6-3-双向队列常用操作" class="headerlink" title="6.3 双向队列常用操作"></a>6.3 双向队列常用操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化双向队列 */</span><br><span class="line">Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 元素入队 */</span><br><span class="line">deque.offerLast(1);   // 添加至队尾</span><br><span class="line">deque.offerFirst(3);  // 添加至队首</span><br><span class="line"></span><br><span class="line">/* 访问元素 */</span><br><span class="line">int peekFirst = deque.peekFirst();  // 队首元素</span><br><span class="line">int peekLast = deque.peekLast();    // 队尾元素</span><br><span class="line"></span><br><span class="line">/* 元素出队 */</span><br><span class="line">int popFirst = deque.pollFirst();  // 队首元素出队</span><br><span class="line">int popLast = deque.pollLast();    // 队尾元素出队</span><br><span class="line"></span><br><span class="line">/* 获取双向队列的长度 */</span><br><span class="line">int size = deque.size();</span><br><span class="line"></span><br><span class="line">/* 判断双向队列是否为空 */</span><br><span class="line">boolean isEmpty = deque.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="6-4-基于双向链表实现双向队列"><a href="#6-4-基于双向链表实现双向队列" class="headerlink" title="6.4 基于双向链表实现双向队列"></a>6.4 基于双向链表实现双向队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    ListNode next; <span class="comment">// 后继节点引用</span></span><br><span class="line">    ListNode prev; <span class="comment">// 前驱节点引用</span></span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        prev = next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于双向链表实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListDeque</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode front, rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queSize</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 双向队列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        front = rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队操作 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num, <span class="type">boolean</span> isFront)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        <span class="comment">// 若链表为空，则令 front, rear 都指向 node</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            front = rear = node;</span><br><span class="line">        <span class="comment">// 队首入队操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表头部</span></span><br><span class="line">            front.prev = node;</span><br><span class="line">            node.next = front;</span><br><span class="line">            front = node; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾入队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表尾部</span></span><br><span class="line">            rear.next = node;</span><br><span class="line">            node.prev = rear;</span><br><span class="line">            rear = node; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize++; <span class="comment">// 更新队列长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        push(num, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushLast</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        push(num, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队操作 */</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">pop</span><span class="params">(<span class="type">boolean</span> isFront)</span> &#123;</span><br><span class="line">        <span class="comment">// 若队列为空，直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="comment">// 队首出队操作</span></span><br><span class="line">        <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            val = front.val; <span class="comment">// 暂存头节点值</span></span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">fNext</span> <span class="operator">=</span> front.next;</span><br><span class="line">            <span class="keyword">if</span> (fNext != <span class="literal">null</span>) &#123;</span><br><span class="line">                fNext.prev = <span class="literal">null</span>;</span><br><span class="line">                front.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front = fNext; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾出队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = rear.val; <span class="comment">// 暂存尾节点值</span></span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">rPrev</span> <span class="operator">=</span> rear.prev;</span><br><span class="line">            <span class="keyword">if</span> (rPrev != <span class="literal">null</span>) &#123;</span><br><span class="line">                rPrev.next = <span class="literal">null</span>;</span><br><span class="line">                rear.prev = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear = rPrev; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize--; <span class="comment">// 更新队列长度</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">popFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pop(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">popLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pop(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="literal">null</span> : front.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="literal">null</span> : rear.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-哈希表"><a href="#7-哈希表" class="headerlink" title="7. 哈希表"></a>7. 哈希表</h2><h3 id="7-1-哈希表常用操作"><a href="#7-1-哈希表常用操作" class="headerlink" title="7.1 哈希表常用操作"></a>7.1 哈希表常用操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化哈希表 */</span><br><span class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 添加操作 */</span><br><span class="line">// 在哈希表中添加键值对 (key, value)</span><br><span class="line">map.put(12836, &quot;小哈&quot;);   </span><br><span class="line">map.put(15937, &quot;小啰&quot;);   </span><br><span class="line">map.put(16750, &quot;小算&quot;);   </span><br><span class="line">map.put(13276, &quot;小法&quot;);</span><br><span class="line">map.put(10583, &quot;小鸭&quot;);</span><br><span class="line"></span><br><span class="line">/* 查询操作 */</span><br><span class="line">// 向哈希表输入键 key ，得到值 value</span><br><span class="line">String name = map.get(15937);</span><br><span class="line"></span><br><span class="line">/* 删除操作 */</span><br><span class="line">// 在哈希表中删除键值对 (key, value)</span><br><span class="line">map.remove(10583);</span><br><span class="line"></span><br><span class="line">/* 遍历哈希表 */</span><br><span class="line">// 遍历键值对 key-&gt;value</span><br><span class="line">for (Map.Entry &lt;Integer, String&gt; kv: map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + &quot; -&gt; &quot; + kv.getValue());</span><br><span class="line">&#125;</span><br><span class="line">// 单独遍历键 key</span><br><span class="line">for (int key: map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">// 单独遍历值 value</span><br><span class="line">for (String val: map.values()) &#123;</span><br><span class="line">    System.out.println(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-树"><a href="#8-树" class="headerlink" title="8. 树"></a>8. 树</h2><h3 id="8-1-二叉树"><a href="#8-1-二叉树" class="headerlink" title="8.1 二叉树"></a>8.1 二叉树</h3><ul><li><p>二叉树常见术语：</p><ul><li>根节点 root node：位于二叉树顶层的节点，没有父节点。</li><li>叶节点 leaf node：没有子节点的节点，其两个指针均指向。</li><li>边 edge：连接两个节点的线段，即节点引用（指针）。</li><li>节点所在的层 level：从顶至底递增，根节点所在层为 1 。</li><li>节点的度 degree：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</li><li>二叉树的高度 height：从根节点到最远叶节点所经过的边的数量。</li><li>节点的深度 depth：从根节点到该节点所经过的边的数量。</li><li>节点的高度 height：从最远叶节点到该节点所经过的边的数量。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_1.png"></li></ul></li><li><p>二叉树分类：</p><ul><li>完美二叉树（满二叉树）<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_3.png"></li><li>完全二叉树<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_4.png"></li><li>完满二叉树<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_5.png"></li><li>平衡二叉树<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_6.png"></li></ul></li><li><p>二叉树基本操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  /* 二叉树节点类 */</span><br><span class="line">  class TreeNode &#123;</span><br><span class="line">      int val;         // 节点值</span><br><span class="line">      TreeNode left;   // 左子节点引用</span><br><span class="line">      TreeNode right;  // 右子节点引用</span><br><span class="line">      TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* 初始化二叉树 */</span><br><span class="line">  // 初始化节点</span><br><span class="line">  TreeNode n1 = new TreeNode(1);</span><br><span class="line">  TreeNode n2 = new TreeNode(2);</span><br><span class="line">  TreeNode n3 = new TreeNode(3);</span><br><span class="line">  TreeNode n4 = new TreeNode(4);</span><br><span class="line">  TreeNode n5 = new TreeNode(5);</span><br><span class="line">  // 构建引用指向（即指针）</span><br><span class="line">  n1.left = n2;</span><br><span class="line">  n1.right = n3;</span><br><span class="line">  n2.left = n4;</span><br><span class="line">  n2.right = n5;</span><br><span class="line">  </span><br><span class="line">  /* 插入与删除节点 */</span><br><span class="line">  TreeNode P = new TreeNode(0);</span><br><span class="line">  // 在 n1 -&gt; n2 中间插入节点 P</span><br><span class="line">  n1.left = P;</span><br><span class="line">  P.left = n2;</span><br><span class="line">  // 删除节点 P</span><br><span class="line">  n1.left = n2;</span><br><span class="line">  ```  </span><br><span class="line">  ![](面试-算法/树_2.png)</span><br><span class="line"></span><br><span class="line">- 读取二叉树：</span><br><span class="line">  ```java</span><br><span class="line">  import java.io.BufferedReader;</span><br><span class="line">  import java.io.IOException;</span><br><span class="line">  import java.io.InputStreamReader;</span><br><span class="line">   </span><br><span class="line">  public class Main&#123;</span><br><span class="line">      //4.输入二叉树</span><br><span class="line">      public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          //获取键盘一行的输入，以enter键为结束标志</span><br><span class="line">          BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">          String[] s = reader.readLine().split(&quot; &quot;); //用空格分割，也可以用逗号分割</span><br><span class="line">   </span><br><span class="line">          //用数组按层级遍历顺序存储二叉树的节点</span><br><span class="line">          TreeNode[] tree = new TreeNode[s.length];</span><br><span class="line">          for(int i = 0; i &lt; tree.length; i++)&#123;</span><br><span class="line">              int val_i = Integer.parseInt(s[i]);</span><br><span class="line">              if(val_i == -1)&#123;</span><br><span class="line">                  tree[i] = null; //-1代表null</span><br><span class="line">              &#125;else&#123;</span><br><span class="line">                  tree[i] = new TreeNode(val_i); </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">   </span><br><span class="line">          //再遍历一边，给左右子树赋值</span><br><span class="line">          for(int i = 0; i * 2 + 2 &lt; tree.length; i++)&#123;</span><br><span class="line">              if(tree[i] != null)&#123;</span><br><span class="line">                  tree[i].left = tree[i * 2 + 1];</span><br><span class="line">                  tree[i].right = tree[i * 2 + 2];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          TreeNode root = tree[0];</span><br><span class="line">          //root是最终得到的二叉树根节点</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      //辅助类：构造树需要的结点类</span><br><span class="line">      static class TreeNode &#123;</span><br><span class="line">          int val;</span><br><span class="line">          TreeNode left, right;</span><br><span class="line">          public TreeNode(int val) &#123;</span><br><span class="line">              this.val = val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-2-二叉树遍历"><a href="#8-2-二叉树遍历" class="headerlink" title="8.2 二叉树遍历"></a>8.2 二叉树遍历</h3><ul><li>层序遍历：本质上属于广度优先遍历 breadth-first traversal，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_7.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 层序遍历 */</span><br><span class="line">List&lt;Integer&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    // 初始化队列，加入根节点</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    // 初始化一个列表，用于保存遍历序列</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); // 队列出队</span><br><span class="line">        list.add(node.val);           // 保存节点值</span><br><span class="line">        if (node.left != null)&#123;</span><br><span class="line">            queue.offer(node.left);   // 左子节点入队</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right != null)&#123;</span><br><span class="line">            queue.offer(node.right);  // 右子节点入队</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>前序、中序、后序遍历：都属于「深度优先遍历 depth-first traversal」，它体现了一种“先走到尽头，再回溯继续”的遍历方式。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_8.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* 前序遍历 */</span><br><span class="line">void preOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 中序遍历 */</span><br><span class="line">void inOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 后序遍历 */</span><br><span class="line">void postOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-二叉树数组表示"><a href="#8-3-二叉树数组表示" class="headerlink" title="8.3 二叉树数组表示"></a>8.3 二叉树数组表示</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_9.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数组表示下的二叉树类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(List&lt;Integer&gt; arr)</span> &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 节点数量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tree.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的值 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">val</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 若索引越界，则返回 null ，代表空位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> tree.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的左子节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的右子节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的父节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 层序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 直接遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val(i) != <span class="literal">null</span>)</span><br><span class="line">                res.add(val(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 深度优先遍历 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Integer i, String order, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 若为空位，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (val(i) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;pre&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(left(i), order, res);</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(right(i), order, res);</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;post&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;pre&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;in&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;post&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-二叉搜索树"><a href="#8-4-二叉搜索树" class="headerlink" title="8.4 二叉搜索树"></a>8.4 二叉搜索树</h3><ul><li><p>二叉搜索树(binary search tree)满足以下条件：</p><ul><li>对于根节点，左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值。</li><li>任意节点的左、右子树也是二叉搜索树，即同样满足条件 1. 。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_10.png"></li></ul></li><li><p>查找节点</p><ul><li>若 cur.val &lt; num ，说明目标节点在 cur 的右子树中，因此执行 cur &#x3D; cur.right 。</li><li>若 cur.val &gt; num ，说明目标节点在 cur 的左子树中，因此执行 cur &#x3D; cur.left 。</li><li>若 cur.val &#x3D; num ，说明找到目标节点，跳出循环并返回该节点。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 查找节点 */</span><br><span class="line">TreeNode search(int num) &#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    // 循环查找，越过叶节点后跳出</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // 目标节点在 cur 的右子树中</span><br><span class="line">        if (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        // 目标节点在 cur 的左子树中</span><br><span class="line">        else if (cur.val &gt; num)</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        // 找到目标节点，跳出循环</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回目标节点</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>插入节点</p><ul><li>查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（遍历至None）时跳出循环。</li><li>在该位置插入节点：初始化节点 num ，将该节点插入当前的位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* 插入节点 */</span><br><span class="line">void insert(int num) &#123;</span><br><span class="line">    // 若树为空，则初始化根节点</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        root = new TreeNode(num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode cur = root, pre = null;</span><br><span class="line">    // 循环查找，越过叶节点后跳出</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // 找到重复节点，直接返回</span><br><span class="line">        if (cur.val == num)</span><br><span class="line">            return;</span><br><span class="line">        pre = cur;</span><br><span class="line">        // 插入位置在 cur 的右子树中</span><br><span class="line">        if (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        // 插入位置在 cur 的左子树中</span><br><span class="line">        else</span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    // 插入节点</span><br><span class="line">    TreeNode node = new TreeNode(num);</span><br><span class="line">    if (pre.val &lt; num)</span><br><span class="line">        pre.right = node;</span><br><span class="line">    else</span><br><span class="line">        pre.left = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/* 删除节点 */</span><br><span class="line">void remove(int num) &#123;</span><br><span class="line">    // 若树为空，直接提前返回</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    TreeNode cur = root, pre = null;</span><br><span class="line">    // 循环查找，越过叶节点后跳出</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // 找到待删除节点，跳出循环</span><br><span class="line">        if (cur.val == num)</span><br><span class="line">            break;</span><br><span class="line">        pre = cur;</span><br><span class="line">        // 待删除节点在 cur 的右子树中</span><br><span class="line">        if (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        // 待删除节点在 cur 的左子树中</span><br><span class="line">        else</span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若无待删除节点，则直接返回</span><br><span class="line">    if (cur == null)</span><br><span class="line">        return;</span><br><span class="line">    // 子节点数量 = 0 or 1</span><br><span class="line">    if (cur.left == null || cur.right == null) &#123;</span><br><span class="line">        // 当子节点数量 = 0 / 1 时， child = null / 该子节点</span><br><span class="line">        TreeNode child = cur.left != null ? cur.left : cur.right;</span><br><span class="line">        // 删除节点 cur</span><br><span class="line">        if (cur != root) &#123;</span><br><span class="line">            if (pre.left == cur)</span><br><span class="line">                pre.left = child;</span><br><span class="line">            else</span><br><span class="line">                pre.right = child;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 若删除节点为根节点，则重新指定根节点</span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 子节点数量 = 2</span><br><span class="line">    else &#123;</span><br><span class="line">        // 获取中序遍历中 cur 的下一个节点</span><br><span class="line">        TreeNode tmp = cur.right;</span><br><span class="line">        while (tmp.left != null) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        // 递归删除节点 tmp</span><br><span class="line">        remove(tmp.val);</span><br><span class="line">        // 用 tmp 覆盖 cur</span><br><span class="line">        cur.val = tmp.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-5-AVL树"><a href="#8-5-AVL树" class="headerlink" title="8.5 AVL树"></a>8.5 AVL树</h3><h2 id="9-堆"><a href="#9-堆" class="headerlink" title="9. 堆"></a>9. 堆</h2><h3 id="9-1-基础问题"><a href="#9-1-基础问题" class="headerlink" title="9.1 基础问题"></a>9.1 基础问题</h3><ul><li><p>概念：</p><ul><li>大顶堆 max heap：任意节点的值大于等于其子节点的值。</li><li>小顶堆 min heap：任意节点的值小于等于其子节点的值。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E5%A0%86_1.png"></li></ul></li><li><p>堆常用操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化堆 */</span><br><span class="line">// 初始化小顶堆</span><br><span class="line">Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span><br><span class="line">Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line">/* 元素入堆 */</span><br><span class="line">maxHeap.offer(1);</span><br><span class="line">maxHeap.offer(3);</span><br><span class="line">maxHeap.offer(2);</span><br><span class="line">maxHeap.offer(5);</span><br><span class="line">maxHeap.offer(4);</span><br><span class="line"></span><br><span class="line">/* 获取堆顶元素 */</span><br><span class="line">int peek = maxHeap.peek(); // 5</span><br><span class="line"></span><br><span class="line">/* 堆顶元素出堆 */</span><br><span class="line">// 出堆元素会形成一个从大到小的序列</span><br><span class="line">peek = maxHeap.poll(); // 5</span><br><span class="line">peek = maxHeap.poll(); // 4</span><br><span class="line">peek = maxHeap.poll(); // 3</span><br><span class="line">peek = maxHeap.poll(); // 2</span><br><span class="line">peek = maxHeap.poll(); // 1</span><br><span class="line"></span><br><span class="line">/* 获取堆大小 */</span><br><span class="line">int size = maxHeap.size();</span><br><span class="line"></span><br><span class="line">/* 判断堆是否为空 */</span><br><span class="line">boolean isEmpty = maxHeap.isEmpty();</span><br><span class="line"></span><br><span class="line">/* 输入列表并建堆 */</span><br><span class="line">minHeap = new PriorityQueue&lt;&gt;(Arrays.asList(1, 3, 2, 5, 4));</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-建堆操作"><a href="#9-2-建堆操作" class="headerlink" title="9.2 建堆操作"></a>9.2 建堆操作</h3><ul><li>堆的存储与表示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E5%A0%86_2.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/* 获取左子节点索引 */</span><br><span class="line">int left(int i) &#123;</span><br><span class="line">    return 2 * i + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 获取右子节点索引 */</span><br><span class="line">int right(int i) &#123;</span><br><span class="line">    return 2 * i + 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 获取父节点索引 */</span><br><span class="line">int parent(int i) &#123;</span><br><span class="line">    return (i - 1) / 2; // 向下整除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 访问堆顶元素 */</span><br><span class="line">int peek() &#123;</span><br><span class="line">    return maxHeap.get(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 元素入堆 */</span><br><span class="line">void push(int val) &#123;</span><br><span class="line">    // 添加节点</span><br><span class="line">    maxHeap.add(val);</span><br><span class="line">    // 从底至顶堆化</span><br><span class="line">    siftUp(size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从节点 i 开始，从底至顶堆化 */</span><br><span class="line">void siftUp(int i) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 获取节点 i 的父节点</span><br><span class="line">        int p = parent(i);</span><br><span class="line">        // 当“越过根节点”或“节点无须修复”时，结束堆化</span><br><span class="line">        if (p &lt; 0 || maxHeap.get(i) &lt;= maxHeap.get(p))</span><br><span class="line">            break;</span><br><span class="line">        // 交换两节点</span><br><span class="line">        swap(i, p);</span><br><span class="line">        // 循环向上堆化</span><br><span class="line">        i = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 元素出堆 */</span><br><span class="line">int pop() &#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if (isEmpty())</span><br><span class="line">        throw new IndexOutOfBoundsException();</span><br><span class="line">    // 交换根节点与最右叶节点（即交换首元素与尾元素）</span><br><span class="line">    swap(0, size() - 1);</span><br><span class="line">    // 删除节点</span><br><span class="line">    int val = maxHeap.remove(size() - 1);</span><br><span class="line">    // 从顶至底堆化</span><br><span class="line">    siftDown(0);</span><br><span class="line">    // 返回堆顶元素</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从节点 i 开始，从顶至底堆化 */</span><br><span class="line">void siftDown(int i) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 判断节点 i, l, r 中值最大的节点，记为 ma</span><br><span class="line">        int l = left(i), r = right(i), ma = i;</span><br><span class="line">        if (l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(ma))</span><br><span class="line">            ma = l;</span><br><span class="line">        if (r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(ma))</span><br><span class="line">            ma = r;</span><br><span class="line">        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span><br><span class="line">        if (ma == i)</span><br><span class="line">            break;</span><br><span class="line">        // 交换两节点</span><br><span class="line">        swap(i, ma);</span><br><span class="line">        // 循环向下堆化</span><br><span class="line">        i = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-3-Top-K-问题"><a href="#9-3-Top-K-问题" class="headerlink" title="9.3 Top-K 问题"></a>9.3 Top-K 问题</h3><ul><li>给定一个长度为无序数组nums，请返回数组中前 k 大的元素。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 基于堆查找数组中最大的 k 个元素 */</span><br><span class="line">Queue&lt;Integer&gt; topKHeap(int[] nums, int k) &#123;</span><br><span class="line">    Queue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    // 将数组的前 k 个元素入堆</span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        heap.offer(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 从第 k+1 个元素开始，保持堆的长度为 k</span><br><span class="line">    for (int i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆</span><br><span class="line">        if (nums[i] &gt; heap.peek()) &#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">            heap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="10-图"><a href="#10-图" class="headerlink" title="10. 图"></a>10. 图</h2><h3 id="10-1-基于邻接矩阵的实现"><a href="#10-1-基于邻接矩阵的实现" class="headerlink" title="10.1 基于邻接矩阵的实现"></a>10.1 基于邻接矩阵的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/* 基于邻接矩阵实现的无向图类 */</span><br><span class="line">class GraphAdjMat &#123;</span><br><span class="line">    List&lt;Integer&gt; vertices; // 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjMat; // 邻接矩阵，行列索引对应“顶点索引”</span><br><span class="line"></span><br><span class="line">    /* 构造方法 */</span><br><span class="line">    public GraphAdjMat(int[] vertices, int[][] edges) &#123;</span><br><span class="line">        this.vertices = new ArrayList&lt;&gt;();</span><br><span class="line">        this.adjMat = new ArrayList&lt;&gt;();</span><br><span class="line">        // 添加顶点</span><br><span class="line">        for (int val : vertices) &#123;</span><br><span class="line">            addVertex(val);</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加边</span><br><span class="line">        // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span><br><span class="line">        for (int[] e : edges) &#123;</span><br><span class="line">            addEdge(e[0], e[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取顶点数量 */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return vertices.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加顶点 */</span><br><span class="line">    public void addVertex(int val) &#123;</span><br><span class="line">        int n = size();</span><br><span class="line">        // 向顶点列表中添加新顶点的值</span><br><span class="line">        vertices.add(val);</span><br><span class="line">        // 在邻接矩阵中添加一行</span><br><span class="line">        List&lt;Integer&gt; newRow = new ArrayList&lt;&gt;(n);</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            newRow.add(0);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.add(newRow);</span><br><span class="line">        // 在邻接矩阵中添加一列</span><br><span class="line">        for (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.add(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 删除顶点 */</span><br><span class="line">    public void removeVertex(int index) &#123;</span><br><span class="line">        if (index &gt;= size())</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        // 在顶点列表中移除索引 index 的顶点</span><br><span class="line">        vertices.remove(index);</span><br><span class="line">        // 在邻接矩阵中删除索引 index 的行</span><br><span class="line">        adjMat.remove(index);</span><br><span class="line">        // 在邻接矩阵中删除索引 index 的列</span><br><span class="line">        for (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加边 */</span><br><span class="line">    // 参数 i, j 对应 vertices 元素索引</span><br><span class="line">    public void addEdge(int i, int j) &#123;</span><br><span class="line">        // 索引越界与相等处理</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        // 在无向图中，邻接矩阵沿主对角线对称，即满足 (i, j) == (j, i)</span><br><span class="line">        adjMat.get(i).set(j, 1);</span><br><span class="line">        adjMat.get(j).set(i, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 删除边 */</span><br><span class="line">    // 参数 i, j 对应 vertices 元素索引</span><br><span class="line">    public void removeEdge(int i, int j) &#123;</span><br><span class="line">        // 索引越界与相等处理</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        adjMat.get(i).set(j, 0);</span><br><span class="line">        adjMat.get(j).set(i, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 打印邻接矩阵 */</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.print(&quot;顶点列表 = &quot;);</span><br><span class="line">        System.out.println(vertices);</span><br><span class="line">        System.out.println(&quot;邻接矩阵 =&quot;);</span><br><span class="line">        PrintUtil.printMatrix(adjMat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-基于邻接表的实现"><a href="#10-2-基于邻接表的实现" class="headerlink" title="10.2 基于邻接表的实现"></a>10.2 基于邻接表的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/* 基于邻接表实现的无向图类 */</span><br><span class="line">class GraphAdjList &#123;</span><br><span class="line">    // 邻接表，key: 顶点，value：该顶点的所有邻接顶点</span><br><span class="line">    Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    /* 构造方法 */</span><br><span class="line">    public GraphAdjList(Vertex[][] edges) &#123;</span><br><span class="line">        this.adjList = new HashMap&lt;&gt;();</span><br><span class="line">        // 添加所有顶点和边</span><br><span class="line">        for (Vertex[] edge : edges) &#123;</span><br><span class="line">            addVertex(edge[0]);</span><br><span class="line">            addVertex(edge[1]);</span><br><span class="line">            addEdge(edge[0], edge[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取顶点数量 */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return adjList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加边 */</span><br><span class="line">    public void addEdge(Vertex vet1, Vertex vet2) &#123;</span><br><span class="line">        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 添加边 vet1 - vet2</span><br><span class="line">        adjList.get(vet1).add(vet2);</span><br><span class="line">        adjList.get(vet2).add(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 删除边 */</span><br><span class="line">    public void removeEdge(Vertex vet1, Vertex vet2) &#123;</span><br><span class="line">        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 删除边 vet1 - vet2</span><br><span class="line">        adjList.get(vet1).remove(vet2);</span><br><span class="line">        adjList.get(vet2).remove(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加顶点 */</span><br><span class="line">    public void addVertex(Vertex vet) &#123;</span><br><span class="line">        if (adjList.containsKey(vet))</span><br><span class="line">            return;</span><br><span class="line">        // 在邻接表中添加一个新链表</span><br><span class="line">        adjList.put(vet, new ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 删除顶点 */</span><br><span class="line">    public void removeVertex(Vertex vet) &#123;</span><br><span class="line">        if (!adjList.containsKey(vet))</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 在邻接表中删除顶点 vet 对应的链表</span><br><span class="line">        adjList.remove(vet);</span><br><span class="line">        // 遍历其他顶点的链表，删除所有包含 vet 的边</span><br><span class="line">        for (List&lt;Vertex&gt; list : adjList.values()) &#123;</span><br><span class="line">            list.remove(vet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 打印邻接表 */</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;邻接表 =&quot;);</span><br><span class="line">        for (Map.Entry&lt;Vertex, List&lt;Vertex&gt;&gt; pair : adjList.entrySet()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span><br><span class="line">            for (Vertex vertex : pair.getValue())</span><br><span class="line">                tmp.add(vertex.val);</span><br><span class="line">            System.out.println(pair.getKey().val + &quot;: &quot; + tmp + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-图的遍历"><a href="#10-3-图的遍历" class="headerlink" title="10.3 图的遍历"></a>10.3 图的遍历</h3><ul><li><p>广度优先遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 广度优先遍历 BFS */</span><br><span class="line">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span><br><span class="line">List&lt;Vertex&gt; graphBFS(GraphAdjList graph, Vertex startVet) &#123;</span><br><span class="line">    // 顶点遍历序列</span><br><span class="line">    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    // 哈希表，用于记录已被访问过的顶点</span><br><span class="line">    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">    visited.add(startVet);</span><br><span class="line">    // 队列用于实现 BFS</span><br><span class="line">    Queue&lt;Vertex&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">    que.offer(startVet);</span><br><span class="line">    // 以顶点 vet 为起点，循环直至访问完所有顶点</span><br><span class="line">    while (!que.isEmpty()) &#123;</span><br><span class="line">        Vertex vet = que.poll(); // 队首顶点出队</span><br><span class="line">        res.add(vet);            // 记录访问顶点</span><br><span class="line">        // 遍历该顶点的所有邻接顶点</span><br><span class="line">        for (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">            if (visited.contains(adjVet))</span><br><span class="line">                continue;        // 跳过已被访问过的顶点</span><br><span class="line">            que.offer(adjVet);   // 只入队未访问的顶点</span><br><span class="line">            visited.add(adjVet); // 标记该顶点已被访问</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回顶点遍历序列</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>深度优先遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 深度优先遍历 DFS 辅助函数 */</span><br><span class="line">void dfs(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) &#123;</span><br><span class="line">    res.add(vet);     // 记录访问顶点</span><br><span class="line">    visited.add(vet); // 标记该顶点已被访问</span><br><span class="line">    // 遍历该顶点的所有邻接顶点</span><br><span class="line">    for (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">        if (visited.contains(adjVet))</span><br><span class="line">            continue; // 跳过已被访问过的顶点</span><br><span class="line">        // 递归访问邻接顶点</span><br><span class="line">        dfs(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 深度优先遍历 DFS */</span><br><span class="line">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span><br><span class="line">List&lt;Vertex&gt; graphDFS(GraphAdjList graph, Vertex startVet) &#123;</span><br><span class="line">    // 顶点遍历序列</span><br><span class="line">    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    // 哈希表，用于记录已被访问过的顶点</span><br><span class="line">    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">    dfs(graph, visited, res, startVet);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-4-拓扑排序"><a href="#10-4-拓扑排序" class="headerlink" title="10.4 拓扑排序"></a>10.4 拓扑排序</h3><h2 id="11-搜索"><a href="#11-搜索" class="headerlink" title="11. 搜索"></a>11. 搜索</h2><h2 id="12-分治"><a href="#12-分治" class="headerlink" title="12. 分治"></a>12. 分治</h2><h2 id="13-回溯算法"><a href="#13-回溯算法" class="headerlink" title="13. 回溯算法"></a>13. 回溯算法</h2><h2 id="14-动态规划"><a href="#14-动态规划" class="headerlink" title="14. 动态规划"></a>14. 动态规划</h2><h2 id="15-贪心算法"><a href="#15-贪心算法" class="headerlink" title="15. 贪心算法"></a>15. 贪心算法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="面试" scheme="https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试-数据库</title>
    <link href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-06-08T11:50:53.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#1-什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2><ul><li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li></ul><h2 id="2-什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#2-什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="2. 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>2. 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2><ul><li><strong>元组</strong>：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li><strong>码</strong>：码就是能唯一标识实体的属性，对应表中的列。</li><li><strong>候选码</strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong>：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><h2 id="3-什么是-ER-图？"><a href="#3-什么是-ER-图？" class="headerlink" title="3. 什么是 ER 图？"></a>3. 什么是 ER 图？</h2><p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。</p><p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p><p>ER 图由下面 3 个要素组成：</p><ul><li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li><li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li><li><strong>联系</strong>：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li></ul><p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/1.png"></p><h2 id="4-数据库范式了解吗"><a href="#4-数据库范式了解吗" class="headerlink" title="4. 数据库范式了解吗?"></a>4. 数据库范式了解吗?</h2><p>数据库范式有 3 种：</p><ul><li>1NF(第一范式)：每个列都不可以再拆分。</li><li>2NF(第二范式)：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li><li>3NF(第三范式)：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li></ul><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h2 id="5-主键和外键有什么区别"><a href="#5-主键和外键有什么区别" class="headerlink" title="5. 主键和外键有什么区别?"></a>5. 主键和外键有什么区别?</h2><ul><li>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h2 id="6-drop、delete-与-truncate-区别？"><a href="#6-drop、delete-与-truncate-区别？" class="headerlink" title="6. drop、delete 与 truncate 区别？"></a>6. drop、delete 与 truncate 区别？</h2><h3 id="6-1-用法不同"><a href="#6-1-用法不同" class="headerlink" title="6.1 用法不同"></a>6.1 用法不同</h3><ul><li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul><h3 id="6-2-属于不同的数据库语言"><a href="#6-2-属于不同的数据库语言" class="headerlink" title="6.2 属于不同的数据库语言"></a>6.2 属于不同的数据库语言</h3><p><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 <code>delete</code> 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</p><p><strong>DML 语句和 DDL 语句区别：</strong></p><ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li><li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li><li>另外，由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言 DQL（Data Query Language）。</li></ul><h3 id="6-3-执行速度不同"><a href="#6-3-执行速度不同" class="headerlink" title="6.3 执行速度不同"></a>6.3 执行速度不同</h3><p>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code>。</p><ul><li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li><li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li><li><code>drop</code>命令会把表占用的空间全部释放掉。</li></ul><h2 id="7-数据库设计通常分为哪几步"><a href="#7-数据库设计通常分为哪几步" class="headerlink" title="7. 数据库设计通常分为哪几步?"></a>7. 数据库设计通常分为哪几步?</h2><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol><h2 id="8-NoSQL"><a href="#8-NoSQL" class="headerlink" title="8. NoSQL"></a>8. NoSQL</h2><h3 id="8-1-NoSQL是什么？"><a href="#8-1-NoSQL是什么？" class="headerlink" title="8.1 NoSQL是什么？"></a>8.1 NoSQL是什么？</h3><ul><li>概念：<ul><li>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值对、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</li></ul></li><li>NoSQL 能否存储关系型数据？<ul><li>NoSQL 数据库可以存储关系型数据，它们与关系型数据库的存储方式不同。</li></ul></li><li>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/2.png"></p><h3 id="8-2-SQL-和-NoSQL-有什么区别？"><a href="#8-2-SQL-和-NoSQL-有什么区别？" class="headerlink" title="8.2 SQL 和 NoSQL 有什么区别？"></a>8.2 SQL 和 NoSQL 有什么区别？</h3><table><thead><tr><th align="left"></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td align="left">数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td align="left">发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td align="left">例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td></tr><tr><td align="left">ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td></tr><tr><td align="left">性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td align="left">扩展</td><td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td align="left">用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td align="left">查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr></tbody></table><h3 id="8-3-NoSQL-数据库有什么优势？"><a href="#8-3-NoSQL-数据库有什么优势？" class="headerlink" title="8.3 NoSQL 数据库有什么优势？"></a>8.3 NoSQL 数据库有什么优势？</h3><ul><li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</li><li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li><li><strong>高性能：</strong> NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li><li><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li></ul><h3 id="8-4-NoSQL-数据库有哪些类型？"><a href="#8-4-NoSQL-数据库有哪些类型？" class="headerlink" title="8.4 NoSQL 数据库有哪些类型？"></a>8.4 NoSQL 数据库有哪些类型？</h3><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/3.png"></p><h2 id="9-字符集"><a href="#9-字符集" class="headerlink" title="9. 字符集"></a>9. 字符集</h2><p>MySQL 字符编码集中有两套 UTF-8 编码实现：**<code>utf8</code>** 和 **<code>utf8mb4</code>**。</p><p>如果使用 <strong><code>utf8</code></strong> 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p><h3 id="9-1-何为字符集？"><a href="#9-1-何为字符集？" class="headerlink" title="9.1 何为字符集？"></a>9.1 何为字符集？</h3><p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p><h3 id="9-2-有哪些常见的字符集？"><a href="#9-2-有哪些常见的字符集？" class="headerlink" title="9.2 有哪些常见的字符集？"></a>9.2 有哪些常见的字符集？</h3><ul><li>常见的字符集有 ASCII、GB2312、GBK、UTF-8……。</li><li>不同的字符集的主要区别在于：<ul><li>可以表示的字符范围</li><li>编码方式</li></ul></li></ul><h3 id="9-3-ASCII"><a href="#9-3-ASCII" class="headerlink" title="9.3 ASCII"></a>9.3 ASCII</h3><ul><li><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</li><li>ASCII 码长度是一个字节也就是 8 个 bit，ASCII 字符集共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</li><li>0（48），A（65），a（97）</li><li></li></ul><h3 id="9-4-GB2312"><a href="#9-4-GB2312" class="headerlink" title="9.4 GB2312"></a>9.4 GB2312</h3><ul><li>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</li><li>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</li></ul><h3 id="9-5-GBK"><a href="#9-5-GBK" class="headerlink" title="9.5 GBK"></a>9.5 GBK</h3><ul><li>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</li></ul><h3 id="9-6-GB18030"><a href="#9-6-GB18030" class="headerlink" title="9.6 GB18030"></a>9.6 GB18030</h3><ul><li>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</li></ul><h3 id="9-7-BIG5"><a href="#9-7-BIG5" class="headerlink" title="9.7 BIG5"></a>9.7 BIG5</h3><ul><li>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</li></ul><h3 id="9-8-UTF-8"><a href="#9-8-UTF-8" class="headerlink" title="9.8 UTF-8"></a>9.8 UTF-8</h3><ul><li><strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）</li><li>UTF-8 使用 1 到 4 个字节为每个字符编码， </li><li><strong>UTF-8</strong> 是目前使用最广的一种字符编码。</li></ul><h2 id="10-MySQL-字符集"><a href="#10-MySQL-字符集" class="headerlink" title="10. MySQL 字符集"></a>10. MySQL 字符集</h2><ul><li>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</li><li>MySQL 字符编码集中有两套 UTF-8 编码实现：<ul><li>**<code>utf8</code>**：<code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li><li>**<code>utf8mb4</code>**：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li><li>因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</li></ul></li></ul><h2 id="11-SQL语句知识点总结"><a href="#11-SQL语句知识点总结" class="headerlink" title="11. SQL语句知识点总结"></a>11. SQL语句知识点总结</h2><h3 id="11-1-SQL-分类"><a href="#11-1-SQL-分类" class="headerlink" title="11.1 SQL 分类"></a>11.1 SQL 分类</h3><ul><li><p>数据定义语言（DDL）</p><ul><li>概念：数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</li><li>功能：<strong>定义数据库对象</strong>。</li><li>核心指令： <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</li></ul></li><li><p>数据操纵语言（DML）</p><ul><li>概念：数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</li><li>功能：<strong>访问数据</strong>，因此其语法都是以<strong>读写数据库</strong>为主。</li><li>核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</li></ul></li><li><p>事务控制语言（TCL）</p><ul><li>概念：事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</li><li>核心指令： <code>COMMIT</code>、<code>ROLLBACK</code>。</li></ul></li><li><p>数据控制语言（DCL）</p><ul><li>概念：数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</li><li>核心指令： <code>GRANT</code>、<code>REVOKE</code>。</li></ul></li></ul><h3 id="11-2-增删改查"><a href="#11-2-增删改查" class="headerlink" title="11.2 增删改查"></a>11.2 增删改查</h3><ul><li><p>插入数据：<code>INSERT INTO</code> 语句用于向表中插入新记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username, password, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>更新数据：<code>UPDATE</code> 语句用于更新表中的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><ul><li><code>DELETE</code> 语句用于删除表中的记录。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;robot&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查询数据</p><ul><li><p>关键字：</p><ul><li><code>SELECT</code> 语句用于从数据库中查询数据。</li><li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li><li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</li><li><code>ASC</code>：升序（默认）</li><li><code>DESC</code>：降序</li></ul></li><li><p><strong>查询单列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure></li><li><p><strong>查询多列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure></li><li><p><strong>查询所有列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure></li><li><p><strong>查询不同的值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">vend_id <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure></li><li><p><strong>限制查询结果</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回前 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 返回第 3 ~ 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>排序</p></li><li><p><code>order by</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>desc</code> 关键字。</p></li><li><p><code>order by</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li><li><p>分组：**<code>group by</code>**：</p><ul><li><p><strong>分组</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure></li><li><p><strong>分组后排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>**<code>having</code>**：</p><ul><li><p><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</p></li><li><p><code>having</code> 一般都是和 <code>group by</code> 连用。</p></li><li><p><code>where</code> 和 <code>having</code> 可以在相同的查询中。</p></li><li><p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>**<code>having</code> vs <code>where</code>**：</p><ul><li><code>where</code>：过滤过滤指定的行，后面不能加聚合函数（分组函数）。<code>where</code> 在<code>group by</code> 前。</li><li><code>having</code>：过滤分组，一般都是和 <code>group by</code> 连用，不能单独使用。<code>having</code> 在 <code>group by</code> 之后。</li></ul></li></ul></li></ul></li></ul><h2 id="12-SQL面试题总结"><a href="#12-SQL面试题总结" class="headerlink" title="12. SQL面试题总结"></a>12. SQL面试题总结</h2><h2 id="13-MySQL索引详解"><a href="#13-MySQL索引详解" class="headerlink" title="13. MySQL索引详解"></a>13. MySQL索引详解</h2><h3 id="13-1-索引介绍"><a href="#13-1-索引介绍" class="headerlink" title="13.1 索引介绍"></a>13.1 索引介绍</h3><ul><li>概念：<strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></li><li>作用：索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</li><li>数据结构：索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了<strong>B+树</strong>作为索引结构。</li></ul><h3 id="13-2-索引的优缺点"><a href="#13-2-索引的优缺点" class="headerlink" title="13.2 索引的优缺点"></a>13.2 索引的优缺点</h3><ul><li><p><strong>优点</strong>：</p><ul><li>使用索引可以大大加快数据的检索速度（大大减少检索的数据量，这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul></li><li><p><strong>使用索引一定能提高查询性能吗?</strong></p><ul><li>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</li></ul></li></ul><h3 id="13-3-索引的分类"><a href="#13-3-索引的分类" class="headerlink" title="13.3 索引的分类"></a>13.3 索引的分类</h3><ul><li>按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。</li><li>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。</li><li>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。</li><li>按「字段个数」分类：单列索引、联合索引。</li></ul><h3 id="13-4-MySQL索引使用有哪些注意事项呢"><a href="#13-4-MySQL索引使用有哪些注意事项呢" class="headerlink" title="13.4 MySQL索引使用有哪些注意事项呢"></a>13.4 MySQL索引使用有哪些注意事项呢</h3><ul><li><p>哪些情况会导致索引失效:</p><ul><li>like通配符可能导致索引失效。</li><li>查询条件包含or，可能导致索引失效</li><li>如何字段类型是字符串，where时一定用引号括起来，否则索引失效</li><li>对索引列运算（如，+、-、*、&#x2F;），索引失效。</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用mysql的内置函数，索引失效。</li><li>索引字段上使用is null， is not null，可能导致索引失效。</li><li>索引字段上使用（！&#x3D; 或者 &lt; &gt;，not in）时，可能会导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>mysql估计使用全表扫描要比使用索引快,则不使用索引。</li></ul></li><li><p>索引不适合哪些场景</p><ul><li>数据量少的不适合加索引</li><li>更新比较频繁的也不适合加索引</li><li>区分度低的字段不适合加索引（如性别）</li></ul></li></ul><h3 id="13-5-数据库索引结构为什么要用B-树，为什么不用二叉树？"><a href="#13-5-数据库索引结构为什么要用B-树，为什么不用二叉树？" class="headerlink" title="13.5 数据库索引结构为什么要用B+树，为什么不用二叉树？"></a>13.5 数据库索引结构为什么要用B+树，为什么不用二叉树？</h3><ul><li><p>MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。</p></li><li><p>要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I&#x2F;0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I&#x2F;0 的操作次数内完成。</p></li><li><p>二分查找树：二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。</p></li><li><p>自平衡二叉树：为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。而树的高度决定于磁盘 I&#x2F;O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I&#x2F;O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</p></li><li><p>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ul></li></ul><h2 id="14-执行一条-select-语句，期间发生了什么？"><a href="#14-执行一条-select-语句，期间发生了什么？" class="headerlink" title="14. 执行一条 select 语句，期间发生了什么？"></a>14. 执行一条 select 语句，期间发生了什么？</h2><h3 id="14-1-MySQL-的架构"><a href="#14-1-MySQL-的架构" class="headerlink" title="14.1 MySQL 的架构"></a>14.1 MySQL 的架构</h3><ul><li>MySQL 的架构共分为两层：Server 层和存储引擎层，</li><li>Server 层负责建立连接、分析和执行 SQL。</li><li>存储引擎层负责数据的存储和提取。</li></ul><h3 id="14-2-SQL的select语句的执行流程"><a href="#14-2-SQL的select语句的执行流程" class="headerlink" title="14.2 SQL的select语句的执行流程"></a>14.2 SQL的select语句的执行流程</h3><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/4.png"></p><h2 id="15-MySQL事务"><a href="#15-MySQL事务" class="headerlink" title="15. MySQL事务"></a>15. MySQL事务</h2><h3 id="15-1-事务是什么"><a href="#15-1-事务是什么" class="headerlink" title="15.1 事务是什么"></a>15.1 事务是什么</h3><ul><li>就是用户定义的一系列数据库操作，这些操作可以视为一个完成的逻辑处理工作单元，要么全部执行，要么全部不执行，是不可分割的工作单元。</li></ul><h3 id="15-2-MySQL事务四大特性（ACID）："><a href="#15-2-MySQL事务四大特性（ACID）：" class="headerlink" title="15.2 MySQL事务四大特性（ACID）："></a>15.2 MySQL事务四大特性（ACID）：</h3><ul><li>原子性（Atomicity）：一个事务被作为一个整体执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。不会结束在中间某个环节。事务在执行过程中如果发生异常，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>一致性（Consistency）：指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转100块钱，不管成功与否，A和B的总金额是不变的。</li><li>隔离性（Isolation）：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</li><li>持久性（Durability）：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中，即便系统故障也不会丢失。</li></ul><h3 id="15-3-MySQL事务四大特性（ACID）实现原理："><a href="#15-3-MySQL事务四大特性（ACID）实现原理：" class="headerlink" title="15.3 MySQL事务四大特性（ACID）实现原理："></a>15.3 MySQL事务四大特性（ACID）实现原理：</h3><ul><li>原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。</li><li>持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。</li><li>隔离性：通过锁以及MVCC，使事务相互隔离开。</li><li>一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。</li></ul><h3 id="15-4-MySQL数据隔离级别"><a href="#15-4-MySQL数据隔离级别" class="headerlink" title="15.4 MySQL数据隔离级别"></a>15.4 MySQL数据隔离级别</h3><ul><li>MySQL 里有四个隔离级别：Read uncommttied（可以读取未提交数据）、Read committed（可以读取已提交数据）、Repeatable read（可重复读）、Serializable（可串行化）。</li><li>在 InnoDB 中，默认为 Repeatable 级别，InnoDB 中使用一种被称为 next-key locking 的策略来避免幻读（phantom）现象的产生。</li><li>不同的事务隔离级别会导致不同的问题：</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（Read uncommttied）</td><td>&amp;#10004;</td><td>&amp;#10004;</td><td>&amp;#10004;</td></tr><tr><td>读已提交（Read committed）</td><td>&amp;#10008;</td><td>&amp;#10004;</td><td>&amp;#10004;</td></tr><tr><td>可重复读（Repeatable read）</td><td>&amp;#10008;</td><td>&amp;#10008;</td><td>&amp;#10004;</td></tr><tr><td>可串行化（Serializable）</td><td>&amp;#10008;</td><td>&amp;#10008;</td><td>&amp;#10008;</td></tr></tbody></table><h3 id="15-5-MVCC原理"><a href="#15-5-MVCC原理" class="headerlink" title="15.5 MVCC原理"></a>15.5 MVCC原理</h3><p>参考：<a href="https://www.modb.pro/db/40241">https://www.modb.pro/db/40241</a></p><ul><li>概念：MVCC（Multi-Version Concurrency Control）多版本并发控制，是数据库控制并发访问的一种手段。MVCC只在 读已提交(RC) 和 可重复度（RR） 这两种事务隔离级别下才有效。MVCC是数据库引擎（InnoDB）层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能</li><li>实现： InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</li><li>MVCC 最大的好处：读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。</li></ul><hr><p><strong>详细描述MVCC：</strong></p><ul><li>创建一张测试表并写入测试数据，进行实验：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create database likecolumn;</span><br><span class="line"></span><br><span class="line">use likecolumn;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `t1` (</span><br><span class="line"></span><br><span class="line">`id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line"></span><br><span class="line">`a` int(11) NOT NULL,</span><br><span class="line"></span><br><span class="line">`b` int(11) NOT NULL,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line"></span><br><span class="line">KEY `idx_c` (`a`)</span><br><span class="line"></span><br><span class="line">) ENGINE=InnoDB CHARSET=utf8mb4;</span><br><span class="line"></span><br><span class="line">insert into t1(a,b) values (1,1),(2,2);</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>序号</th><th>session 1</th><th>session 2</th></tr></thead><tbody><tr><td>1</td><td>set session transaction_isolation&#x3D;’READCOMMITTED’; &#x2F;* 设置会话隔离级别为 RC*&#x2F;</td><td>set session transaction_isolation&#x3D;’READCOMMITTED’;&#x2F;* 设置会话隔离级别为 RC*&#x2F;</td></tr><tr><td>2</td><td>select * from t1;      <img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/26.png"></td><td></td></tr><tr><td>3</td><td>begin;</td><td></td></tr><tr><td>4</td><td>update t1 set b&#x3D;666 where a&#x3D;1;</td><td></td></tr><tr><td>5</td><td></td><td>begin;</td></tr><tr><td>6</td><td></td><td>select * from t1; <img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/27.png"></td></tr><tr><td>7</td><td>commit;</td><td></td></tr><tr><td>8</td><td></td><td>select * from t1; <img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/28.png"></td></tr><tr><td>9</td><td></td><td>commit;</td></tr></tbody></table><p>这里解释一下上面的实验过程，在 session1 开启一个事务更新了 a&#x3D;1 这行记录，但还没提交的情况下，在 session2 中，满足 a&#x3D;1 这条记录，b 的值还是原始值 1，而不是 session1 更新之后的 666，那么在数据库层面，这是怎么实现的呢？</p><p><strong>其实 InnoDB 就是通过 MVCC 和 UNDO LOG 来实现的。</strong></p><ul><li><p>MVCC 的实现原理</p><ul><li><p>对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：</p><ul><li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。</li><li>事务 ID：记录最后一次修改该记录的事务 ID。</li><li>回滚指针：指向这条记录的上一个版本。</li></ul></li><li><p>我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图：</p></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/29.png"></p><ul><li>如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b&#x3D;666 where a&#x3D;1 时，大致步骤如下：<ul><li>数据库会先对满足 a&#x3D;1 的行加排他锁；</li><li>然后将原记录复制到 undo 表空间中；</li><li>修改 b 字段的值为 666，修改事务 ID 为 2；</li><li>并通过隐藏的回滚指针指向 undo log 中的历史记录；</li><li>事务提交，释放前面对满足 a&#x3D;1 的行所加的排他锁。</li></ul></li><li>在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是来自 undolog 中。</li></ul></li><li><p>因此可以总结出 MVCC 实现的原理大致是：<br>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。<br>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。</p></li></ul><h2 id="16-说一下什么是幻读，脏读，不可重复读？"><a href="#16-说一下什么是幻读，脏读，不可重复读？" class="headerlink" title="16. 说一下什么是幻读，脏读，不可重复读？"></a>16. 说一下什么是幻读，脏读，不可重复读？</h2><h3 id="16-1-脏读："><a href="#16-1-脏读：" class="headerlink" title="16.1 脏读："></a>16.1 脏读：</h3><p>脏读是指一个事务中访问到了另外一个事务未提交的数据，如下所示：</p><table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td></td><td>update table set age&#x3D;10 where id&#x3D;1</td></tr><tr><td>select age from table where id&#x3D;1</td><td></td></tr><tr><td>commit</td><td>commit</td></tr></tbody></table><blockquote><p>如果会话 2 更新 age 为 10，但是在 commit 之前，会话 1 希望得到 age，那么会获得的值就是更新前的值。或者如果会话 2 更新了值但是执行了 rollback，而会话 1 拿到的仍是 10。这就是脏读。</p></blockquote><h3 id="16-2-不可重复读："><a href="#16-2-不可重复读：" class="headerlink" title="16.2 不可重复读："></a>16.2 不可重复读：</h3><p>一个事务读取同一条记录2次，得到的结果不一致：</p><table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>select age from table where id&#x3D;1</td><td></td></tr><tr><td></td><td>update table set age&#x3D;10 where id&#x3D;1</td></tr><tr><td></td><td>commit</td></tr><tr><td>select age from table where id&#x3D;1</td><td></td></tr><tr><td>commit</td><td></td></tr></tbody></table><blockquote><p>由于在读取中间变更了数据，所以会话 1 事务查询期间的得到的结果就不一样了。</p></blockquote><h3 id="16-3-幻读："><a href="#16-3-幻读：" class="headerlink" title="16.3 幻读："></a>16.3 幻读：</h3><p>一个事务读取2次，得到的记录条数不一致：</p><table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>select age from table where id&gt;2</td><td></td></tr><tr><td></td><td>insert into table(id, age) values(5, 10)</td></tr><tr><td></td><td>commit</td></tr><tr><td>select age from table where id&gt;2</td><td></td></tr><tr><td>commit</td><td></td></tr></tbody></table><blockquote><p>上图很明显的表示了这个情况，由于在会话 1 之间插入了一个新的值，所以得到的两次数据就不一样了。</p></blockquote><h2 id="17-说一下什么是内连接、外连接、交叉连接、笛卡尔积呢？"><a href="#17-说一下什么是内连接、外连接、交叉连接、笛卡尔积呢？" class="headerlink" title="17. 说一下什么是内连接、外连接、交叉连接、笛卡尔积呢？"></a>17. 说一下什么是内连接、外连接、交叉连接、笛卡尔积呢？</h2><p>例子图示：</p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/5.png"></p><h3 id="17-1-内连接（inner-join）："><a href="#17-1-内连接（inner-join）：" class="headerlink" title="17.1 内连接（inner join）："></a>17.1 内连接（inner join）：</h3><ul><li>概念：取得两张表中满足存在连接匹配关系的记录。</li><li>例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from Student s</span><br><span class="line">inner join Course c on s.C_S_Id=c.C_Id</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/6.png"></p><h3 id="17-2-外连接（outer-join）："><a href="#17-2-外连接（outer-join）：" class="headerlink" title="17.2 外连接（outer join）："></a>17.2 外连接（outer join）：</h3><ul><li>概念：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。</li><li>分类：左外连接（left join &#x2F; left outer join）、右外连接（right join &#x2F; right outer join）和全外连接（full join &#x2F; full outer join）</li><li>左外连接：满足on条件表达式，左外连接是以左表为准，返回左表所有的数据，与右表匹配的则有值，没有匹配的则以空（null）取代。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from Student s</span><br><span class="line">left join Course c on s.C_S_Id=c.C_Id</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/7.png"></p><ul><li>右外连接：满足on条件表达式，右外连接是以右表为准，返回右表所有的数据，与左表匹配的则有值，没有匹配的则以空（null）取代。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from Student s</span><br><span class="line">right join Course c on s.C_S_Id=c.C_Id</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/8.png"></p><ul><li>全外连接：满足on条件表达式，返回两个表符合条件的所有行，a表没有匹配的则a表的列返回null，b表没有匹配的则b表的列返回null，即返回的是左连接和右连接的并集。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from Student s</span><br><span class="line">full join Course c on s.C_S_Id=c.C_Id</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/9.png"></p><h3 id="17-3-交叉连接（cross-join）："><a href="#17-3-交叉连接（cross-join）：" class="headerlink" title="17.3 交叉连接（cross join）："></a>17.3 交叉连接（cross join）：</h3><ul><li>概念：显示两张表所有记录一一对应，没有匹配关系进行筛选，也被称为：笛卡尔积。比如A表有10条记录，B表有100条记录，那么笛卡尔积关联查询结果就是10*100&#x3D;1000条记录，一般我们要避免笛卡尔积的出现。</li><li>例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from Student s</span><br><span class="line">cross join Course c</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 加上条件返回满足条件表达式的两个表的行：</span><br><span class="line">select * from Student s</span><br><span class="line">cross join Course c </span><br><span class="line">where s.C_S_Id=c.C_Id</span><br></pre></td></tr></table></figure><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/10.png"></p><h2 id="18-SQL优化"><a href="#18-SQL优化" class="headerlink" title="18. SQL优化"></a>18. SQL优化</h2><h3 id="18-1-整体思路"><a href="#18-1-整体思路" class="headerlink" title="18.1 整体思路"></a>18.1 整体思路</h3><ul><li>查看执行计划 explain</li><li>如果有告警信息，查看告警信息 show warnings;</li><li>查看SQL涉及的表结构和索引信息</li><li>根据执行计划，思考可能的优化点</li><li>按照可能的优化点执行表结构变更、增加索引、SQL改写等操作</li><li>查看优化后的执行时间和执行计划</li><li>如果优化效果不明显，重复第四步操作</li></ul><h3 id="18-2-SQL慢查询优化案例"><a href="#18-2-SQL慢查询优化案例" class="headerlink" title="18.2 SQL慢查询优化案例"></a>18.2 SQL慢查询优化案例</h3><ul><li><p>表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `a`</span><br><span class="line">(</span><br><span class="line">    `id`          int(11) NOT NULLAUTO_INCREMENT,</span><br><span class="line">    `seller_id`   bigint(20)                                       DEFAULT NULL,</span><br><span class="line">    `seller_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">    `gmt_create`  varchar(30)                                      DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE `b`</span><br><span class="line">(</span><br><span class="line">    `id`          int(11) NOT NULLAUTO_INCREMENT,</span><br><span class="line">    `seller_name` varchar(100) DEFAULT NULL,</span><br><span class="line">    `user_id`     varchar(50)  DEFAULT NULL,</span><br><span class="line">    `user_name`   varchar(100) DEFAULT NULL,</span><br><span class="line">    `sales`       bigint(20)   DEFAULT NULL,</span><br><span class="line">    `gmt_create`  varchar(30)  DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE `c`</span><br><span class="line">(</span><br><span class="line">    `id`         int(11) NOT NULLAUTO_INCREMENT,</span><br><span class="line">    `user_id`    varchar(50)  DEFAULT NULL,</span><br><span class="line">    `order_id`   varchar(100) DEFAULT NULL,</span><br><span class="line">    `state`      bigint(20)   DEFAULT NULL,</span><br><span class="line">    `gmt_create` varchar(30)  DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>有问题的查询SQL: a，b，c 三张表关联，查询用户17 在当前时间前后10个小时的订单情况，并根据订单创建时间升序排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select a.seller_id,</span><br><span class="line">       a.seller_name,</span><br><span class="line">       b.user_name,</span><br><span class="line">       c.state</span><br><span class="line">from a,</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line">where a.seller_name = b.seller_name</span><br><span class="line">  and b.user_id = c.user_id</span><br><span class="line">  and c.user_id = 17</span><br><span class="line">  and a.gmt_create</span><br><span class="line">    BETWEEN DATE_ADD(NOW(), INTERVAL – 600 MINUTE)</span><br><span class="line">    AND DATE_ADD(NOW(), INTERVAL 600 MINUTE)</span><br><span class="line">order by a.gmt_create;</span><br></pre></td></tr></table></figure></li><li><p>先查看各表数据量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;a&#x27;, count(*) from a</span><br><span class="line">union</span><br><span class="line">select &#x27;b&#x27;, count(*) from b</span><br><span class="line">union</span><br><span class="line">select &#x27;c&#x27;, count(*) from c;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/11.jpeg"></p><ul><li>查看原sql执行时间<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select a.seller_id,</span><br><span class="line">       a.seller_name,</span><br><span class="line">       b.user_name,</span><br><span class="line">       c.state</span><br><span class="line">from a,</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line">where a.seller_name = b.seller_name</span><br><span class="line">  and b.user_id = c.user_id</span><br><span class="line">  and c.user_id = 17</span><br><span class="line">  and a.gmt_create</span><br><span class="line">    BETWEEN DATE_ADD(NOW(), INTERVAL – 600 MINUTE)</span><br><span class="line">    AND DATE_ADD(NOW(), INTERVAL 600 MINUTE)</span><br><span class="line">order by a.gmt_create;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/12.jpeg"></p><ul><li>查看执行计划 explain<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">explain select </span><br><span class="line">       a.seller_id,</span><br><span class="line">       a.seller_name,</span><br><span class="line">       b.user_name,</span><br><span class="line">       c.state</span><br><span class="line">from a,</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line">where a.seller_name = b.seller_name</span><br><span class="line">  and b.user_id = c.user_id</span><br><span class="line">  and c.user_id = 17</span><br><span class="line">  and a.gmt_create</span><br><span class="line">    BETWEEN DATE_ADD(NOW(), INTERVAL – 600 MINUTE)</span><br><span class="line">    AND DATE_ADD(NOW(), INTERVAL 600 MINUTE)</span><br><span class="line">order by a.gmt_create;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/13.jpeg"></p><p>执行计划中几个重要字段的解释说明</p><table><thead><tr><th>字段</th><th>解释</th></tr></thead><tbody><tr><td>id</td><td>每个被独立执行的操作标识，标识对象被操作的顺序，id值越大，先被执行，如果相同，执行顺序从上到下</td></tr><tr><td>select_type</td><td>查询中每个select 字句的类型</td></tr><tr><td>table</td><td>被操作的对象名称，通常是表名，但有其他格式</td></tr><tr><td>partitions</td><td>匹配的分区信息(对于非分区表值为NULL)</td></tr><tr><td>type</td><td>连接操作的类型</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td><strong>key</strong></td><td>优化器实际使用的索引(最重要的列) 从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL。当出现ALL时表示当前SQL出现了“坏味道”</td></tr><tr><td>key_len</td><td>被优化器选定的索引键长度，单位是字节</td></tr><tr><td>ref</td><td>表示本行被操作对象的参照对象，无参照对象为NULL</td></tr><tr><td>rows</td><td>查询执行所扫描的元组个数（对于innodb，此值为估计值）</td></tr><tr><td>filtered</td><td>条件表上数据被过滤的元组个数百分比</td></tr><tr><td><strong>extra</strong></td><td>执行计划的重要补充信息，当此列出现Using filesort , Using temporary 字样时就要小心了，很可能SQL语句需要优化</td></tr></tbody></table><ul><li><p>通过观察执行计划和SQL语句，确定初步优化方案</p><ul><li>SQL中<code>where</code>条件字段类型要跟表结构一致，表中<code>user_id</code>为varchar(50)类型，实际SQL用的int类型，存在隐式转换，也未添加索引。将b和c表 user_id 字段改成int类型。</li><li>因存在b表和c表关联，将b和c表<code>user_id</code>创建索引</li><li>因存在a表和b表关联，将a和b表 seller_name字段创建索引</li><li>利用复合索引消除临时表和排序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table b modify `user_id` int(10) DEFAULT NULL;</span><br><span class="line">alter table c modify `user_id` int(10) DEFAULT NULL;</span><br><span class="line">alter table c add index `idx_user_id`(`user_id`);</span><br><span class="line">alter table b add index `idx_user_id_sell_name`(`user_id`,`seller_name`);</span><br><span class="line">alter table a add index `idx_sellname_gmt_sellid`(`gmt_create`,`seller_name`,`seller_id`);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看优化后的执行时间</p></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/14.jpeg"></p><ul><li>继续查看优化后的执行计划</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/15.jpeg"></p><p>这里只看到查询需要扫描的元素比较大，不过还看到了有两处告警信息，直接查看告警信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show warnings;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/16.jpeg"></p><p><code>Cannot use range access on index  ‘idx_sellname_gmt_sellid’ due to type or collation conversion on field ‘get_create’</code>，这句话是告诉你由于<code>gmt_create</code>列发生了类型转换所以无法走索引。<br>查看SQL建表语句发现gmt_create字段被设计成了varchar类型，在SQL查询时需要转化成时间格式做查询，确实不能走索引。所以需要调整一下gmt_create字段格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table a modify &quot;gmt_create&quot; datetime DEFAULT NULL;</span><br></pre></td></tr></table></figure><ul><li>修改字段后再来查看执行时间</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/17.jpeg"></p><ul><li>再观察优化后的执行计划</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/18.jpeg"></p><h3 id="18-3-SQL优化要点"><a href="#18-3-SQL优化要点" class="headerlink" title="18.3 SQL优化要点"></a>18.3 SQL优化要点</h3><ol><li><p>在表中建立索引，优先考虑<code>where</code>、<code>group by</code>使用到的字段。</p></li><li><p>尽量避免使用<code>select *</code>，返回无用的字段会降低查询效率，如：<code>SELECT * FROM t</code>。</p><ul><li>优化方式：<strong>使用具体的字段代替*，只返回使用到的字段</strong>。</li></ul></li><li><p>尽量避免使用<code>in</code>和<code>not in</code>，会导致数据库引擎放弃索引进行全表扫描，如：<code>SELECT * FROM t WHERE id IN (2,3)</code>、<code>SELECT * FROM t1 WHERE username IN (SELECT username FROM t2)</code>。</p><ul><li>优化方式：<ul><li><strong>如果是连续数值，可以用between代替</strong>，如：<code>SELECT * FROM t WHERE id BETWEEN 2 AND 3</code>；</li><li><strong>如果是子查询，可以用exists代替</strong>，如：<code>SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE t1.username = t2.username)</code>。</li></ul></li></ul></li><li><p>尽量避免使用<code>or</code>，会导致数据库引擎放弃索引进行全表扫描。如：<code>SELECT * FROM t WHERE id = 1 OR id = 3</code>。</p><ul><li>优化方式：可以用<code>union</code>代替<code>or</code>，如：<code>SELECT * FROM t WHERE id = 1 UNION SELECT * FROM t WHERE id = 3</code></li><li>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。<blockquote><p>（PS：如果or两边的字段是同一个，如例子中这样。貌似两种方式效率差不多，即使union扫描的是索引，or扫描的是全表）</p></blockquote></li></ul></li><li><p>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。如：<code>SELECT * FROM t WHERE username LIKE &#39;%li%&#39;</code></p><ul><li>优化方式：尽量在字段后面使用模糊查询。如：<code>SELECT * FROM t WHERE username LIKE &#39;li%&#39;</code></li></ul></li><li><p>尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如：<code>SELECT * FROM t WHERE score IS NULL</code></p><ul><li>优化方式：可以给字段添加默认值0，对0值进行判断。如：<code>SELECT * FROM t WHERE score = 0</code></li></ul></li><li><p>尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。如：<code>SELECT * FROM t2 WHERE score/10 = 9</code>、<code>SELECT * FROM t2 WHERE SUBSTR(username,1,2) = &#39;li&#39;</code></p><ul><li>优化方式：可以将表达式、函数操作移动到等号右侧。如：<code>SELECT * FROM t2 WHERE score = 10*9</code>、<code>SELECT * FROM t2 WHERE username LIKE &#39;li%&#39;</code></li></ul></li><li><p>当数据量大时，避免使用where 1&#x3D;1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如：<code>SELECT * FROM t WHERE 1=1</code></p><ul><li>优化方式：用代码拼装sql时进行判断，没where加where，有where加and。</li></ul></li></ol><h2 id="19-分库分表"><a href="#19-分库分表" class="headerlink" title="19. 分库分表"></a>19. 分库分表</h2><h3 id="19-1-什么是分库分表"><a href="#19-1-什么是分库分表" class="headerlink" title="19.1 什么是分库分表:"></a>19.1 什么是分库分表:</h3><p>分库分表是在海量数据下，由于单库、表数据量过大，导致数据库性能持续下降的问题，演变出的技术方案。</p><p>通过一定的规则，将原本数据量大的数据库拆分成多个单独的数据库，将原本数据量大的表拆分成若干个数据表，使得单一的库、表性能达到最优的效果（响应速度快），以此提升整体数据库性能。</p><h3 id="19-2-分库分表方案"><a href="#19-2-分库分表方案" class="headerlink" title="19.2 分库分表方案:"></a>19.2 分库分表方案:</h3><ul><li><p>垂直分库：垂直分库一般来说按照业务和功能的维度进行拆分，将不同业务数据分别放到不同的数据库中。垂直分库把一个库的压力分摊到多个库，提升了一些数据库性能，但并没有解决由于单表数据量过大导致的性能问题，所以就需要配合后边的分表来解决。</p><ul><li>例子：按业务类型对数据分离，剥离为多个数据库，像订单、支付、会员、积分相关等表放在对应的订单库、支付库、会员库、积分库。不同业务禁止跨库直连，获取对方业务数据一律通过API接口交互，这也是微服务拆分的一个重要依据。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/19.jpeg"></li></ul></li><li><p>垂直分表：垂直分表针对业务上字段比较多的大表进行的，一般是把业务宽表中比较独立的字段，或者不常用的字段拆分到单独的数据表中，是一种大表拆小表的模式。</p><ul><li>例子：一张<code>t_order</code>订单表上有几十个字段，其中订单金额相关字段计算频繁，为了不影响订单表t_order的性能，就可以把订单金额相关字段拆出来单独维护一个t_order_price_expansion扩展表，这样每张表只存储原表的一部分字段，通过订单号order_no做关联，再将拆分出来的表路由到不同的库中。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/20.jpeg"></li></ul></li><li><p>水平分库：水平分库是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，以此实现水平扩展，是一种常见的提升数据库性能的方式。</p><ul><li>例子：<code>db_orde_1</code>、<code>db_order_2</code>两个数据库内有完全相同的<code>t_order</code>表，我们在访问某一笔订单时可以通过对订单的订单编号取模的方式 <code>订单编号 mod 2 （数据库实例数）</code> ，指定该订单应该在哪个数据库中操作。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/21.jpeg"></li></ul></li><li><p>水平分表：水平分表是在同一个数据库内，把一张大数据量的表按一定规则，切分成多个结构完全相同表，而每个表只存原表的一部分数据。</p><ul><li>例子：例如：一张<code>t_order</code>订单表有900万数据，经过水平拆分出来三个表，<code>t_order_1</code>、<code>t_order_2</code>、<code>t_order_3</code>，每张表存有数据300万，以此类推。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/22.jpeg"></li></ul></li></ul><h3 id="19-3-数据存在哪个库的表"><a href="#19-3-数据存在哪个库的表" class="headerlink" title="19.3 数据存在哪个库的表"></a>19.3 数据存在哪个库的表</h3><blockquote><p>分库分表以后会出现一个问题，一张表会出现在多个数据库里，到底该往哪个库的哪个表里存呢？</p></blockquote><blockquote><p>常见的有 <code>取模算法</code> 、<code>范围限定算法</code>、<code>范围+取模算法</code> 、<code>预定义算法</code></p></blockquote><ul><li><p>取模算法：</p><ul><li>概念：关键字段取模（对hash结果取余数 hash(XXX) mod N)，N为数据库实例数或子表数量）是最为常见的一种路由方式。</li><li>例子：以t_order订单表为例，先给数据库从 0 到 N-1进行编号，对 t_order订单表中order_no订单编号字段进行取模hash(order_no) mod N，得到余数i。i&#x3D;0存第一个库，i&#x3D;1存第二个库，i&#x3D;2存第三个库，以此类推。</li><li>缺点：取模算法对集群的伸缩支持不太友好，集群中有N个数据库实例<code>hash(user_id) mod N</code>，当某一台机器宕机，本应该落在该数据库的请求就无法得到处理，这时宕掉的实例会被踢出集群。此时机器数减少算法发生变化hash(user_id) mod N-1，同一用户数据落在了在不同数据库中，等这台机器恢复，用user_id作为条件查询用户数据就会少一部分。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/23.jpeg"></li></ul></li><li><p>范围限定算法：</p><ul><li>概念：范围限定算法以某些范围字段，如时间或ID区拆分。</li><li>例子：用户表t_user被拆分成t_user_1、t_user_2、t_user_3三张表，后续将user_id范围为1 ~ 1000w的用户数据放入t_user_1，1000~ 2000w放入t_user_2，2000~3000w放入t_user_3，以此类推。按日期范围划分同理。</li><li>缺点：由于连续分片可能存在数据热点，比如按时间字段分片时，如果某一段时间（双11等大促）订单骤增，存11月数据的表可能会被频繁的读写，其他分片表存储的历史数据则很少被查询，导致数据倾斜，数据库压力分摊不均匀。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/24.jpeg"></li></ul></li><li><p>范围+取模算法：</p><ul><li>为了避免热点数据的问题，我们可以对上范围算法优化一下。</li><li>这次我们先通过范围算法定义每个库的用户表t_user只存1000w数据，第一个db_order_1库存放userId从1 ~ 1000w，第二个库1000<del>2000w，第三个库2000</del>3000w，以此类推。</li><li>每个库里再把用户表t_user拆分成t_user_1、t_user_2、t_user_3等，对userd进行取模路由到对应的表中。</li><li>有效的避免数据分布不均匀的问题，数据库水平扩展也简单，直接添加实例无需迁移历史数据。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/25.jpeg"></li></ul></li><li><p>地理位置分片：</p><ul><li>地理位置分片其实是一个更大的范围，按城市或者地域划分，比如华东、华北数据放在不同的分片库、表。</li></ul></li><li><p>预定义算法：</p><ul><li>预定义算法是事先已经明确知道分库和分表的数量，可以直接将某类数据路由到指定库或表中，查询的时候亦是如此。</li></ul></li></ul><h2 id="20-MySQL都有哪些锁呢？"><a href="#20-MySQL都有哪些锁呢？" class="headerlink" title="20. MySQL都有哪些锁呢？"></a>20. MySQL都有哪些锁呢？</h2><ul><li>按照 <code>锁的粒度</code> 划分可以分成：<ul><li>表锁：表级锁是mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。</li><li>页锁：页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。</li><li>行锁：行级锁是mysql中锁定粒度最细的一种锁。表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。</li></ul></li><li>按照 <code>使用的方式</code> 划分可以分为：<ul><li>共享锁：又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</li><li>排它锁：又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li></ul></li><li>按照 <code>思想</code> 的划分：<ul><li>乐观锁</li><li>悲观锁</li></ul></li></ul><h2 id="21-Redis基础"><a href="#21-Redis基础" class="headerlink" title="21. Redis基础"></a>21. Redis基础</h2><h3 id="21-1-什么是Redis"><a href="#21-1-什么是Redis" class="headerlink" title="21.1 什么是Redis"></a>21.1 什么是Redis</h3><p>与传统数据库不同的是，Redis 的数据是存在内存中的，读写速度非常快，被广泛应用于缓存。</p><h3 id="21-2-Redis为什么这么快？"><a href="#21-2-Redis为什么这么快？" class="headerlink" title="21.2 Redis为什么这么快？"></a>21.2 Redis为什么这么快？</h3><ol><li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用；</li><li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li></ol><h2 id="22-Redis应用"><a href="#22-Redis应用" class="headerlink" title="22. Redis应用"></a>22. Redis应用</h2><ul><li><strong>缓存</strong>：</li><li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li><li><strong>消息队列</strong>：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li></ul><h2 id="23-Redis数据结构"><a href="#23-Redis数据结构" class="headerlink" title="23. Redis数据结构"></a>23. Redis数据结构</h2><h3 id="23-1-基本数据结构"><a href="#23-1-基本数据结构" class="headerlink" title="23.1 基本数据结构"></a>23.1 基本数据结构</h3><ul><li><p>Redis 共有 5 种基本数据结构：String（字符串）、Hash（散列）、List（列表）、Set（集合）、Zset（有序集合）。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/30.png"></p></li><li><p>String（字符串）：</p><ul><li>String 是 Redis 中最简单同时也是最常用的一个数据结构。</li><li>应用场景：把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li></ul></li><li><p>Hash（哈希）</p><ul><li>概念：Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象。</li><li>应用场景：对象数据存储场景，比如用户信息、商品信息、文章信息等。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/31.png"></li></ul></li><li><p>List（列表）</p><ul><li>概念：Redis用双端链表实现List</li><li>应用场景：信息流展示（最新文章、最新动态）；消息队列（功能过于简单且存在很多缺陷，不建议这样做）。</li></ul></li><li><p>Set（集合）</p><ul><li>概念：Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择。</li><li>应用场景：需要存放的数据不能重复的场景，点赞，或点踩，收藏等，可以放到set中实现</li></ul></li><li><p>Zset（有序集合）</p><ul><li>概念：Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</li><li>应用场景：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜等等。</li></ul></li><li><p>总结</p></li></ul><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>String</td><td>一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</td></tr><tr><td>Hash</td><td>一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</td></tr><tr><td>List</td><td>Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</td></tr><tr><td>Set</td><td>无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</td></tr><tr><td>Zset</td><td>和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</td></tr></tbody></table><h3 id="23-2-特殊数据结构"><a href="#23-2-特殊数据结构" class="headerlink" title="23.2 特殊数据结构"></a>23.2 特殊数据结构</h3><p>除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构：Bitmap、HyperLogLog、GEO。</p><ul><li><p>Bitmap</p><ul><li>概念：Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</li><li>应用场景：<strong>需要保存状态信息（0&#x2F;1 即可表示）的场景</strong>。举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li></ul></li><li><p>HyperLogLog</p><ul><li>概念：HyperLogLog 是一种有名的基数计数概率算法。</li><li>应用场景：<strong>数量量巨大（百万、千万级别以上）的计数场景</strong>。举例：热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计。</li></ul></li><li><p>Geospatial index</p><ul><li>概念：Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</li><li>应用场景：<strong>需要管理使用地理空间数据的场景</strong>。举例：附近的人。</li></ul></li><li><p>总结</p></li></ul><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>Bitmap</td><td>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</td></tr><tr><td>HyperLogLog</td><td>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</td></tr><tr><td>Geospatial index</td><td>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</td></tr></tbody></table><h2 id="24-Redis持久化机制"><a href="#24-Redis持久化机制" class="headerlink" title="24. Redis持久化机制"></a>24. Redis持久化机制</h2><h3 id="24-1-概念："><a href="#24-1-概念：" class="headerlink" title="24.1 概念："></a>24.1 概念：</h3><p>redis是一个内存数据库，一旦服务器宕机，内存中的数据将全部丢失。所以，对 Redis 来说，实现数据的持久化，避免从后端数据库中进行恢复，是至关重要的。</p><h3 id="24-2-分类"><a href="#24-2-分类" class="headerlink" title="24.2 分类"></a>24.2 分类</h3><p>经典的redis的持久化机制分为两种：快照（snapshotting，RDB）和只追加文件（append-only file, AOF）；4.0之后，redis又提供了一种RDB和AOF的混合持久化机制。</p><h3 id="24-3-各自的实现机制，优缺点"><a href="#24-3-各自的实现机制，优缺点" class="headerlink" title="24.3 各自的实现机制，优缺点"></a>24.3 各自的实现机制，优缺点</h3><ul><li>rdb就是把某时刻的数据以二进制的形式固化到磁盘上，优点是二进制存储，结构压缩紧凑，方便传输，适用于备份容灾，缺点是实时性不高，单纯rdb，很难保证数据的可靠性，容易造成数据丢失；</li><li>aof则是以日志的形式记录数据的变更信息，相对于rdb，其数据实时性较高，一定程度上保证了数据的安全可靠，但是，其文件大小容易暴增，如果aof刷盘频繁的话，还会影响redis性能。</li><li>而混合型则是在一个文件中同时使用rdb和aof格式，集上述两种的优势于一身</li></ul><h3 id="24-4-RDB备份一般什么时候进行"><a href="#24-4-RDB备份一般什么时候进行" class="headerlink" title="24.4 RDB备份一般什么时候进行"></a>24.4 RDB备份一般什么时候进行</h3><ul><li>rdb有三种触发方式。</li><li>第一种，save命令触发，这种是堵塞式的，一般不推荐使用；</li><li>第二种是bgsave命令触发，执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求；</li><li>第三种就是根据业务情况自动触发，在某个固定时间段内，如果出现了指定次数的数据变更则进行rdb。</li></ul><h3 id="24-5-AOF重写机制"><a href="#24-5-AOF重写机制" class="headerlink" title="24.5 AOF重写机制"></a>24.5 AOF重写机制</h3><ul><li>当有命令触发或AOF达到一定大小后，会触发AOF文件重写。重写时，redis会fork一个子进程出来，在子进程中，将内存中所有数据通过redis写命令写入到一个新的AOF文件；AOF写完后，再删除旧的AOF文件，将新的AOF文件更名为旧的AOF文件。</li><li>在fork后，子进程负责将内存中的数据写入新的AOF文件；同时，父进程中，如果有新的数据变更，会将其变更记录写到rewrite_buf中；待子进程写完后，通过信号通知父进程，父进程收到通知后，继续将rewrite_buf中的变更信息写入到新的AOF文件，这样新的aof文件就不会缺失数据了。</li></ul><h2 id="25-Redis线程模型"><a href="#25-Redis线程模型" class="headerlink" title="25. Redis线程模型"></a>25. Redis线程模型</h2><h3 id="25-1-线程模型"><a href="#25-1-线程模型" class="headerlink" title="25.1 线程模型"></a>25.1 线程模型</h3><p>redis 内部使用文件事件处理器 file event handler，它是单线程的，所以redis才叫做单线程模型。它采用IO多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中</p><h3 id="25-2-redis是单线程为什么效率还这么高"><a href="#25-2-redis是单线程为什么效率还这么高" class="headerlink" title="25.2 redis是单线程为什么效率还这么高"></a>25.2 redis是单线程为什么效率还这么高</h3><ul><li>纯内存操作。</li><li>核心是基于非阻塞的 IO 多路复用机制。</li><li>C 语言实现，语言更接近操作系统，执行速度相对会更快。</li><li>单线程反而避免了多线程的频繁上下文切换问题，避免了多线程可能产生的竞争问题。</li></ul><h2 id="26-Redis内存管理"><a href="#26-Redis内存管理" class="headerlink" title="26. Redis内存管理"></a>26. Redis内存管理</h2><p>Redis主要通过<code>控制内存上限</code>和<code>回收策略</code>实现内存管理。</p><h3 id="26-1-设置内存上限"><a href="#26-1-设置内存上限" class="headerlink" title="26.1 设置内存上限"></a>26.1 设置内存上限</h3><ul><li>Redis使用maxmemory参数限制最大可用内存。 </li><li>限制内存的目的主要有：<ul><li>用于缓存场景， 当超出内存上限maxmemory时使用LRU等删除策略释放空间。</li><li>防止所用内存超过服务器物理内存。</li></ul></li></ul><h3 id="26-2-内存回收策略"><a href="#26-2-内存回收策略" class="headerlink" title="26.2 内存回收策略"></a>26.2 内存回收策略</h3><ul><li>删除过期键对象<ul><li>惰性删除</li><li>定期删除</li></ul></li><li>内存使用达到maxmemory上限时触发内存溢出控制策略。</li></ul><h2 id="27-Redis事务"><a href="#27-Redis事务" class="headerlink" title="27. Redis事务"></a>27. Redis事务</h2><h3 id="27-1-Redis是否支持事务？"><a href="#27-1-Redis是否支持事务？" class="headerlink" title="27.1 Redis是否支持事务？"></a>27.1 Redis是否支持事务？</h3><p>redis是支持事务的，他能保证一系列的命令要么全部执行，要么全部不执行</p><h3 id="27-2-Redis隔离级别"><a href="#27-2-Redis隔离级别" class="headerlink" title="27.2 Redis隔离级别"></a>27.2 Redis隔离级别</h3><ul><li>传统的数据库事务的隔级别分为读未提交、读提交、可重复读、可序化四个级别；其他，读提交解决了脏读问题，可重复读解决了不可重复度问题，可序化解决了幻读问题。</li><li>在redis中，他的事务实现机制跟传统的数据库差异较大，如果一定要对接这几种隔离级别的话，我觉得是可序化。</li><li>在redis中，其事务是将多个redis命令通过multi指示命令入队，然后通过exec命令逐个执行队列中的所有命令。</li><li>首先脏读，在redis事务中，如果事务没提交，即事务队列中的命令没执行的话，该事务对数据的改变不会在redis内存数据中体现出来，这样，别的事务就不会读到未提交的数据，即不可能出现脏读；</li><li>再考虑到redis的单线程出来模型，通过exec执行事务队列中多条命令时，不会存在其他redis命令的并发执行，这样的话，在redis事务中，天然解决了不可重复度问题。</li><li>同时，也由于redis的单线程模型，不存在多事务并发执行，所以，幻读问题在redis中也是不存在的。</li><li>所以说，如果要对接传统数据库事务隔离级别的话，redis实现了可序化的隔离级别。</li></ul><h3 id="27-3-相比传统数据库，redis的事务有什么不足的地方"><a href="#27-3-相比传统数据库，redis的事务有什么不足的地方" class="headerlink" title="27.3 相比传统数据库，redis的事务有什么不足的地方"></a>27.3 相比传统数据库，redis的事务有什么不足的地方</h3><ul><li><p>相比传统数据库，redis事务最大的不足，我觉得是不支持回滚；在传统数据库中，如果事务中途执行错误，是支持回滚的，在redis中，这个不支持。</p></li><li><p>redis不支持回滚，那么如果事务中途出现错误了会怎么样呢？</p><ul><li>这里有两种情况：第一种，命令入队时，如果redis命令格式错误，则会导致整个事务都不执行；第二种，如果执行命令时，其中某个命令出错，会继续执行完其他所有命令</li></ul></li><li><p>你怎么看待redis事务不支持回滚特性的？</p><ul><li>这里比较赞同redis作者的解析，redis作者认为，事务中途的错误都是由于开发者的编码错误造成的；而同时，没有任何机制能够避免程序员自己造成的错误，所以redis采用了简单、高效的无回滚事务处理机制。</li></ul></li></ul><h3 id="27-4-redis事务中，有类似传统数据库中的锁机制吗？"><a href="#27-4-redis事务中，有类似传统数据库中的锁机制吗？" class="headerlink" title="27.4 redis事务中，有类似传统数据库中的锁机制吗？"></a>27.4 redis事务中，有类似传统数据库中的锁机制吗？</h3><p>在redis事务中，通过watch实现了CAS式的乐观锁</p><h2 id="28-Redis生产问题"><a href="#28-Redis生产问题" class="headerlink" title="28. Redis生产问题"></a>28. Redis生产问题</h2><h3 id="28-1-缓存穿透"><a href="#28-1-缓存穿透" class="headerlink" title="28.1 缓存穿透"></a>28.1 缓存穿透</h3><ul><li>概念：当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/32.png"></p><ul><li><p>发生的情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul></li><li><p>解决方案：</p><ul><li>限制非法请求；</li><li>设置缓存空值或者默认值；</li><li>使用过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。</li></ul></li></ul><h3 id="28-2-缓存击穿"><a href="#28-2-缓存击穿" class="headerlink" title="28.2 缓存击穿"></a>28.2 缓存击穿</h3><ul><li>概念：如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/33.png"></p><ul><li>解决方案：<ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存</li><li>不给热点数据设置过期时间，由后台异步更新缓存。</li></ul></li></ul><h3 id="28-3-缓存雪崩"><a href="#28-3-缓存雪崩" class="headerlink" title="28.3 缓存雪崩"></a>28.3 缓存雪崩</h3><ul><li>概念：当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/34.png"></p><ul><li><p>发生原因：</p><ul><li>大量数据同时过期</li><li>Redis 故障宕机</li></ul></li><li><p>解决方案：</p><ul><li>大量数据同时过期<ul><li>均匀设置过期时间</li><li>互斥锁</li></ul></li><li>Redis 故障宕机<ul><li>服务熔断或请求限流机制；</li><li>构建 Redis 缓存高可靠集群；</li></ul></li></ul></li></ul><h2 id="31-主从同步"><a href="#31-主从同步" class="headerlink" title="31. 主从同步"></a>31. 主从同步</h2><h2 id="32-部署方式"><a href="#32-部署方式" class="headerlink" title="32. 部署方式"></a>32. 部署方式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是数据库-数据库管理系统-数据库系统-数据库管理员&quot;&gt;&lt;a href=&quot;#1-什么是数据库-数据库管理系统-数据库系统-数据库管理员&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</summary>
      
    
    
    
    <category term="面试" scheme="https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试-简历</title>
    <link href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%80%E5%8E%86/"/>
    <id>https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%80%E5%8E%86/</id>
    <published>2021-06-08T11:50:53.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1. JVM内存结构"></a>1. JVM内存结构</h2><h2 id="2-GC算法"><a href="#2-GC算法" class="headerlink" title="2. GC算法"></a>2. GC算法</h2><h2 id="3-对象创建过程"><a href="#3-对象创建过程" class="headerlink" title="3. 对象创建过程"></a>3. 对象创建过程</h2><h2 id="4-OOM问题排查"><a href="#4-OOM问题排查" class="headerlink" title="4. OOM问题排查"></a>4. OOM问题排查</h2><h2 id="5-IOC"><a href="#5-IOC" class="headerlink" title="5. IOC"></a>5. IOC</h2><h2 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6. AOP"></a>6. AOP</h2><h2 id="7-自动装配"><a href="#7-自动装配" class="headerlink" title="7. 自动装配"></a>7. 自动装配</h2><h2 id="8-优化SQL"><a href="#8-优化SQL" class="headerlink" title="8. 优化SQL"></a>8. 优化SQL</h2><h2 id="9-表结构设计"><a href="#9-表结构设计" class="headerlink" title="9. 表结构设计"></a>9. 表结构设计</h2><h2 id="10-分库分表"><a href="#10-分库分表" class="headerlink" title="10. 分库分表"></a>10. 分库分表</h2><h2 id="11-主从同步"><a href="#11-主从同步" class="headerlink" title="11. 主从同步"></a>11. 主从同步</h2><h2 id="12-持久化"><a href="#12-持久化" class="headerlink" title="12. 持久化"></a>12. 持久化</h2><h2 id="13-淘汰机制"><a href="#13-淘汰机制" class="headerlink" title="13. 淘汰机制"></a>13. 淘汰机制</h2><h2 id="14-kafka负载均衡"><a href="#14-kafka负载均衡" class="headerlink" title="14. kafka负载均衡"></a>14. kafka负载均衡</h2><h2 id="15-kafka消息可靠性保证"><a href="#15-kafka消息可靠性保证" class="headerlink" title="15. kafka消息可靠性保证"></a>15. kafka消息可靠性保证</h2><h2 id="16-leader选举"><a href="#16-leader选举" class="headerlink" title="16. leader选举"></a>16. leader选举</h2><h2 id="17-分区分配策略"><a href="#17-分区分配策略" class="headerlink" title="17. 分区分配策略"></a>17. 分区分配策略</h2><h2 id="18-三握四挥"><a href="#18-三握四挥" class="headerlink" title="18. 三握四挥"></a>18. 三握四挥</h2><ul><li>概念：三次握手和四次挥手是TCP协议中用来建立和终止TCP连接的过程。</li><li>三次握手：是建立一个TCP连接的过程，需要三个步骤：<ul><li>客户端发送连接请求报文段，</li><li>服务器收到请求并发送确认报文段，</li><li>客户端收到确认并发送确认报文段。</li></ul></li><li>四次挥手是终止一个TCP连接的过程，需要四个步骤：<ul><li>客户端发送终止请求报文段，</li><li>服务器收到请求并发送确认报文段，</li><li>客户端收到确认并发送确认报文段，</li><li>服务器收到确认并终止连接。</li></ul></li></ul><h2 id="19-滑动窗口"><a href="#19-滑动窗口" class="headerlink" title="19. 滑动窗口"></a>19. 滑动窗口</h2><ul><li>概念：滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量。</li></ul><h2 id="20-粘包"><a href="#20-粘包" class="headerlink" title="20. 粘包"></a>20. 粘包</h2><ul><li>什么是TCP粘包问题：<ul><li>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</li></ul></li></ul><h2 id="21-项目"><a href="#21-项目" class="headerlink" title="21. 项目"></a>21. 项目</h2><h3 id="21-1-自我介绍"><a href="#21-1-自我介绍" class="headerlink" title="21.1 自我介绍"></a>21.1 自我介绍</h3><h3 id="21-2-仓库管理系统"><a href="#21-2-仓库管理系统" class="headerlink" title="21.2 仓库管理系统"></a>21.2 仓库管理系统</h3><ul><li><p>背景：</p><ul><li>首先我本科的时候在学校的慈善助学超市当过志愿者，这个超市是由省慈善总会拨款资助的，里面的工作人员都是学生担任。</li><li>我在里面当志愿者的时候发现他们记录购买和分发的生活用品都是使用纸质的本子记录，效率很低，同时容易出现数量对不上的问题。所以我就和同学组队一起做了一个仓库管理系统，希望能够提高助学超市的商品的管理效率。</li></ul></li><li><p>项目开发：</p><ul><li>在这个项目里，我们使用maven来进行依赖控制，使用git进行版本控制，用jira来管理任务和bug。</li><li>我使用junit编写单元测试，根据真实的业务数据来编写案例，而且在编写代码时，我会非常注意编码规范，比如定义变量时会让人一看就理解 ，在关键代码地方多写注释，在if等条件里不会写太复杂，一个方法不会写太长。而且，一旦遇到我的bug，我会第一时间跟进，并会和相关对应的人一起解决掉。</li></ul></li><li><p>技术：</p><ul><li>我们这个项目用到了SpringBoot框架，</li><li>其中用DataSource连接MySQL数据库，</li><li>在控制层里用到了@RequestMapping注解来编写业务处理方法。</li><li>在业务代码里，使用@Autowired注解来以IOC的方式引入类，还用到了@Service和@Component注解。</li><li>当我们从数据库里拿到数据后，会用包含@Entity和@Table注解的模型类来映射数据。</li><li>在这个项目里，我们还用到了@Transactional注解来定义事务，这个注解是作用在Service层上的，</li><li>在这个项目里，我们还用到多个Java集合类和异常处理类。</li></ul></li><li><p>应背八股文：</p><ul><li>1 @Service和@Component注解的差别？</li><li>2 各种Restful请求格式以及各种http请求返回码。</li><li>3 @Transactional事务里的事务隔离级别和事务传播机制概念。</li><li>4 Spring依赖注入概念和@Autowired的用法。</li><li>5 Spring Bean的生命周期。</li><li>6 甚至可能还会问Spring Boot启动流程以及底层源码。</li></ul></li><li><p>内存调优：</p><ul><li>在本项目里，我会非常注意内存的使用性能，并在项目里有过排查分析OOM的项目经验，我在编码的时候，也会非常注意内存性能，同时我也了解过JVM内存结构以及GC算法。</li><li>OOM：<ul><li>先获取内存的 Dump 文件，配置 JVM 启动参数，当触发了 OOM 异常的时候自动生成，</li><li>然后使用 MAT 工具来分析 Dump 文件。</li></ul></li><li>内存性能：<ul><li>在写代码时，我会非常注意，在try…catch…finally里关闭Connection和大的集合，</li><li>一些大的对象用好以后，我会及时把它们设置成null，以此提升它们的回收时间，</li><li>在for等循环里，我不会频繁地操作String对象，因为会产生大量内存碎片。</li><li>同时，我会非常谨慎地使用finalize方法（事先看下），因为这可能会导致对象无法回收。</li><li>在数据同步的业务场景里，我用到了弱引用（或软引用），以此提升数据对象的回收时间。</li></ul></li></ul></li><li><p>应背八股文：</p><ul><li>JVM内存结构</li><li>GC（垃圾回收）流程</li></ul></li><li><p>数据库调优</p><ul><li>1 索引的数据结构（比如B+树），建索引的语句，索引的种类，尤其是复合索引以及对应的回表和最左匹配原则。</li><li>2 索引的正确用法，以及哪些情况下用不到索引，比如where a !&#x3D; ‘xx’可能就用不到。</li><li>3 索引的代价（会占硬盘，以及大批量读写时会重建索引，所以性能慢），以及在小表里，无需建索引。</li><li>4 执行计划的概念，以及通过执行计划排查慢sql时该注意的点（避免全表扫描，设置合理的关联表方式等）。</li><li>5 三范式和反范式相关概念，因为你提到了。</li><li>6 事务隔离级别里的脏读等概念，以及事务传播机制，尤其地，你要具体说出你项目里用的是哪个。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-JVM内存结构&quot;&gt;&lt;a href=&quot;#1-JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;1. JVM内存结构&quot;&gt;&lt;/a&gt;1. JVM内存结构&lt;/h2&gt;&lt;h2 id=&quot;2-GC算法&quot;&gt;&lt;a href=&quot;#2-GC算法&quot; class=&quot;he</summary>
      
    
    
    
    <category term="面试" scheme="https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo博客创建</title>
    <link href="https://wxzhou.top/2020/05/05/Github-Hexo%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/"/>
    <id>https://wxzhou.top/2020/05/05/Github-Hexo%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/</id>
    <published>2020-05-05T07:43:32.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：<br><a href="https://www.cnblogs.com/huanhao/p/hexobase.html">https://www.cnblogs.com/huanhao/p/hexobase.html</a></p><h2 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h2><h3 id="1-1-安装nodejs"><a href="#1-1-安装nodejs" class="headerlink" title="1.1 安装nodejs"></a>1.1 安装nodejs</h3><p>下载地址：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a><br>选择Windows安装包.msi<br>安装过程中’Add to PATH’然后点Next继续就行了</p><h3 id="1-2-安装Git"><a href="#1-2-安装Git" class="headerlink" title="1.2 安装Git"></a>1.2 安装Git</h3><p>下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p><h3 id="1-3-验证nodejs是否安装配置成功"><a href="#1-3-验证nodejs是否安装配置成功" class="headerlink" title="1.3 验证nodejs是否安装配置成功"></a>1.3 验证nodejs是否安装配置成功</h3><p>右键点击Git Bash Here，在里面执行下面命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果输出了版本号，证明配置成功，如果没有版本号，则检查是否成功配置环境变量</p><h3 id="1-4-安装cnpm"><a href="#1-4-安装cnpm" class="headerlink" title="1.4 安装cnpm"></a>1.4 安装cnpm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><h3 id="1-5-检查cnpm是否安装成功"><a href="#1-5-检查cnpm是否安装成功" class="headerlink" title="1.5 检查cnpm是否安装成功"></a>1.5 检查cnpm是否安装成功</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><h2 id="2-安装Hexo和初始化博客"><a href="#2-安装Hexo和初始化博客" class="headerlink" title="2. 安装Hexo和初始化博客"></a>2. 安装Hexo和初始化博客</h2><h3 id="2-1-安装Hexo"><a href="#2-1-安装Hexo" class="headerlink" title="2.1 安装Hexo"></a>2.1 安装Hexo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="2-2-初始化博客"><a href="#2-2-初始化博客" class="headerlink" title="2.2 初始化博客"></a>2.2 初始化博客</h3><p>选择一个文件夹，然后右键打开git bash<br>例如：在F盘新建了一个blog文件夹，就在blog文件夹下打开git bash<br>然后执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>到<code>Install dependencies</code>的时候你可能会卡住，这是大多数人基本都会遇到的</p><p>我们只需要在这里的时候结束命令，按<code>Ctrl + C</code>就可以结束命令</p><p>然后执行下面这个命令，就可以使用国内的镜像为你完成博客的初始化工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure><p>等待命令完成后，就完成了初始化，现在就可以预览我们的博客了</p><p>执行下面这个命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h2><h3 id="3-1-hexo的所有主题都在下面这个地址"><a href="#3-1-hexo的所有主题都在下面这个地址" class="headerlink" title="3.1 hexo的所有主题都在下面这个地址"></a>3.1 hexo的所有主题都在下面这个地址</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[https:<span class="comment">//hexo.io/themes/](https://hexo.io/themes/)</span></span><br></pre></td></tr></table></figure><h3 id="3-2-下载主题"><a href="#3-2-下载主题" class="headerlink" title="3.2 下载主题"></a>3.2 下载主题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 复制的地址 themes/主题名字</span><br></pre></td></tr></table></figure><h2 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h2><p>在博客的目录下有一个叫_config.yml的文件<br>找到themes这一行，然后将主题名字修改为模板名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: 模板名称</span><br></pre></td></tr></table></figure><h2 id="4-部署博客"><a href="#4-部署博客" class="headerlink" title="4. 部署博客"></a>4. 部署博客</h2><h3 id="4-1-创建密钥"><a href="#4-1-创建密钥" class="headerlink" title="4.1 创建密钥"></a>4.1 创建密钥</h3><p>创建一个git秘钥，打开git bash（不要求在哪个目录）<br>不管出现什么信息，你只需要回车就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “your_email<span class="meta">@youremail</span>.com“</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>会输出你的秘钥，我们复制输出信息就行了</p><p>在GitHub中点击头像，点击Settings –&gt; SSH····· –&gt; New SSH Key</p><h3 id="4-2-连接GitHub"><a href="#4-2-连接GitHub" class="headerlink" title="4.2 连接GitHub"></a>4.2 连接GitHub</h3><p>然后在git bash中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git<span class="meta">@github</span>.com</span><br></pre></td></tr></table></figure><p>在博客根目录下打开git bash执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-上传"><a href="#4-3-上传" class="headerlink" title="4.3 上传"></a>4.3 上传</h3><p>安装上传插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>在博客根目录下打开git bash，执行下面的命令就可以上传了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>新建文章</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="title class_">post</span> 文章标题</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章：&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/huanhao/p/hexobase.html&quot;&gt;https://www.cnblogs.com/huanhao/p/hexobase.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-准备阶段</summary>
      
    
    
    
    <category term="Blog" scheme="https://wxzhou.top/categories/Blog/"/>
    
    
    <category term="GitHub" scheme="https://wxzhou.top/tags/GitHub/"/>
    
    <category term="Hexo" scheme="https://wxzhou.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java-day01-Java入门</title>
    <link href="https://wxzhou.top/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/"/>
    <id>https://wxzhou.top/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-05T07:43:32.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-Java背景知识"><a href="#一、-Java背景知识" class="headerlink" title="一、 Java背景知识"></a>一、 Java背景知识</h2><p>在正式开干之前，我们先了解一下Java的背景知识，方便以后你在和大家聊Java的时候可以说到一块去。</p><h3 id="1-1-Java语言的历史"><a href="#1-1-Java语言的历史" class="headerlink" title="1.1 Java语言的历史"></a>1.1 Java语言的历史</h3><ul><li><p><strong>Java是哪家公司的产品？</strong></p><p>Java是美国Sun（Stanford University Network，斯坦福大学网络公司）公司在1995年推出的一门计算机<strong>高级编程语言</strong>。但是在2009年是Sun公司被Oracle（甲骨文）公司给收购了，所以目前Java语言是Oracle公司所有产品。</p></li><li><p><strong>Java名称的来历？</strong></p><p>早期这门语言的名字其实不叫Java，当时称为Oak（橡树的意思），为什么叫橡树呢？原因是因为Sun公司的门口种了很多橡树，但是后来由于商标注册时，Oak商标已经其他公司注册了，所以后面改名为Java了。那么有人好奇为什么叫Java呢？Java是印度的一个岛屿，上面盛产咖啡，可能是因为他们公司的程序员喜欢喝咖啡，所以就改名为Java了。</p></li><li><p><strong>Java的创始人是谁？</strong></p></li><li><p>说完Java名称的来历之后，接下来我们聊聊Java的祖师爷是谁？ Java的联合创始人有很多，但是行业普遍认可的Java的创始人 是<strong>詹姆斯●高斯林</strong>，被称为Java之父</p></li></ul><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660152660273.png" alt="1660152660273"></p><h3 id="1-2-Java能做什么"><a href="#1-2-Java能做什么" class="headerlink" title="1.2 Java能做什么"></a>1.2 Java能做什么</h3><p>了解了Java语言的历史之后，接下来，大家比较关心的问题可能是Java到底能做什么了？</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660141834075.png" alt="1660141834075"></p><p>其实Java能做的事情非常多，它可以做桌面应用的开发、企业互联网应用开发、移动应用开发、服务器系统开发、大数据开发、游戏开发等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>桌面应用开发：能够在电脑桌面运行的软件</span><br><span class="line">举例：财务管理软件、编写程序用的IDEA开发工具等，可以用Java语言开发</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>企业级应用开发：大型的互联网应用程序</span><br><span class="line">举例：淘宝、京东、大家每天都用的tlias教学管理系统等</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>移动应用开发：运行的Android手机端的软件</span><br><span class="line">举例：QQ客户端、抖音APP等</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>服务器系统：应用程序的后台（为客户端程序提供数据）</span><br><span class="line">举例：服务器系统为用户推荐那你喜爱的视频</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>大数据开发：大数据是一个互联网开发方向</span><br><span class="line">举例：目前最火的大数据开发平台是Hadoop，就是用Java语言开发的</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>游戏开发：游戏本质上是给用户提供娱乐的软件，有良好的交互感受</span><br><span class="line">举例：我的世界MineCraft就是用Java语言开发的</span><br></pre></td></tr></table></figure><p>虽然Java能做的事情非常多，但并不是每一个方向都被市场认可（比如桌面应用使用Java语言开发就不太方便，而使用C#语言是比较推荐的）。<strong>目前Java的主流开发方向是使用Java开发企业级互联网应用程序</strong>（很多公司的OA系统，客户关系管理系统，包括传智播客使用教学实施管理系统都是用Java语言开发的）</p><h3 id="1-3-Java的技术体系"><a href="#1-3-Java的技术体系" class="headerlink" title="1.3 Java的技术体系"></a>1.3 Java的技术体系</h3><p>说完Java语言能做什么之后，接下来我们再给同学们介绍一下Java的技术体系。所谓技术体系，就是Java为了满足不同的应用场景提供了不同的技术版本，主要有三个版本。</p><ul><li><p>Java SE（Java Standard Edition）：叫做标准版，它是后面两个版本的基础，也就是学习后面两个版本必须先学习JavaSE。<strong>我们基础班现阶段学习的就是这个版本中的技术</strong>。</p></li><li><p>Java EE（Java Enterprise Edition）: 叫做企业版，它是为企业级应用开发提供的一套解决方案。<strong>在后面就业班课程中主要学习这个版本中的技术</strong>。</p></li><li><p>Java ME（Java Micro Edition）：叫做小型版，它为开发移动设备的应用提供了一套解决方案。<strong>目前已经不被市场认可（淘汰），取而代之的是基于Android系统的应用开发</strong>。</p></li></ul><hr><p>Java语言的相关背景就给大家介绍到这里了，这些内容小伙伴们也不用刻意去记，简单了解一下就可以了。下面我们在简要回顾一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Java是什么？</span><br><span class="line">答：Java是一门高级编程语言</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Java是哪家公司的产品？</span><br><span class="line">答：Java以前是Sun公司的产品，现在Java是属于Oracle公司的产品</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>Java之父是谁？</span><br><span class="line">答：詹姆斯●高斯林</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Java主流的开发方向是什么？</span><br><span class="line">答：企业级互联网应用开发</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Java技术平台有哪些？</span><br><span class="line">答：JavaSE（标准版）、JavaEE（企业版）、JavaME（小型版）</span><br></pre></td></tr></table></figure><h2 id="二、-Java快速入门"><a href="#二、-Java快速入门" class="headerlink" title="二、 Java快速入门"></a>二、 Java快速入门</h2><p>上一章我们给小伙伴们介绍了Java的相关背景，你们现在是不是就想马上用一下Java呀？先不着急，我们得先得安装Java的开发环境，才能使用Java语言开发程序（ps: 就像你先需要安装微信，才能使用微信和朋友聊天是一样的）。</p><p>这里所说的Java开发环境，实际上就是Java官方提供的一个软件，叫做JDK（全称是Java Develop Kit），翻译过来意思就是Java开发工具包。<strong>我们先要到官网上去下载JDK，然后安装在自己的电脑上，才可以在自己的电脑上使用JDK来开发Java程序</strong></p><p>JDK的版本有很多，下图是JDK版本更新的历程图，有LTS标识的是长期支持版本（意思就是Oracle会不定期更新）。目前公司中用得最多的版本是JDK8版本，在目前这套课程中我们为了将一些新特性会使用JDK17版本。</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660143538211.png" alt="1660143538211"></p><p>下面已经给小伙伴们提供了详细的JDK下载和安装过程的截图，大家只需要按照步骤操作就行。</p><h3 id="2-1-JDK下载和安装"><a href="#2-1-JDK下载和安装" class="headerlink" title="2.1 JDK下载和安装"></a>2.1 JDK下载和安装</h3><ul><li><strong>JDK的下载</strong></li></ul><p>这是JDK下载的官方网址 <a href="https://www.oracle.com/java/technologies/downloads/%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8A%8A%E8%AF%A5%E7%BD%91%E5%9D%80%E5%A4%8D%E5%88%B6%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E6%A0%8F%EF%BC%8C%E6%95%B2%E5%9B%9E%E8%BD%A6">https://www.oracle.com/java/technologies/downloads/，你需要把该网址复制到浏览器的地址栏，敲回车</a></p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660527717279.png" alt="1660527717279"></p><p>进入网址后，选择JDK17版本，找到Windows标签，选择x64 Installer版本。如下图所示</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660527981411.png" alt="1660527981411"></p><p>下载完成之后，在你下载的目录下会出现一个JDK的安装包，如下图所示</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660528307458.png" alt="1660528307458"></p><p>到这JDK的下载就完成了，接下来就需要按照下面的步骤完成JDK安装.</p><ul><li><strong>JDK的安装</strong></li></ul><p>双击安装包，按照下图引导，点击下一步即可安装。<strong>需要注意的是安装JDK后不像你安装QQ一样会在桌面上显示一个图标，JDK安装后桌面上没有图标！！！</strong></p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660144855615.png" alt="1660144855615"></p><p><strong>如何验证安装成功了呢？</strong></p><p>刚才不是让你记住安装目录吗？你记住了吗？如果你自己修改过目录，就打开你自己修改的目录（呀！！忘记了o(╥﹏╥)o，那我帮不了你了，谁让你不认真听讲的）；如果没有修改安装目录，默认在<code>C:\Program Files\Java\jdk-17.0.3</code>目录下。</p><p>在文件资源管理器打开JDK的安装目录的bin目录，会发现有两个命令工具 <code>javac.exe</code> <code>java.exe</code> ，这就是JDK提供给我们使用的<strong>编译工具和运行工具</strong>，如下图所示</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660145259521.png" alt="1660145259521"></p><p>我们现在就使用一下 <code>javac.exe</code> <code>java.exe</code> 这两个工具，测试一下JDK是否可用</p><ol><li>第一步：在JDK的bin目录，地址栏输入cmd，回车</li></ol><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660529458474.png" alt="1660529458474"></p><p>输入完cmd回车后，会出现一个黑窗口，专业说法叫<strong>命令行窗口</strong></p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660529493477.png" alt="1660529493477"></p><ol start="2"><li><p>第二步：在命令行窗口中输入 <code>javac -version</code>回车，然后输入<code>java -version</code>回车</p><p>如果出现下面红色框框的提示正确版本号，和我们安装的JDK版本号一致，就说明JDK安装成功</p></li></ol><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660145482256.png" alt="1660145482256"></p><p>做完以上步骤之后，恭喜小伙伴^_^，你的电脑上就已经有Java的开发环境了，接下来可以开发Java程序了。</p><h3 id="2-2-cmd常见命令"><a href="#2-2-cmd常见命令" class="headerlink" title="2.2 cmd常见命令"></a>2.2 cmd常见命令</h3><p>前面测试JDK是否安装成功，需要在黑窗口中输入<code>javac -version</code>和<code>java -version</code> 这其实就是JDK查看编译工具和运行工具版本号的命令。</p><p>这种输入命令的和电脑交互的方式，称之为命令行交互。也就是说，可以使用命令指挥电脑做事情。接下来我们了解几种Windows系统常见的命令，后面可能会用到。</p><p>下面是Windows系统常见的命令以及作用，小伙伴们可以自己试一试。需要注意的是，每敲完一条命令之后，马上敲回车就表示执行这条命名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E:  <span class="comment">//切换到E盘</span></span><br><span class="line">cd [目录]        <span class="comment">//进入指定的目录</span></span><br><span class="line">cd ..         <span class="comment">//退回到上一级目录</span></span><br><span class="line">cd /         <span class="comment">//退回到根目录</span></span><br><span class="line">dir             <span class="comment">//显示当前目录下所有的内容</span></span><br><span class="line">cls             <span class="comment">//清空屏幕</span></span><br></pre></td></tr></table></figure><h3 id="2-3-Java入门程序"><a href="#2-3-Java入门程序" class="headerlink" title="2.3 Java入门程序"></a>2.3 Java入门程序</h3><p>上一节我们已经安装好了JDK，接下来，我们就正式开始开发第一个入门Java程序。按照国际惯例，学习任何一本编程语言第一个案例都叫做 <strong>Hello World</strong>，意思是向世界问好，从此开用程序和世界沟通的大门。</p><blockquote><p><strong>编写Java程序的步骤</strong></p></blockquote><p>编写一个Java程序需要经过3个步骤：<strong>编写代码，编译代码，运行代码</strong></p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660145843138.png" alt="1660145843138"></p><ul><li><input checked disabled type="checkbox"> 编写代码：任何一个文本编辑器都可以些代码，如Windows系统自带的记事本</li><li><input checked disabled type="checkbox"> 编译代码：将人能看懂的源代码（.java文件）转换为Java虚拟机能够执行的字节码文件（.class文件）</li><li><input checked disabled type="checkbox"> 运行代码：将字节码文件交给Java虚拟机执行</li></ul><hr><blockquote><p><strong>编写第一个Java入门程序</strong></p></blockquote><p>按照下面提供的步骤，一步一步的完成第一个Java入门程序的编写、编译和执行。</p><p><strong>第一步</strong>：新建一个后缀为.java的文本文件<code>HelloWorld.java</code>，用记事本编写代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot; HelloWorld &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：进入<code>HelloWorld.java</code>文件所在目录，在地址栏输入cmd回车，即可在此处打开命令行窗口。</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660146387184.png" alt="1660146387184"></p><p>编译：在命令行窗口输入编译命令<code>javac HelloWorld</code>完成编译，编译后会生成一个<code>HelloWorld.class</code>文件。</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660146644956.png" alt="1660146644956"></p><p><strong>第三步</strong>：再接着输入<code>java HelloWorld</code>就可以运行了，运行结果如下。</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660146816170.png" alt="1660146816170"></p><h3 id="2-4-Java程序中常见的问题"><a href="#2-4-Java程序中常见的问题" class="headerlink" title="2.4 Java程序中常见的问题"></a>2.4 Java程序中常见的问题</h3><p>刚才小伙伴们在编写第一个HelloWorld程序的时候，是不是很容易报错啊？ 我观察过第一次写代码，90%的同学都会有些小问题的，比如单词写错了！ 括号少写一个！等等！  我想给大家说的是，写错代码都是很正常的，<strong>一个什么错都犯过的程序员，才是真正的程序员</strong>。</p><p>下面我们把程序中常见的问题，总结一下。大家在写代码时注意一下这些问题就可以了</p><ul><li><input checked disabled type="checkbox"> Windows的文件扩展名没有勾选</li><li><input checked disabled type="checkbox"> 代码写了，但是忘记保存了</li><li><input checked disabled type="checkbox"> 文件名和类名不一致。</li><li><input checked disabled type="checkbox"> 英文大小写错误，单词拼写错误，存在中文符号，找不到main方法。</li><li><input checked disabled type="checkbox"> 括号不配对。</li><li><input checked disabled type="checkbox"> 编译或执行工具使用不当。</li></ul><hr><blockquote><ul><li><strong>文件扩展名没有打开</strong></li></ul></blockquote><p>下图中文件扩展名的勾勾没有勾选，就会导致你创建的文件是普通的文本文件（.txt）文件，而不是java文件。</p><p><strong>正确做法是把文件扩展名的勾选上</strong></p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660147216279.png" alt="1660147216279"></p><blockquote><ul><li><strong>文件名和类名不一致</strong></li></ul></blockquote><p>你看下图中，文件名是<code>HelloWorld</code>，但是类名是<code>Helloworld</code>看出区别了吗？一个是大写的W，一个是小写的w。 不仔细看还真看不出来。 </p><p>**正确写法是文件名叫<code>HelloWorld</code>，类名也叫<code>HelloWorld**</code></p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660531741851.png" alt="1660531741851"></p><blockquote><ul><li><strong>单词大小写错吴</strong></li></ul></blockquote><p>下图中不是string和system这两个单词都写错了， 这里是严格区分大小写的</p><p><strong>正确写法是String和System</strong></p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660531915677.png" alt="1660531915677"></p><blockquote><ul><li><strong>主方法写错了</strong></li></ul></blockquote><p>下图所示，主方法的名称写成了<code>mian</code>，这是错误的。</p><p>主方法正确写法：必须是<code> public static void main(String[] args)&#123;&#125;</code>，一个字母都不能错。</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660532147208.png" alt="1660532147208"></p><blockquote><ul><li><strong>标点符号写错了</strong></li></ul></blockquote><p>下图中打印语句最后的分号，写成功中文分号<code>；</code></p><p><strong>正确写法应该是英文分号</strong> <code>;</code>  不仔细看还真看不出区别，要小心</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660532298281.png" alt="1660532298281"></p><h3 id="2-5-JDK的组成"><a href="#2-5-JDK的组成" class="headerlink" title="2.5 JDK的组成"></a>2.5 JDK的组成</h3><p>在前几节课中我们已经安装了JDK，并且开发了一个Java入门程序，用javac命令编译，用Java命令运行，但是对于Java程序的执行原理并没有过多的介绍。 </p><p>下面我们把JDK的组成，以及跨平台原理给大家介绍一下，有利于同学们理解Java程序的执行过程。 </p><p>JDK由JVM、核心类库、开发工具组成，如下图所示</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660147531310.png" alt="1660147531310"></p><p>下面分别介绍一下JDK中每一个部分是用来干什么的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 什么是JVM?</span><br><span class="line">    答：JDK最核心的组成部分是JVM（Java Virtual Machine），它是Java虚拟机，真正运行Java程序的地方。</span><br><span class="line">    </span><br><span class="line">- 什么是核心类库？</span><br><span class="line">答：它是Java本身写好的一些程序，给程序员调用的。 Java程序员并不是凭空开始写代码，是要基于核心类库提供的一些基础代码，进行编程。</span><br><span class="line"></span><br><span class="line">- 什么是JRE?</span><br><span class="line">    答：JRE（Java Runtime Enviroment），意思是Java的运行环境；它是由JVM和核心类库组成的；如果你不是开发人员，只需要在电脑上安装JRE就可以运行Java程序。</span><br><span class="line">    </span><br><span class="line">- 什么是开发工具呢？</span><br><span class="line">答：Java程序员写好源代码之后，需要编译成字节码，这里会提供一个编译工具叫做javac.exe，编写好源代码之后，想要把class文件加载到内存中运行，这里需要用到运行工具java.exe。 </span><br><span class="line">除了编译工具和运行工具，还有一些其他的反编译工具、文档工具等待...</span><br></pre></td></tr></table></figure><p>JDK、JRE的关系用一句话总结就是：用JDK开发程序，交给JRE运行</p><h3 id="2-6-Java的跨平台原理"><a href="#2-6-Java的跨平台原理" class="headerlink" title="2.6 Java的跨平台原理"></a>2.6 Java的跨平台原理</h3><p>学完JDK的组成后，我们知道Java程序的执行是依赖于Java虚拟机的。就是因为有了Java虚拟机所以Java程序有一个重要的特性叫做跨平台性。</p><ul><li><p><strong>什么是跨平台行呢？</strong></p><p>所谓跨平台指的是用Java语言开发的程序可以在多种操作系统上运行，常见的操作系统有Windows、Linux、MacOS系统。</p><p>如果没有跨平台性，同一个应用程序，想要在多种操作系统上运行，需要针对各个操作系统单独开发应用。比如微信有Windows版本、MacOS版本、Android版本、IOS版本</p></li><li><p><strong>为什么Java程序可以跨平台呢？</strong></p><p>跨平台性的原理是因为在<strong>不同版本的操作系统</strong>中安装有<strong>不同版本的Java虚拟机</strong>，Java程序的运行只依赖于Java虚拟机，和操作系统并没有直接关系。<strong>从而做到一处编译，处处运行</strong>。</p></li></ul><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660147588001.png" alt="1660147588001"></p><h3 id="2-7-JDK环境变量配置"><a href="#2-7-JDK环境变量配置" class="headerlink" title="2.7 JDK环境变量配置"></a>2.7 JDK环境变量配置</h3><p>JDK安装后，接下我们来学习一个补充知识，叫做Path环境变量</p><ul><li><p><strong>什么是Path环境变量？</strong></p><p>Path环境变量是让系统程序的路径，方便程序员在命令行窗口的任意目录下启动程序；</p></li><li><p><strong>如何配置环境变量呢？</strong></p><p>比如把QQ的启动程序，配置到Path环境变量下就可以在任意目录下启动QQ，按照一下步骤操作。</p><p><strong>第一步：</strong>先找到QQ启动程序所在的目录<code>C:\Program Files (x86)\Tencent\QQ\Bin</code>，复制这个路径</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660538063180.png" alt="1660538063180"></p><p><strong>第二步：</strong>按照下面的步骤，找到Path环境变量。</p><p>首先找到此电脑，右键点击属性，可以按照下面的界面；点击【高级系统设置】，再点击【环境变量】</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660538424000.png" alt="1660538424000"></p><p>双击Path后，点击新建，把QQ启动目录粘贴进来，不要忘记点确定哦^_^</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660538760744.png" alt="1660538760744"></p><p><strong>第三步：</strong>配置好之后，检查是否配置成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Win+R 输入cmd回车，打开命令行窗口</span><br><span class="line"><span class="number">2.</span>输入QQScLanucher，可以看到QQ启动了</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660539146158.png" alt="1660539146158"></p><hr><ul><li><p><strong>将JDK配置到Path路径下</strong></p><p>上面我们配置了QQ的启动目录到Path环境变量位置，那么接下来，我们把JDK的bin目录配置到Path环境变量下，这样就可以在任意目录下启动javac和java命令来完成编译和运行了。</p><p><strong>第一步：</strong>找到JDK的bin目录<code>C:\Program Files\Java\jdk-17.0.3\bin</code>，复制一下</p><p><strong>第二步：</strong>将JDK的bin目录粘贴在Path环境变量后面</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660539632325.png" alt="1660539632325"></p><p><strong>第三步：检测否配置成功</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>按住Win+R输入cmd 回车，打开命令行创建</span><br><span class="line"><span class="number">2.</span>输入javac -version 看提示信息是否显示你安装JDK的版本号</span><br><span class="line">  输入java -version 看提示信息是否显示你安装JDK的版本号</span><br><span class="line">【如果显示版本号都是JDK17就表示配置安装成功】</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660539955302.png" alt="1660539955302"></p></li></ul><p>你如果按照前面的操作到这里，就说明JDK环境变量已经配置好了，后面使用JDK命令可以在任意目录下运行。</p><h2 id="三、Java开发工具"><a href="#三、Java开发工具" class="headerlink" title="三、Java开发工具"></a>三、Java开发工具</h2><p>大家刚才写代码的时候都是用记事本写的，但是有没有觉得记事本写代码不太方便啊！记事本写代码单词写错了没有提示，格式也不好调整，写代码之后还需要我们到命令行使用javac命令手动编译，然后运行。</p><p>有没有一种软件能够将写代码、编译、运行等工具集成到一起呢？ 有，这就是集成开发环境（Integrated Development Environment ，简称IDE）。除此之外，IDEA还有代码提示、检查代码错误等功能，从而提高程序员的开发效率。</p><p>IDE有很多种，常见的Eclipse、MyEclipse、Intellij IDEA、JBuilder、NetBeans等。但是这些IDE中目前比较火的是Intellij IDEA（以下简称IDEA），被众多Java程序员视为最好用的Java集成开发环境，所以我们课程中就以IDEA为开发工具来编写代码，以后大家去公司也建议用IDEA作为开发环境。</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660150643893.png" alt="1660150643893"></p><h3 id="3-1-IDEA下载和安装"><a href="#3-1-IDEA下载和安装" class="headerlink" title="3.1 IDEA下载和安装"></a>3.1 IDEA下载和安装</h3><p>为了引导大家正确的完成IDEA的下载和安装，给小伙伴们单独提供了一个文档《IDEA安装、使用、配置.pdf》，文档中提供了IDEA详细的安装和使用步骤，大家只需要按照文档的步骤一步一步操作就行。</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660541810799.png" alt="1660541810799"></p><h3 id="3-2-IDEA编写Java程序"><a href="#3-2-IDEA编写Java程序" class="headerlink" title="3.2 IDEA编写Java程序"></a>3.2 IDEA编写Java程序</h3><p>上一节我们安装好了IDEA之后，接下来我们就可以使用IDEA开发一个HelloWorld程序玩一玩！目的是让大家知道在IDEA中开发Java程序的步骤。</p><p>想要在IDEA正确的写一个Java程序，必须先认识一下IDEA的管理Java程序的工程结构。</p><ul><li>第一步：首先得在IDEA中创建一个Project（工程、也叫项目），后面统称为工程。</li><li>第二步：需要在Project中创建Module（模块），一个工程中可以包含多个模块</li><li>第三步：需要在Module中新建Package（包），一个模块中可以有多个包</li><li>第四步：需要在Package中新建Class（类），一个包中可以包含多个类</li></ul><p>软件工程其实类似于建筑工程，我们对比建筑工程来理解。</p><ul><li>Project（工程）：你可以理解成小区的院子</li><li>Module（模块）：你可以理解成小区院子里面的每一栋楼</li><li>Package（包）：你可以理解成每一栋楼的一层</li><li>Class（类）：你可以理解成每一层的住户</li></ul><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660542739892.png" alt="1660542739892"></p><p>在实际开发中比如淘宝网站这样的工程，但是由于功能很多，所以就把淘宝网站分为不同的模块，首页是一个模块、购物车是一个模块、订单也是一个模块；</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660543086870.png" alt="1660543086870"></p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660544338418.png" alt="1660544338418"></p><ul><li><p><strong>创建工程Project</strong></p><p>创建工程的步骤比较多，在《IDEA安装、使用、配置.pdf》中提供的详细的引导步骤，照着一步一步的操作就行。</p><p>用浏览器打开《IDEA安装、使用、配置.pdf》点击左侧的导航栏可以定位到对应的位置，每一个部分都有截图步骤</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660544715195.png" alt="1660544715195"></p></li></ul><h3 id="3-4-IDEA各种配置"><a href="#3-4-IDEA各种配置" class="headerlink" title="3.4 IDEA各种配置"></a>3.4 IDEA各种配置</h3><p>刚才有同学在使用IDEA编写程序时，可能会觉得字体比较小，背景色是黑色的，注释是灰色的，看不清，长时间可能对眼睛不好。我们可以通过IDEA相关的设置，把字体调大一点，背景色调为护眼色，注释也调为绿色。</p><ul><li><strong>主题配置</strong></li></ul><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660150404720.png" alt="1660150404720"></p><ul><li><strong>字体配置</strong></li></ul><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660150433205.png" alt="1660150433205"></p><ul><li><strong>背景色配置</strong></li></ul><p>把背景色的颜色值，调为204、238、200；就是豆沙绿的护眼色了</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660545292279.png" alt="1660545292279"></p><p>更多配置，大家可以参考《IDEA安装、使用、配置.pdf》</p><h3 id="3-5-常用快捷键"><a href="#3-5-常用快捷键" class="headerlink" title="3.5 常用快捷键"></a>3.5 常用快捷键</h3><p>讲完IDEA相关配置之后，接下来给大家讲一个很重要的IDEA的使用技巧，这就是IDEA的快捷键，所谓快捷键就是通过键盘上的按键组合起来，就可以帮我们生成代码。使用快捷键可以大大提高我们的开发效率。</p><p>下面是几种常见的快捷键，以及他们的作用，大家可以自己试试</p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>功能效果</strong></th></tr></thead><tbody><tr><td>main&#x2F;psvm、sout、…</td><td>快速键入相关代码</td></tr><tr><td>Ctrl + D</td><td>复制当前行数据到下一行</td></tr><tr><td>Ctrl + Y</td><td>删除所在行，建议用Ctrl + X</td></tr><tr><td>Ctrl + ALT + L</td><td>格式化代码</td></tr><tr><td>ALT + SHIFT + ↑ , ALT + SHIFT + ↓</td><td>上下移动当前代码</td></tr><tr><td>Ctrl + &#x2F; , Ctrl + Shift + &#x2F;</td><td>对代码进行注释(讲注释的时候再说)</td></tr></tbody></table><p>快捷键其实有很多，这里列举的是现阶段我们用得比较多的，现在记住不也不要紧，以后经常用，用着用着就记住了。</p><p>在后面的课程中讲到一些新的知识点时，还有会继续给大家讲一些新的快捷键。</p><h2 id="四-Java基础语法"><a href="#四-Java基础语法" class="headerlink" title="四. Java基础语法"></a>四. Java基础语法</h2><p>前面讲到的所有内容，都是为Java程序开发做一些准备工作，我们还没有正式教大家如何编写代码。</p><p>想要编写Java代码，就必须学习Java的语法，学习语法最主要做到下面两点就可以了</p><ul><li>记住语法格式</li><li>明确这种语法格式能达到什么效果</li></ul><p>这里需要给大家说明一点：语法格式是Java语言的设计者规定好的，我们不用关心它为什么这么写，因为它造出来就是这么写的。</p><h3 id="4-1-注释"><a href="#4-1-注释" class="headerlink" title="4.1 注释"></a>4.1 注释</h3><p>我们先从最简单的语法开始学习，先来学习注释！</p><ul><li><p>什么是注释？</p><p>注释是解释说明程序的问题，方便自己和别人阅读代码</p></li><li><p>注释有哪几种？格式怎样？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>单行注释：</span><br><span class="line"><span class="comment">//后面根解释文字</span></span><br><span class="line"><span class="number">2.</span>多行注释</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里写注释文字</span></span><br><span class="line"><span class="comment">    可以写多行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="number">3.</span>文档注释</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    这里写文档注释</span></span><br><span class="line"><span class="comment">    也可以写多行，文档注释可以利用JDK的工具生成帮助文档</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure></li><li><p>下面用注释解释一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">目标：学会使用注释</span></span><br><span class="line"><span class="comment">     这是程序的讲解注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoteDemo</span>&#123;</span><br><span class="line">    <span class="comment">//这是程序的主方法，是程序的入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我开始学习Java程序，好嗨皮~~&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        窗前明月光</span></span><br><span class="line"><span class="comment">        疑是地上霜</span></span><br><span class="line"><span class="comment">        举头望明月</span></span><br><span class="line"><span class="comment">        低头思故乡</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;播仔&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;deli&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>再多学一招：每次手动加注释比较麻烦，也可以使用快捷键加注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + / 单行注释（对当前行进行注释）</span><br><span class="line">Ctrl + Shift + / 对选中的代码进行多行注释。</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660546999747.png" alt="1660546999747"></p><h3 id="4-2-字面量"><a href="#4-2-字面量" class="headerlink" title="4.2 字面量"></a>4.2 字面量</h3><p>学习完注释之后，我们来学习一个全新的知识点叫字面量。</p><ul><li><p>什么是字面量？</p><p>大家不要被这个词搞晕了，它其实很简单，我们知道计算机是来处理数据的，字面量其实就是告诉程序员数据在程序中的书写格式。下面是常用的数据在程序中的书写格式</p></li></ul><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660150925625.png" alt="1660150925625"></p><ul><li>编写程序，在命令行打印输出各种类型的字面值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目标：需要同学们掌握常见数据在程序中的书写格式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiteralDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.整数</span></span><br><span class="line">        System.out.println(<span class="number">666</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.小数</span></span><br><span class="line">        System.out.println(<span class="number">3.66</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.字符: 字符必须用单引号引起来</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&#x27;中&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&#x27; &#x27;</span>); <span class="comment">//空格也算字符</span></span><br><span class="line">        <span class="comment">//特殊字符：\t表示制表符 \n表示换行</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;\t&#x27;</span>); <span class="comment">//这相当于一个tab键，专业叫做制表符</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;\n&#x27;</span>); <span class="comment">//这是换行的意思</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.字符串：字符串是双引号引起来的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我爱你中国abc&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.布尔值：只有两个值true和false</span></span><br><span class="line">        System.out.println(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：对于字面量，大家只要能够正确写出各种数据就可以了</p><h3 id="4-3-变量"><a href="#4-3-变量" class="headerlink" title="4.3 变量"></a>4.3 变量</h3><p>学习完字面量之后，接下来我们再来学习变量。对于变量的学习路径如下所示</p><ol><li><p>先认识什么是变量？</p></li><li><p>学习为什么要用变量？</p></li><li><p>学习变量有啥应用场景？</p></li></ol><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660548540262.png" alt="1660548540262"></p><ul><li><strong>什么是变量？</strong></li></ul><p>变量是用来记录程序中的数据的。其本质上是内存中的一块区域，你可以把这块区域理解成一个小盒子。</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660548847936.png" alt="1660548847936"></p><p>我们通过先通过一段代码演示一下，并解释变量的含义</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660151428759.png" alt="1660151428759"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><p>当执行<code>int age = 18;</code> 这句代码时，JVM会在内存中申请一块区域，在这个区域中存储了一个整数18，给这个区域取的名字叫age； 相当于在盒子中存了一个数据18，这个盒子的名字是age，当我们打印age时，就是从盒子中把盒子中的数据取出来再打印。</p><ul><li><strong>为什么要用变量呢？</strong></li></ul><p>使用变量来记录数据，对于数据的管理更为灵活。比如我们有多个地方用到一个整数10,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.假设4多个地方用到整数10; 现在我想把10改为20，这时你得一条语句一条语句的修改</span></span><br><span class="line">System.out.println(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.同样这里还是在多个地方用到整数10，你可以先用一个变量记录这个整数10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//然后在需要用到整数10的地方，用x代替就行；</span></span><br><span class="line"><span class="comment">//如果我们把x值改了，那么后面用到x的值的地方就都一起改变了</span></span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><ul><li><strong>变量有应用场景?</strong></li></ul><p>变量的应用场景无处不在，只要是程序中能发生变化的数据，都可以用变量存储。比如：你微信钱包中的余额，你微信的昵称，你微信的个性签名； 余额随着你花钱是不是在变少，昵称和个性签名也可以经常修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如：你现在有188.8元，一会要发100元，再收20元。</span></span><br><span class="line"><span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">188.8</span>;</span><br><span class="line"><span class="comment">//发100元</span></span><br><span class="line">money = money - <span class="number">100</span>;</span><br><span class="line"><span class="comment">//再收20元</span></span><br><span class="line">money = money + <span class="number">20</span>;</span><br><span class="line"><span class="comment">//再打印money记录的值是多少</span></span><br><span class="line">System.out.println(money);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//再比如：公交车大人2元，小孩一元，公交车经过2站</span></span><br><span class="line"><span class="comment">//第一站：3个大人1个小孩上车</span></span><br><span class="line"><span class="comment">//第二站：1个大人1个小孩上车，请问一共上了多少人，一共收入多少钱？</span></span><br><span class="line"><span class="comment">//刚开始公交车箱子里没有钱，用money2表示箱子里的钱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">money2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//刚开始公交车上也没有人，用count变量表示上车的人数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过两站的人数：第一站3人，第二站1人，总的人数是3+1</span></span><br><span class="line">count = <span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//经过两站的钱数：</span></span><br><span class="line">money2 = money2+<span class="number">3</span>*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//经过第一站后</span></span><br><span class="line">money2 = money2+<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//经过第二站后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印人数和钱数</span></span><br><span class="line">System.out.println(count);</span><br><span class="line">System.out.println(money);</span><br></pre></td></tr></table></figure><ul><li><strong>变量的注意事项</strong></li></ul><p>在上节课已经给大家讲了变量的基本使用，变量在实际开发中用得特别多，关于变量使用注意事项需要给大家交代一下。</p><p>讲这些注意事项目的是让大家知道，有哪些写法是允许，有哪些写法是不允许的，能分辨对错，并知道为什么错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>变量定义在哪个&#123;&#125;范围内，就只在哪个大括号内有效。变量的有效范围称之为变量的作用域</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a); <span class="comment">//这是是对的</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a); <span class="comment">//这里会出错</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>在同一个作用域内，不能有两个同名的变量</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">//这里会出错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>变量没有初始化只，不能直接使用</span><br><span class="line"><span class="type">int</span> a; <span class="comment">//仅仅定义了变量，但是没有初始值</span></span><br><span class="line">System.out.println(a); <span class="comment">//这里会出错</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>变量可以定义在同一行</span><br><span class="line">如：<span class="type">int</span> a=<span class="number">10</span>, b=<span class="number">20</span>; <span class="comment">//a和b都是int类型</span></span><br></pre></td></tr></table></figure><p>到此有关变量的所有使用方式，以及变量需要注意的问题，就学习完了。</p><p>我们再总结一下几点</p><ul><li>变量是用来记录程序中的数据的，可以把变量理解成内存中的小盒子，盒子里放的东西就是变量记录的数据</li><li>变量的定义格式： <code>数据类型 变量名 = 初始值;</code></li><li>变量记录的数据程序运行过程中是可以发生改变的：<code>变量名 = 值;</code></li></ul><hr><h3 id="4-4-关键字"><a href="#4-4-关键字" class="headerlink" title="4.4 关键字"></a>4.4 关键字</h3><p>学完变量之后，我们再来认识一下Java的关键字。</p><ul><li><p><strong>什么是关键字？</strong></p><p>关键字是java语言中有特殊含义的单词。比如用int表示整数，用double表示小数，等等！</p></li><li><p><strong>关键字有哪些？</strong></p><p>我们学习Java的语法其本质就是学习这些关键字的含义，一共有50多个关键字，我们不是一次性把这些关键字学完，会在后续的课程中每天学一点，慢慢得你就都学会了。</p></li></ul><table><thead><tr><th><strong>abstract</strong></th><th><strong>assert</strong></th><th><strong>boolean</strong></th><th><strong>break</strong></th><th><strong>byte</strong></th></tr></thead><tbody><tr><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>char</strong></td><td><strong>class</strong></td><td><strong>const</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>default</strong></td><td><strong>do</strong></td><td><strong>double</strong></td><td><strong>else</strong></td></tr><tr><td><strong>enum</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>finally</strong></td><td><strong>float</strong></td></tr><tr><td><strong>for</strong></td><td><strong>goto</strong></td><td><strong>if</strong></td><td><strong>implements</strong></td><td><strong>import</strong></td></tr><tr><td><strong>instanceof</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr><td><strong>new</strong></td><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td></tr><tr><td><strong>return</strong></td><td><strong>strictfp</strong></td><td><strong>short</strong></td><td><strong>static</strong></td><td><strong>super</strong></td></tr><tr><td><strong>switch</strong></td><td><strong>synchronized</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td></tr><tr><td><strong>transient</strong></td><td><strong>try</strong></td><td><strong>void</strong></td><td><strong>volatile</strong></td><td><strong>while</strong></td></tr></tbody></table><ul><li><strong>如何识别那些单词是关键字？</strong></li></ul><p>现在我们不用知道这些关键字是什么意思，主要能够根据特点识别那些是关键字就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键字的特点：</span><br><span class="line"><span class="number">1.</span>关键字都是小写的</span><br><span class="line"><span class="number">2.</span>关键字在idea中有特殊颜色标记（如果你没有修改关键字的颜色，默认是蓝色的）</span><br></pre></td></tr></table></figure><p>下图中红色框住的单词都是关键字；没有框住的单词都不是关键字</p><p><img src="/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/1660553031642.png" alt="1660553031642"></p><h3 id="4-5-标志符"><a href="#4-5-标志符" class="headerlink" title="4.5 标志符"></a>4.5 标志符</h3><p>接下来我们学习一下标志符，所谓标志符其实就是我们自己取的名字。像前面我们取的类名，变量名其实都是标志符。</p><p>讲标志符的目的，是让大家知道取名字的规则，不能让我们随即便瞎取。有些规则是强制要求的，不遵守就会报错。还有一些规则是我们建议大家遵守的，这样取名字显得我们更加专业^_^。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">强制要求：必须遵守，不遵守就会报错</span><br><span class="line"><span class="number">1.</span>最好是字母、数字、下划线、$组成</span><br><span class="line"><span class="number">2.</span>不能以数字开头</span><br><span class="line"><span class="number">3.</span>不能是Java的关键字</span><br><span class="line"></span><br><span class="line">建议遵守：按照下面的方式取名字会显得更加专业</span><br><span class="line"><span class="number">1.</span>所有的名字要见名知意，便于自己和别人阅读</span><br><span class="line">举例： <span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125; <span class="comment">//一看这个类就知道表示一个学生</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">10</span>;    <span class="comment">//一看这个变量就知道表示年龄</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>类名：首字母大写（大驼峰命名）</span><br><span class="line">举例： <span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>变量名：第二个单词开始首字母大写（小驼峰命名）</span><br><span class="line">举例： <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">6.88</span>;  </span><br><span class="line">  <span class="type">double</span> <span class="variable">applePrice</span> <span class="operator">=</span> <span class="number">7.5</span>; </span><br></pre></td></tr></table></figure><hr><p>到此，恭喜小伙伴们，今天所有的内容就学习完了，加油奥利给！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、-Java背景知识&quot;&gt;&lt;a href=&quot;#一、-Java背景知识&quot; class=&quot;headerlink&quot; title=&quot;一、 Java背景知识&quot;&gt;&lt;/a&gt;一、 Java背景知识&lt;/h2&gt;&lt;p&gt;在正式开干之前，我们先了解一下Java的背景知识，方便以后你在和大家</summary>
      
    
    
    
    <category term="Java" scheme="https://wxzhou.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wxzhou.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java-day03-Java流程控制</title>
    <link href="https://wxzhou.top/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://wxzhou.top/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-05-05T07:43:32.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>各位同学，今天我们学习一个全新的知识——程序流程控制。什么是流程控制呢？说白了就是控制程序的执行顺序。</p><p>先给同学们介绍一下，程序有哪些流程控制、以及Java提供了哪些方案来控制程序的执行顺序？</p><p>程序的流程控制一般分为3种：<strong>顺序结构、分支结构、循环结构</strong></p><ul><li><p>顺序结构：就是不加任何控制，代码从main方法开始自上而下执行</p></li><li><p>分支结构：就是根据条件判断是true还是false，有选择性的执行哪些代码。在Java语言中提供了两个格式if 、 switch</p></li><li><p>循环结构：就是控制某一段代码重复执行。在Java语言中提供了三种格式，for、while、do-while</p></li></ul><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661129154598.png" alt="1661129154598"></p><p>以上就是我们今天要学习的课程内容</p><h2 id="一、分支结构"><a href="#一、分支结构" class="headerlink" title="一、分支结构"></a>一、分支结构</h2><h3 id="1-1-if分支"><a href="#1-1-if分支" class="headerlink" title="1.1 if分支"></a>1.1 if分支</h3><p>各位同学，接下来我们学习分支结构的第一种形式——if分支。</p><p>if它的作用，是用于对条件进行判断，判断的结果只可能有两个值true或者false，然后根据条件判断的结果来决定执行那段代码。</p><p><strong>1. if分支的应用场景有哪些呢？</strong></p><p>比如，在火车站、地铁站等公共场所，会对过往的旅客测体温。如果体温在37度以内，就属于正常的；如果体温在37读以上，测体温的装置就会报警。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661130193692.png" alt="1661130193692"></p><p>再比如，你在使用微信付钱时，微信内部的程序会先判断你的余额是否足够，如果足够就可以支付成功；如果余额不足，就会提示支付失败。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661133550463.png" alt="1661133550463"></p><p><strong>2. if分支的格式</strong></p><p>接下来，我们来看一看if分支在Java语言中长什么样子呢？在Java中if分支有三种格式。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661131177976.png" alt="1661131177976"></p><p>接下来我们用一些实际案例给大家演示一下if语句的应用，以及每一种if语句的执行流程。</p><p><strong>3. if 第一种形式</strong></p><p>if 第一种形式的代码格式，和执行流程如下图所示</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661131910804.png" alt="1661131910804"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 第一种形式执行流程如下：</span><br><span class="line">    如果 条件表达式 为<span class="literal">true</span>，就执行下面的语句体</span><br><span class="line">    如果 条件表达式 为<span class="literal">false</span>,就不执行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：测量用户体温，发现体温高于37度就报警。</span></span><br><span class="line"><span class="type">double</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">36.9</span>;</span><br><span class="line"><span class="keyword">if</span>(t &gt; <span class="number">37</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这个人的温度异常，把他赶紧带走~~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. if 第二种形式</strong></p><p>if 第二种形式的代码格式，和执行流程如下图所示</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661132063147.png" alt="1661132063147"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 第二种形式执行流程如下：</span><br><span class="line">    如果 条件表达式 为<span class="literal">true</span>,就执行下面的语句体<span class="number">1</span></span><br><span class="line">    如果 条件表达式 为<span class="literal">false</span>,就执行<span class="keyword">else</span>下面的语句体<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求2：发红包，你的钱包余额是99元，现在要发出90元</span></span><br><span class="line"><span class="comment">// 如果钱够触发发红包的动作，如果钱不够，则提示：余额不足。</span></span><br><span class="line"><span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line"><span class="keyword">if</span>(money &gt;= <span class="number">90</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发红包成功了~&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;余额不足~~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. if 第三种形式</strong></p><p>if 第三种形式的代码格式，和执行流程如下图所示</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661132132708.png" alt="1661132132708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 第三种形式执行流程如下：</span><br><span class="line">    如果 条件表达式<span class="number">1</span> 为<span class="literal">true</span>,就执行下面的代码<span class="number">1</span>; </span><br><span class="line">    如果 条件表达式<span class="number">1</span> 为<span class="literal">false</span>，就继续判断条件表达式<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    如果 条件表达式<span class="number">2</span> 为<span class="literal">true</span>，就执行下面的语句体;</span><br><span class="line">    如果 条件表达式<span class="number">2</span> 为<span class="literal">false</span>，就继续判断条件语句体<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    如果 条件表达式<span class="number">3</span> 为<span class="literal">true</span>,就执行下面的语句体<span class="number">3</span></span><br><span class="line">    如果 条件表达式<span class="number">3</span> 为<span class="literal">false</span>,就继续判断后面的表达式;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    如果前面所有条件表达式判断都为<span class="literal">false</span>，就执行最后的<span class="keyword">else</span>语句中的代码</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求3：某个公司有一个绩效系统，根据员工的打分输出对应的绩效级别。[0,60) D  [60,80) C [80,90) B [90,100] A</span></span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">298</span>;</span><br><span class="line"><span class="keyword">if</span>(score &gt;= <span class="number">0</span> &amp;&amp; score &lt; <span class="number">60</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;您的绩效级别是： D&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">80</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;您的绩效级别是： C&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">90</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;您的绩效级别是： B&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;您的绩效级别是： A&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;您录入的分数有毛病~~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. if 使用的几个常见问题</strong></p><p>同学们在第一次写if 代码时，经常一不小心会出现一些问题。下面把同学们可能出现的问题给大家看一看，以后大家要避免出现这些问题。</p><ul><li>第1个问题：if的()后面不能写分号<code>;</code> 否则if下面的语句与if无关</li></ul><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661132888600.png" alt="1661132888600"></p><ul><li>第2个问题：if后面的大括号，如果只有一行代码，大括号可以省略</li></ul><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661132851560.png" alt="1661132851560"></p><p><strong>7. if 分支小结</strong></p><p>关于if分支结构的几种格式，以及各种格式的执行流程，还有if在什么场景下使用我们就讲完了。下面我们总结一下</p><ul><li><p>if分支有什么作用？举几个应用场景？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">if</span>作用：<span class="keyword">if</span>分支可以根据条件，选择执行某段程序</span><br><span class="line">- <span class="keyword">if</span>应用场景</span><br><span class="line">    比如<span class="number">1</span>：测量用户体温，发现体温高于<span class="number">37</span>度就报警</span><br><span class="line">    比如<span class="number">2</span>:发红包，你的钱包余额是<span class="number">99</span>元，现在要发出<span class="number">90</span>元</span><br><span class="line">    比如<span class="number">3</span>:根据员工的绩效打分输出对应的绩效级别</span><br></pre></td></tr></table></figure></li><li><p>if分支的格式有几种，执行流程是什么样的？</p></li></ul><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661133510341.png" alt="1661133510341"></p><hr><h3 id="1-2-switch分支"><a href="#1-2-switch分支" class="headerlink" title="1.2 switch分支"></a>1.2 switch分支</h3><p>学完if 分支之后，接下来我们来学习分支结构的第二种形式——switch分支。</p><p><strong>1. switch分支的执行流程</strong></p><p>switch 分支的作用，<strong>是通过比较值来决定执行哪条分支代码</strong>。先看一下switch分支的格式和执行流程</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661134120042.png" alt="1661134120042"></p><p>下面通过案例来演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求：做个电子备忘录，在控制台分别输出周一到周五的工作安排</span></span><br><span class="line"><span class="comment">    周一：埋头苦干，解决bug              </span></span><br><span class="line"><span class="comment">    周二：请求大牛程序员帮忙             </span></span><br><span class="line"><span class="comment">    周三：今晚啤酒、龙虾、小烧烤      </span></span><br><span class="line"><span class="comment">    周四：主动帮助新来的女程序解决bug</span></span><br><span class="line"><span class="comment">    周五：今晚吃鸡</span></span><br><span class="line"><span class="comment">    周六：与王婆介绍的小芳相亲</span></span><br><span class="line"><span class="comment">    周日：郁郁寡欢、准备上班。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">week</span> <span class="operator">=</span> <span class="string">&quot;周三&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (week)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;周一&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;埋头苦干，解决bug&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;周二&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;请求大牛程序员帮忙&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;周三&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;今晚啤酒、龙虾、小烧烤&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;周四&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;主动帮助新来的女程序解决bug&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;周五&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;今晚吃鸡&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;周六&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;与王婆介绍的小芳相亲&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;周日&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;郁郁寡欢、准备上班&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;您输入的星期信息不存在~~~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. if 、switch如何选择</strong></p><p>学习完switch 分支之后，有同学可能会想，已经了有if分支，为什么还有switch分支呢？感觉上面的案例用if分支也能做啊？  那我们在具体应用场景下如何选择呢？</p><p>如果单从功能上来讲，if 分支 的功能是更加强大的，switch分支能做的事情if 分支都能做。但是具体用哪一种分支形式，也是有一些使用原则的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 如果是对一个范围进行判断，建议使用<span class="keyword">if</span>分支结构</span><br><span class="line">- 如果是与一个一个的值比较的时候，建议使用<span class="keyword">switch</span>分支结构</span><br></pre></td></tr></table></figure><h3 id="1-3-switch-注意事项"><a href="#1-3-switch-注意事项" class="headerlink" title="1.3 switch 注意事项"></a>1.3 switch 注意事项</h3><p>各位同学，接下来我们学习swtich的注意事项。同学们掌握这些注意事项之后，就可以避免入坑了，也可以应对一些面试笔试题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- <span class="number">1.</span>表达式类型只能是<span class="type">byte</span>、<span class="type">short</span>、<span class="type">int</span>、<span class="type">char</span></span><br><span class="line">JDK5开始支持枚举，JDK7开始支持String</span><br><span class="line">不支持<span class="type">double</span>、<span class="type">float</span>、<span class="type">double</span></span><br><span class="line">    </span><br><span class="line">- <span class="number">2.</span><span class="keyword">case</span>给出的值不允许重复，且只能是字面量，不能是变量。</span><br><span class="line"></span><br><span class="line">- <span class="number">3.</span>正常使用<span class="keyword">switch</span>的时候，不要忘记写<span class="keyword">break</span>，否则会出现穿透现象。</span><br></pre></td></tr></table></figure><p><strong>1. 演示switch语句匹配的数据类型</strong></p><p>各位同学，如果下图所示，可以自己分别用变量a、b放在switch语句中匹配试一试，如果遇到不支持的写法，IDEA会报错的。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661135813464.png" alt="1661135813464"></p><p><strong>2. 演示case后面的值，只能是字面量不能是变量</strong></p><p>各位同学，也可以自己试试，下图箭头指向的位置只能写字面量，不能写变量</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661136001680.png" alt="1661136001680"></p><p><strong>3. 演示case穿透现象</strong></p><p>当switch语句中没有遇到break，就会直接穿透到下一个case语句执行，直到遇到break为止。</p><p>这种语法设计也是有它的用处的，当多个case语句想要执行同一段代码时，可以利用case穿透现象，提高代码复用性。</p><p>比如：我们下面程序中，想要让周二、周三、周四，都请大牛程序员来写代码。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661136414587.png" alt="1661136414587"></p><h2 id="二、循环结构"><a href="#二、循环结构" class="headerlink" title="二、循环结构"></a>二、循环结构</h2><p>各位同学，接下来我们学习循环结构。循环结构可以控制一段代码重复执行。循环结构有for循环、while循环、do-while循环。</p><h3 id="2-1-for循环——格式和流程"><a href="#2-1-for循环——格式和流程" class="headerlink" title="2.1 for循环——格式和流程"></a>2.1 for循环——格式和流程</h3><p>这里首先来学习for循环，同学们重点掌握for循环的书写格式，并理解for循环的执行流程。</p><p><strong>1. for循环的格式和流程</strong></p><p>为了让大家更直观的理解for循环的执行流程，我们直接来看具体的案例代码。</p><p>比如：我们想要在控制台打印输出3个HelloWorld</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：打印3行Hello World</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，是按照下面的① ② ③ ④， ② ③ ④… 的顺序来执行的；</p><p>当②条件为true时，再依次执行③④代码，然后回到②继续判断</p><p>当②条件为false时，就结束循环</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661137599188.png" alt="1661137599188"></p><p>具体执行的每一步可以看下面的图解</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661138616082.png" alt="1661138616082"></p><p>通过上面的案例演示，最后我们再总结一下for循环的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环格式：</span></span><br><span class="line"><span class="keyword">for</span> (初始化语句; 循环条件; 迭代语句) &#123;</span><br><span class="line">    循环体语句(重复执行的代码);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">初始化语句：一般是定义一个变量，并给初始值</span><br><span class="line">循环条件：一般是一个关系表达式，结果必须是<span class="literal">true</span>或者<span class="literal">false</span></span><br><span class="line">迭代语句：用于对条件进行控制，一般是自增或者自减</span><br><span class="line">循环语句体：需要重复执行的代码</span><br></pre></td></tr></table></figure><p><strong>2. for循环有哪些应用场景</strong></p><p>通过上面的学习，我们已经知道了for循环怎么编写，并且也知道了它的执行流程。</p><p>那么具体在哪些实际场景下使用呢？<strong>其实只要是重复做的事情，都可以用循环语句来做</strong></p><p>比如：在京东的网页上展示100台手机信息，我们只需要把展示数据的代码写一份，重复执行就可以了。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661139301013.png" alt="1661139301013"></p><p>再比如：再我们教学管理系统中，有很多班级需要展示在页面上，我们没必要每一个班级都写一份展示数据代码，只需要写一份重复执行就可以了。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661139453144.png" alt="1661139453144"></p><h3 id="2-2-for循环案例1——求和"><a href="#2-2-for循环案例1——求和" class="headerlink" title="2.2 for循环案例1——求和"></a>2.2 for循环案例1——求和</h3><p>学完for循环的格式和流程之后，我们再通过案例来巩固一下。通过这个案例，主要是让同学们掌握一种使用程序来求和的思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.掌握使用for循环批量产生数据。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">求和的思路分析：</span><br><span class="line"><span class="number">1</span>)首先需要定义一个求和变量，一般命名为sum</span><br><span class="line"><span class="number">2</span>)再遍历得到所有需要求和的数据(<span class="number">1</span>~<span class="number">100</span>之间的所有整数)</span><br><span class="line"><span class="number">3</span>)让需要求和的数据和sum累加，</span><br><span class="line">结果：所有数据累加完之后最终sum就是所有数据的和</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.需求：求1~100中所有整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义一个循环，先产生1-100，这100个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//每产生一个数据，就把这个数和sum累加</span></span><br><span class="line">    sum += i; <span class="comment">//sum = sum  + i;</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;1-100的数据和：&quot;</span> +  sum);</span><br></pre></td></tr></table></figure><p>分析上面代码的执行过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>时：sum=<span class="number">0</span>+<span class="number">1</span>; sum=<span class="number">1</span>;</span><br><span class="line">i=<span class="number">2</span>时：sum=<span class="number">1</span>+<span class="number">2</span>; sum=<span class="number">3</span>;</span><br><span class="line">i=<span class="number">3</span>时：sum=<span class="number">3</span>+<span class="number">3</span>; sum=<span class="number">6</span>;</span><br><span class="line">i=<span class="number">4</span>时：sum=<span class="number">6</span>+<span class="number">4</span>; sum=<span class="number">10</span>;</span><br><span class="line">...</span><br><span class="line">i=<span class="number">100</span>时: sum+=<span class="number">99</span>; sum=<span class="number">5050</span></span><br></pre></td></tr></table></figure><h3 id="2-2-for循环案例2——求奇数和"><a href="#2-2-for循环案例2——求奇数和" class="headerlink" title="2.2 for循环案例2——求奇数和"></a>2.2 for循环案例2——求奇数和</h3><p>需求：求1~100之间奇数的和</p><p><strong>1.  代码写法一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">求奇数和的思路（只是求和的数据变成了奇数，思路和前面没有变化）</span><br><span class="line"><span class="number">1</span>)首先需要定义一个求和变量，这里命名为sum1</span><br><span class="line"><span class="number">2</span>)再遍历得到所有需要求和的数据(<span class="number">1</span>~<span class="number">100</span>之间的所有奇数)</span><br><span class="line"><span class="number">3</span>)让需要求和的数据和sum1累加，</span><br><span class="line">结果：所有数据累加完之后最终sum1就是所有数据的和</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1)定义一个变量用于求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//2)定义一个循环产生1-100之间的奇数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// i = 1 3 5 7 ...</span></span><br><span class="line">    <span class="comment">//3)让需要求和的数据和sum1累加，</span></span><br><span class="line">    sum1 += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;1-100之间的奇数和：&quot;</span> +  sum1);</span><br></pre></td></tr></table></figure><p>以上代码的执行流程分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化sum1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">当i=<span class="number">1</span>时：sum1+=<span class="number">1</span>; sum1=<span class="number">1</span>;</span><br><span class="line">当i=<span class="number">3</span>时：sum1+=<span class="number">3</span>; sum1=<span class="number">4</span>;</span><br><span class="line">当i=<span class="number">5</span>时：sum1+=<span class="number">5</span>; sum1=<span class="number">9</span>;</span><br><span class="line">...</span><br><span class="line">当i=<span class="number">99</span>时：sum1+=<span class="number">99</span>; sum1=<span class="number">2500</span></span><br></pre></td></tr></table></figure><p><strong>2. 代码写法二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">求奇数和的思路（只是求和的数据变成了奇数，思路和前面没有变化）</span><br><span class="line"><span class="number">1</span>)首先需要定义一个求和变量，这里命名为sum2</span><br><span class="line"><span class="number">2</span>)再遍历得到所有需要求和的数据(<span class="number">1</span>~<span class="number">100</span>之间的所有整数)</span><br><span class="line"><span class="number">3</span>)在求和之前先对数据判断，如果是奇数，才和sum1累加；否则什么也不干</span><br><span class="line">结果：所有数据累加完之后最终sum1就是所有数据的和</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1)首先需要定义一个求和变量，这里命名为sum2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="comment">//2)再遍历得到所有需要求和的数据(1~100之间的所有整数)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//i = 1 2 3 4 5 6 ... 99 100</span></span><br><span class="line">    <span class="comment">//3)在求和之前先对数据判断，如果是奇数，才和sum1累加；否则什么也不干</span></span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// i = 1 3 5 7 9 ... 99</span></span><br><span class="line">        sum2 += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;1-100之间的奇数和：&quot;</span> + sum2);</span><br></pre></td></tr></table></figure><p><strong>for循环小结</strong></p><p>今天关于for循环，我们学习这几个案例就够了，重点还是掌握for循环的执行流程。在以后，我们还会经常用到for循环，用多了，你就会越来越熟悉了。但是在具体场景下，还是需要具体问题具体分析。</p><hr><h3 id="2-3-while循环——格式和流程"><a href="#2-3-while循环——格式和流程" class="headerlink" title="2.3 while循环——格式和流程"></a>2.3 while循环——格式和流程</h3><p>各位同学，接下来我们学习第二种循环结构——while循环。</p><p>我们先来认识一下while循环长什么样子，然后按照格式写一个while循环的基础案例</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661141338265.png" alt="1661141338265"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：打印5行Hello World</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// i = 0 1 2 3 4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的执行流程如下图所示：按照①   ②③④  ②③④ … 的流程执行</p><p>如果②步骤为true，才循环执行③④步骤</p><p>如果②步骤为false，则循环结束</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661141996444.png" alt="1661141996444"></p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661141867092.png" alt="1661141867092"></p><p><strong>for、while如何选择</strong></p><p>学到这里，细心的同学可能会发现while循环和for循环的执行流程是一样的。那他们是不是可以通用呢？</p><ul><li><p>从功能来说：能够用for循环做的，都能用while循环做。</p></li><li><p>使用规范上来说：知道循环几次，建议使用for；不知道循环几次建议使用while</p></li></ul><h3 id="2-3-while循环案例——折纸案例"><a href="#2-3-while循环案例——折纸案例" class="headerlink" title="2.3 while循环案例——折纸案例"></a>2.3 while循环案例——折纸案例</h3><p>各位同学，上一节我们已经学习了while循环的基本使用。下面我们通过一个案例再将while循环的使用巩固一下，主要目的还是想让大家知道什么使用while循环来完成需求。</p><p>案例需求如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求：世界最高山峰珠穆朗玛峰高度是：<span class="number">8848.86</span>米=<span class="number">8848860</span>毫米，假如我有一张足够大的它的厚度是<span class="number">0.1</span>毫米。请问：该纸张折叠多少次，可以折成珠穆朗玛峰的高度？</span><br></pre></td></tr></table></figure><p>我们来分析一下该怎么做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">分析：首先由于不知道折叠多少次，我们可以选择用<span class="keyword">while</span>循环</span><br><span class="line"><span class="number">1</span>)纸张的初始化厚度为<span class="number">0.1</span>毫米，珠峰的高度为<span class="number">8848860</span>毫米</span><br><span class="line"><span class="type">double</span> <span class="variable">peakHeight</span> <span class="operator">=</span> <span class="number">8848860</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">paperThickness</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="number">2</span>)每次折叠纸张的厚度为原来的两倍，这是需要循环执行的</span><br><span class="line"><span class="keyword">while</span>(纸张厚度&lt;<span class="number">8848860</span>)&#123;</span><br><span class="line">纸张厚度*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>)需要求折叠的次数，可以用一个变量来记录折叠的次数</span><br><span class="line"><span class="type">int</span> 次数 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(纸张厚度&lt;<span class="number">8848860</span>)&#123;</span><br><span class="line">纸张厚度*=<span class="number">2</span>;</span><br><span class="line">            次数++; <span class="comment">//每次折叠次数累加</span></span><br><span class="line">&#125;</span><br><span class="line">结果：等循环结束之后，打印记录次数的值，就是折叠多少次了。</span><br></pre></td></tr></table></figure><p>按照上面分析的思路把代码写出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、定义变量记住珠穆朗玛峰的高度和纸张的高度。</span></span><br><span class="line"><span class="type">double</span> <span class="variable">peakHeight</span> <span class="operator">=</span> <span class="number">8848860</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">paperThickness</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、定义一个变量count用于记住纸张折叠了多少次</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义while循环控制纸张开始折叠</span></span><br><span class="line"><span class="keyword">while</span> (paperThickness &lt; peakHeight) &#123;</span><br><span class="line">    <span class="comment">// 把纸张进行折叠，把纸张的厚度变成原来的2倍。</span></span><br><span class="line">    paperThickness = paperThickness * <span class="number">2</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;需要折叠多少次：&quot;</span> + count);</span><br><span class="line">System.out.println(<span class="string">&quot;最终纸张的厚度是：&quot;</span> + paperThickness);</span><br></pre></td></tr></table></figure><h3 id="2-4-do-while循环——格式和流程"><a href="#2-4-do-while循环——格式和流程" class="headerlink" title="2.4 do-while循环——格式和流程"></a>2.4 do-while循环——格式和流程</h3><p>各位同学，接下来我们学习循环结构的第三种格式——do-while循环。</p><p>们先来认识一下while循环长什么样子，然后按照格式写一个while循环的基础案例。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661143715539.png" alt="1661143715539"></p><p>如下图所示：do-while循环的执行流程，是按照①  ②③④   ②③④… 的顺序执行的。</p><p>我们会发现，do-while循环的特点是先执行，再判断的。即使条件不成立，也会先执行一次。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661143856132.png" alt="1661143856132"></p><p><strong>下面我们把三种循环的区别给同学们总结一下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">for</span>循环 和 <span class="keyword">while</span>循环（先判断后执行）; </span><br><span class="line">   <span class="keyword">do</span>...<span class="keyword">while</span> （先执行后判断）</span><br><span class="line">   </span><br><span class="line"><span class="number">2.</span><span class="keyword">for</span>循环和<span class="keyword">while</span>循环的执行流程是一模一样的，</span><br><span class="line">功能上无区别，<span class="keyword">for</span>能做的<span class="keyword">while</span>也能做，反之亦然。</span><br><span class="line">如果已知循环次数建议使用<span class="keyword">for</span>循环，如果不清楚要循环多少次建议使用<span class="keyword">while</span>循环。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="keyword">for</span>循环中控制循环的变量只在循环中使用</span><br><span class="line">  <span class="keyword">while</span>循环中，控制循环的变量在循环后还可以继续使用</span><br></pre></td></tr></table></figure><h3 id="2-6-死循环"><a href="#2-6-死循环" class="headerlink" title="2.6 死循环"></a>2.6 死循环</h3><p>同学们在写代码时，可能一不小心把代码写成了死循环，所谓死循环就是停不下来的循环。</p><p>接下来，带着同学们认识几种死循环的写法。然后再说一下死循环有什么用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for死循环</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while死循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do-while死循环</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World3&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><strong>死循环有什么应用场景呢？</strong></p><p>最典型的是可以用死循环来做服务器程序， 比如百度的服务器程序就是一直在执行的，你随时都可以通过浏览器去访问百度。如果哪一天百度的服务器停止了运行，有就意味着所有的人都永不了百度提供的服务了。</p><p>对于这样的应用我们目前了解一下就可以了。对于目前来说我们只要知道代码格式该怎么写，能达到什么效果就行。</p><h3 id="2-8-循环嵌套"><a href="#2-8-循环嵌套" class="headerlink" title="2.8 循环嵌套"></a>2.8 循环嵌套</h3><p>各位同学，接下来我们学习一种在实际工作中很常用的循环形式——循环嵌套。</p><p>所谓循环嵌套，就是一个循环中又包含另一个循环（就是同学们常说的，套娃^_^），下面我们通过案例代码演示一下。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661145140910.png" alt="1661145140910"></p><p>循环嵌套执行流程：外部循环每循环一次，内部循环会全部执行完一轮。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span>时; i&lt;<span class="number">3</span>为<span class="literal">true</span>; 进入循环</span><br><span class="line"><span class="comment">//j的取值从0到5,执行一轮，打印5次&quot;我爱你&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我爱你：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    内层循环执行完之后，执行外层的i++; i的值<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">i=<span class="number">1</span>时：i&lt;<span class="number">3</span>为<span class="literal">true</span>; 进入循环</span><br><span class="line"><span class="comment">//j的取值从0到5,又执行一轮，打印5次&quot;我爱你&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我爱你：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    内层循环执行完之后，执行外层的i++; i的值<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">i=<span class="number">2</span>时：i&lt;<span class="number">3</span>为<span class="literal">true</span>; 进入循环</span><br><span class="line"><span class="comment">//j的取值从0到5,再执行一轮，打印5次&quot;我爱你&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我爱你：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    内层循环执行完之后，执行外层的i++; i的值<span class="number">3</span></span><br><span class="line">    </span><br><span class="line">i=<span class="number">3</span>时：i&lt;<span class="number">3</span>为<span class="literal">false</span>; 外层循环结束</span><br></pre></td></tr></table></figure><p>理解问循环嵌套的执行流程之后，我们再写一个案例来巩固一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需求：在控制台使用 * 打印出<span class="number">4</span>行<span class="number">5</span>列的矩形</span><br><span class="line">    ****</span><br><span class="line">    ****</span><br><span class="line">    ****</span><br><span class="line">    ****</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1)先写一个循环用来在一行中打印5个&quot;*&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;*&quot;</span>); <span class="comment">// 不换行</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(); <span class="comment">//换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2)再将第一步的代码套一层循环，执行4次，就可以打印4行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;*&quot;</span>); <span class="comment">// 不换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(); <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，对于嵌套循环重点理解这句话：<strong>外部循环每循环一次，内部循环会全部执行完一轮。</strong></p><h3 id="2-9-跳转语句-break-、continue"><a href="#2-9-跳转语句-break-、continue" class="headerlink" title="2.9 跳转语句 break 、continue"></a>2.9 跳转语句 break 、continue</h3><p>前面我们学习了循环结构，在中间我们还接触了死循环的一些形式，那么我想要在循环过程中提前跳出循环怎么做呢？</p><p>这里就需要用到跳转语句，需要用到<strong>break</strong>和<strong>continue</strong>两个关键字。我们先来认识一下这两个关键字的作用</p><ul><li>break作用：跳出并结束当前所在循环的执行</li><li>continue作用：结束本次循环，进入下一次循环</li></ul><p>案例1：演示break的使用，提前终止循环的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、break:跳出并结束当前所在循环的执行。</span></span><br><span class="line"><span class="comment">// 场景：假如你又有老婆了，你犯错了，你老婆罚你说：5句我爱你</span></span><br><span class="line"><span class="comment">// 说到第三句的时候心软了，让你别再说了。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我爱你：&quot;</span> + i);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明已经说完了第三句了，心软了。</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 跳出并结束当前所在循环的执行。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例2：演示continue的使用，结束循环中的一次，继续下一次循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、continue:跳出当前循环的当次执行，直接进入循环的下一次执行。</span></span><br><span class="line"><span class="comment">// 场景: 假如你有老婆，你犯错了，你老婆罚你洗碗5天。</span></span><br><span class="line"><span class="comment">// 第三天的时候，你表现很好，第三天不用洗碗，但是不解恨，第四天还是要继续的。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经到了第三天，第三天不用洗的。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;洗碗：&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<strong>break和continue不是任何地方都可以使用的</strong></p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661146324812.png" alt="1661146324812"></p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661146405314.png" alt="1661146405314"></p><hr><h3 id="2-10-循环结构总结"><a href="#2-10-循环结构总结" class="headerlink" title="2.10 循环结构总结"></a>2.10 循环结构总结</h3><p>到这里关于循环结构的所有内容就都已经学习完了，我们再把几种循环结构在什么场景下使用，再总结一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 什么是流程控制</span><br><span class="line">答：流程控制是用来控制程序的执行顺序的</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 分支结构<span class="keyword">if</span>和<span class="keyword">switch</span>，如何选择？</span><br><span class="line">答：<span class="keyword">if</span>分支：一般用于对一个范围进行判断</span><br><span class="line"><span class="keyword">switch</span>分支：对一个一个值进行匹配</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">for</span>循环和<span class="keyword">while</span>循环、<span class="keyword">do</span>-<span class="keyword">while</span>如何循环</span><br><span class="line">答：知道循环次数用<span class="keyword">for</span>、不知道循环次数用<span class="keyword">while</span></span><br><span class="line">   想要先执行，再判断，用<span class="keyword">do</span>-<span class="keyword">while</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、生成随机数"><a href="#三、生成随机数" class="headerlink" title="三、生成随机数"></a>三、生成随机数</h2><p>各位同学，接下来我们再学习一个新的知识——生成随机数。</p><p>生成随机数其实在很多场景下都很实用，比如，在课堂上可以写一个随机点名器点同学起来回答问题；再比如公司年会可以随机抽奖等。</p><h3 id="3-1-如何产生一个随机数"><a href="#3-1-如何产生一个随机数" class="headerlink" title="3.1 如何产生一个随机数"></a>3.1 如何产生一个随机数</h3><p>生成随机数的功能，其实 Java已经给我们提供了，在JDK中提供了一个类叫做Random，我们只需要调用Random这个类提供的功能就可以了。</p><p><img src="/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/1661147570538.png" alt="1661147570538"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标：掌握使用Random生成随机数的步骤。</span></span><br><span class="line"><span class="comment">// 1、导包。import java.util.Random; (idea会自动完成)</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 2、创建一个Random对象，用于生成随机数。</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 3、调用Random提供的功能：nextInt得到随机数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>); <span class="comment">// 0 - 9</span></span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-猜数字小游戏"><a href="#3-2-猜数字小游戏" class="headerlink" title="3.2 猜数字小游戏"></a>3.2 猜数字小游戏</h3><p>各位同学，接下来我们通过一个案例把前面的流程控制、跳转语句、随机数综合运用一下；</p><p>如果能把这个案例写出来，说明你对今天的知识点掌握得挺好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">需求：</span><br><span class="line">随机生成一个<span class="number">1</span>-<span class="number">100</span>之间的数据，提示用户猜测，猜大提示过大，猜小提示过小，直到猜中  结束游戏</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line"><span class="number">1.</span>先随机生成一个<span class="number">1</span>-<span class="number">100</span>之间的数据。</span><br><span class="line">谁可以帮你生成随机数啊？ 是不是要用到Random？</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>定义一个死循环让用户可以一直猜测。</span><br><span class="line">用户猜的数据从哪里来啊？ 是不是要用到Scanner?</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>在死循环里，每次让用户录入的数据和随机数进行比较</span><br><span class="line">如果比随机数大：提示猜大了</span><br><span class="line">如果比随机数小：提示猜小了</span><br><span class="line">如果和随机数相同：提示恭喜你猜中了</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、随机产生一个1-100之间的数据，做为中奖号码。</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">luckNumber</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个死循环，让用户不断的猜测数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 提示用户猜测</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您猜测的数据：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">guessNumber</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、判断用户猜测的数字与幸运号码的大小情况</span></span><br><span class="line">            <span class="keyword">if</span>(guessNumber &gt; luckNumber)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您猜测的数字过大~~&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(guessNumber &lt; luckNumber)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您猜测的数字过小~~&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;恭喜您，猜测成功了，可以买单了~~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 结束死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;各位同学，今天我们学习一个全新的知识——程序流程控制。什么是流程控制呢？说白了就是控制程序的执行顺序。&lt;/p&gt;
&lt;p&gt;先给同学们介绍一下，程序有哪些流程控制、以及Java提供了哪些方案来控制程序的执行顺序？&lt;/p&gt;
&lt;p&gt;程序的流程控制一般分为3种：&lt;strong&gt;顺序结构</summary>
      
    
    
    
    <category term="Java" scheme="https://wxzhou.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wxzhou.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java-day02-类型转换、运算符</title>
    <link href="https://wxzhou.top/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://wxzhou.top/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-05-05T07:43:32.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据的表示详解"><a href="#一、数据的表示详解" class="headerlink" title="一、数据的表示详解"></a>一、数据的表示详解</h2><p>昨天我们学习了变量，我们知道变量可以用来记录数据的。那么数据在计算机底层是以什么形式表示的呢？下面我们就学习一下数据在计算机中的底层原理。</p><h3 id="1-1-整数在计算机中的存储原理"><a href="#1-1-整数在计算机中的存储原理" class="headerlink" title="1.1 整数在计算机中的存储原理"></a>1.1 整数在计算机中的存储原理</h3><p>其实任何数据在计算机中都是以<strong>二进制</strong>表示的。那这里肯定有人问，什么是二进制啊？所谓二进制其实就是一种数据的表示形式，它的特点是逢2进1。</p><p>数据的表示形式除了二进制（逢2进1），八进制（逢8进1）、还有十进制（逢10进1）、十六进制（逢10进1）等。</p><p>对于二进制绝大多数同学，应该是非常陌生的。 没关系！来，大家跟着我的思路，你就知道二进制是怎么表示数据的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>二进制中只有<span class="number">0</span>和<span class="number">1</span>两个数</span><br><span class="line">首先十进制的<span class="number">0</span>和二进制的<span class="number">0</span>是一样的，十进制的<span class="number">1</span>和二进制的<span class="number">1</span>也是 一样的。但是十进制中  有<span class="number">2</span>，但是二进制中就没有<span class="number">2</span>了</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>那么二进制是如何表示十进制的<span class="number">2</span>呢？</span><br><span class="line"><span class="number">1</span></span><br><span class="line">+<span class="number">1</span></span><br><span class="line">——————————</span><br><span class="line">   <span class="number">10</span>  这里两个<span class="number">1</span>相加，结果为<span class="number">2</span>，由于二进制满<span class="number">2</span>进<span class="number">1</span>，所以最终结果<span class="number">10</span></span><br><span class="line">   </span><br><span class="line"><span class="number">3.</span>那么二进制是如何表示十进制的<span class="number">3</span>呢？</span><br><span class="line">前面我们已经知道二进制<span class="number">10</span>表示十进制的<span class="number">2</span>，那么二进制<span class="number">10</span>+<span class="number">1</span>就表示十进制的<span class="number">3</span>啊！</span><br><span class="line"><span class="number">10</span></span><br><span class="line">+    <span class="number">1</span></span><br><span class="line">—————————</span><br><span class="line">    <span class="number">11</span> 十进制的<span class="number">3</span>对应的二进制是<span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>那么二进制是如何表示十进制<span class="number">4</span>的呢？</span><br><span class="line">前面我们已经知道二进制<span class="number">11</span>表示十进制的<span class="number">4</span>，那么<span class="number">11</span>+<span class="number">1</span>就表示十进制的<span class="number">5</span>啊</span><br><span class="line"><span class="number">11</span></span><br><span class="line">+    <span class="number">1</span></span><br><span class="line">—————————</span><br><span class="line">   <span class="number">100</span>   十进制的<span class="number">5</span>对应的二进制是<span class="number">100</span></span><br><span class="line"></span><br><span class="line">你找到规律了吗？ 你能不能依次写出<span class="number">5</span>的二进制、<span class="number">6</span>的二进制？</span><br></pre></td></tr></table></figure><p>前面每算一个二进制数据都是采用+1的方式，逢2进1，一个一个算出来的。有没有更快的算出十进制对应二进制的方法呢？ 这里学习一种方式：叫做除2取余法。</p><ul><li><strong>除2取余法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>怎么做呢？</span><br><span class="line">答：让十进制数据连续除以<span class="number">2</span>，直到商为<span class="number">0</span>，余数反转</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>举例<span class="number">1</span>：把十进制<span class="number">6</span>转换为二进制</span><br><span class="line">商余数</span><br><span class="line"><span class="number">6</span>/<span class="number">2</span>     <span class="number">3</span>    <span class="number">0</span></span><br><span class="line">    <span class="number">3</span>/<span class="number">2</span><span class="number">1</span> <span class="number">1</span></span><br><span class="line">    <span class="number">1</span>/<span class="number">2</span><span class="number">0</span> <span class="number">1</span></span><br><span class="line">    然后把余数反转：<span class="number">6</span>对应的二进制是<span class="number">110</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>举例<span class="number">2</span>： 把十进制<span class="number">13</span>转换为二进制</span><br><span class="line">商余数</span><br><span class="line"><span class="number">13</span>/<span class="number">2</span><span class="number">6</span> <span class="number">1</span></span><br><span class="line">    <span class="number">6</span>/<span class="number">2</span><span class="number">3</span> <span class="number">0</span></span><br><span class="line">    <span class="number">3</span>/<span class="number">2</span> <span class="number">1</span>  <span class="number">1</span></span><br><span class="line">    <span class="number">1</span>/<span class="number">2</span><span class="number">0</span> <span class="number">1</span></span><br><span class="line">    然后把余数反转：<span class="number">10</span>对应的二进制是<span class="number">1101</span></span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>练习<span class="number">1</span>：你能把十进制<span class="number">7</span>转换为二进制吗？</span><br><span class="line">自己试试吧！</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于变量记录的数据在计算机中如何表示我们就先学习到这里。</p><ul><li><strong>计算机的最小存储单位</strong></li></ul><p>前面我们已经知道计算机表示数据是用二进制来的， 这里我又要抛出一个问题来了！ 我现在想要在计算机中存储一个整数6，转换为二进制是110，那么计算机中只是存110吗三位数字吗？ 其实不是的，<strong>计算机中最小的存储单位是字节（Byte），一个字节占8位（bit）</strong>，也就是说即使这个数据不足8位也需要用8位来存储。</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660754639238.png" alt="1660754639238"></p><p>我们随便找到一个文件，看文件的属性，可以看到文件的大小都是以字节为单位的。</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660754762466.png" alt="1660754762466"></p><h3 id="1-2-字符在计算机中的存储原理"><a href="#1-2-字符在计算机中的存储原理" class="headerlink" title="1.2 字符在计算机中的存储原理"></a>1.2 字符在计算机中的存储原理</h3><p>通过上一节的学习，我们知道了整数是如何在计算机中如何存储的？那么字符在计算机中是如何存储的呢？</p><p>其实字符并不是直接存储的，而是把每一个字符编为一个整数，存储的是字符对应整数的二进制形式。美国人搞了一套字符和整数的对应关系表，叫做ASCII编码表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ASCII编码表中字符编码的规律：</span><br><span class="line"><span class="number">1.</span>字符<span class="number">0</span>对应<span class="number">48</span>，后面的<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4.</span>.<span class="number">.9</span> 对应的十进制整数依次往后顺延</span><br><span class="line"><span class="number">2.</span>字符a对应<span class="number">97</span>，后面的b,c,d,e...z 对应的十进制整数依次往后顺延</span><br><span class="line"><span class="number">3.</span>字符A对应<span class="number">65</span>，后面的B,C,D,E...Z 对应的十进制整数依次往后顺延</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660755324089.png" alt="1660755324089"></p><p>需要注意的是，在ASCII编码表中是不包含汉字的。汉字在其他编码表中，后面我们会单独介绍。关于字符在计算机中的存储学到这就可以了。</p><h3 id="1-3-图片视频声音的存储原理"><a href="#1-3-图片视频声音的存储原理" class="headerlink" title="1.3 图片视频声音的存储原理"></a>1.3 图片视频声音的存储原理</h3><ul><li><strong>图片的存储</strong></li></ul><p>通过上面的学习我们已经知道整数和字符是如何存储的，最终都是要转换为二进制数据的，对吧！ 那图片、声音、视频又是如何存储的呢？我们也来了解一下</p><p>我们从图片开始，如果你把一张图片不断的放大，你会看到有马赛克的效果。你会发现图片中的每一个细节是由一个一个的小方格组成的，每一个小方格中其实就是一种颜色。任何一种颜色可以使用三原色来表示，简称RGB，其中R（红色），G（绿色），B（蓝色），而RGB中每一种颜色又用一个字节的整数来表示，最小值是0最大值是255</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660755882309.png" alt="1660755882309"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RGB（<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>）表示黑色</span><br><span class="line">RGB（<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>）表示白色</span><br><span class="line">RGB（<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>） 表示红色</span><br><span class="line">RGB（<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>） 表示红色和绿色混合为黄色</span><br><span class="line">RGB（<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>） 表示红色和蓝色混合为紫色</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你在画图板的颜色编辑器中可以通过指定RGB的值，来调整得到任意的颜色。一张图片实际上就是有很多个小方块的颜色组成的，而每一种颜色又是由RGB三原色的整数表示的，整数最终会转换为二进制进行存储。</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660756387308.png" alt="1660756387308"></p><ul><li><strong>视频的存储</strong></li></ul><p>实际上视频和图片是一样的，把多张图片连续播放，在一秒钟内连续播放24张以上，由于人眼存在视觉暂留现象，人眼感受不到画面切换的时间间隔，就认为是连续的视频了。</p><ul><li><strong>声音的存储</strong></li></ul><p>了解过物理的同学肯定知道，声音是以波的形式传播的。我们可以把声波在表示在一个坐标系上，然后在坐标系上取一些点，把这些点的坐标值以二进制的形式存储到计算机中，这就是声音的存储原理。</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660757825804.png" alt="1660757825804"></p><h3 id="1-4-数据的其他表示形式"><a href="#1-4-数据的其他表示形式" class="headerlink" title="1.4 数据的其他表示形式"></a>1.4 数据的其他表示形式</h3><ul><li><strong>二进制到十进制的转换</strong></li></ul><p>前面我们学习了十进制可以转二进制，采用的是除2取余法，那么我们反过来能不能把二进制转换为十进制呢？</p><p>这里给大家介绍一种计算方式叫做：<strong>8421码</strong></p><p>为了便于理解，我们先在看一下十进制怎么转十进制，主要是为了让大家看到演化过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>十进制转十进制</span><br><span class="line">比如我们把<span class="number">12345</span>进行分解：</span><br><span class="line">        <span class="number">12345</span> = <span class="number">10000</span> + <span class="number">2000</span> + <span class="number">300</span> + <span class="number">40</span> + <span class="number">5</span></span><br><span class="line">              = <span class="number">1</span>*<span class="number">10</span>^<span class="number">4</span> + <span class="number">2</span>*<span class="number">10</span>^<span class="number">3</span> + <span class="number">3</span>*<span class="number">10</span>^<span class="number">2</span> + <span class="number">5</span>*<span class="number">10</span>^<span class="number">0</span></span><br><span class="line">我们发现：</span><br><span class="line">在十进制中如果把十进制的每一位从右往左从<span class="number">0</span>开始编一个号，假设这一位数字是a,那么这一位数表示的值就是：a*<span class="number">10</span>^n；</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------二<span class="number">2.</span>二进制转十进制：</span><br><span class="line">类比十进制：</span><br><span class="line">如果把二进制的每一位从从右往左<span class="number">0</span>开始编一个号用n表示，假设二进制的每一位是a，</span><br><span class="line">那么这一位表示的十进制值是：a*<span class="number">2</span>^n</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>)假设二进制的每一位都是<span class="number">1</span>：</span><br><span class="line"><span class="number">128</span><span class="number">64</span><span class="number">32</span><span class="number">16</span><span class="number">8</span><span class="number">4</span><span class="number">2</span><span class="number">1</span>每一位表示的十进制：a*<span class="number">2</span>^n</span><br><span class="line"><span class="number">7</span><span class="number">6</span><span class="number">5</span><span class="number">4</span><span class="number">3</span><span class="number">2</span><span class="number">1</span><span class="number">0</span>编号：n</span><br><span class="line"><span class="number">1</span><span class="number">1</span><span class="number">1</span><span class="number">1</span><span class="number">1</span><span class="number">1</span><span class="number">1</span><span class="number">1</span>   二进制的每一位：a</span><br><span class="line"></span><br><span class="line">        二进制 十进制</span><br><span class="line">        <span class="number">11111111</span> = <span class="number">1</span>*<span class="number">2</span>^<span class="number">7</span>  + <span class="number">1</span>*<span class="number">2</span>^<span class="number">6</span> + <span class="number">1</span>*<span class="number">2</span>^<span class="number">5</span> + ... + <span class="number">1</span>*<span class="number">2</span>^<span class="number">0</span></span><br><span class="line">                 = <span class="number">128</span>    + <span class="number">64</span>    + <span class="number">32</span>    + ... + <span class="number">1</span></span><br><span class="line">                 = <span class="number">255</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">2</span>)假设二进制的为<span class="number">0010001</span></span><br><span class="line">    <span class="number">128</span><span class="number">64</span><span class="number">32</span><span class="number">16</span><span class="number">8</span><span class="number">4</span><span class="number">2</span><span class="number">1</span>每一位表示的十进制：a*<span class="number">2</span>^n</span><br><span class="line">    <span class="number">7</span><span class="number">6</span><span class="number">5</span><span class="number">4</span><span class="number">3</span><span class="number">2</span><span class="number">1</span><span class="number">0</span>编号：n</span><br><span class="line">    <span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">1</span>二进制的每一位：a</span><br><span class="line">    </span><br><span class="line">    二进制十进制</span><br><span class="line">    <span class="number">00001101</span> = <span class="number">0</span>*<span class="number">2</span>^<span class="number">7</span> + <span class="number">0</span>*<span class="number">2</span>^<span class="number">6</span> + <span class="number">1</span>*<span class="number">2</span>^<span class="number">5</span> + ... + <span class="number">1</span>*<span class="number">2</span>^<span class="number">0</span></span><br><span class="line">     = <span class="number">0</span>     + <span class="number">0</span>     + <span class="number">32</span>  + ... + <span class="number">1</span></span><br><span class="line">     = <span class="number">33</span></span><br><span class="line"></span><br><span class="line">    <span class="number">3</span>)<span class="number">8421</span>码：从右往左给二进制的每一位数依次按照<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8.</span>..标记</span><br><span class="line">    <span class="number">128</span><span class="number">64</span><span class="number">32</span><span class="number">16</span><span class="number">8</span><span class="number">4</span><span class="number">2</span><span class="number">1</span></span><br><span class="line">    <span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">1</span></span><br><span class="line">    -----------------------------</span><br><span class="line">    只需要将<span class="number">1</span>位上的数字加起来，就是二进制对应的十进制</span><br><span class="line">    </span><br><span class="line">    二进制  十进制</span><br><span class="line">    <span class="number">00001101</span> = <span class="number">8</span>+<span class="number">4</span>+<span class="number">1</span></span><br><span class="line">     = <span class="number">13</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">0000111</span> =      <span class="number">4</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">     = <span class="number">7</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">0001111</span>  =      <span class="number">8</span>+<span class="number">4</span>+<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">     =      <span class="number">25</span></span><br></pre></td></tr></table></figure><ul><li><strong>二进制转八进制</strong></li></ul><p>前面我们说计算机中数据都是采用二进制来存储的，但是二进制阅读和编写起来都不太方便。为了便于阅读和书写，又推出了八进制、十六进制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>运算规则：</span><br><span class="line">把二进制的每三位一组合，然后对每三位用<span class="number">8421</span>码进行计算，最后拼接到一起</span><br><span class="line">原因：因为<span class="number">111</span>，的值是<span class="number">7</span>, 再大满<span class="number">7</span>就需要往进位了。 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>把二进制<span class="number">11001110</span>转换为八进制数据</span><br><span class="line"><span class="number">01</span><span class="number">100</span> <span class="number">001</span>二进制每三位一组合</span><br><span class="line">    <span class="number">1</span><span class="number">4</span><span class="number">1</span>每一组进行<span class="number">8421</span>码运算</span><br><span class="line">    ----------</span><br><span class="line">    八进制：<span class="number">141</span></span><br></pre></td></tr></table></figure><ul><li><strong>二进制转十六进制</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>运算规则：</span><br><span class="line">把二进制的每四位一组合，然后对每四位用<span class="number">8421</span>码进行计算，最后拼接到一起</span><br><span class="line">原因：因为<span class="number">1111</span>，的值是<span class="number">15</span>, 再大<span class="number">1</span>满<span class="number">16</span>了就需要往进位了。 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>举例：把二进制<span class="number">11001110</span>转换为十六进制数据</span><br><span class="line"><span class="number">0110</span> <span class="number">0001</span>二进制每四位一组合</span><br><span class="line">    <span class="number">6</span> <span class="number">1</span>每一组进行<span class="number">8421</span>码运算</span><br><span class="line">    ----------</span><br><span class="line">    十六进制：<span class="number">61</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>练习：把<span class="number">111100</span>转换为十六进制</span><br><span class="line"><span class="number">0011</span> <span class="number">1100</span></span><br><span class="line">    <span class="number">3</span> <span class="number">12</span>由于十六进制中有a,b,c,d,e,f分别表示<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span></span><br><span class="line">    -----------</span><br><span class="line">    十六进制：3c</span><br></pre></td></tr></table></figure><h3 id="1-5-不同进制在Java程序中的书写格式"><a href="#1-5-不同进制在Java程序中的书写格式" class="headerlink" title="1.5 不同进制在Java程序中的书写格式"></a>1.5 不同进制在Java程序中的书写格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.pirntln(<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>); <span class="comment">//98</span></span><br><span class="line">System.out.pirntln(<span class="number">0b01100001</span>); <span class="comment">//97</span></span><br><span class="line">System.out.pirntln(<span class="number">0141</span>); <span class="comment">//97</span></span><br><span class="line">System.out.pirntln(<span class="number">0x61</span>); <span class="comment">//97</span></span><br></pre></td></tr></table></figure><h2 id="二、数据类型详解"><a href="#二、数据类型详解" class="headerlink" title="二、数据类型详解"></a>二、数据类型详解</h2><p>在前面的课程中，我们学过了变量的定义，在定义变量时我们是要声明数据类型的，这里的<strong>数据类型是用来规定变量存储什么类型的数据</strong>。</p><p>比如<code>int a = 10;</code> 这里的<code>int</code>就是限制变量只能存储整数； 除了int这种数据类型Java还提供了很多其他的数据类型。Java的数据类型整体上来说分为两大类： <strong>基本数据类型</strong>、<strong>引用数据类型</strong>。 </p><p>我们今天主要学习基本数据类型，基本数据类型一共有4类8种，每一种数据类型占用的内存空间不一样，能够表示的数据范围也不一样。如下图所示</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660832924103.png" alt="1660832924103"></p><p>需要我们注意的是，随便写一个整数或者小数的字面量，它也是有默认数据类型的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 比如23，它默认就为int类型；如果加上后缀L，则为long类型；</span><br><span class="line">- 比如23.8，它默认为double类型；如果加上后缀F，则为float类型;</span><br></pre></td></tr></table></figure><p>下面定义各种类型的变量，将这8种基本数据类型都用一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握8种基本数据类型，用来定义变量。</span></span><br><span class="line">        <span class="comment">// 1、整型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">98</span>;</span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">number3</span> <span class="operator">=</span> <span class="number">12323232</span>; <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：随便写一个整型字面量，默认是int类型的，73642422442424虽然没有超过long的范围，但是它超过了本身int的范围了。</span></span><br><span class="line">        <span class="comment">// 如果希望随便写一个整型字面量是long类型的，需要在其后面加上L/l</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">number4</span> <span class="operator">=</span> <span class="number">73642422442424L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、浮点型</span></span><br><span class="line">        <span class="comment">//注意:</span></span><br><span class="line">        <span class="comment">//随便写一个小数字面量，默认当成double类型对待的，</span></span><br><span class="line">        <span class="comment">//如果希望这个小数是float类型的，需要在后面加上：F/f</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">score1</span> <span class="operator">=</span> <span class="number">99.5F</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">score2</span> <span class="operator">=</span> <span class="number">99.8</span>; <span class="comment">// 默认定义方案。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、字符型</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch3</span> <span class="operator">=</span> <span class="string">&#x27;国&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、布尔型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用数据类型：String.</span></span><br><span class="line">        <span class="comment">// String代表的是字符串类型，定义的变量可以用来记住字符串。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;黑马&quot;</span>;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、数据类型转换"><a href="#三、数据类型转换" class="headerlink" title="三、数据类型转换"></a>三、数据类型转换</h2><h3 id="3-1-自动类型转换"><a href="#3-1-自动类型转换" class="headerlink" title="3.1 自动类型转换"></a>3.1 自动类型转换</h3><p>各位同学，接下来我们来学习类型转换的知识。为什么要学习类型转换呢？因为在我们实际开发中可能存在将某种类型变量的值，赋值给另一个类型的变量；也可能存在多种数据类型的数据一起运算的情况。</p><p>在以上情况中，其实都会涉及到类型转换。类型转换的形式总体分为2种，一种是<strong>自动类型转换</strong>，一种是<strong>强制类型转换</strong>。 这里先学习自动类型转换</p><ul><li><strong>什么是自动类型转换呢？</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答：自动类型转换指的是，数据范围小的变量可以直接赋值给数据范围大的变量</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span>; </span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; <span class="comment">//这里就发生了自动类型转换(把byte类型转换int类型)</span></span><br></pre></td></tr></table></figure><ul><li><strong>自动类型转换的原理是怎样的？</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：自动类型转换其本质就是在较小数据类型数据前面，补了若干个字节</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660837214161.png" alt="1660837214161"></p><p>除了byte和int之间的转换之外，其他类型也可以转换，转换顺序如下图所示</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660837456261.png" alt="1660837456261"></p><p>下面我们通过代码演示一下，自动类型转换的各种形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeConversionDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：理解自动类型转换机制。</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; <span class="comment">// 发生了自动类型转换了</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 4</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> c;<span class="comment">// 8 发生了自动类型转换了</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="comment">// &#x27;a&#x27; 97 =&gt; 00000000 01100001</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ch; <span class="comment">// 发生了自动类型转换了 =&gt;  00000000 00000000  00000000 01100001</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>表达式的自动类型转换</strong></li></ul><p>自动类型转换还有另外一种形式，就是表达式的自动类型转换。所谓表达式指的是几个变量或者几个数据一起参与运算的式子。</p><p>如果同一个表达式中，出现不同类型的变量或者数据一起运算，这种情况下运算结果是一个什么数据类型呢？需要遵守下面的两条运算规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>多种数据类型参与运算，其结果以大的数据类型为准</span><br><span class="line"><span class="number">2.</span><span class="type">byte</span>,<span class="type">short</span>,<span class="type">char</span> 三种类型数据在和其他类型数据运算时，都会转换为<span class="type">int</span>类型再运算</span><br></pre></td></tr></table></figure><p>接下来我们来看代码演示，自己试一试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeConversionDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握表达式的自动类型转换机制。</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">rs</span> <span class="operator">=</span> a + b + c;</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">rs2</span> <span class="operator">=</span> a + b + <span class="number">1.0</span>;</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs3</span> <span class="operator">=</span> i + j;</span><br><span class="line">        System.out.println(rs3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 面试笔试题： 即使两个byte运算，结果也会提升为int</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2;</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-强制类型转换"><a href="#3-2-强制类型转换" class="headerlink" title="3.2 强制类型转换"></a>3.2 强制类型转换</h3><p>前面我们学习了自动类型转换，我们知道可以将数据类型小的数据可以直接赋值给数据范围大的变量。 那反过来，能不能将数据范围大的数据直接赋值给数据范围小的变量呢？ <strong>答案是会报错。</strong></p><p>因为数据范围大的数据，赋值给数据范围小的变量，它有可能装不下；就像把一个大桶的水倒入一个小桶中，有溢出的风险。</p><ul><li><strong>什么是强制类型转换</strong></li></ul><p>但是你强行将范围大的数据，赋值给范围小的变量也是可以的，这里就需要用到强制类型转换。下面是强制类型转换的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标数据类型  变量名  =  (目标数据类型)被转换的数据;</span><br></pre></td></tr></table></figure><p>下面是强制类型转换的代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeConversionDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握强制类型转换。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) a;  <span class="comment">// ALT + ENTER 强制类型转换。</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1500</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">byte</span>) i;</span><br><span class="line">        System.out.println(j);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">99.5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) d; <span class="comment">// 强制类型转换</span></span><br><span class="line">        System.out.println(m); <span class="comment">// 丢掉小数部分，保留整数部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>强制类型转换的原理</strong></p><p>强制类型转换的原理，其实就是<strong>强行把前面几个字节砍掉，但是有数据丢失的风险</strong>。</p></li></ul><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660840481803.png" alt="1660840481803"></p><p>到这有关数据类型和数据类型转换的内容，我们就学习完了。大家能够知道什么时候会发生自动类型转换，以及如何进行强制类型转换就可以了。</p><h2 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h2><p>接下来，给同学们讲解一个在开发中用得很多的一块内容，叫做运算符。</p><p>大家知道计算机是用来处理数据的，处理数据就少不了对数据的计算，想要对数据进行计算就必须用到运算符。</p><p>运算符就是参与运算的符号。Java提供的运算符有很多种，可以分为算术下面几种</p><ul><li>基本算术运算符</li><li>自增自减运算符</li><li>赋值运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>三元运算符</li></ul><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p>先从最基本的算术运算符开始学习，算术运算符有 <code>+ - * / % </code> ，其中<code>*</code>表示乘法，<code>/</code>表示除法，<code>%</code>表示取余数</p><p>需要我们注意以下几点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/: 两个整数相除，结果也是一个整数</span><br><span class="line">%: 表示两个数相除，取余数</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660841349983.png" alt="1660841349983"></p><p>需要我们注意的是：<code>+</code>符号除了用于加法运算，还可以作为连接符。**<code>+</code>符号与字符串运算的时候是用作连接符的，其结果依然是一个字符串**。</p><p>下面通过代码演示一下各种算术运算符的运算效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握基本的算术运算符的使用。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">        System.out.println(a - b);</span><br><span class="line">        System.out.println(a * b); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(a / b); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(<span class="number">5</span> / <span class="number">2</span>); <span class="comment">// 2.5 ==&gt; 2</span></span><br><span class="line">        System.out.println(<span class="number">5.0</span> / <span class="number">2</span>); <span class="comment">// 2.5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="number">1.0</span> * i / j); <span class="comment">// 2.5</span></span><br><span class="line"></span><br><span class="line">        System.out.println(a % b); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="number">3</span> % <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标2：掌握使用+符号做连接符的情况。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span> + a2); <span class="comment">// &quot;abc5&quot;</span></span><br><span class="line">        System.out.println(a2 + <span class="number">5</span>); <span class="comment">//  10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;itheima&quot;</span> + a2 + <span class="string">&#x27;a&#x27;</span>); <span class="comment">// &quot;itheima5a&quot;</span></span><br><span class="line">        System.out.println(a2 + <span class="string">&#x27;a&#x27;</span> + <span class="string">&quot;itheima&quot;</span>); <span class="comment">// 102itheima</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-自增自减运算符"><a href="#3-2-自增自减运算符" class="headerlink" title="3. 2 自增自减运算符"></a>3. 2 自增自减运算符</h3><p>接下来，学习一种比较常用的运算符：<code>++</code>和<code>--</code> </p><p><code>++</code>读作自增，<code>--</code>读作自减； 运算规则如下</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660841701880.png" alt="1660841701880"></p><p>需要我们注意的是，自增自减只能对变量进行操作，不能操作字面量。具体使用时也分为两种情况，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>单独使用：++或者--放在变量前面没有区别</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">10</span>; </span><br><span class="line">    a++;  <span class="comment">//11</span></span><br><span class="line">--a;  <span class="comment">//10</span></span><br><span class="line">System.out.println(a); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>混合使用：++或者--放在变量或者前面运算规则稍有不通过</span><br><span class="line"><span class="comment">//++在后：先做其他事情，再做自增和自减</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++; <span class="comment">//等价于 int b = a; a++; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//++在前：先自增或者自减，再做其他运输</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> --x; <span class="comment">//等价于x--; int y = x;  </span></span><br></pre></td></tr></table></figure><p>下面通过代码演示一下<code>++</code>和<code>--</code>的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握自增自减运算符的使用。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// a++; // a = a + 1</span></span><br><span class="line">        ++a;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a--; // a = a - 1</span></span><br><span class="line">        --a;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自增自减只能操作变量不能操作字面量的，会报错！</span></span><br><span class="line">      <span class="comment">//System.out.println(2++);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> ++i; <span class="comment">// 先加后用</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs2</span> <span class="operator">=</span> j++; <span class="comment">// 先用后加</span></span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-赋值运算符"><a href="#3-3-赋值运算符" class="headerlink" title="3.3 赋值运算符"></a>3.3 赋值运算符</h3><p>接下来，我们学习赋值运算符。基本的赋值运算符其实就是<code>=</code>号，意思就是把右边的数据赋值给左边的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//将数据10赋值给左边的变量a</span></span><br></pre></td></tr></table></figure><p>除了基本的赋值运算符，我们这里主要学习一下扩展的赋值运算符。有<code>+= -= *= /= %=</code></p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660872631676.png" alt="1660872631676"></p><p>我们以<code>+=</code>为例来看一下它的运算规则，其他的运算符运算同理分析即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//+=解析：在a原来记录值10的基础上累加5，将结果重新赋值给a; </span></span><br><span class="line">a+=<span class="number">5</span>; </span><br><span class="line"><span class="comment">//最终打印a的值为15</span></span><br><span class="line">System.out.println(a); </span><br></pre></td></tr></table></figure><p>下面通过一个首发红包的例子给大家演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握扩展赋值运算符的使用。</span></span><br><span class="line">        <span class="comment">// +=</span></span><br><span class="line">        <span class="comment">// 需求：收红包</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9.5</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">520</span>;</span><br><span class="line">        a += b;  <span class="comment">// a = (double)(a + b);</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -= 需求：发红包</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">600</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">520</span>;</span><br><span class="line">        i -= j;  <span class="comment">// i = (double)(i - j);</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// m *= n; // 等价形式： m = (int)(m * n)</span></span><br><span class="line">        <span class="comment">// m /= n; // 等价形式： m = (int)(m / n)</span></span><br><span class="line">        m %= n;    <span class="comment">// 等价形式： m = (int)(m % n)</span></span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学完扩展赋值运算符的基本使用之后，接下来我们看一个面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">问题<span class="number">1</span>：下面的代码否有问题？</span><br><span class="line">    <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">x = x + y;  <span class="comment">//这句代码有问题，因为两个byte类型数据相加，会提升为int类型;</span></span><br><span class="line"></span><br><span class="line">问题<span class="number">2</span>：下面的代码是否有问题？</span><br><span class="line"><span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">x+=<span class="number">3</span>; <span class="comment">//这句代码没有问题，因为这里有隐含的强制类型转换</span></span><br><span class="line">  <span class="comment">//x+=3; 等价于 byte x = (byte)(x+y);</span></span><br></pre></td></tr></table></figure><p>到这里赋值运算符就学习完了，稍微总结一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>基本赋值运算符：</span><br><span class="line">=符号含义： 把右边的值赋值给左边的变量</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>扩展赋值运算符：</span><br><span class="line">+= -= *= /= %=符号含义：将右边的数据和左边的变量相加、相减、相乘、相除、取余数后，将结果重新赋值给左边的变量。</span><br></pre></td></tr></table></figure><h3 id="3-4-关系运算符"><a href="#3-4-关系运算符" class="headerlink" title="3.4 关系运算符"></a>3.4 关系运算符</h3><p>接下来我们学习一个，在实际代码中用得很多，但是又非常简单的运算符，叫关系运算符。关系运算符（也叫比较运算符）。</p><p>下图是每一种关系运算符的符号及作用，每一个关系运算符的结果都是false</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660872844712.png" alt="1660872844712"></p><p>下面通过代码来家演示一下，各种关系运算符的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握关系运算符的基本使用。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rs</span> <span class="operator">=</span> a &gt; b;</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        System.out.println(a &gt;= b); <span class="comment">// 要么a大于b,或者a等于b</span></span><br><span class="line">        System.out.println(<span class="number">2</span> &gt;= <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(a &lt; b);</span><br><span class="line">        System.out.println(a &lt;= b); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="number">2</span> &lt;= <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="number">5</span> == <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意了：判断是否相等一定是用 == ，=是用来赋值的。</span></span><br><span class="line">        <span class="comment">// System.out.println(a = b); </span></span><br><span class="line">        System.out.println(a != b); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="number">10</span> != <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="literal">false</span> ^ <span class="literal">true</span> ^ <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们只需要知道每一种关系运算符的运算效果就行了，<strong>关于关系运算符的实际运用需要在后面学习了流程控制语句才能实际用到。</strong></p><p>关系运算符在程序中常用于条件判断，根据条件判断的结果是true还是false，来决定后续该执行哪些操作。</p><h3 id="3-5-逻辑运算符"><a href="#3-5-逻辑运算符" class="headerlink" title="3.5 逻辑运算符"></a>3.5 逻辑运算符</h3><p>学习完关系运算符之后，接下来我们学习一下逻辑运算符。我们来看一下逻辑运算符有哪些。</p><p><strong>逻辑运算符是用来将多个条件放在一起运算，最终结果是true或者false</strong></p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660873470958.png" alt="1660873470958"></p><p>下面我们通过几个案例来演示一下逻辑运算符的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求1：要求手机必须满足尺寸大于等于6.95，且内存必须大于等于8.</span></span><br><span class="line"><span class="comment">//需求2：要求手机要么满足尺寸大于等于6.95，要么内存必须大于等于8.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握逻辑运算符的使用。</span></span><br><span class="line">        <span class="comment">// 需求：要求手机必须满足尺寸大于等于6.95，且内存必须大于等于8.</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">6.8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 1、&amp; 前后的条件的结果必须都是true ,结果才是true.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rs</span> <span class="operator">=</span> size &gt;= <span class="number">6.95</span> &amp; storage &gt;= <span class="number">8</span>;</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：要求手机要么满足尺寸大于等于6.95，要么内存必须大于等于8.</span></span><br><span class="line">        <span class="comment">// 2、| 只要多个条件中有一个是true,结果就是true.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rs2</span> <span class="operator">=</span> size &gt;= <span class="number">6.95</span> | storage &gt;= <span class="number">8</span>;</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、!取反的意思</span></span><br><span class="line">        System.out.println(!<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line">        System.out.println(!<span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(!(<span class="number">2</span> &gt; <span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、^ 前后条件的结果相同时返回false，不同时返回true.</span></span><br><span class="line">        System.out.println(<span class="literal">true</span> ^ <span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="literal">false</span> ^ <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="literal">true</span> ^ <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="literal">false</span> ^ <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、&amp;&amp; 左边为false，右边不执行。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// System.out.println(i &gt; 100 &amp;&amp; ++j &gt; 99);</span></span><br><span class="line">        System.out.println(i &gt; <span class="number">100</span> &amp; ++j &gt; <span class="number">99</span>);</span><br><span class="line">        System.out.println(j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、|| 左边是true ，右边就不执行。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="comment">// System.out.println(m &gt; 3 || ++n &gt; 40);</span></span><br><span class="line">        System.out.println(m &gt; <span class="number">3</span> | ++n &gt; <span class="number">40</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里关于逻辑运算符的规则记学习完了，给你一个运算表达式你能分析出结果就行。<strong>至于逻辑运算符的实际运用，需要在学习了流程控制语句之后，才能实际用到。</strong></p><p>逻辑运算符在程序中常用于组合几个条件判断，根据条件判断的结果是true还是false，来决定后续该执行哪些操作。</p><h3 id="3-6-三元运算符"><a href="#3-6-三元运算符" class="headerlink" title="3.6 三元运算符"></a>3.6 三元运算符</h3><p>接下来，我们学习今天最后一种运算符，叫做三元运算符。</p><p>先认识一下三元运算符的格式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系表达式? 值<span class="number">1</span> : 值<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>三元运算的执行流程：首先计算关系表达式的值，如果关系表达式的值为true，则返回值1；如果关系表达式的值为false, 则返回值2；</p><p>如下图所示：判断学生的成绩是否&gt;&#x3D;60，如果为true，就考试通过；如果为false，就成绩不合格。</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660875022987.png" alt="1660875022987"></p><p>接下来通过代码来演示一下，目的是让大家掌握三元运算符的格式和执行流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握三元运算符的基本使用。</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">58.5</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> score &gt;= <span class="number">60</span> ? <span class="string">&quot;成绩及格&quot;</span> : <span class="string">&quot;成绩不及格&quot;</span>;</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：找出2个整数中的较大值，并输出。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">69</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a &gt; b ? a : b;</span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：找3个整数中的较大值。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">45</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">34</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出2个整数中的较大值。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i &gt; j ? i : j;</span><br><span class="line">        <span class="comment">// 找出temp与k中的较大值。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max2</span> <span class="operator">=</span> temp &gt; k ? temp : k;</span><br><span class="line">        System.out.println(max2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-7-运算优先级"><a href="#3-7-运算优先级" class="headerlink" title="3.7 运算优先级"></a>3.7 运算优先级</h3><p>最后我们在给大家介绍一下运算符的优先级，如果你想要知道各个运算符的优先级，哪些先算哪些后算，可以参考下面这张图</p><p><img src="/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/1660875681298.png" alt="1660875681298"></p><p>从图中我们发现，&amp;&amp;运算比||运算的优先级高，所以&amp;&amp;和||同时存在时，是先算&amp;&amp;再算||；</p><p>比如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里&amp;&amp;先算 相当于 true || false 结果为true</span></span><br><span class="line">System.out.println(<span class="number">10</span> &gt; <span class="number">3</span> || <span class="number">10</span> &gt; <span class="number">3</span> &amp;&amp; <span class="number">10</span> &lt; <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>最后给大家说一下，在实际开发中，其实我们很少考虑运算优先级， 因为如果你想让某些数据先运算，其实加<code>()</code>就可以了，这样阅读性更高。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有括号先算 相当于 true &amp;&amp; false 结果为false</span></span><br><span class="line">System.out.println((<span class="number">10</span> &gt; <span class="number">3</span> || <span class="number">10</span> &gt; <span class="number">3</span>) &amp;&amp; <span class="number">10</span> &lt; <span class="number">3</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="五、案例技术：获取用户键盘输入的数据"><a href="#五、案例技术：获取用户键盘输入的数据" class="headerlink" title="五、案例技术：获取用户键盘输入的数据"></a>五、案例技术：获取用户键盘输入的数据</h2><p>最后给大家讲一个案例技术，这个技术现在其实有一些超前，因为需要用到后面学习的知识。但是在这里讲可以让我们的学习体验度更好一点，前面案例中参与运算的数据都是在程序中写死的，下面我们想让自己键盘录入数据，然后参与程序的运行。</p><p><strong>键盘录入这个事情，其实并不是我们自己做的，而是Java本身就提供了这样的功能，我们按照它的要求，去调用就行。</strong></p><p>我们在安装JDK的时候，其实JDK中就已经包含了一些Java写好的代码，我们把Java写好的代码直接拿过来用就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：Scanner就是Java提供给我们用于键盘录入数据的类，为了录入不同类型的数据，还提供了不同的功能，每一个功能会有不同的名称，我们只需要调用Scanner提供的功能就可以完成键盘录入数据。</span><br></pre></td></tr></table></figure><p>大家只需要按照下面的步骤编写代码，就可以键盘录入数据了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【第<span class="number">1</span>步】：在class类上导包：一般不需要我们自己做，idea工具会自动帮助我们 导包的。</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">【第<span class="number">2</span>步】：得到一个用于键盘扫描器对象（照抄代码就行，固定格式）</span><br><span class="line"><span class="comment">//Scanner是键盘扫描器对象(你就把它理解成一个东西)，这个东西有录入的功能</span></span><br><span class="line"><span class="comment">//sc是给这个东西取的名字</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">【第<span class="number">3</span>步】：开始调用sc的功能，来接收用户键盘输入的数据。</span><br><span class="line"><span class="comment">//sc这个东西有键盘录入整数的功能，这个功能的名字叫nextInt()</span></span><br><span class="line"><span class="comment">//.表示表示调用的意思</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;我的年龄是:&quot;</span>+age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sc这个东西还有键盘录入字符串的功能，这个功能的名字叫next</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;我的姓名是:&quot;</span>+name);</span><br></pre></td></tr></table></figure><p>下面是完整代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、导包:一般不需要我们自己做，idea工具会自动帮助我们 导包的。</span></span><br><span class="line">        <span class="comment">// 2、抄写代码：得到一个键盘扫描器对象（东西）</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始 调用sc的功能，来接收用户键盘输入的数据。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入您的年龄：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 执行到这儿，会开始等待用户输入一个整数，直到用户按了回车键，才会拿到数据。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;您的年龄是：&quot;</span>  + age);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入您的名字：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next(); <span class="comment">// 执行到这儿，会开始等待用户输入一个字符串，直到用户按了回车键，才会拿到数据。</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot;欢迎您进入系统~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、数据的表示详解&quot;&gt;&lt;a href=&quot;#一、数据的表示详解&quot; class=&quot;headerlink&quot; title=&quot;一、数据的表示详解&quot;&gt;&lt;/a&gt;一、数据的表示详解&lt;/h2&gt;&lt;p&gt;昨天我们学习了变量，我们知道变量可以用来记录数据的。那么数据在计算机底层是以什么形式</summary>
      
    
    
    
    <category term="Java" scheme="https://wxzhou.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wxzhou.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java-day04-Java数组</title>
    <link href="https://wxzhou.top/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/"/>
    <id>https://wxzhou.top/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/</id>
    <published>2020-05-05T07:43:32.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、认识数组"><a href="#一、认识数组" class="headerlink" title="一、认识数组"></a>一、认识数组</h2><p>先来认识一下什么数组</p><h3 id="1-什么数组"><a href="#1-什么数组" class="headerlink" title="1. 什么数组"></a>1. 什么数组</h3><p>数组就是一个容器，用来存一批同种类型的数据的。</p><p>比如：想要存储 20,10,80,60,90 这些数据。 我们可以把代码写成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">20</span>,<span class="number">10</span>,<span class="number">80</span>,<span class="number">60</span>,<span class="number">90</span>&#125;;</span><br></pre></td></tr></table></figure><p>比如：想要存储 “牛二“,“西门“,“全蛋“ 这些数据。我们可以把代码写成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;牛二&quot;</span>, <span class="string">&quot;西门&quot;</span>, <span class="string">&quot;全蛋&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-数组的应用场景"><a href="#2-数组的应用场景" class="headerlink" title="2. 数组的应用场景"></a>2. 数组的应用场景</h3><p>有变量，为什么还要有数组呢？ 比如，我们要做一个点名器</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661321640902.png" alt="1661321640902"></p><p>如果用变量来做的话，代码是这样子的</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661321680612.png" alt="1661321680612"></p><p>如果用数组来做的话，代码是这样子的</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661321716135.png" alt="1661321716135"></p><p>一对比我们发现数组的写法比变量的写法更加简洁，所以我们可以得出一个结论</p><p><strong>结论：遇到批量数据的存储和操作时，数组比变量更适合</strong></p><h2 id="二、数组的定义和访问"><a href="#二、数组的定义和访问" class="headerlink" title="二、数组的定义和访问"></a>二、数组的定义和访问</h2><p>各位同学，我们已经知道数组是用来干什么的。那么如何使用Java语言写一个数组呢？这里就需要学习一下数组的初始化格式。</p><p>数组有两种初始化的方式，一种是静态初始化、一种是动态初始化。我们先用静态初始化来学习数组的操作。</p><h3 id="2-1-数组的静态初始化"><a href="#2-1-数组的静态初始化" class="headerlink" title="2.1 数组的静态初始化"></a>2.1 数组的静态初始化</h3><p>所谓静态初始化指的是：在定义数组时直接给数组中的数据赋值。</p><p><strong>1. 静态初始化标准格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 变量名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>按照格式定义int类型、double类型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组，用来存储多个年龄</span></span><br><span class="line"><span class="type">int</span>[] ages = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;</span><br><span class="line"><span class="comment">//定义数组，用来存储多个成绩</span></span><br><span class="line"><span class="type">double</span>[] scores = <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">89.9</span>, <span class="number">99.5</span>, <span class="number">59.5</span>, <span class="number">88.0</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>2. 静态初始化简化格式</strong></p><p>Java语言的设计者为了简化定义数组的写法，还为静态初始化提供了一种简化写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 变量名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>使用简化格式定义int类型、double类型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组，用来存储多个年龄</span></span><br><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;</span><br><span class="line"><span class="comment">//定义数组，用来存储多个成绩</span></span><br><span class="line"><span class="type">double</span>[] scores = &#123;<span class="number">89.9</span>, <span class="number">99.5</span>, <span class="number">59.5</span>, <span class="number">88.0</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>3. 注意哟！！</strong></p><ul><li>定义数组时， <code>数据类型[] 数组名</code> 也可写成 <code>数据类型 数组名[]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两种写法是等价的。但是建议大家用第一种，因为这种写法更加普遍</span></span><br><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;;</span><br><span class="line"><span class="type">int</span> ages[] = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 数组在计算机中的基本原理</strong></p><p>我们知道数组是怎么定义的之后，那么接下来看一下数组在计算机中的基本原理。</p><p>我们以<code>int[] ages = &#123;12,24,36&#125;;</code>这句话为例，看一下这句话到底在计算机中做了那些事情。</p><ul><li>首先，左边<code>int[] ages</code> 表示定义了一个数组类型的变量，变量名叫ages</li><li>其次，右边<code>&#123;12,24,36&#125;</code>表示创建一个数组对象，你完全可以把它理解成一个能装数据的东西。这个对象在内存中会有一个地址值<code>[I@4c873330</code>，每次创建一个数组对象都会有不用的地址值。</li><li>然后，把右边的地址值<code>[I@4c873330</code>赋值给左边的ages变量</li><li>所以，ages变量就可以通过地址值，找到数组这个东西。</li></ul><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661353166416.png" alt="1661353166416"></p><h3 id="2-2-数组的元素访问"><a href="#2-2-数组的元素访问" class="headerlink" title="2.2 数组的元素访问"></a>2.2 数组的元素访问</h3><p>各位同学，通过刚才的学习，我们知道数组是用来存储数据的。那么数组中存储的数据又如何访问呢？这里所说的访问，意思就是获取中数组中数据的值、或者给数组中的数据赋值。</p><p>这里先给大家统一几个概念，数组中存储的数据我们叫做元素；而且数组中的每一个元素都有一个编号与之对应，我们把这个编号叫做索引，这个索引是从0依次递增的整数。如下图所示</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661354056668.png" alt="1661354056668"></p><p>要想访问数组中的元素，格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组名可以找到数组对象的地址，再通过索引就可以定位到具体的元素了</span></span><br><span class="line">数组名[索引]</span><br></pre></td></tr></table></figure><p>接下来用代码来演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//索引：   0   1   2</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;;</span><br><span class="line"><span class="comment">// 1、访问数组的全部数据</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">//12</span></span><br><span class="line">System.out.println(arr[<span class="number">1</span>]); <span class="comment">//24</span></span><br><span class="line">System.out.println(arr[<span class="number">2</span>]); <span class="comment">//36</span></span><br><span class="line"><span class="comment">//下面代码没有3索引，会出现ArrayIndexOutOfBoundsException 索引越界异常</span></span><br><span class="line"><span class="comment">//System.out.println(arr[3]); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、修改数组中的数据</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">66</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">100</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">//66</span></span><br><span class="line">System.out.println(arr[<span class="number">1</span>]); <span class="number">0</span></span><br><span class="line">System.out.println(arr[<span class="number">2</span>]); <span class="comment">//100</span></span><br></pre></td></tr></table></figure><p>除了访问数组中的元素，我们可以获取数组中元素的个数，后面我们统称为数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、访问数组的元素个数：数组名.length</span></span><br><span class="line">System.out.println(arr.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技巧：获取数组的最大索引: arr.length - 1(前提是数组中存在数据)</span></span><br><span class="line">System.out.println(arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;&#125;;</span><br><span class="line">System.out.println(arr2.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3-数组的遍历"><a href="#2-3-数组的遍历" class="headerlink" title="2.3 数组的遍历"></a>2.3 数组的遍历</h3><p>各位同学，接下来我们学习一个对数组最最最常见的操作——数组遍历。所谓遍历意思就是将数组中的元素一个一个的取出来。</p><p>我们刚才学习了数组中元素的访问，访问元素必须用到索引，如下列代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;;</span><br><span class="line">System.out.println(ages[<span class="number">0</span>]);</span><br><span class="line">System.out.println(ages[<span class="number">1</span>]);</span><br><span class="line">System.out.println(ages[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>但是，如果数组中有很多很多元素，索引靠自己一个一个数肯定是不行的！我们可以使用for循环从0开始一直遍历到长度-1的位置，就可以获取所有的索引了。 </p><p>当你获取到每一个索引，那么每一个元素不就获取到了吗？上代码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ages.length; i++) &#123;</span><br><span class="line">    <span class="comment">// i的取值 = 0,1,2</span></span><br><span class="line">    System.out.println(ages[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-数组静态初始化案例"><a href="#2-4-数组静态初始化案例" class="headerlink" title="2.4 数组静态初始化案例"></a>2.4 数组静态初始化案例</h3><p>学习完数组的静态初始化之后，接下来我们做一个练习题来巩固一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">需求：某部门<span class="number">5</span>名员工的销售额分别是：<span class="number">16</span>、<span class="number">26</span>、<span class="number">36</span>、<span class="number">6</span>、<span class="number">100</span>，请计算出他们部门的总销售额。</span><br><span class="line"></span><br><span class="line">需求分析：</span><br><span class="line"><span class="number">1.</span>看到有<span class="number">16</span>、<span class="number">26</span>、<span class="number">36</span>、<span class="number">6</span>、<span class="number">100</span>这<span class="number">5</span>个数据数据，而且数据值很明确;</span><br><span class="line"><span class="number">1</span>)想到,可以使用数组静态初始化把这<span class="number">5</span>个数据存起来</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>请计算出他们部门的总销售额（这不就是求数组中数据的和吗？）</span><br><span class="line"><span class="number">2</span>)必须先将数组中所有的元素遍历出来</span><br><span class="line"><span class="number">3</span>)想要求和，得先有一个求和变量sum</span><br><span class="line"><span class="number">4</span>)再将每一个元素和求和变量sum进行累加（求和思想）</span><br></pre></td></tr></table></figure><p>按照分析的思路来写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、定义一个数组存储5名员工的销售额</span></span><br><span class="line"><span class="comment">//索引          0   1    2  3   4</span></span><br><span class="line"><span class="type">int</span>[] money = &#123;<span class="number">16</span>, <span class="number">26</span>, <span class="number">36</span>, <span class="number">6</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、定义一个变量用于累加求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、遍历这个数组中的每个数据。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; money.length; i++) &#123;</span><br><span class="line">    <span class="comment">// i = 0  1  2  3  4</span></span><br><span class="line">    sum += money[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;员工的销售总额：&quot;</span> + sum);</span><br></pre></td></tr></table></figure><h3 id="2-5-数组的动态初始化"><a href="#2-5-数组的动态初始化" class="headerlink" title="2.5 数组的动态初始化"></a>2.5 数组的动态初始化</h3><p>各位同学，刚才我们初始化数组时，都是直接将元素写出来。但是还有另一个初始化数组的方式叫 <strong>动态初始化</strong>。</p><p>动态初始化不需要我们写出具体的元素，而是指定元素类型和长度就行。格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型[]  数组名 = new 数据类型[长度];</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>下面是动态初始化数组的原理图。我们发现<code>int[] arr</code> 其实就是一个变量，它记录了数组对象的地址值，而且数组中的元素默认值是0。</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661356063895.png" alt="1661356063895"></p><p><strong>注意：</strong></p><p>使用动态初始化定义数组时，根据元素类型不同，默认值也有所不同。</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661417981361.png" alt="1661417981361"></p><p>关于数组动态初始化的格式和原理，咱们就先学习到这里。</p><h3 id="2-6-数组动态初始化案例"><a href="#2-6-数组动态初始化案例" class="headerlink" title="2.6 数组动态初始化案例"></a>2.6 数组动态初始化案例</h3><p>各位同学，接下来我们做一个数组动态初始化的案例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">案例需求：</span><br><span class="line">某歌唱比赛，需要开发一个系统：可以录入<span class="number">6</span>名评委的打分，录入完毕后立即输出平均分做</span><br><span class="line">选手得分</span><br><span class="line"></span><br><span class="line">需求分析：</span><br><span class="line"><span class="number">1.</span>需要录入<span class="number">6</span>名评委的分数，可以用一个数组来保存。</span><br><span class="line">   因为在评委没有录入分数之前，还不确定数组中应该存哪些数据。</span><br><span class="line">   所以可以使用数组的动态初始化</span><br><span class="line"><span class="number">2.</span>遍历数组中的每一个位置，并录入分数，将分数存入数组中</span><br><span class="line"><span class="number">3.</span>遍历数组中的每一个元素，对元素求和</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、定义一个动态初始化的数组，负责后期存储6个评委的打分。</span></span><br><span class="line"><span class="type">double</span>[] scores = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、遍历数组中的每个位置，录入评委的分数，存入到数组中去</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line">    <span class="comment">// i = 0 1 2 3 4 5</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请您输入当前第&quot;</span> + (i + <span class="number">1</span>) +<span class="string">&quot;个评委的分数：&quot;</span>);</span><br><span class="line">    <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">    scores[i] = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、遍历数组中的每个元素进行求和</span></span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line">    sum += scores[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;选手最终得分是：&quot;</span> + sum / scores.length);</span><br></pre></td></tr></table></figure><h2 id="三、数组在计算机中的执行原理"><a href="#三、数组在计算机中的执行原理" class="headerlink" title="三、数组在计算机中的执行原理"></a>三、数组在计算机中的执行原理</h2><p>好的各位同学，在前面我们已经学习了数组的基本使用，也理解了数组的基本原理。由于数组是一个容器，变量也是一个容器，在理解他们执行原理的时候，有些同学就容易搞混，现在我把他们放在一起带着大家回顾一下他们的会执行原理，顺便带着大家详细理解一下Java程序的执行的内存原理。</p><h3 id="3-1-数组的执行原理，Java程序的执行原理"><a href="#3-1-数组的执行原理，Java程序的执行原理" class="headerlink" title="3.1 数组的执行原理，Java程序的执行原理"></a>3.1 数组的执行原理，Java程序的执行原理</h3><p>我们以下面的代码，来讲解变量、数组的执原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">44</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">55</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们给大家讲过，程序是在内存中执行的。实际上Java程序是把编译后的字节码加载到Java虚拟机中执行的。</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661437717797.png" alt="1661437717797"></p><p>Java为了便于虚拟机执行Java程序，将虚拟机的内存划分为 方法区、栈、堆、本地方法栈、寄存器 这5块区域。同学们需要重点关注的是  <strong>方法区、栈、堆</strong>。</p><p>下面把每一个块内存区域作用介绍一下，我们大致只需要知道每一部分存储什么内容就行。</p><ul><li><strong>方法区</strong>：字节码文件先加载到这里</li><li><strong>栈</strong>：方法运行时所进入的内存区域，由于变量在方法中，所以变量也在这一块区域中</li><li><strong>堆</strong>：存储new出来的东西，并分配地址。由于数组是new 出来的，所以数组也在这块区域。</li></ul><p>下面是上面案例执行的内存原理如下图所示，按照① ② ③ ④ ⑤ ⑥ 的标记的顺序来看</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661438278304.png" alt="1661438278304"></p><p><strong>总结一下<code>int a = 10</code>与 <code>int[] arr = new int[]&#123;11,22,33&#125;的区别</code></strong></p><ul><li><strong>a</strong>是一个变量，在栈内存中，<strong>a</strong>变量中存储的数据就是<strong>10</strong>这个值。</li><li><strong>arr</strong>也是一个变量，在栈中，存储的是数组对象在堆内存中的地址值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的int a是一个基本类型变量，存储的是一个数值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> ; </span><br><span class="line"><span class="comment">//这里的int[] arr是一个引用类型的变量，存储的是一个地址值</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-多个变量指向同一个数组的问题"><a href="#3-2-多个变量指向同一个数组的问题" class="headerlink" title="3.2 多个变量指向同一个数组的问题"></a>3.2 多个变量指向同一个数组的问题</h3><p>各位同学，我们了解了数组在内存中的执行原理。我们知道数组类型的变量，指向的是堆内存中数组对象的地址。但是在实际开发中可能存在一种特殊情况，就是多个变量指向同一个数组对象的形式。</p><p>讲解这个知识点的目的，是让同学们注意多个变量指向同一个数组对象存在什么问题？</p><p>我们先看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：认识多个变量指向同一个数组对象的形式，并掌握其注意事项。</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把int类型的数组变量arr1赋值给int类型的数组变量arr2</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = arr1;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line"></span><br><span class="line">        arr2[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">        System.out.println(arr1[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        arr2 = <span class="literal">null</span>; <span class="comment">// 拿到的数组变量中存储的值是null</span></span><br><span class="line">        System.out.println(arr2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(arr2[0]);</span></span><br><span class="line">        <span class="comment">//System.out.println(arr2.length);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点关注这一段代码</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661439843879.png" alt="1661439843879"></p><p>刚执行完<code>int[] arr1 = &#123;11,22,33&#125;;</code>时，内存原理如下</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661439986204.png" alt="1661439986204"></p><p>当执行完<code>int[] arr2 = arr1;</code>后，内存原理如下</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661440179341.png" alt="1661440179341"></p><p>当执行到<code>arr2[1]=99;时</code>，内存原理如下</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661440425901.png" alt="1661440425901"></p><p><strong>总结一下：</strong></p><ul><li><p>两个变量指向同一个数组时，两个变量记录的是同一个地址值。</p></li><li><p>当一个变量修改数组中的元素时，另一个变量去访问数组中的元素，元素已经被修改过了。</p></li></ul><p>到这里有关数组的基本操作，和内存原理我们就全部学习完了。</p><h2 id="四、数组专项练习"><a href="#四、数组专项练习" class="headerlink" title="四、数组专项练习"></a>四、数组专项练习</h2><p>接下来我们做一些专项练习题，把数组的常见操作练习一下。在学习这个案例时，重点掌握数组求最值的思路，代码只是用来表达你的思路的。</p><h3 id="4-1-数组求最值"><a href="#4-1-数组求最值" class="headerlink" title="4.1 数组求最值"></a>4.1 数组求最值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求：定义一个<span class="type">int</span>类型数组，求数组中元素的最大值，并打印最大值</span><br></pre></td></tr></table></figure><p>我们先看一下选美比赛，是怎么选出颜值最高的人的。然后再以此思路，来写代码找出数组中元素的最大值。</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661441712915.png" alt="1661441712915"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组求最大值思路：</span><br><span class="line"><span class="number">1</span>)先找出数组中<span class="number">0</span>索引的元素，假设为最大值，用max表示【擂主】</span><br><span class="line"><span class="number">2</span>)遍历后面的每一个元素和max比较，把较大的元素值重新赋值给max(擂主换人)</span><br><span class="line">    <span class="number">3</span>)最后max就是所有元素的最大值(最后站在台上的擂主)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、把颜值数据拿到程序中来，用数组装起来</span></span><br><span class="line">        <span class="type">int</span>[] faceScores = &#123;<span class="number">15</span>, <span class="number">9000</span>, <span class="number">10000</span>, <span class="number">20000</span>, <span class="number">9500</span>, -<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个变量用于最终记住最大值。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> faceScores[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从数组的第二个位置开始遍历。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; faceScores.length; i++) &#123;</span><br><span class="line">            <span class="comment">// i = 1  2  3  4  5</span></span><br><span class="line">            <span class="comment">// 判断一下当前遍历的这个数据，是否大于最大值变量max存储的数据，</span></span><br><span class="line">            <span class="comment">//如果大于，当前遍历的数据需要赋值给max</span></span><br><span class="line">            <span class="keyword">if</span>(faceScores[i] &gt; max )&#123;</span><br><span class="line">                max = faceScores[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最高颜值是：&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结一下：</strong></p><p>通过这个案例，我们主要掌握求最值的思路，以后不管遇到求最大值还是最小值，编程思路都是一样的，不同的可能是数据不同。</p><h3 id="4-2-数组元素反转"><a href="#4-2-数组元素反转" class="headerlink" title="4.2 数组元素反转"></a>4.2 数组元素反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需求：某个数组有<span class="number">5</span>个数据：<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>，请将这个数组中的数据进行反转。</span><br><span class="line">      [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]  反转后 [<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>数组元素反转的核心，其实是数组中两个数据的交换。我们可以认为两个数据分别存储在两个水杯中。想要交换两个水杯中的东西，我们得借助第三个水杯，如下图所示</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661442733592.png" alt="1661442733592"></p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661442758553.png" alt="1661442758553"></p><p>数组中元素交换，就是用的借用第三方变量的思想。 我们把数组中的每一个元素当做一个水杯，然后索引控制哪两个元素互换位置。</p><p>怎么样，才能达到元素反转的效果呢？我们只需将第一个和最后一个元素互换、第二个和倒数第二个互换、依次内推…. 如下图所示</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661443189060.png" alt="1661443189060"></p><p>怎么样写代码，才能达到上面的效果呢？我们继续分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>每次交换，需要有左右两边的两个索引，我们可以用i和j表示</span><br><span class="line">刚开始i=<span class="number">0</span>，j=数组长度-<span class="number">1</span>;</span><br><span class="line"><span class="number">2.</span>每次让i和j索引位置的两个元素互换位置</span><br><span class="line">arr[i]和arr[j]互换位置</span><br><span class="line"><span class="number">3.</span>每次还完位置之后，让i往右移动一位，让j往前移动一位</span><br></pre></td></tr></table></figure><p>具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：完成数组反转。</span></span><br><span class="line">        <span class="comment">// 1、准备一个数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个循环，设计2个变量，一个在前，一个在后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = arr.length - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="comment">// arr[i]   arr[j]</span></span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            <span class="comment">// 1、定义一个临时变量记住后一个位置处的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">            <span class="comment">// 2、把前一个位置处的值赋值给后一个位置了</span></span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            <span class="comment">// 3、把临时变量中记住的后一个位置处的值赋值给前一个位置处</span></span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、遍历数组中的每个数据，看是否反转成功了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结一下：</strong></p><p>通过上面的案例，需要我们掌握元素互换位置的编程思路；以后遇到数据互换问题，都这样做。</p><h3 id="4-3-随机排名"><a href="#4-3-随机排名" class="headerlink" title="4.3 随机排名"></a>4.3 随机排名</h3><p>各位同学，通过数组元素反转的案例，我们学会了如何对两个数据进行交换。接下来，我们再学习随机排名案例，将数据交换的思路再巩固一下。</p><p>先来看一下需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求：某公司开发部<span class="number">5</span>名开发人员，要进行项目进展汇报演讲，现在采取随机排名后进行汇报。请先依次录入<span class="number">5</span>名员工的工号，然后展示出一组随机的排名顺序。</span><br></pre></td></tr></table></figure><p>分析一下随机排名的思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在程序中录入<span class="number">5</span>名员工的工号存储起来 ---&gt; 使用动态初始化数组的方式。</span><br><span class="line"><span class="number">2.</span>依次遍历数组中的每个数据。</span><br><span class="line"><span class="number">3.</span>每遍历到一个数据，都随机一个索引值出来，让当前数据与该索引位置处的数据进行交换。</span><br></pre></td></tr></table></figure><p>如下图所示，每次遍历到一个元素，随机将当前位置元素和随机索引元素换位置。</p><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661444407716.png" alt="1661444407716"></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：完成随机排名</span></span><br><span class="line">        <span class="comment">// 1、定义一个动态初始化的数组用于存储5名员工的工号</span></span><br><span class="line">        <span class="type">int</span>[] codes = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、提示用户录入5名员工的工号。</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; codes.length; i++) &#123;</span><br><span class="line">            <span class="comment">// i = 0 1 2 3 4</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入第&quot;</span> + (i + <span class="number">1</span>) +<span class="string">&quot;个员工的工号：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            codes[i] = code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、打乱数组中的元素顺序。</span></span><br><span class="line">        <span class="comment">// [12, 33, 54, 26, 8]</span></span><br><span class="line">        <span class="comment">//  i       index</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; codes.length; i++) &#123;</span><br><span class="line">            <span class="comment">// codes[i]</span></span><br><span class="line">            <span class="comment">// 每遍历到一个数据，都随机一个数组索引范围内的值。</span></span><br><span class="line">            <span class="comment">//然后让当前遍历的数据与该索引位置处的值交换。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(codes.length); <span class="comment">// 0 - 4</span></span><br><span class="line">            <span class="comment">// 定义一个临时变量记住index位置处的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> codes[index];</span><br><span class="line">            <span class="comment">// 把i位置处的值赋值给index位置处</span></span><br><span class="line">            codes[index] = codes[i];</span><br><span class="line">            <span class="comment">// 把index位置原来的值赋值给i位置处</span></span><br><span class="line">            codes[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、遍历数组中的工号输出即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; codes.length; i++) &#123;</span><br><span class="line">            System.out.print(codes[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这有关数组的常见练习题我们就讲完了，待会我们在给同学们讲一个开发中用得比较多的工具叫做Debug调试。</p><h2 id="五、Debug调试工具"><a href="#五、Debug调试工具" class="headerlink" title="五、Debug调试工具"></a>五、Debug调试工具</h2><p>各位同学，为了让大家更好的理解代码的执行流程，这里给大家讲一个在开发中非常重要的工具——叫做Debug调试。 </p><p>通过Debug调试，我们可以查看代码的执行流程。当你代码中有Bug但是又发现不了的时候，你就可以用Debug调试工具，查看执行流程，逐步分析是哪一行出现了问题。</p><p>Debug调试工具的使用步骤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步：打断点，如下图的红色小圆点</span><br><span class="line">第二步：右键Debug方式启动程序，如下图右键菜单</span><br><span class="line">  启动后，代码会停留在打断点的这一行</span><br><span class="line">第三步：点击箭头按钮，一行一行往下执行</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/1661444896100.png" alt="1661444896100"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、认识数组&quot;&gt;&lt;a href=&quot;#一、认识数组&quot; class=&quot;headerlink&quot; title=&quot;一、认识数组&quot;&gt;&lt;/a&gt;一、认识数组&lt;/h2&gt;&lt;p&gt;先来认识一下什么数组&lt;/p&gt;
&lt;h3 id=&quot;1-什么数组&quot;&gt;&lt;a href=&quot;#1-什么数组&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="https://wxzhou.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wxzhou.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java-day05-方法</title>
    <link href="https://wxzhou.top/2020/05/05/day05-%E6%96%B9%E6%B3%95/"/>
    <id>https://wxzhou.top/2020/05/05/day05-%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-05T07:43:32.000Z</published>
    <updated>2024-02-12T11:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来学习一下方法是什么</p><h2 id="一、方法概述"><a href="#一、方法概述" class="headerlink" title="一、方法概述"></a>一、方法概述</h2><p><strong>1.1 方法是什么</strong></p><p><strong>方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用。</strong>这句话什么意思呢？意思是，把一段功能代码围在一起，别人都可以来调用它。</p><p>下图是方法的完整格式</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661667297650.png" alt="1661667297650"></p><p>我们看一个需求，比如现在张工、李工两个人都需要求两个整数的和。不使用方法，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、李工。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a+b;</span><br><span class="line">System.out.println(<span class="string">&quot;和是：&quot;</span> + c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、张工。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> a1+b1;</span><br><span class="line">System.out.println(<span class="string">&quot;和是：&quot;</span> + c1);</span><br></pre></td></tr></table></figure><p>阅读上面的代码，我们不难发现。两次求和的代码中，除了求和的数据不一样，代码的组织结构完全一样。</p><p><strong>像这种做相同事情的代码，就可以用方法进行封装</strong>。需要用到这段代码功能时，让别人调用方法就行。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标：掌握定义方法的完整格式，搞清楚使用方法的好处。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：假如现在很多程序员都要进行2个整数求和的操作。</span></span><br><span class="line">        <span class="comment">// 1、李工。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;和是：&quot;</span> + rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、张工。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs2</span> <span class="operator">=</span> sum(<span class="number">30</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;和是：&quot;</span> + rs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.2 方法的执行流程</strong></p><p>当调用一个方法时，执行流程，按照下图中标注的序号执行。</p><p>​① 通过sum方法名找到sum方法</p><p>​② 把10传递给方法中的参数a</p><p>​③ 把20传递给方法中的参数b；</p><p>​④  执行方法中的代码，此时<code>int c=a+b;</code>; 相当于 <code>int c = 10+20</code>; c的值为30</p><p>​ <code>return c</code> 的含义是，把c的结果返回给调用处。 也就是调用sum方法的结果为30,</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661668878007.png" alt="1661668878007"></p><p>学习完方法的执行流程之后，下面有几个注意事项需要我们写代码时注意一下。</p><p><strong>1.3 定义方法的注意点</strong></p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661680196574.png" alt="1661680196574"></p><ol><li><p>方法的修饰符：暂时都使用public static 修饰。（目前看做是固定写法，后面是可以改动的）</p></li><li><p>方法申明了具体的返回值类型，内部必须使用return返回对应类型的数据。</p></li><li><p>形参列表可以有多个，甚至可以没有； 如果有多个形参，多个形参必须用“，”隔开，且不能给初始化值。</p></li></ol><p><strong>1.4 使用方法的好处</strong></p><p>最好，我们总结一下，用方法有什么好处，可以归纳为下面2点：</p><ol><li>提高了代码的复用性，提高了开发效率。</li><li>让程序的逻辑更清晰。</li></ol><p>如下图所示：写好一个方法之后，每一个人都可以直接调用，而不用再重复写相同的代码。所以是提高了代码的复用性，不用写重复代码，自然也提高了开发效率。</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661680445407.png" alt="1661680445407"></p><p>那么让程序的逻辑更加清晰，是如何体现的呢？ 比如，我们后期会用所学习的技术，做一个ATM系统，ATM系统中有查看账户、存钱、取钱、修改密码等功能，到时候我们可以把每一个功能都写成一个方法。如下图所示，这样程序的逻辑就更加清晰了。</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661680833652.png" alt="1661680833652"></p><p>好了，关于方法是什么，以及方法的基本使用就学习到这里。</p><p><strong>总结一下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>什么是方法？</span><br><span class="line">答：方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用</span><br><span class="line"><span class="number">2.</span>方法的完整格式是什么样的？</span><br><span class="line"><span class="comment">//格式如下：</span></span><br><span class="line">修饰符  返回值类型  方法名( 形参列表 )&#123;</span><br><span class="line">    方法体代码(需要执行的功能代码)</span><br><span class="line">       <span class="keyword">return</span> 返回值;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">3.</span>方法要执行必须怎么办？</span><br><span class="line">必须调用才执行; </span><br><span class="line"><span class="comment">//调用格式:</span></span><br><span class="line">方法名(...);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>使用方法有什么好处？</span><br><span class="line">答：提高代码的复用性，提高开发效率，使程序逻辑更清晰。</span><br></pre></td></tr></table></figure><h2 id="二、方法的其他形式"><a href="#二、方法的其他形式" class="headerlink" title="二、方法的其他形式"></a>二、方法的其他形式</h2><p>各位同学，刚才我们学习了定义完整格式的方法。但是实际开发中，需要按照方法解决的实际业务需求，设计出合理的方法形式来解决问题。</p><p>实际上设计一个合理的方法，需要重点关注下面两点</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661685360525.png" alt="1661685360525"></p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661685287374.png" alt="1661685287374"></p><p>设计一个合理的方法的原则如下：</p><ul><li>如果方法不需要返回数据，返回值类型必须申明成void（无返回值申明）,  此时方法内部不可以使用return返回数据。</li><li>方法如果不需要接收外部传递进来的数据，则不需要定义形参，且调用方法时也不可以传数据给方法。</li><li>没有参数，且没有返回值类型（void）的方法，称为值无参数、无返回值方法。此时调用方法时不能传递数据给方法。</li></ul><p>接下来我们看几个案例代码，练习根据实际需求定义出合理的方法</p><p><strong>需求1：写一个方法，打印3个”Hello World”</strong></p><p>分析：需求已经非常明确，打印的是3个HelloWorld，在方法中直接循环3次就可以完成需求。不需要外部给方法传递数据，所以不需要参数。</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661686972979.png" alt="1661686972979"></p><p><strong>需求2：写一个方法，打印若干个”Hello World”，具体多少个，有调用者指定</strong></p><p>分析：需求不明确打印HelloWorld的个数，而是需要调用者指定。也就是说，调用者调用方法时需要给方法传递打印HelloWorld的个数。那么定义方法时，就需要写一个参数，来接收调用者传递过来的个数。</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661687241729.png" alt="1661687241729"></p><h2 id="三、方法使用常见的问题"><a href="#三、方法使用常见的问题" class="headerlink" title="三、方法使用常见的问题"></a>三、方法使用常见的问题</h2><p>各位同学，自己第一次写方法时，或多或少会可能会出现一些问题。下面把使用方法时，常见的问题整理一下。</p><p>目的是让同学们，以后写方法时避免出现这些问题。一旦出现这些问题，要知道是什么原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- <span class="number">1.</span> 方法在内种没有先后顺序，但是不能把一个方法定义在另一个方法中。</span><br><span class="line"></span><br><span class="line">- <span class="number">2.</span> 方法的返回值类型写<span class="keyword">void</span>（无返回申明）时，方法内不能使用<span class="keyword">return</span>返回数据，</span><br><span class="line">如果方法的返回值类型写了具体类型，方法内部则必须使用<span class="keyword">return</span>返回对应类型的数据。</span><br><span class="line"></span><br><span class="line">- <span class="number">3.</span> <span class="keyword">return</span>语句的下面，不能编写代码，属于无效的代码，执行不到这儿。</span><br><span class="line"></span><br><span class="line">- <span class="number">4.</span> 方法不调用就不会执行,  调用方法时，传给方法的数据，必须严格匹配方法的参数情况。</span><br><span class="line"></span><br><span class="line">- <span class="number">5.</span> 调用有返回值的方法，有<span class="number">3</span>种方式：</span><br><span class="line">     ① 可以定义变量接收结果 </span><br><span class="line">     ② 或者直接输出调用，</span><br><span class="line">     ③ 甚至直接调用；</span><br><span class="line"></span><br><span class="line">- <span class="number">6.</span> 调用无返回值的方法，只有<span class="number">1</span>种方式： 只能直接调用。</span><br></pre></td></tr></table></figure><h2 id="四、方法的案例"><a href="#四、方法的案例" class="headerlink" title="四、方法的案例"></a>四、方法的案例</h2><h3 id="4-1-方法案例1"><a href="#4-1-方法案例1" class="headerlink" title="4.1 方法案例1"></a>4.1 方法案例1</h3><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661687914420.png" alt="1661687914420"></p><p>按照需求：定义方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">需要求1~n的和，由于n不确定是多少，所以就把n写成形式参数，n的具体值由调用者指定。</span></span><br><span class="line"><span class="comment">在方法中把n当做一个确定的数据来使用就行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// i = 1 2 3 ... n</span></span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好方法之后，在main方法中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> add(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;1-5的和是：&quot;</span> + rs); <span class="comment">//15</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> add(<span class="number">6</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;1-6的和是：&quot;</span> + rs); <span class="comment">//21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-方法案例2"><a href="#4-2-方法案例2" class="headerlink" title="4.2 方法案例2"></a>4.2 方法案例2</h3><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661687941843.png" alt="1661687941843"></p><p>按照需求：定义方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">需求中，是要判断一个数是奇数还是偶数，但是并没有明确说，是哪一个数。</span></span><br><span class="line"><span class="comment">也就是说这个数可能是奇数，也可以能是偶数，是一个能够变化的数。</span></span><br><span class="line"><span class="comment">把这个数写成方法的形式参数，就可以达到这个目的。因为调用方法时，调用者可以给传递  奇数，也可以传递偶数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(number + <span class="string">&quot;是一个偶数！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(number + <span class="string">&quot;是一个奇数！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好方法之后，在main方法中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    judge(<span class="number">7</span>); <span class="comment">//调用后打印：7是一个奇数</span></span><br><span class="line">    judge(<span class="number">8</span>); <span class="comment">//调用后打印：8是一个偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、方法在计算机中的执行原理"><a href="#五、方法在计算机中的执行原理" class="headerlink" title="五、方法在计算机中的执行原理"></a>五、方法在计算机中的执行原理</h2><p>各位同学，刚才我们已经写了好几个方法并成功调用了。但是不知道同学们奇不奇怪一个问题。方法在计算机的内存中到底是怎么干的呢？</p><p>为了让大家更加深刻的理解方法的执行过程，接下来，给同学们讲一下方法在计算机中的执行原理。理解方法的执行原理，对我们以后知识的学习也是有帮助的。</p><p>我们知道Java程序的运行，都是在内存中执行的，而内存区域又分为栈、堆和方法区。那Java的方法是在哪个内存区域中执行呢？</p><p>答案是栈内存。 <strong>每次调用方法，方法都会进栈执行；执行完后，又会弹栈出去。</strong></p><p>方法进栈和弹栈的过程，就类似于手枪子弹夹，上子弹和击发子弹的过程。最后上的一颗子弹是，第一个打出来的；第一颗上的子弹，是最后一个打出来的。</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661689511649.png" alt="1661689511649"></p><p>假设在main方法中依次调用A方法、B方法、C方法，在内存中的执行流程如下：</p><ul><li>每次调用方法，方法都会从栈顶压栈执行没执行</li><li>每个方法执行完后，会从栈顶弹栈出去</li></ul><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661692070922.png" alt="1661692070922"></p><h3 id="5-1-有返回值的方法，内存分析"><a href="#5-1-有返回值的方法，内存分析" class="headerlink" title="5.1 有返回值的方法，内存分析"></a>5.1 有返回值的方法，内存分析</h3><p>下面我们分析一下，求两个整数和的代码，在内存中的执行原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b )</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b; </span><br><span class="line">        <span class="keyword">return</span> c;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示：以上代码在内存中的执行过程，按照①②③④⑤⑥⑦的步骤执行.</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661694127049.png" alt="1661694127049"></p><h3 id="5-2-无返回值的方法，内存分析"><a href="#5-2-无返回值的方法，内存分析" class="headerlink" title="5.2 无返回值的方法，内存分析"></a>5.2 无返回值的方法，内存分析</h3><p>刚才我们分析的是有有参数有返回值的方法内存原理。下面再分析一个无返回值、无参数的内存原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2Method</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        study();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">eat();</span><br><span class="line">System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">sleep();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661696067585.png" alt="1661696067585"></p><p><strong>总结一下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>方法的运行区域在哪里？</span><br><span class="line">答：栈内存。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>栈有什么特点？方法为什么要在栈中运行自己？</span><br><span class="line">答：先进后出。保证一个方法调用完另一个方法后，可以回来继续执行。</span><br></pre></td></tr></table></figure><h2 id="六、方法参数的传递机制"><a href="#六、方法参数的传递机制" class="headerlink" title="六、方法参数的传递机制"></a>六、方法参数的传递机制</h2><p>各位同学，刚才我们学习了方法运行的原理，相信大家对方法的运行过程有更加深刻的认识。但是方法参数的传递过程还需要，还需要进一步学习一下。</p><p>因为我们刚才演示的一些方法中传递的参数都是基本类型，实际上参数还可以是传递引用类型。接下来，学习一下当参数是基本类型时、和参数是引用类型时的区别。</p><p>先记住一个结论：<strong>Java的参数传递机制都是：值传递</strong></p><p>所谓值传递：指的是在传递实参给方法的形参的时候，传递的是实参变量中存储的值的副本。 同学们肯定想知道，形参是什么？实参又是什么呢？ 请看下面这个张图</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661725157681.png" alt="1661725157681"></p><h3 id="6-1-参数传递的基本类型数据"><a href="#6-1-参数传递的基本类型数据" class="headerlink" title="6.1 参数传递的基本类型数据"></a>6.1 参数传递的基本类型数据</h3><p>接下来，看一下方法参数传递是基本类型数据时，内存中是怎么执行的。</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661725470322.png" alt="1661725470322"></p><p>我们把参数传递的结论再复习一下：<strong>Java的参数传递机制都是：值传递，传递的是实参存储的值的副本。</strong></p><h3 id="6-3-参数传递的是引用数据类型"><a href="#6-3-参数传递的是引用数据类型" class="headerlink" title="6.3 参数传递的是引用数据类型"></a>6.3 参数传递的是引用数据类型</h3><p>接下来，看一下方法的参数是引用类型的数据时，内存中是怎么执行的。</p><p><img src="/2020/05/05/day05-%E6%96%B9%E6%B3%95/1661728059814.png" alt="1661728059814"></p><p>我们发现调用change方法时参数是引用类型，<strong>实际上也是值传递，只不过参数传递存储的地址值</strong>。此时change方法和main方法中两个方法中各自有一个变量arrs，这两个变量记录的是同一个地址值[I@4c873330，change方法把数组中的元素改了，main方法在访问时，元素已经被修改了。</p><p><strong>总结一下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>基本类型和引用类型的参数在传递的时候有什么不同？</span><br><span class="line">= 都是值传递</span><br><span class="line">- 基本类型的参数传递存储的数据值。</span><br><span class="line">    - 引用类型的参数传递存储的地址值。</span><br></pre></td></tr></table></figure><h2 id="七、方法参数传递案例"><a href="#七、方法参数传递案例" class="headerlink" title="七、方法参数传递案例"></a>七、方法参数传递案例</h2><h3 id="7-1-方法参数传递案例1"><a href="#7-1-方法参数传递案例1" class="headerlink" title="7.1 方法参数传递案例1"></a>7.1 方法参数传递案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">需求：输出一个<span class="type">int</span>类型的数组内容，要求输出格式为：[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]。</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line"> <span class="number">1.</span>方法是否需要接收数据进行处理？</span><br><span class="line"> 方法要打印<span class="type">int</span>类型数组中的元素，打印哪一个数组需求并不明确；</span><br><span class="line">        所以可以把<span class="type">int</span>数组写成参数，让调用者指定</span><br><span class="line">        </span><br><span class="line"> <span class="number">2.</span>方法是否需要返回数据？</span><br><span class="line"> 方法最终的目的知识打印数组中的元素。</span><br><span class="line"> 不需要给调用者返回什么，所以不需要返回值，返回值类型写<span class="keyword">void</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">3.</span>方法内部的业务：遍历数组，并输出相应的内容</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：完成打印int类型的数组内容。</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">70</span>&#125;;</span><br><span class="line">        printArray(arr);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="literal">null</span>;</span><br><span class="line">        printArray(arr2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr3 = &#123;&#125;;</span><br><span class="line">        printArray(arr3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数：int[] arr表示要被打印元素的数组，需要调用者传递</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(arr); <span class="comment">// null</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 跳出当前方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="comment">// 直接遍历接到的数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[i] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-方法参数传递案例2"><a href="#7-2-方法参数传递案例2" class="headerlink" title="7.2 方法参数传递案例2"></a>7.2 方法参数传递案例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">需求：比较两个<span class="type">int</span>类型的数组是否一样，返回<span class="literal">true</span>或者<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line"><span class="number">1.</span>方法是否需要接收数据进行处理？</span><br><span class="line">因为，方法中需要两个<span class="type">int</span>数组比较，但是需求并不明确是哪两个数组；</span><br><span class="line">所以，需要接收两个<span class="type">int</span>类型的数组，形参声明为：<span class="type">int</span>[] arr1，<span class="type">int</span>[] arr2 </span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span>方法是否需要返回数据？</span><br><span class="line"> 因为,方法最终的结果需要<span class="literal">true</span>或者<span class="literal">false</span>;</span><br><span class="line">所以，返回值类型是<span class="type">boolean</span></span><br><span class="line"> </span><br><span class="line"><span class="number">3.</span> 方法内部的业务：判断两个数组内容是否一样。</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：完成判断两个int类型的数组是否一样。</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        System.out.println(equals(arr1, arr2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">    int[] arr1, 参与比较的第一个int数组</span></span><br><span class="line"><span class="comment">    int[] arr2  参与比较的第二个int数组</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">    返回比较的结果true或者false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、判断arr1和arr2是否都是null.</span></span><br><span class="line">        <span class="keyword">if</span>(arr1 == <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 相等的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、判断arr1是null，或者arr2是null.</span></span><br><span class="line">        <span class="keyword">if</span>(arr1 == <span class="literal">null</span> || arr2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不相等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、判断2个数组的长度是否一样，如果长度不一样，直接返回false.</span></span><br><span class="line">        <span class="keyword">if</span>(arr1.length != arr2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不相等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、两个数组的长度是一样的，接着比较它们的内容是否一样。</span></span><br><span class="line">        <span class="comment">// arr1 = [10, 20, 30]</span></span><br><span class="line">        <span class="comment">// arr2 = [10, 20, 30]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断当前位置2个数组的元素是否不一样，不一样直接返回false</span></span><br><span class="line">            <span class="keyword">if</span>(arr1[i] != arr2[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不相等的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 两个数组是一样的。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="八、方法重载"><a href="#八、方法重载" class="headerlink" title="八、方法重载"></a>八、方法重载</h2><p>接下来，我们学习一个开发中很重要的一个方法的形式——叫方法重载。</p><p>所谓方法重载指的是：一个类中，出现多个相同的方法名，但是它们的形参列表是不同的，那么这些方法就称为方法重载了。</p><p>我们在这里要能够认识，哪些是重载的方法。</p><p>下面案例中有多个test方法，但是参数列表都不一样，它们都是重载的方法。调用时只需要通过参数来区分即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodOverLoadDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：认识方法重载，并掌握其应用场景。</span></span><br><span class="line">        test();</span><br><span class="line">        test(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test1===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test2===&quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">double</span> a)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> b, <span class="type">double</span> a)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们认识了方法重载，那么方法重载有哪些应用场景呢？ </p><p>一般在开发中，我们经常需要为处理一类业务，提供多种解决方案，此时用方法重载来设计是很专业的。</p><p>比如，我们现在看一个案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需求：开发武器系统，功能需求如下：</span><br><span class="line">    可以默认发一枚武器。</span><br><span class="line">    可以指定地区发射一枚武器。</span><br><span class="line">    可以指定地区发射多枚武器。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的几个需求中，不管以什么样的方式发武器，其实最终的目的都是发武器。</p><p>所以我们可以设计几个名称相同的方法，这样调用者调用起来就不用记那么多名字了</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握方法重载的应用场景。</span></span><br><span class="line">        fire();</span><br><span class="line">        fire(<span class="string">&quot;岛国2&quot;</span>);</span><br><span class="line">        fire(<span class="string">&quot;米国&quot;</span>, <span class="number">999</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span>&#123;</span><br><span class="line">        fire(<span class="string">&quot;岛国&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">(String country)</span>&#123;</span><br><span class="line">        fire(country, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">(String country, <span class="type">int</span> number)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发射了&quot;</span> + number + <span class="string">&quot;枚武器给&quot;</span> + country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结一下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>什么是方法重载？</span><br><span class="line">答：一个类中，多个方法的名称相同，但它们形参列表不同。</span><br><span class="line"><span class="number">2.</span>方法重载需要注意什么？</span><br><span class="line">- 一个类中，只要一些方法的名称相同、形参列表不同，那么它们就是方法重载了，</span><br><span class="line">  其它的都不管（如：修饰符，返回值类型是否一样都无所谓）。</span><br><span class="line"></span><br><span class="line">- 形参列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、方法重载有啥应用场景？</span><br><span class="line">答：开发中我们经常需要为处理一类业务，提供多种解决方案，此时用方法重载来设计是很专业的。</span><br></pre></td></tr></table></figure><h2 id="九、return单独使用"><a href="#九、return单独使用" class="headerlink" title="九、return单独使用"></a>九、return单独使用</h2><p>各位同学，关于方法的定义，我们还剩下最后一种特殊用法，就是在方法中单独使用return语句，可以用来提前结束方法的执行。</p><p>如，下面的chu方法中，当除数为0时，就提前结束方法的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        chu(<span class="number">10</span> , <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">            System.err.println(“您的数据有误！！不执行！！”);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 直接跳出并结束当前chu方法的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        System.out.println(<span class="string">&quot;除法结果是：&quot;</span>+c); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天的课程就到此结束了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们先来学习一下方法是什么&lt;/p&gt;
&lt;h2 id=&quot;一、方法概述&quot;&gt;&lt;a href=&quot;#一、方法概述&quot; class=&quot;headerlink&quot; title=&quot;一、方法概述&quot;&gt;&lt;/a&gt;一、方法概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.1 方法是什么&lt;/strong&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="https://wxzhou.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wxzhou.top/tags/Java/"/>
    
  </entry>
  
</feed>
