{"meta":{"title":"wxzhou's blog","subtitle":"Record some technical posts.","description":"wxzhou's blog which records some technical posts.","author":"wxzhou","url":"https://wxzhou.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-07-08T15:21:58.836Z","updated":"2024-02-12T11:56:31.000Z","comments":false,"path":"/404.html","permalink":"https://wxzhou.top/404.html","excerpt":"","text":""},{"title":"Books","date":"2024-07-08T15:22:01.875Z","updated":"2024-02-12T11:56:31.000Z","comments":false,"path":"books/index.html","permalink":"https://wxzhou.top/books/index.html","excerpt":"","text":""},{"title":"About","date":"2024-07-08T15:22:01.874Z","updated":"2024-02-12T11:56:31.000Z","comments":false,"path":"about/index.html","permalink":"https://wxzhou.top/about/index.html","excerpt":"","text":"Java Development."},{"title":"Categories","date":"2024-07-08T15:22:01.877Z","updated":"2024-02-12T11:56:31.000Z","comments":false,"path":"categories/index.html","permalink":"https://wxzhou.top/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-07-08T15:22:01.881Z","updated":"2024-02-12T11:56:31.000Z","comments":false,"path":"repository/index.html","permalink":"https://wxzhou.top/repository/index.html","excerpt":"","text":""},{"title":"Links","date":"2024-07-08T15:22:01.879Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"links/index.html","permalink":"https://wxzhou.top/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2024-07-08T15:22:01.882Z","updated":"2024-02-12T11:56:31.000Z","comments":false,"path":"tags/index.html","permalink":"https://wxzhou.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux云服务器故障排查（内存优化）","slug":"Linux云服务器故障排查(内存优化)","date":"2023-08-20T07:51:44.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2023/08/20/Linux云服务器故障排查(内存优化)/","link":"","permalink":"https://wxzhou.top/2023/08/20/Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5(%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96)/","excerpt":"","text":"1. 内存占用 执行 top 命令查看系统的实时负载，进入 top 的实时界面后，默认按照 CPU 的使用率排序 通过 shift + m 按键将进程按照内存使用情况从大到小排序 2. Mysql 内存优化1234567MySQL 在启动的时候，会占用一部分的内存来作为缓冲区，这样做的原因是可以优化查询速度，我们可以发现只要查询过一次 MySQL，然后用相同的语句再次查询，第二次查询会比第一次更快，这其中就用到了 MySQL 自身的缓存系统。MySQL 的缓存机制是当某一个连接访问某张表时，MySQL 会先检查访问的表是否在缓存区中，如果这张表已经在缓存区中打开，那就会直接访问缓存区从而加快查询速度，如果这张表不在缓存区，那就会从实际的数据库文件进行查询，然后再把这张表加入缓存区，以便后续查询加快速度。由于这个机制我们的 MySQL 在运行过程占用的内存会逐渐增加，而本系统查询频率并不多，我们要做的就是去掉 MySQL 用来加快查询的各种机制。 2.1 修改 my.cnf 可以使用 mysql --help | grep &#39;my.cnf&#39; 来查看默认加载的 my.cnf 目录，排序前的优先 使用vim打开排在第一个的my.cnf，加入如下内容：1234table_open_cache=200table_definition_cache=400performance_schema_max_table_instances=400performance_schema=off 重启 MySQL：1service mysqld restart 3. Java 内存优化3.1 规定内存大小可以在 tomcat &#x2F;bin 目录下的 catalina.sh，设置 JAVA_OPTS 参数规定运行时内存使用情况。因为 tomcat 容器里的 java 都是一些小项目和 demo，用不着分配这么多内存，所以只需分配很小内存即可。 1JAVA_OPTS=&quot;$JAVA_OPTS -Xms64m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m&quot; 参数详解： Xms：Java 虚拟机堆区内存初始内存分配的大小 Xmx：Java 虚拟机堆区内存初始内存分配的最大上限 Xmn：Java 虚拟机堆区内存初始内存分配的最小值 XX:PermSize：非堆区初始化内存分配大小 XX:MaxPermSize：非堆区分配的内存的最大上限 XX:MaxNewSize：新生代可被分配的内存的最大上限 3.2 回收 buffer&#x2F;cache 创建脚本 cleanCache.sh 添加内容：1234567#!/bin/bashecho &quot;开始清除缓存&quot;sync;sync;sync # 写入硬盘，防止数据丢失sleep 10 # 延迟10秒echo 1 &gt; /proc/sys/vm/drop_cachesecho 2 &gt; /proc/sys/vm/drop_cachesecho 3 &gt; /proc/sys/vm/drop_caches 打开权限：1chmod +x cleanCache.sh 打开定时任务配置文件1crontab -e # 弹出配置文件 添加定时任务，每两小时执行一次12# 分 时 日 月 周 命令0 */2 * * * ./cleanCache.sh 设置 crond 启动以及开机自启12systemctl start crond.servicesystemctl enable crond.service 查看定时任务是否被执行1cat /var/log/cron | grep cleanCache","categories":[{"name":"Linux","slug":"Linux","permalink":"https://wxzhou.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wxzhou.top/tags/Linux/"}]},{"title":"解决IDEA配置.gitignore不生效的问题","slug":"解决IDEA配置-gitignore不生效的问题","date":"2023-07-20T11:05:29.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2023/07/20/解决IDEA配置-gitignore不生效的问题/","link":"","permalink":"https://wxzhou.top/2023/07/20/%E8%A7%A3%E5%86%B3IDEA%E9%85%8D%E7%BD%AE-gitignore%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1. 问题当使用IDEA提交项目数据到git时, 即使配置了提交忽略文件.gitignore,也无法生效,提交文件中会出现杂乱配置文件,不知道你自己所更改了哪些项目位置,查看比较麻烦 2. 原因.gitignore只能忽略未被track的文件，而git本地缓存。如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 3. 解决方案：解决方法就是先把本地缓存删除（改变成未track状态），然后再提交。使用以下几个命令即可快速解决 注意:以下命令需要在你项目中右键点击 Git Bash Here进行命令窗口输入 123git rm -r --cached .git add .git commit -m &#x27;update .gitignore&#x27;","categories":[{"name":"GIT","slug":"GIT","permalink":"https://wxzhou.top/categories/GIT/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://wxzhou.top/tags/IDEA/"},{"name":"GIT","slug":"GIT","permalink":"https://wxzhou.top/tags/GIT/"}]},{"title":"查看一台服务器上所有显卡上的使用者和GPU占用情况","slug":"查看一台服务器上所有显卡上的使用者和GPU占用情况","date":"2023-02-18T04:34:49.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2023/02/18/查看一台服务器上所有显卡上的使用者和GPU占用情况/","link":"","permalink":"https://wxzhou.top/2023/02/18/%E6%9F%A5%E7%9C%8B%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%89%80%E6%9C%89%E6%98%BE%E5%8D%A1%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%85%E5%92%8CGPU%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/","excerpt":"","text":"1.安装gpustat1pip install gpustat 2.安装完成后使用下面命令即可1watch -n 2 --color gpustat --c 3.查看显卡使用情况1nvidia-smi","categories":[{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/tags/Python/"},{"name":"Server","slug":"Server","permalink":"https://wxzhou.top/tags/Server/"}]},{"title":"Linux下在文件夹所有文件中查找相关内容","slug":"Linux下在文件夹所有文件中查找相关内容","date":"2023-02-15T07:51:44.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2023/02/15/Linux下在文件夹所有文件中查找相关内容/","link":"","permalink":"https://wxzhou.top/2023/02/15/Linux%E4%B8%8B%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/","excerpt":"","text":"1. 使用grep1.1 说明grep是在使用Linux时经常会用到的一个命令了，这个命令平时大都主要用来进行对一段输出的关键字定位，但是这个命令也可以通过使用某些参数来达到文件夹文件内容遍历的效果 1.2 语法1grep -nr &quot;str&quot; path 1.3 参数 grep: 就是grep命令 -nr: n是line number行号，r是recursive，可以理解为遍历文件文件夹 “str”: 双引号里面的str就是要查找的内容，用双引号何以使用空格和一些字符进行查找 path: path就是查找路径，默认是.&#x2F;，也就是当前目录开始，也可以手动指定目录 1.4 实例1grep -nr &quot;Welcome to the exchange link&quot; /home/wxzhou/project/PhaGCN2/z2/hexo 1.5 优缺点 优点：命令简单方便，简短 缺点：会遍历所有文件，效率较低 2. 使用find、xargs和grep配合2.1 说明find是查找指令，用来查找文件的；xargs可以将标准输入作为另一个命令的参数；grep上面已经解释过了。那么，如果使用find来循环查找文件，使用他输出的文件名作为参数给xargs，xargs再将文件名作为grep的参数输入，使用grep来查找文件内容进行定位不久可以实现文件内容查找了吗 2.2 语法1find path -name &quot;PATTEN&quot; | xargs grep -n &quot;str&quot; | grep &quot;str&quot; 2.3 参数 find、xargs、grep：上面已经讲过，分别是三个软件 name：就是通过名字查找，后面跟着的参数可以通过正则表达式类似的方法限定文件名 其他grep或者类似的参数据不赘述了 2.4 实例1find /home/$USER/.config -name &quot;*.sh&quot; | xargs grep &quot;/bin/bash&quot; | grep &quot;/bin/bash&quot; 2.5 优缺点 优点：可以通过-name来限定文件名，从而减少grep查看文件内容的次数，提高效率 缺点：命令冗长，难记","categories":[{"name":"Linux","slug":"Linux","permalink":"https://wxzhou.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wxzhou.top/tags/Linux/"}]},{"title":"Linux服务器环境安装","slug":"Linux服务器环境安装","date":"2023-02-15T07:51:44.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2023/02/15/Linux服务器环境安装/","link":"","permalink":"https://wxzhou.top/2023/02/15/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","excerpt":"","text":"linux安装部署启动 系统环境需求 12345678阿里云CentOS8.2JDK &gt;= 1.8Tomcat &gt;= 9.0MySQL &gt;= 5.7Maven &gt;= 3.0RedisNode.jsNginx 新建目录 1234567891011#tmp存放临时安装包mkdir -p /data/tmp#service存放软件环境mkdir -p /data/service#gitee存放代码版本控制库mkdir -p /data/git#app存放部署程序mkdir -p /data/app 开放 8080 端口 1234567891011121314# 检查防火墙状态firewall-cmd --state# running 表示防火墙是开启的，如果你看到的是 not running，防火墙关闭，需要开启systemctl restart firewalld.service# 开放 8080 端口firewall-cmd --zone=public --add-port=8080/tcp --permanent# 重启防火墙systemctl restart firewalld.service# 重新载入配置firewall-cmd --reload JDK安装 123456789101112131415161718#将jdk安装包上传到/data/tmp文件夹中#进入安装包目录，解压cd /data/tmptar -zxvf jdk-8u261-linux-x64.tar.gz#把解压出来的文件夹转移到统一的地方mv /data/tmp/jdk1.8.0_261 /data/service/jdk1.8.0_261#修改环境变量/etc/profile，JAVA_HOME修改为自己的jdk路径。vim /etc/profileexport JAVA_HOME=/data/service/jdk1.8.0_261export PATH=$PATH:$JAVA_HOME/bin#使环境变量生效source /etc/profile#检查是否配置成功java -version Tomcat安装 12345678910111213#将Tomcat安装包上传到/data/tmp文件夹中#进入安装包目录，解压cd /data/tmptar -zxvf apache-tomcat-9.0.34.tar.gz#把解压出来的文件夹转移到统一的地方mv /data/tmp/apache-tomcat-9.0.34 /data/service/apache-tomcat-9.0.34#启动Tomcat：进入目录/data/service/apache-tomcat-9.0.34/bin./startup.sh#关闭Tomcat./shutdown.sh Maven安装 123456789101112131415#进入安装包目录，解压cd /data/tmptar -zxvf apache-maven-3.9.3-bin.tar.gzmv apache-maven-3.9.3 /data/service/#修改环境变量/etc/profile，MAVEN_HOME修改为自己的路径。vim /etc/profileexport MAVEN_HOME=/data/service/apache-maven-3.9.3export PATH=$PATH:$MAVEN_HOME/bin#使环境变量生效source /etc/profile#检查是否配置成功mvn -v Git安装 123456789101112131415161718192021222324252627282930313233343536373839404142# 获取github最新的Git安装包下载链接，进入Linux服务器，执行下载，命令为： cd /data/tmp/wget https://github.com/git/git/archive/v2.17.0.tar.gz# 压缩包解压，命令为： tar -zxvf git-2.17.0.tar.gz# 移动文件夹mv /data/tmp/git-2.17.0 /data/service/git-2.17.0# 安装编译源码所需依赖，命令为：yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker # 安装依赖时，yum自动安装了Git，需要卸载旧版本Git，命令为： yum remove git# 进入解压后的文件夹，命令 cd /data/service/git-2.17.0 # 然后执行编译，命令为 make prefix=/usr/local/git all # 安装Git至/usr/local/git路径，命令为 make prefix=/usr/local/git install# 打开环境变量配置文件，命令 vim /etc/profile# 添加内容# gitexport GIT_HOME=/usr/local/git/export PATH=$PATH:$GIT_HOME/bin# 然后保存，退出，刷新source /etc/profile#检查是否配置成功git --versionssh-keygen -t rsa -C &quot;wxzhou20@qq.com&quot;cat ~/.ssh/id_rsa.pub MySQL安装 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 上传MySQL安装包到/data/tmp中# 解压缩tar -xvf mysql-8.0.20-1.el7.x86_64.rpm-bundle.tar # 删除自带的 mariadbrpm -qa | grep mariadbrpm -e mariadb-libs-5.5.65-1.el7.x86_64 --nodeps# 安装rpm -ivh mysql-community-common-8.0.20-1.el7.x86_64.rpm --nodeps --forcerpm -ivh mysql-community-libs-8.0.20-1.el7.x86_64.rpm --nodeps --forcerpm -ivh mysql-community-client-8.0.20-1.el7.x86_64.rpm --nodeps --forcerpm -ivh mysql-community-server-8.0.20-1.el7.x86_64.rpm --nodeps --force# 初始化Mysqlyum install -y libaiomysqld --initialize# 如果MySQL没有开启，可以使用如下代码开启service mysqld start# 授权防火墙chown mysql:mysql /var/lib/mysql -R;systemctl start mysqld.service;systemctl enable mysqld;# 查看数据库的初始化密码cat /var/log/mysqld.log | grep password# 登录数据库mysql -uroot -p# 修改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;# 开启远程访问create user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;flush privileges;exit# 开放 3306 端口firewall-cmd --zone=public --add-port=3306/tcp --permanentsystemctl restart firewalld.servicefirewall-cmd --reload Node.js安装 12345678tar xf node-v14.15.4-linux-x64.tar.xz // 解压cd node-v14.15.4-linux-x64/ // 进入解压目录./bin/node -v // 执行node命令 查看版本//解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接：mv /data/tmp/node-v14.15.4-linux-x64 /data/service/ln -s /data/service/node-v14.15.4-linux-x64/bin/npm /usr/local/bin/ln -s /data/service/node-v14.15.4-linux-x64/bin/node /usr/local/bin/ Nginx 安装 12345678910111213141516171819#首先安装nginx前置软件yum -y install gcc pcre-devel zlib-devel openssl openssl-devel#下载nginx软件安装包cd /data/tmpwget http://nginx.org/download/nginx-1.19.6.tar.gztar -zxvf nginx-1.19.6.tar.gzcd nginx-1.19.6#设置安装目录为/usr/local/nginx./configure --prefix=/usr/local/nginxmakemake install# 启动nginx/usr/local/nginx/sbin/nginx# 重启/usr/local/nginx/sbin/nginx -s reload Redis 安装 12345678910111213141516171819202122232425#下载Redis软件安装包cd /data/tmpwget http://download.redis.io/releases/redis-3.2.10.tar.gztar -xzvf redis-3.2.10.tar.gzmv /data/tmp/redis-3.2.10 /data/service/redis-3.2.10cd /data/service/redis-3.2.10# 安装makevim ./redis.conf(改动的位置：# 注释掉172.0.0.1（默认redis是只能内网127.0.0.1访问，如果想外网访问需要修改绑定的地址）61行：# bind 127.0.0.1# 关闭保护模式80行：protected-mode no# 设置redis可以一直在后台运行，以守护进程方式运行，即关闭SSH工具程序也在运行。128行：daemonize yes)# 启动redis服务/data/service/redis-3.2.10/src/redis-server /data/service/redis-3.2.10/redis.conf# 查看redis服务是否启动ps -ef | grep redis# 关闭redis进程kill -9 进程号 Docker 安装 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 1、yum 包更新到最新 yum update# 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的yum install -y yum-utils device-mapper-persistent-data lvm2# 3、 设置yum源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 4、 安装docker，出现输入的界面都按 yyum install -y docker-ce# 5、 查看docker版本，验证是否验证成功docker -v# 6. nacos安装# docker拉取镜像 docker pull nacos/nacos-server:1.2.0# 创建容器docker run -e JVM_XMS=100m -e JVM_XMX=100m -e MODE=standalone --name nacos --restart=always -d -p 8848:8848 nacos/nacos-server:1.2.0# 7. zookeeper安装docker pull zookeeper:3.4.14docker run --name zookeeper --restart=always -d -p 2181:2181 zookeeper:3.4.14# 8. kafka安装docker pull wurstmeister/kafka:2.12-2.3.1docker run -d --name kafka \\--env KAFKA_ADVERTISED_HOST_NAME=47.114.141.103 \\--env KAFKA_ZOOKEEPER_CONNECT=47.114.141.103:2181 \\--env KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://47.114.141.103:9092 \\--env KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \\--env KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms256M&quot; \\-p 9092:9092 wurstmeister/kafka:2.12-2.3.1# 9. es安装docker pull elasticsearch:7.4.0docker run -id --name elasticsearch -d --restart=always -p 9200:9200 -p 9300:9300 -v /usr/share/elasticsearch/plugins:/usr/share/elasticsearch/plugins -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; elasticsearch:7.4.0# 10. MongoDB安装docker pull mongodocker run -di --name mongo-service --restart=always -p 27017:27017 -v ~/data/mongodata:/data mongo 1234567891011121314151617# 常见命令：# 如果docker没启动，使用下面命令启动systemctl start docker# 查看当前有些什么imagesdocker images# 删除images（镜像）docker rmi &lt;image id&gt;# 查看所有运行或者不运行容器docker ps -a# 停止、启动、杀死、重启、删除一个容器docker stop Name或者ID docker start Name或者ID docker kill Name或者ID docker restart name或者IDdocker rm ID jenkins安装 123456789101112131415161718192021222324252627282930313233343536373839yum -y install epel-releaseyum -y install daemonizecd /data/tmp/wget https://get.jenkins.io/redhat-stable/jenkins-2.319.3-1.1.noarch.rpmrpm -ivh jenkins-2.319.3-1.1.noarch.rpm# 修改Jenkins配置vim /etc/sysconfig/jenkins# jdk目录JENKINS_JAVA_CMD=&quot;/data/service/jdk1.8.0_261/bin/java&quot;# jenkins用户JENKINS_USER=&quot;root&quot;# jenkins端口JENKINS_PORT=&quot;16060&quot;# 设置权限chown -R root:root /var/lib/jenkinschown -R root:root /var/cache/jenkinschown -R root:root /var/log/jenkins # 启动Jenkinssystemctl start jenkinssystemctl status jenkins# 获取账号密码cat /var/lib/jenkins/secrets/initialAdminPassword# 卸载rpm -e jenkinsrm -rf /etc/sysconfig/jenkins.rpmsaverm -rf /var/cache/jenkins/rm -rf /var/lib/jenkins/rm -rf /var/log/jenkinsrm -rf /usr/lib/jenkins# 插件网站http://updates.jenkins-ci.org/download/plugins/","categories":[{"name":"Linux","slug":"Linux","permalink":"https://wxzhou.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wxzhou.top/tags/Linux/"}]},{"title":"Pytorch安装torch-geometric","slug":"Pytorch安装torch-geometric","date":"2022-05-09T08:55:27.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2022/05/09/Pytorch安装torch-geometric/","link":"","permalink":"https://wxzhou.top/2022/05/09/Pytorch%E5%AE%89%E8%A3%85torch-geometric/","excerpt":"","text":"第一步：在Pytorch中下载需要的版本链接：https://pytorch.org/get-started/previous-versions/e.g. torch == 1.7.1 1234567891011121314# CUDA 11.0pip install torch==1.7.1+cu110 torchvision==0.8.2+cu110 torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html# CUDA 10.2pip install torch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2# CUDA 10.1pip install torch==1.7.1+cu101 torchvision==0.8.2+cu101 torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html# CUDA 9.2pip install torch==1.7.1+cu92 torchvision==0.8.2+cu92 torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html# CPU onlypip install torch==1.7.1+cpu torchvision==0.8.2+cpu torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html 第二步：根据自己下载的Torch、cuda、python版本，下载对应的torch-geometric, torch-sparse, torch-scatter, torch-cluster, torch-spline-conv。链接：https://data.pyg.org/whl/e.g. 1234567# 如果在第一步下载了torch==1.7.1+cu110，python=3.7，那么就在上述链接中选择对应版本的torch，然后再选择对应的包下载# 下载之后尽可以进行安装pip install torch_cluster-1.5.8-cp37-cp37m-linux_x86_64.whlpip install torch_scatter-2.0.5-cp37-cp37m-linux_x86_64.whlpip install torch_sparse-0.6.8-cp37-cp37m-linux_x86_64.whlpip install torch_spline_conv-1.2.0-cp37-cp37m-linux_x86_64.whlpip install torch_geometric==1.7.0 完成！","categories":[{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/tags/Python/"},{"name":"Pytorch","slug":"Pytorch","permalink":"https://wxzhou.top/tags/Pytorch/"}]},{"title":"Pycharm远程debug服务器python","slug":"Pycharm远程debug服务器python","date":"2022-04-29T03:03:06.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2022/04/29/Pycharm远程debug服务器python/","link":"","permalink":"https://wxzhou.top/2022/04/29/Pycharm%E8%BF%9C%E7%A8%8Bdebug%E6%9C%8D%E5%8A%A1%E5%99%A8python/","excerpt":"","text":"1. 第一步：设置服务器中的解释器2. 第二步：在服务器中安装pydevd1pip install pydevd 3. 第三步：在本地设置监听配置run -&gt; Edit Configurations -&gt; “+” -&gt; Python Debug Server右侧具体信息中填写三项： 1234IDE host name: 本地IPv4的地址Port: 随便填一个，比如10000Path mapping: 本地对应服务器的映射最后Apply 4. 第四步：将如下代码插入至远程计算机的应用程序中123# 插入位置为需要Debug的地方import pydevd pydevd.settrace(&#x27;172.*.*.*&#x27;, port=10000, stdoutToServer=True, stderrToServer=True) 5. 第五步：在PyCharm中启动Debug Server","categories":[{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/tags/Python/"},{"name":"Server","slug":"Server","permalink":"https://wxzhou.top/tags/Server/"},{"name":"Pycharm","slug":"Pycharm","permalink":"https://wxzhou.top/tags/Pycharm/"}]},{"title":"实验室服务器安装Anaconda环境","slug":"实验室服务器安装Anaconda环境","date":"2022-02-09T05:56:25.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2022/02/09/实验室服务器安装Anaconda环境/","link":"","permalink":"https://wxzhou.top/2022/02/09/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Anaconda%E7%8E%AF%E5%A2%83/","excerpt":"","text":"1.使用MobaXterm登入下载软件，连接服务器之后，进入下一步。 2.安装Anaconda（1）我们需要在官网上查找自己需要的版本，地址链接在下面:1https://repo.anaconda.com/archive/ 找到后进行安装（以我的为例）： 1wget https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh （2）下载完成之后，进行安装，依次输入下面两条命令：12chmod +x Anaconda3-2020.11-Linux-x86_64.sh./Anaconda3-2020.11-Linux-x86_64.sh （3）点击enter，一直出现yes or no，输入yes；后面安装提示进行操作。（4）配置路径添加环境变量，依次输入下面两条命令：12export PATH=&quot;/$HOME/anaconda3/bin:$PATH&quot;export PATH=&quot;$PATH:$HOME/anaconda/bin&quot; （5）检查是否安装完成：如图所示： 输入： 123456cd anaconda3# 切换到anaconda3目录下conda -V# 查看conda版本python -V# 查看python版本 3.使用（1）新建一个环境，设定python version是3.8conda create -n rl python=3.8 （2）查看环境，激活环境，退出环境：123456# 查看环境conda info --envs# 激活环境conda activate rl# 退出环境conda deactivate","categories":[{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/tags/Python/"},{"name":"Server","slug":"Server","permalink":"https://wxzhou.top/tags/Server/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://wxzhou.top/tags/Anaconda/"}]},{"title":"kafka-01-概念","slug":"kafka-01-概念","date":"2021-06-08T11:50:53.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2021/06/08/kafka-01-概念/","link":"","permalink":"https://wxzhou.top/2021/06/08/kafka-01-%E6%A6%82%E5%BF%B5/","excerpt":"","text":"1. kafka是什么，应用场景有哪些1.1 Kafka是一个分布式流式处理平台。流平台具有三个关键功能： 消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。 容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。 流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。 1.2 Kafka主要有两大应用场景： 消息队列 ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。 数据处理： 构建实时的流数据处理程序来转换或处理数据流。 2. 和其他消息队列相比,Kafka 的优势在哪里？ 极致的性能：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。 生态系统兼容性无可匹敌：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。 3. 什么是 Producer、Consumer、Broker、Topic、Partition？3.1 几个概念： Producer（生产者）: 产生消息的一方。 Consumer（消费者）: 消费消息的一方。 Broker（代理）: 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个Kafka Cluster。 Topic（主题）: Producer 将消息发送到特定的主题，Consumer 通过订阅特定的Topic(主题) 来消费消息。 Partition（分区） : Partition 属于 Topic 的一部分。一个 Topic 可以有多个Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个Broker 。这正如我上面所画的图一样。 3.2 大概流程： Kafka 将生产者发布的消息发送到Topic（主题）中，需要这些消息的消费者可以订阅这些Topic（主题）; 每个Topic被切分成若干个part放入不同的分区中，比如Topic A分成A1、A2、A3分成三部分，分别放入放入P1、P2、P3中; 不同的分区可以存放在不同的Broker中，也可以存放在相同的Broker中，比如{“B1”:”P1”, “B2”:”P2,P3”}、{“B1”:”P1,P2”, “B2”:”P3”}等； 同一个分区有多个副本（Replica），这些副本都是相同的，每个Broker中存放一个分区的副本； 同一个分区的副本可以分为两种：leader副本、follower副本（又可以分为ISR副本和普通副本），我们发送的消息会被发送到leader副本，然后follower副本才能从leader副本中拉取消息进行保存，ISR是同步保存leader副本，普通副本是异步保存leader副本。 4. Kafka 的多副本机制Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间一个叫做 leader，其他副本称为follower。我们发送的消息会被发送到leader 副本，然后follower副本才能从 leader 副本中拉取消息进行保存同步。生产者和消费者只与leader副本交互。其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当leader副本发生故障时会从follower中选举出一个leader，优先从ISR中选举一个follower为leader。 5. Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？ Kafka通过给特定Topic指定多个Partition, 而各个Partition可以分布在不同的Broker上, 这样便能提供比较好的并发能力（负载均衡）。 Partition可以指定对应的Replica数量, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。 6. Kafka 如何保证消息的消费顺序？这个问题可以从两个方面来回答：kafka 为什么会存在无序消费、kafka 如何保证有序消费。 首先，在 kafka 的架构里面，用到了 Partition 分区机制来实现消息的物理存储，在同一个 topic 下面，可以维护多个 partition 来实现消息的分片。生产者在发送消息的时候，会根据消息的 key 进行取模，来决定把当前消息存储到哪个 partition 里面，并且消息是按照先后顺序有序存储到 partition 里面的。在这种情况下，假设有一个 topic 存在三个 partition，消息的消费顺序不是按照发送顺序来实现的，从而导致乱序的问题。 第一种保证消息消费顺序的方法：1 个Topic只对应一个Partition。 第二种保证消息消费顺序的方法：Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key, data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。 总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法： 1 个 Topic 只对应一个 Partition。 发送消息的时候指定 key&#x2F;Partition。 7. kafka 如何保证消息不丢失？ kafka 是一个用来实现异步消息通信的中间件，它的整个架构由Producer、Consumer、Broker 组成。所以，对于 kafka 如何保证消息不丢失这个问题，可以从三个方面来考虑和实现。 首先是 Producer 端，需要确保消息能够到达 Broker 并实现消息存储，在这个层面，有可能出现网络问题，导致消息发送失败，所以，针对 Producer 端，可以通过2种方式来避免消息丢失 Producer 默认是异步发送消息，这种情况下要确保消息发送成功，有两个方法 把异步发送改成同步发送，这样 producer 就能实时知道消息发送的结果。 添加异步回调函数来监听消息发送的结果，如果发送失败，可以在回调中重试。 Producer 本身提供了一个重试参数 retries，如果因为网络问题或者Broker 故障导致发送失败，Producer 会自动重试。 然后是 Broker 端，Broker 需要确保 Producer 发送过来的消息不会丢失，也就是只需要把消息持久化到磁盘就可以了。 最后是 Consumer 端，消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。解决办法是，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset。 但是，这样会带来消息被重新消费的问题。比如消费者刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。 8. Kafka 中一个 Topic 有三个Partition，同一个消费组中两个消费者如何消费的？这个问题涉及到Kafka里面的Consumer Group Coordinator ，也就是消费组协调器。它会根据消费者订阅的 Topic 中的 partition 数量、和消费组中的消费者实例数量来决定每个消费者消费哪些 Partition。这个算法会在消费组中选择一个消费者实例作为 Leader，Leader 负责分配 Partition 给消费者实例，并协调消费者实例之间的Partition分配和reblance。当一个消费者实例加入或离开消费组的时候，协调器会触发 Partition 的重新分配，确保所有 Partition 都能被消费者实例均匀地消费。","categories":[{"name":"kafka","slug":"kafka","permalink":"https://wxzhou.top/categories/kafka/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://wxzhou.top/tags/kafka/"}]},{"title":"面试-kafka","slug":"面试-kafka","date":"2021-06-08T11:50:53.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2021/06/08/面试-kafka/","link":"","permalink":"https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-kafka/","excerpt":"","text":"1. kafka是什么，应用场景有哪些1.1 Kafka是一个分布式流式处理平台。流平台具有三个关键功能： 消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。 容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。 流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。 1.2 Kafka主要有两大应用场景： 消息队列 ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。 数据处理： 构建实时的流数据处理程序来转换或处理数据流。 2. 和其他消息队列相比,Kafka 的优势在哪里？ 极致的性能：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。 生态系统兼容性无可匹敌：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。 3. 什么是 Producer、Consumer、Broker、Topic、Partition？3.1 几个概念： Producer（生产者）: 产生消息的一方。 Consumer（消费者）: 消费消息的一方。 Broker（代理）: 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个Kafka Cluster。 Topic（主题）: Producer 将消息发送到特定的主题，Consumer 通过订阅特定的Topic(主题) 来消费消息。 Partition（分区） : Partition 属于 Topic 的一部分。一个 Topic 可以有多个Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个Broker 。这正如我上面所画的图一样。 3.2 大概流程： Kafka 将生产者发布的消息发送到Topic（主题）中，需要这些消息的消费者可以订阅这些Topic（主题）; 每个Topic被切分成若干个part放入不同的分区中，比如Topic A分成A1、A2、A3分成三部分，分别放入放入P1、P2、P3中; 不同的分区可以存放在不同的Broker中，也可以存放在相同的Broker中，比如{“B1”:”P1”, “B2”:”P2,P3”}、{“B1”:”P1,P2”, “B2”:”P3”}等； 同一个分区有多个副本（Replica），这些副本都是相同的，每个Broker中存放一个分区的副本； 同一个分区的副本可以分为两种：leader副本、follower副本（又可以分为ISR副本和普通副本），我们发送的消息会被发送到leader副本，然后follower副本才能从leader副本中拉取消息进行保存，ISR是同步保存leader副本，普通副本是异步保存leader副本。 4. Kafka 的多副本机制Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间一个叫做 leader，其他副本称为follower。我们发送的消息会被发送到leader 副本，然后follower副本才能从 leader 副本中拉取消息进行保存同步。生产者和消费者只与leader副本交互。其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当leader副本发生故障时会从follower中选举出一个leader，优先从ISR中选举一个follower为leader。 5. Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？ Kafka通过给特定Topic指定多个Partition, 而各个Partition可以分布在不同的Broker上, 这样便能提供比较好的并发能力（负载均衡）。 Partition可以指定对应的Replica数量, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。 6. Kafka 如何保证消息的消费顺序？这个问题可以从两个方面来回答：kafka 为什么会存在无序消费、kafka 如何保证有序消费。 首先，在 kafka 的架构里面，用到了 Partition 分区机制来实现消息的物理存储，在同一个 topic 下面，可以维护多个 partition 来实现消息的分片。生产者在发送消息的时候，会根据消息的 key 进行取模，来决定把当前消息存储到哪个 partition 里面，并且消息是按照先后顺序有序存储到 partition 里面的。在这种情况下，假设有一个 topic 存在三个 partition，消息的消费顺序不是按照发送顺序来实现的，从而导致乱序的问题。 第一种保证消息消费顺序的方法：1 个Topic只对应一个Partition。 第二种保证消息消费顺序的方法：Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key, data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。 总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法： 1 个 Topic 只对应一个 Partition。 发送消息的时候指定 key&#x2F;Partition。 7. kafka 如何保证消息不丢失？ kafka 是一个用来实现异步消息通信的中间件，它的整个架构由Producer、Consumer、Broker 组成。所以，对于 kafka 如何保证消息不丢失这个问题，可以从三个方面来考虑和实现。 首先是 Producer 端，需要确保消息能够到达 Broker 并实现消息存储，在这个层面，有可能出现网络问题，导致消息发送失败，所以，针对 Producer 端，可以通过2种方式来避免消息丢失 Producer 默认是异步发送消息，这种情况下要确保消息发送成功，有两个方法 把异步发送改成同步发送，这样 producer 就能实时知道消息发送的结果。 添加异步回调函数来监听消息发送的结果，如果发送失败，可以在回调中重试。 Producer 本身提供了一个重试参数 retries，如果因为网络问题或者Broker 故障导致发送失败，Producer 会自动重试。 然后是 Broker 端，Broker 需要确保 Producer 发送过来的消息不会丢失，也就是只需要把消息持久化到磁盘就可以了。 最后是 Consumer 端，消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。解决办法是，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset。 但是，这样会带来消息被重新消费的问题。比如消费者刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。 8. Kafka 中一个 Topic 有三个Partition，同一个消费组中两个消费者如何消费的？这个问题涉及到Kafka里面的Consumer Group Coordinator ，也就是消费组协调器。它会根据消费者订阅的 Topic 中的 partition 数量、和消费组中的消费者实例数量来决定每个消费者消费哪些 Partition。这个算法会在消费组中选择一个消费者实例作为 Leader，Leader 负责分配 Partition 给消费者实例，并协调消费者实例之间的Partition分配和reblance。当一个消费者实例加入或离开消费组的时候，协调器会触发 Partition 的重新分配，确保所有 Partition 都能被消费者实例均匀地消费。","categories":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试-Java","slug":"面试-java","date":"2021-06-08T11:50:53.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2021/06/08/面试-java/","link":"","permalink":"https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/","excerpt":"","text":"1. Java 语言的特点 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程； 可靠性（具备异常处理和自动内存管理机制）； 安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）； 高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）； 支持网络编程并且很方便； 编译与解释并存； 强大的生态； 2. JVM、 JDK、 JRE2.1 JVM：Java Virtual Machine，Java虚拟机 JVM是Java程序的运行环境，它能够执行Java程序编译后的字节码文件。JVM是运行Java程序的核心，因为Java程序必须在JVM上运行才能执行。 JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言“一次编译，随处可以运行”(Write Once, Run Anywhere)的关键所在。 2.1 JDK：Java Development Kit 它是功能齐全的 Java SDK，是提供给开发者使用的，能够创建和编译 Java 程序。 JDK包含了JRE，同时还包含了javac（编译 java 源码的编译器）、javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。 2.3 JRE（Java Runtime Environment） JRE是 Java 运行时环境。 它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。 3. 字节码 JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。 Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。 .class -&gt; 机器码1234JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。 4. 注释 单行注释：通常用于解释方法内某单行代码的作用。 多行注释：通常用于解释一段代码的作用。 文档注释：通常用于生成 Java 开发文档。 5. 标识符和关键字 标识符：就是一个名字，比如为程序、类、变量、方法等取名字； 关键字：被赋予特殊含义的标识符，比如private、protected、public等。 6. 自增自减运算符 自增运算符(++)和自减运算符(–) 当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。 7. 移位运算符 &lt;&lt; : 左移运算符，向左移若干位，高位丢弃，低位补零。x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下)。 : 带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x &gt;&gt; 1,相当于 x 除以 2。 : 无符号右移，忽略符号位，空位都以 0 补齐。 8. continue、break 和 return 的区别 continue：指跳出当前的这一次循环，继续下一次循环。 break：指跳出整个循环体，继续执行循环下面的语句。 return：用于跳出所在方法，结束该方法的运行。 9. 基本数据类型8 种基本数据类型 6 种数字类型： 4 种整数型：byte(1)、short(2)、int(4)、long(8) 2 种浮点型：float(4)、double(8) 1 种字符类型：char(2) 1 种布尔型：boolean 10. 基本类型和包装类型的区别 用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。 占用空间：相比于包装类型（对象类型），基本数据类型占用的空间往往非常小。 默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是null。 比较方式：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。 11. 包装类型的缓存机制 Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。 Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据； Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False； 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。 12. 自动装箱与拆箱是什么，原理是什么 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型；12Integer i = 10; //装箱int n = i; //拆箱 原理：从字节码中，我们发现装箱其实就是调用了包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。12Integer i = 10 等价于 Integer i = Integer.valueOf(10)int n = i 等价于 int n = i.intValue(); 注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作 13. 为什么浮点数运算的时候会有精度丢失的风险这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。 14. 如何解决浮点数运算的精度丢失问题 BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。 通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。 1234567BigDecimal a = new BigDecimal(&quot;1.0&quot;);BigDecimal b = new BigDecimal(&quot;0.9&quot;);System.out.println(a.add(b)); // 1.9System.out.println(a.subtract(b)); // 0.1System.out.println(a.multiply(b)); // 0.90System.out.println(a.divide(b)); // 无法除尽，抛出 ArithmeticException 异常System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11 15. 超过 long 整型的数据应该如何表示 基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。在 Java 中，64 位 long 整型是最大的整数类型。123long l = Long.MAX_VALUE;System.out.println(l + 1); // -9223372036854775808System.out.println(l + 1 == Long.MIN_VALUE); // true 此时要使用BigInteger类进行操作，BigInteger内部使用int[]数组来存储任意大小的整形数据。相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。12345678910BigInteger bi1 = new BigInteger(&quot;123456789&quot;) ; // 声明BigInteger对象Integer bi2 = new BigInteger(&quot;987654321&quot;) ; // 声明BigInteger对象tem.out.println(&quot;加法操作：&quot; + bi2.add(bi1)) ; // 加法操作System.out.println(&quot;减法操作：&quot; + bi2.subtract(bi1)) ; // 减法操作System.out.println(&quot;乘法操作：&quot; + bi2.multiply(bi1)) ; // 乘法操作System.out.println(&quot;除法操作：&quot; + bi2.divide(bi1)) ; // 除法操作System.out.println(&quot;最大数：&quot; + bi2.max(bi1)) ; // 求出最大数System.out.println(&quot;最小数：&quot; + bi2.min(bi1)) ; // 求出最小数BigInteger result[] = bi2.divideAndRemainder(bi1) ; // 求出余数的除法操作System.out.println(&quot;商是：&quot; + result[0] + &quot;；余数是：&quot; + result[1]) ; 16. 成员变量与局部变量的区别 语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。 默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 17. 静态变量有什么作用 静态变量也就是被 static 关键字修饰的变量。 它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。 也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。 18. 字符型常量和字符串常量的区别 形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。 含义 : 字符常量相当于一个整型值(ASCII值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。 占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。 19. 静态方法为什么不能调用非静态成员 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。 20. 静态方法和实例方法有何不同20.1 调用方式 在外部调用静态方法时，可以使用类名.方法名的方式，也可以使用对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 不过，需要注意的是一般不建议使用对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。因此，一般建议使用类名.方法名的方式来调用静态方法。 20.2 访问类成员是否存在限制静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。 21. 重载和重写有什么区别 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写，遵循”两同两小一大” “两同”即方法名相同、形参列表相同； “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。 22. 可变长参数 从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。123public static void method1(String... args) &#123; //......&#125; 可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数123public static void method2(String arg1, String... args) &#123; //......&#125; 方法重载会优先匹配固定参数的方法，因为固定参数的方法匹配度更高1234567891011121314151617public class VariableLengthArgument &#123; public static void printVariable(String... args) &#123; for (String s : args) &#123; System.out.println(s); &#125; &#125; public static void printVariable(String arg1, String arg2) &#123; System.out.println(arg1 + arg2); &#125; public static void main(String[] args) &#123; printVariable(&quot;a&quot;, &quot;b&quot;); printVariable(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;); &#125;&#125; Java 的可变参数编译后实际会被转换成一个数组 23. 面向对象和面向过程的区别 两者的主要区别在于解决问题的方式不同： 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。 面向对象开发的程序一般更易维护、易复用、易扩展 24. 创建一个对象用什么运算符?对象实体与对象引用有何不同? new 运算符，new 创建对象实例（对象实例在 内存中），对象引用指向对象实例（对象引用存放在栈内存中）。 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）； 一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 25. 对象的相等和引用相等的区别 对象的相等一般比较的是内存中存放的内容是否相等。 引用相等一般比较的是他们指向的内存地址是否相等。 26. 如果一个类没有声明构造方法，该程序能正确执行吗? 构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。 如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。 如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。 27. 构造方法有哪些特点？是否可被 override27.1 特点： 名字与类名相同 没有返回值，但不能用 void 声明构造函数 生成类的对象时自动执行，无需调用 27.2 是否可被重写 构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 28. 面向对象三大特征 封装：一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些可以被外界访问的方法来操作属性。 继承：通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。 多态：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。 29. 接口和抽象类有什么共同点和区别29.1 共同点： 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。 29.2 区别： 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。 一个类只能继承一个类，但是可以实现多个接口。 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。 30. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。1234567891011121314151617181920212223242526272829303132# 实现了 Cloneable 接口，并重写了 clone() 方法public class Address implements Cloneable&#123; private String name; // 省略构造函数、Getter&amp;Setter方法 @Override public Address clone() &#123; try &#123; return (Address) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125;&#125;public class Person implements Cloneable &#123; private Address address; // 省略构造函数、Getter&amp;Setter方法 @Override public Person clone() &#123; try &#123; Person person = (Person) super.clone(); return person; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125;&#125;Person person1 = new Person(new Address(&quot;武汉&quot;));Person person1Copy = person1.clone();System.out.println(person1.getAddress() == person1Copy.getAddress()); // true// 从输出结构就可以看出， person1 的克隆对象和 person1 使用的仍然是同一个 Address 对象。 深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。12345678910111213141516171819public class Person implements Cloneable &#123; private Address address; // 省略构造函数、Getter&amp;Setter方法 @Override public Person clone() &#123; try &#123; Person person = (Person) super.clone(); person.setAddress(person.getAddress().clone()); return person; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125;&#125;Person person1 = new Person(new Address(&quot;武汉&quot;));Person person1Copy = person1.clone();System.out.println(person1.getAddress() == person1Copy.getAddress()); // false// 从输出结构就可以看出，显然 person1 的克隆对象和 person1 包含的 Address 对象已经是不同的了。 引用拷贝：两个不同的引用指向同一个对象 31. Object 类的常见方法有哪些Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class&lt;?&gt; getClass()/** * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。 */public native int hashCode()/** * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。 */public boolean equals(Object obj)/** * native 方法，用于创建并返回当前对象的一份拷贝。 */protected native Object clone() throws CloneNotSupportedException/** * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。 */public String toString()/** * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。 */public final native void notify()/** * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 */public final native void notifyAll()/** * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。 */public final native void wait(long timeout) throws InterruptedException/** * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。 */public final void wait(long timeout, int nanos) throws InterruptedException/** * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 */public final void wait() throws InterruptedException/** * 实例被垃圾回收器回收的时候触发的操作 */protected void finalize() throws Throwable &#123; &#125; 32. &#x3D;&#x3D; 和 equals() 的区别32.1 &#x3D;&#x3D; 对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。 对于引用数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。 32.2 equals() equals()不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。 equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。 33. hashCode() 有什么用 hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。 另外需要注意的是：Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的。 34. 为什么要有 hashCode hashCode() 和 equals()都是用于比较两个对象是否相等。 在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程） 如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。 如果两个对象的 hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。 如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。 35. 为什么重写 equals() 时必须重写 hashCode() 方法 因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。 36. String、StringBuffer、StringBuilder 的区别36.1 可变性 String 是不可变的。 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。 36.2 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。 AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。 StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 36.3 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。 相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 36.4 总结 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer 37. String 为什么是不可变的 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供&#x2F;暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 38. 字符串拼接用“+” 还是 StringBuilder38.1 + 字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象。1234String str1 = &quot;he&quot;;String str2 = &quot;llo&quot;;String str3 = &quot;world&quot;;String str4 = str1 + str2 + str3; 在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。123456String[] arr = &#123;&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;&#125;;String s = &quot;&quot;;for (int i = 0; i &lt; arr.length; i++) &#123; s += arr[i];&#125;System.out.println(s); 38.2 StringBuilder 如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。123456String[] arr = &#123;&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;&#125;;StringBuilder s = new StringBuilder();for (String value : arr) &#123; s.append(value);&#125;System.out.println(s); 39. String#equals() 和 Object#equals() 有何区别 String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。 40. 字符串常量池的作用了解吗 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域. 主要目的是为了避免字符串的重复创建。12345// 在常量池中创建字符串对象”ab“String aa = &quot;ab&quot;;// 直接返回常量池中字符串”ab“的引用String bb = &quot;ab&quot;;System.out.println(aa==bb); // true 41. String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？ 会创建 1 或 2 个字符串对象。 如果字符串常量池中不存在字符串“abc”: 首先在字符串常量池中创建一个”abc”对象 然后在堆内存中创建1个对象指向字符串常量池中的”abc”，因此将创建总共 2 个字符串对象。 如果常量池中已存在字符串“abc”，则只会在堆中创建一个对象指向字符串常量池中的”abc” 42. String#intern 方法有什么作用 String.intern() 是一个 native（本地）方法，可以简单分为两种情况： 如果字符串常量池中保存了对应的字符串，就直接返回该字符串的引用。 如果字符串常量池中没有保存对应的字符串，那就在常量池中创建一个该字符串的对象并返回。1234567891011121314// 在字符串常量池中创建一个&quot;Java&quot;对象String s1 = &quot;Java&quot;;// 直接返回字符串常量池中字符串对象”Java“String s2 = s1.intern();// 会在堆中在单独创建一个字符串对象，指向常量池中”Java“对象String s3 = new String(&quot;Java&quot;);// 直接返回字符串常量池中字符串对象”Java“String s4 = s3.intern();// s1 和 s2 指向的是常量池中的同一个对象System.out.println(s1 == s2); // true// s3 和 s4 指向的是不同的对象，s3指向的是堆中的一个字符串对象，s4指向的是常量池中的”Java“对象System.out.println(s3 == s4); // false// s1 和 s4 指向的是常量池中的同一个”Java“对象System.out.println(s1 == s4); //true 43. Exception 和 Error 有什么区别？在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类: Exception: 程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。 Error：Error 属于程序无法处理的错误 ，不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 44. Checked Exception 和 Unchecked Exception 有什么区别 Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。 Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。 45. Throwable 类常用方法有哪些？ String getMessage(): 返回异常发生时的简要描述 String toString(): 返回异常发生时的详细信息 String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同 void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息 46. try-catch-finally 如何使用？ try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch块：用于处理 try 捕获到的异常。 finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。12345678try &#123; System.out.println(&quot;Try to do something&quot;); throw new RuntimeException(&quot;RuntimeException&quot;);&#125; catch (Exception e) &#123; System.out.println(&quot;Catch Exception -&gt; &quot; + e.getMessage());&#125; finally &#123; System.out.println(&quot;Finally&quot;);&#125; 1234输出：Try to do somethingCatch Exception -&gt; RuntimeExceptionFinally 47. finally 中的代码一定会执行吗？不一定的！在某些情况下，finally 中的代码不会被执行。 finally执行之前虚拟机被终止运行的话，finally 中的代码就不会被执行。 程序所在的线程死亡。 关闭 CPU。 48. 如何使用 try-with-resources 代替try-catch-finally Java 中类似于InputStream、OutputStream、Scanner、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下：1234567891011121314//读取文本文件的内容Scanner scanner = null;try &#123; scanner = new Scanner(new File(&quot;D://read.txt&quot;)); while (scanner.hasNext()) &#123; System.out.println(scanner.nextLine()); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; finally &#123; if (scanner != null) &#123; scanner.close(); &#125;&#125; 使用 Java 7 之后的 try-with-resources 语句改造上面的代码:12345678try (Scanner scanner = new Scanner(new File(&quot;test.txt&quot;))) &#123; while (scanner.hasNext()) &#123; System.out.println(scanner.nextLine()); &#125;&#125; catch (FileNotFoundException fnfe) &#123; fnfe.printStackTrace();&#125; 当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。12345678910try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;))); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123; int b; while ((b = bin.read()) != -1) &#123; bout.write(b); &#125;&#125;catch (IOException e) &#123; e.printStackTrace();&#125; 49. 异常使用有哪些需要注意的地方？ 不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。 抛出的异常信息一定要有意义。 建议抛出更加具体的异常，比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。 使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中） 50. 什么是泛型？有什么作用？ 泛型（Generics）是 JDK5 中引入的一个新特性。 使用泛型参数，可以增强代码的可读性以及稳定性。 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList persons &#x3D; new ArrayList() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。 51. 泛型的使用方式有哪几种？ 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。 泛型类：1234567891011121314// 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型// 在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125;&#125; 12// 实例化泛型类Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); 泛型接口：123public interface Generator&lt;T&gt; &#123; public T method();&#125; 123456789101112131415// 实现泛型接口，不指定类型：class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T method() &#123; return null; &#125;&#125;// 实现泛型接口，指定类型：class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;&#123; @Override public String method() &#123; return &quot;hello&quot;; &#125;&#125; 泛型方法：12345public static &lt;E&gt; void printArray(E[] inputArray)&#123; for (E element : inputArray )&#123; System.out.printf( &quot;%s &quot;, element ); &#125;&#125; 52. 何谓注解 Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。 注解本质是一个继承了Annotation 的特殊接口：1234567@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;public interface Override extends Annotation&#123;&#125; 53. 注解的解析方法有哪几种注解只有被解析之后才会生效，常见的解析方法有两种： 编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。 运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。 54. Java 值传递Java 中将实参传递给方法（或函数）的方式是值传递： 如果参数是基本类型：传递的就是基本类型的字面量值的拷贝，会创建副本。 如果参数是引用类型：传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。 55. 什么是序列化和反序列化?55.1 定义如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。 55.2 区别 序列化：serialization, 将数据结构或对象转换成二进制字节流的过程，主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程 55.3 应用场景 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化； 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化； 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。 55.4 序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层 TCP&#x2F;IP 四层模型是：应用层、传输层、网络层、网络接口层 序列化协议属于 TCP&#x2F;IP 协议应用层的一部分 56. 常见序列化协议有哪些56.1 JDK 自带的序列化方式 JDK 自带的序列化，只需实现 java.io.Serializable接口即可。1234567891011121314@AllArgsConstructor@NoArgsConstructor@Getter@Builder@ToStringpublic class RpcRequest implements Serializable &#123; private static final long serialVersionUID = 1905122041950251207L; private String requestId; private String interfaceName; private String methodName; private Object[] parameters; private Class&lt;?&gt;[] paramTypes; private RpcMessageTypeEnum rpcMessageTypeEnum;&#125; 为什么不推荐使用 JDK 自带的序列化? 不支持跨语言调用 性能差 存在安全问题 56.2 其他序列化协议 有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。 57. 何为反射？ 反射（Reflection） 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查. 通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性 58. 反射的应用场景了解么 平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景; 像Spring&#x2F;Spring Boot、MyBatis等框架中大量使用了动态代理，而动态代理的实现依赖反射。 59. 反射机制的优缺点 优点： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利 缺点： 安全问题：比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。 性能问题：反射的性能要稍差点，但是对于框架来说实际是影响不大。 60. 获取 Class 对象的四种方式 知道具体类的情况下可以使用：1Class alunbarClass = TargetObject.class; 通过 Class.forName()传入类的全路径获取：1Class alunbarClass1 = Class.forName(&quot;cn.javaguide.TargetObject&quot;); 通过对象实例instance.getClass()获取：12TargetObject o = new TargetObject();Class alunbarClass2 = o.getClass(); 通过类加载器xxxClassLoader.loadClass()传入类路径获取:1ClassLoader.getSystemClassLoader().loadClass(&quot;cn.javaguide.TargetObject&quot;); 61. 反射的一些基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 创建一个我们要使用反射操作的类 TargetObjectpublic class TargetObject &#123; private String value; public TargetObject() &#123; value = &quot;JavaGuide&quot;; &#125; public void publicMethod(String s) &#123; System.out.println(&quot;I love &quot; + s); &#125; private void privateMethod() &#123; System.out.println(&quot;value is &quot; + value); &#125;&#125;// 使用反射操作这个类的方法以及参数import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123; /** * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例 */ Class&lt;?&gt; targetClass = Class.forName(&quot;cn.javaguide.TargetObject&quot;); TargetObject targetObject = (TargetObject) targetClass.newInstance(); /** * 获取 TargetObject 类中定义的所有方法 */ Method[] methods = targetClass.getDeclaredMethods(); for (Method method : methods) &#123; System.out.println(method.getName()); &#125; /** * 获取指定方法并调用 */ Method publicMethod = targetClass.getDeclaredMethod(&quot;publicMethod&quot;, String.class); publicMethod.invoke(targetObject, &quot;JavaGuide&quot;); /** * 获取指定参数并对参数进行修改 */ Field field = targetClass.getDeclaredField(&quot;value&quot;); //为了对类中的参数进行修改我们取消安全检查 field.setAccessible(true); field.set(targetObject, &quot;JavaGuide&quot;); /** * 调用 private 方法 */ Method privateMethod = targetClass.getDeclaredMethod(&quot;privateMethod&quot;); //为了调用private方法我们取消安全检查 privateMethod.setAccessible(true); privateMethod.invoke(targetObject); &#125;&#125; 1234publicMethodprivateMethodI love JavaGuidevalue is JavaGuide 62. 代理模式62.1 概念： 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。 代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。 62.2 静态代理 静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改），且麻烦(需要对每个目标类都单独写一个代理类）。 从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 实现步骤： 定义一个接口及其实现类； 创建一个代理类同样实现这个接口 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1. 定义发送短信的接口public interface SmsService &#123; String send(String message);&#125;// 2. 实现发送短信的接口public class SmsServiceImpl implements SmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125;// 3. 创建代理类并同样实现发送短信的接口public class SmsProxy implements SmsService &#123; private final SmsService smsService; public SmsProxy(SmsService smsService) &#123; this.smsService = smsService; &#125; @Override public String send(String message) &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method send()&quot;); smsService.send(message); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method send()&quot;); return null; &#125;&#125;// 4. 实际使用public class Main &#123; public static void main(String[] args) &#123; SmsService smsService = new SmsServiceImpl(); SmsProxy smsProxy = new SmsProxy(smsService); smsProxy.send(&quot;java&quot;); &#125;&#125;// 5. 运行上述代码之后，控制台打印出：before method send()send message:javaafter method send() 62.3 动态代理 从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 实现步骤 定义一个接口及其实现类； 创建动态代理类，实现InvocationHandler接口，重写invoke方法，在 invoke 方法中调用原生方法（被代理类的方法）并自定义一些处理逻辑； 创建代理对象的工厂类，通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 1. 定义发送短信的接口public interface SmsService &#123; String send(String message);&#125;// 2. 实现发送短信的接口public class SmsServiceImpl implements SmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125;// 3. 定义一个 JDK 动态代理类import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class DebugInvocationHandler implements InvocationHandler &#123; /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method &quot; + method.getName()); Object result = method.invoke(target, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method &quot; + method.getName()); return result; &#125;&#125;// 4. 获取代理对象的工厂类public class JdkProxyFactory &#123; // 主要通过Proxy.newProxyInstance（）方法获取某个类的代理对象 public static Object getProxy(Object target) &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), // 目标类的类加载器 target.getClass().getInterfaces(), // 代理需要实现的接口，可指定多个 new DebugInvocationHandler(target) // 代理对象对应的自定义 InvocationHandler ); &#125;&#125;// 5. 实际使用SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());smsService.send(&quot;java&quot;);// 6. 运行上述代码之后，控制台打印出：before method sendsend message:javaafter method send 62.4 静态代理和动态代理的对比 灵活性： 静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，非常麻烦 动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。 JVM 层面： 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 63. SPI63.1 SPI和API的区别 实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。 当接口存在于调用方这边时，就是SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。 举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。 63.2 应用场景很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。 64. 语法糖64.1 定义 语法糖（Syntactic Sugar） 也称糖衣语法。 指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。 简而言之，语法糖让程序更加简洁，有更高的可读性。 64.2 switch 支持 String switch自身原本就支持基本类型。比如int、char等。 对于int类型，直接进行数值的比较。 对于char类型则是比较其 ascii 码。 所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。 Java 7 中switch开始支持String 字符串的 switch 是通过equals()和hashCode()方法来实现的 64.3 泛型 对于JVM来说，他根本不认识Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。1234567891011// 原来的代码：Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(&quot;name&quot;, &quot;hollis&quot;);map.put(&quot;wechat&quot;, &quot;Hollis&quot;);map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);// 解语法糖之后会变成：Map map = new HashMap();map.put(&quot;name&quot;, &quot;hollis&quot;);map.put(&quot;wechat&quot;, &quot;Hollis&quot;);map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;); 64.4 自动装箱与拆箱 装箱过程是通过调用包装器的 valueOf 方法实现的， 拆箱过程是通过调用包装器的 xxxValue 方法实现的。 64.5 可变长参数可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。 64.6 断言断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertionError 来打断程序的执行。 1234567891011public class AssertTest &#123; public static void main(String args[]) &#123; int a = 1; int b = 1; assert a == b; System.out.println(&quot;公众号：Hollis&quot;); assert a != b : &quot;Hollis&quot;; System.out.println(&quot;博客：www.hollischuang.com&quot;); &#125;&#125; 64.7 数值字面量编译器并不认识在数字字面量中的_，需要在编译阶段把他去掉。 123456789101112131415161718// 数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。// 这些下划线不会对字面量的数值产生影响，目的就是方便阅读。public class Test &#123; public static void main(String... args) &#123; int i = 10_000; System.out.println(i); &#125;&#125;// 反编译后：public class Test &#123; public static void main(String[] args) &#123; int i = 10000; System.out.println(i); &#125;&#125; 64.8 for-eachfor-each 的实现原理其实就是使用了普通的 for 循环和迭代器 64.9 try-with-resource背后的原理很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。 65. 集合概述65.1 集合概览集合，也叫作容器，主要是由两大接口派生而来： Collection接口，主要用于存放单一元素，包含三个主要子接口：List、Set 和 Queue。 Map 接口，主要用于存放键值对。 65.2 说说 List, Set, Queue, Map 四者的区别？ List(对付顺序的好帮手): 存储的元素是有序、可重复、有索引。 Set(注重独一无二的性质): 存储的元素是无序、不可重复、无索引。 Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。 Map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 65.3 集合框架底层数据结构总结先来看一下 Collection 接口下面的集合。 List ArrayList：Object[] 数组 Vector：Object[] 数组 LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环) Set HashSet(无序，唯一): 基于 HashMap （JDK8以前：数组+链表，JDK8以后：数组+链表+红黑树）实现的，底层采用 HashMap 来保存元素。 LinkedHashSet: LinkedHashSet 是 HashSet 的子类，基于HashMap来实现，每个元素额外多了一个双链表记录前后元素的位置。 TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树) Queue PriorityQueue: Object[] 数组来实现二叉堆 ArrayQueue: Object[] 数组 + 双指针 再来看看 Map 接口下面的集合。 Map HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间 LinkedHashMap：LinkedHashMap 继承自 HashMap，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。 TreeMap：红黑树（自平衡的排序二叉树） 65.4 如何选用集合?我们主要根据集合的特点来选择合适的集合。比如： 我们需要根据键值获取到元素值时就选用 Map 接口下的集合， 需要排序时选择 TreeMap 不需要排序时就选择 HashMap 需要保证线程安全就选用 ConcurrentHashMap。 我们只需要存放元素值时，就选择实现Collection 接口的集合 需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet， 不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList 65.5 为什么要使用集合？ 数组： 当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。 但是，使用数组存储对象存在一些不足：存储类型固定，长度固定。 集合： 集合的优势在于它们的大小可变、支持泛型等。 集合提高了数据的存储和处理灵活性。 66. List66.1 ArrayList底层的原理 利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组 添加第一个元素时，底层会创建一个新的长度为10的数组 存满时，会扩容1.5倍 如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准 66.2 ArrayList 和 Array（数组）的区别？ArrayList 内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活： ArrayList会根据实际存储的元素动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。 ArrayList 允许你使用泛型来确保类型安全，Array 则不可以。 ArrayList 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。Array 可以直接存储基本类型数据，也可以存储对象。 ArrayList 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 add()、remove()等。Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。 ArrayList创建时不需要指定大小，而Array创建时必须指定大小。 12345678910111213141516171819202122232425// Array// 初始化一个 String 类型的数组String[] stringArr = new String[]&#123;&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;&#125;;// 修改数组元素的值stringArr[0] = &quot;goodbye&quot;;System.out.println(Arrays.toString(stringArr));// [goodbye, world, !]// 删除数组中的元素，需要手动移动后面的元素for (int i = 0; i &lt; stringArr.length - 1; i++) &#123; stringArr[i] = stringArr[i + 1];&#125;stringArr[stringArr.length - 1] = null;System.out.println(Arrays.toString(stringArr));// [world, !, null] ArrayList// 初始化一个 String 类型的 ArrayListArrayList&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;));// 添加元素到 ArrayList 中stringList.add(&quot;goodbye&quot;);System.out.println(stringList);// [hello, world, !, goodbye]// 修改 ArrayList 中的元素stringList.set(0, &quot;hi&quot;);System.out.println(stringList);// [hi, world, !, goodbye]// 删除 ArrayList 中的元素stringList.remove(0);System.out.println(stringList); // [world, !, goodbye] 66.3 ArrayList 可以添加 null 值吗？ ArrayList 中可以存储任何类型的对象，包括 null 值。 不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。 1234567ArrayList&lt;String&gt; listOfStrings = new ArrayList&lt;&gt;();listOfStrings.add(null);listOfStrings.add(&quot;java&quot;);System.out.println(listOfStrings);// 输出：[null, java] 66.4 ArrayList 插入和删除元素的时间复杂度？ 插入： 头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 **O(n)**。 尾部插入：当 ArrayList 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 **O(1)**，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。 指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 **O(n)**。 删除： 头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 **O(n)**。 尾部删除：当删除的元素位于列表末尾时，时间复杂度为 **O(1)**。 指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。 66.5 LinkedList 插入和删除元素的时间复杂度？ 头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 **O(1)**。 尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 **O(1)**。 指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。 66.6 LinkedList 为什么不能实现 RandomAccess 接口？ RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。 由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。 66.7 ArrayList 与 LinkedList 区别? 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，不保证线程安全； 底层数据结构： ArrayList 底层使用的是 Object 数组； LinkedList 底层使用的是 双向链表 数据结构 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响。 是否支持快速随机访问： ArrayList实现了 RandomAccess 接口， 支持随机访问。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法) LinkedList 不支持高效的随机元素访问。 内存空间占用： ArrayList 的空间浪费主要体现在 list 列表的结尾会预留一定的容量空间; LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。 应用： 我们在项目中一般是不会使用到 LinkedList 的，需要用到 LinkedList 的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好！ 67. Set67.1 HashSet底层原理 HashSet集合底层是基于哈希表实现的，哈希表根据JDK版本的不同，也是有点区别的 JDK8以前：哈希表 &#x3D; 数组+链表 JDK8以后：哈希表 &#x3D; 数组+链表+红黑树 67.2 LinkedHashSet底层原理 67.3 Comparable 和 Comparator 的区别 Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用： Comparable 接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序 Comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序 Comparator 定制排序123456789101112131415161718192021222324252627282930313233343536373839ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();arrayList.add(-1);arrayList.add(3);arrayList.add(3);arrayList.add(-5);arrayList.add(7);arrayList.add(4);arrayList.add(-9);arrayList.add(-7);System.out.println(&quot;原始数组:&quot;);System.out.println(arrayList);// void reverse(List list)：反转Collections.reverse(arrayList);System.out.println(&quot;Collections.reverse(arrayList):&quot;);System.out.println(arrayList);// void sort(List list),按自然排序的升序排序Collections.sort(arrayList);System.out.println(&quot;Collections.sort(arrayList):&quot;);System.out.println(arrayList);// 定制排序的用法Collections.sort(arrayList, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125;&#125;);System.out.println(&quot;定制排序后：&quot;);System.out.println(arrayList);// Output:原始数组:[-1, 3, 3, -5, 7, 4, -9, -7]Collections.reverse(arrayList):[-7, -9, 4, 7, -5, 3, 3, -1]Collections.sort(arrayList):[-9, -7, -5, -1, 3, 3, 4, 7]定制排序后：[7, 4, 3, 3, -1, -5, -7, -9] 重写 compareTo 方法实现按年龄来排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /** * T重写compareTo方法实现按年龄来排序 */ @Override public int compareTo(Person o) &#123; if (this.age &gt; o.getAge()) &#123; return 1; &#125; if (this.age &lt; o.getAge()) &#123; return -1; &#125; return 0; &#125;&#125;public static void main(String[] args) &#123; TreeMap&lt;Person, String&gt; pdata = new TreeMap&lt;Person, String&gt;(); pdata.put(new Person(&quot;张三&quot;, 30), &quot;zhangsan&quot;); pdata.put(new Person(&quot;李四&quot;, 20), &quot;lisi&quot;); pdata.put(new Person(&quot;王五&quot;, 10), &quot;wangwu&quot;); pdata.put(new Person(&quot;小红&quot;, 5), &quot;xiaohong&quot;); // 得到key的值的同时得到key所对应的值 Set&lt;Person&gt; keys = pdata.keySet(); for (Person key : keys) &#123; System.out.println(key.getAge() + &quot;-&quot; + key.getName()); &#125;&#125;// Output：5-小红10-王五20-李四30-张三 67.4 无序性和不可重复性的含义是什么 无序性不等于随机性. 无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。 不可重复性是指添加的元素按照 equals() 判断时 ，返回 false，需要同时重写 equals() 方法和 hashCode() 方法。 67.5 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同 相同点：都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。 不同点：主要区别在于底层数据结构不同。 HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。 LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。 TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。 68. Queue 与 Deque 的区别 Queue 是单端队列，只能从一端插入元素，另一端删除元素，遵循 先进先出（FIFO） 规则。 Deque (Double Ended Queue)是双端队列，在队列的两端均可以插入或删除元素。 69. 集合判空 判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。 这是因为 isEmpty() 方法的可读性更好，并且时间复杂度为 O(1)。 80. 集合遍历 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。 81. 集合数组互转12345678// 数组转集合String[] myArray = &#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;&#125;;List&lt;String&gt; myList = Arrays.asList(myArray);//上面两个语句等价于下面一条语句List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;,&quot;Banana&quot;, &quot;Orange&quot;);// 集合转数组（没有指定类型的话会报错）String[] s = list.toArray(new String[0]); 82. 乐观锁和悲观锁82.1 基本概念乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。 乐观锁：在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。 悲观锁：在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其它线程阻塞，其他人不能修改数据。 83.2 实现方式 乐观锁的实现方式主要有两种：版本号机制和CAS机制 版本号机制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。 12345678**举一个简单的例子**：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ `balance` ）为 \\$100 。1. 操作员 A 此时将其读出（ `version`=1 ），并从其帐户余额中扣除 $50（ $100-\\$50 ）。2. 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ `version`=1 ），并从其帐户余额中扣除 $20 （ $100-\\$20 ）。3. 操作员 A 完成了修改工作，将数据版本号（ `version`=1 ），连同帐户扣除后余额（ `balance`=\\$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 `version` 更新为 2 。4. 操作员 B 完成了操作，也将版本号（ `version`=1 ）试图向数据库提交数据（ `balance`=\\$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。这样就避免了操作员 B 用基于 `version`=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。 CAS 算法： CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。 CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。（原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。） CAS 涉及到三个操作数：V、E、N。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。 V：要更新的变量值(Var) E：预期值(Expected) N：拟写入的新值(New)1234**举一个简单的例子**：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。1. i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。2. i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。 83.3 优缺点和应用场景 当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。 当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。 83.4 乐观锁加锁吗 乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子。 有时乐观锁可能与加锁操作合作，但是不能改变“乐观锁本身不加锁”这一事实。 83.4 CAS有哪些缺点 ABA问题： 定义：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。 解决思路：ABA 问题的解决思路是在变量前面追加上版本号或者时间戳。 高竞争下的开销问题： 定义：在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。 解决思路：针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。 功能限制： 例如CAS只能保证单个变量（或者说单个内存值）操作的原子性，当操作涉及跨多个共享变量时 CAS 无效。 83.5 总结 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。 乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。 CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。 乐观锁的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。 84. JMM(Java Memory Model)84.1 什么是 JMM？为什么需要 JMM？ Java内存模型即Java Memory Model，简称JMM。用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能够达到一致的内存访问效果。 JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 84.2 多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。 线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。 线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。 84.3 Java 内存区域和 JMM 有何区别？ Java 内存区域和内存模型是完全不一样的两个东西： Java 内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分，就比如说堆主要用于存放对象实例。 Java 内存模型抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。 84.4 happens-before 是什么？ 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见（保障可见性），并且第一个操作的执行顺序排在第二个操作之前（JMM对程序员做出的一个逻辑保障，并不是代码真正的执行保障）。 即使两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。只要不改变程序的执行结果，编译器、处理器怎么优化都可以。 1234567int userNum = getUserNum(); // 1int teacherNum = getTeacherNum(); // 2int totalNum = userNum + teacherNum; // 3- 1 happens-before 2- 2 happens-before 3- 1 happens-before 3 虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。 happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。 84.5 happens-before 原则：（一共8条，重点是下面5条） 程序顺序规则：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作； 解锁规则：解锁 happens-before 于加锁； volatile 变量规则：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。 传递规则：如果 A happens-before B，且 B happens-before C，那么 A happens-before C； 线程启动规则：Thread 对象的 start()方法 happens-before 于此线程的每一个动作。 84.6 并发编程三个重要特性 原子性 可见性 有序性 84.7 volatile关键字 在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 防止 JVM 的指令重排序。如果将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。 volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。 84.8 synchronized关键字 概念： synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 使用： 修饰实例方法 （锁当前对象实例）1234synchronized void method() &#123; //业务代码&#125; 修饰静态方法 （锁当前类）123synchronized static void method() &#123; //业务代码&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 定义类class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; count = 0; &#125; public synchronized static void method() &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public synchronized void run() &#123; method(); &#125;&#125;// 代码调用SyncThread syncThread1 = new SyncThread();SyncThread syncThread2 = new SyncThread();Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);thread1.start();thread2.start();// 结果如下：SyncThread1:0SyncThread1:1SyncThread1:2SyncThread1:3SyncThread1:4SyncThread2:5SyncThread2:6SyncThread2:7SyncThread2:8SyncThread2:9 修饰代码块 （锁指定对象&#x2F;类）123synchronized(this) &#123; //业务代码&#125; 底层原理： javac在编译时，会生成对应的monitorenter和monitorexit指令分别对应synchronized同步块的进入和退出. 有两个monitorexit指令的原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用monitorexit命令释放锁。 构造方法可以用 synchronized 修饰么? 构造方法不能使用 synchronized 关键字修饰。 构造方法本身就属于线程安全的，不存在同步的构造方法一说。 synchronized 和 volatile 有什么区别？ volatile 关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好。 volatile 关键字只能用于变量，而 synchronized 关键字可以修饰方法以及代码块。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 85. 线程85.1 创建线程的方式（三种） Thread 继承Thread类，重写run方法，run方法代表线程要完成的任务， 调用线程实例对象的start()方法来启动该线程.12345678910class ThreadDemo1 extends Thread&#123; @Override public void run()&#123; System.out.println(&quot;线程的第一种创建方式&quot;); &#125;&#125;// main方法调用ThreadDemo1 demo1 = new ThreadDemo1();demo1.start(); runnable 实现runnable接口，重写该接口的run()方法，run方法代表线程要完成的任务，调用线程实例对象的start()方法来启动该线程 创建Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用Thread线程对象的start()方法来启动该线程。12345678910class ThreadDemo2 implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;线程的第二种创建方式-实现runnable接口&quot;); &#125;&#125;// main方法调用ThreadDemo2 demo2 = new ThreadDemo2();new Thread(demo2).start(); Callable 实现Callable接口，重写call()方法，该call()方法将作为线程执行体，并且有返回值； 创建Callable实现类的实例对象，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值1234567891011121314151617181920class ThreadDemo3 implements Callable&lt;Integer&gt;&#123; private int i =0; @Override public Integer call() throws Exception &#123; for(int i=0;i&lt;100;i++)&#123; this.i+=i; &#125; return i; &#125;&#125;//main调用ThreadDemo3 demo3 = new ThreadDemo3();FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(demo3);new Thread(task).start();try &#123; System.out.println(task.get());&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; catch (ExecutionException e) &#123;&#125; 85.2 Java对象引用级别 JDK把对象的引用级别由高到低分为强引用、软引用、弱引用、虚引用四种级别 强引用 StrongReference：属于不可回收资源，GC绝对不会回收它，即使是内存不足，JVM宁愿抛出OutOfMemoryError异常，使程序终止，也不会来回收强引用对象。1User user = new User(&quot;Tom&quot;); 软引用 SoftReference：它的性质属于可有可无，因为内存空间充足的情况下，GC不会回收它，但是内存空间紧张，GC发现它仅有软引用，就会回收该对象，所以软引用对象适合作为内存敏感的缓存对象。1SoftReference&lt;User&gt; soft = new SoftReference&lt;&gt;(new User(&quot;Tom&quot;)); 弱引用 WeakReference：弱引用对象相对软引用对象具有更短暂的生命周期，只要GC发现它仅有弱引用，不管内存空间是否充足，都会回收它，不过GC是一个优先级很低的线程，因此不一定会很快发现那些仅有弱引用的对象。1WeakReference&lt;Object&gt; weak = new WeakReference&lt;&gt;(new User(&quot;Tom&quot;)); 85.3 ThreadLocal 概念：创建了一个ThreadLocal变量，它是线程隔离的，访问这个变量的每个线程都会有这个变量的本地副本。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。 使用： get() set() remove()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.text.SimpleDateFormat;import java.util.Random;public class ThreadLocalExample implements Runnable&#123; // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本 private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;)); public static void main(String[] args) throws InterruptedException &#123; ThreadLocalExample obj = new ThreadLocalExample(); for(int i=0 ; i&lt;10; i++)&#123; Thread t = new Thread(obj, &quot;&quot;+i); Thread.sleep(new Random().nextInt(1000)); t.start(); &#125; &#125; @Override public void run() &#123; System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; default Formatter = &quot;+formatter.get().toPattern()); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads formatter.set(new SimpleDateFormat()); System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; formatter = &quot;+formatter.get().toPattern()); &#125;&#125;// 输出结果：Thread Name= 0 default Formatter = yyyyMMdd HHmmThread Name= 0 formatter = yy-M-d ah:mmThread Name= 1 default Formatter = yyyyMMdd HHmmThread Name= 2 default Formatter = yyyyMMdd HHmmThread Name= 1 formatter = yy-M-d ah:mmThread Name= 3 default Formatter = yyyyMMdd HHmmThread Name= 2 formatter = yy-M-d ah:mmThread Name= 4 default Formatter = yyyyMMdd HHmmThread Name= 3 formatter = yy-M-d ah:mmThread Name= 4 formatter = yy-M-d ah:mmThread Name= 5 default Formatter = yyyyMMdd HHmmThread Name= 5 formatter = yy-M-d ah:mmThread Name= 6 default Formatter = yyyyMMdd HHmmThread Name= 6 formatter = yy-M-d ah:mmThread Name= 7 default Formatter = yyyyMMdd HHmmThread Name= 7 formatter = yy-M-d ah:mmThread Name= 8 default Formatter = yyyyMMdd HHmmThread Name= 9 default Formatter = yyyyMMdd HHmmThread Name= 8 formatter = yy-M-d ah:mmThread Name= 9 formatter = yy-M-d ah:mm 原理： ThreadLocal底层是ThreadLocalMap。 每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key ，Object对象为 value 的键值对。1234public class Thread implements Runnable &#123; // 与此线程有关的ThreadLocal值。由ThreadLocal类维护 ThreadLocal.ThreadLocalMap threadLocals = null;&#125; ThreadLocal的set()方法：调用的是ThreadLocalMap的set方法将(ThreadLocal, value)存储到ThreadLocalMap12345678910111213141516public void set(T value) &#123; //获取当前请求的线程 Thread t = Thread.currentThread(); //取出 Thread 类内部的 threadLocals 变量(哈希表结构) ThreadLocalMap map = getMap(t); if (map != null)&#123; // 将需要存储的值放入到这个哈希表中 map.set(this, value); &#125;else&#123; createMap(t, value); &#125;&#125;ThreadLocalMap getMap(Thread t) &#123;return t.threadLocals;&#125; 内存泄露问题是怎么导致的？ ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用，所以在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。 这样，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。 解决方案：使用完ThreadLocal方法后最好手动调用remove()方法 85.4 线程池 概念：为了避免频繁重复的创建和销毁线程，我们可以让这些线程进行复用。而线程池是将创建的线程存储到一个池中，在需要使用时从池中去拿，使用完之后再将线程归还到池中，下一次接着使用。 如何创建线程池：通过ThreadPoolExecutor构造函数来创建 线程池常见参数有哪些？如何解释？ 1234567891011121314151617181920212223242526/*** 用给定的初始参数创建一个新的ThreadPoolExecutor。*/public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量 int maximumPoolSize,//线程池的最大线程数 long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit,//时间单位 BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列 ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可 RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务 ) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; ThreadPoolExecutor 3 个最重要的参数： corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。 maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 ThreadPoolExecutor其他常见参数 : keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 corePoolSize ，回收过程才会停止。 unit : keepAliveTime 参数的时间单位。 threadFactory :executor 创建新线程的时候会用到。 handler :饱和策略。关于饱和策略下面单独介绍一下。 线程池的饱和策略有哪些？ 接口RejectedExecutionHandler定义了饱和策略，所有的饱和策略都需要实现该接口。123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; ThreadPoolExecutor.AbortPolicy： 拒绝处理，抛出RejectedExecutionException异常 ThreadPoolExecutor.CallerRunsPolicy： 由创建该线程的线程（main）执行 ThreadPoolExecutor.DiscardPolicy： 丢弃，不抛出异常 ThreadPoolExecutor.DiscardOldestPolicy： 和最早创建的线程进行竞争，不抛出异常 86. AQS86.1 概述 AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。 这个类在 java.util.concurrent.locks 包下面。 AQS 是一个抽象类，主要用来构建锁和同步器。 86.2 自旋锁和非自旋锁 什么是自旋锁： 它并不会放弃CPU时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止； 什么是非自旋锁： 如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁 非自旋锁和自旋锁最大的区别，在非自旋锁遇到拿不到锁的情况，它会把线程阻塞，直到被唤醒。而自旋锁会不停地尝试。 86.3 CLH锁 CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。 在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。 CLH 队列结构如下图所示： 86.4 AQS原理AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。 87. IO87.1 IO流简介 概念：IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。 分类：IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。 4个抽象类基类：Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 87.2 字节流 InputStream（字节输入流）（抽象类） FileInputStream（子类）12345678910111213141516171819/*** 目标：掌握文件字节输入流，每次读取一个字节。*/public class FileInputStreamTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建文件字节输入流管道，与源文件接通。 InputStream is = new FileInputStream((&quot;file-io-app\\\\src\\\\itheima01.txt&quot;)); // 2、开始读取文件的字节数据。 // public int read():每次读取一个字节返回，如果没有数据了，返回-1. int b; // 用于记住读取的字节。 while ((b = is.read()) != -1)&#123; System.out.print((char) b); &#125; //3、流使用完毕之后，必须关闭！释放系统资源！ is.close(); &#125;&#125; BufferedInputStream（字节缓冲输入流）：缓冲流的底层自己封装了一个长度为8KB（8129byte）的字节数组，但是缓冲流不能单独使用，它需要依赖于原始流。123456789101112131415161718192021222324public class BufferedInputStreamTest1 &#123; public static void main(String[] args) &#123; try ( InputStream is = new FileInputStream(&quot;io-app2/src/itheima01.txt&quot;); // 1、定义一个字节缓冲输入流包装原始的字节输入流 InputStream bis = new BufferedInputStream(is); OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima01_bak.txt&quot;); // 2、定义一个字节缓冲输出流包装原始的字节输出流 OutputStream bos = new BufferedOutputStream(os); )&#123; byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1)&#123; bos.write(buffer, 0, len); &#125; System.out.println(&quot;复制完成！！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; OutputStream（字节输出流）（抽象类） FileOutputStream（子类）123456789101112131415161718192021222324252627/*** 目标：掌握文件字节输出流FileOutputStream的使用。*/public class FileOutputStreamTest4 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个字节输出流管道与目标文件接通。 // 覆盖管道：覆盖之前的数据 // OutputStream os = new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;); // 追加数据的管道 OutputStream os = new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;, true); // 2、开始写字节数据出去了 os.write(97); // 97就是一个字节，代表a os.write(&#x27;b&#x27;); // &#x27;b&#x27;也是一个字节 // os.write(&#x27;磊&#x27;); // [ooo] 默认只能写出去一个字节 byte[] bytes = &quot;我爱你中国abc&quot;.getBytes(); os.write(bytes); os.write(bytes, 0, 15); // 换行符 os.write(&quot;\\r\\n&quot;.getBytes()); os.close(); // 关闭流 &#125;&#125; BufferedOutputStream（字节缓冲输出流） 87.3 字符流 Reader（字符输入流）（抽象类） FileReader（子类）123456789101112131415161718192021/*** 目标：掌握文件字符输入流。*/public class FileReaderTest1 &#123; public static void main(String[] args) &#123; try ( // 1、创建一个文件字符输入流管道与源文件接通 Reader fr = new FileReader(&quot;io-app2\\\\src\\\\itheima01.txt&quot;); )&#123; // 2、每次读取多个字符。 char[] buffer = new char[3]; int len; // 记住每次读取了多少个字符。 while ((len = fr.read(buffer)) != -1)&#123; // 读取多少倒出多少 System.out.print(new String(buffer, 0, len)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; BufferedReader（字符缓冲输入流）：它底层也会有一个8KB的字符数组。字符缓冲流也不能单独使用，它需要依赖于原始字符流一起使用。12345678910111213141516public class BufferedReaderTest2 &#123; public static void main(String[] args) &#123; try ( Reader fr = new FileReader(&quot;io-app2\\\\src\\\\itheima04.txt&quot;); // 创建一个字符缓冲输入流包装原始的字符输入流 BufferedReader br = new BufferedReader(fr); )&#123; String line; // 记住每次读取的一行数据 while ((line = br.readLine()) != null)&#123; System.out.println(line); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; InputStreamReader（转换流）： FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码。转换流可以将字节流转换为字符流，并且可以指定编码方案。 InputStreamReader类表示可以把InputStream转换为Reader，它是字符输入流。 InputStreamReader也是不能单独使用的，它内部需要封装一个InputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。123456789101112131415161718192021public class InputStreamReaderTest2 &#123; public static void main(String[] args) &#123; try ( // 1、得到文件的原始字节流（GBK的字节流形式） InputStream is = new FileInputStream(&quot;io-app2/src/itheima06.txt&quot;); // 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流 Reader isr = new InputStreamReader(is, &quot;GBK&quot;); // 3、把字符输入流包装成缓冲字符输入流 BufferedReader br = new BufferedReader(isr); )&#123; String line; while ((line = br.readLine()) != null)&#123; System.out.println(line); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Writer（字符输出流）（抽象类） FileWriter（子类）123456789101112131415161718192021222324252627282930313233343536/*** 目标：掌握文件字符输出流：写字符数据出去*/public class FileWriterTest2 &#123; public static void main(String[] args) &#123; try ( // 0、创建一个文件字符输出流管道与目标文件接通。 // 覆盖管道 // Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;); // 追加数据的管道 Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;, true); )&#123; // 1、public void write(int c): 写一个字符出去 fw.write(&#x27;a&#x27;); fw.write(97); fw.write(&#x27;磊&#x27;); // 写一个字符出去 fw.write(&quot;\\r\\n&quot;); // 换行 // 2、public void write(String c): 写一个字符串出去 fw.write(&quot;我爱你中国abc&quot;); fw.write(&quot;\\r\\n&quot;); // 3、public void write(String c ,int pos ,int len): 写字符串的一部分出去 fw.write(&quot;我爱你中国abc&quot;, 0, 5); fw.write(&quot;\\r\\n&quot;); // 4、public void write(char[] buffer): 写一个字符数组出去 char[] buffer = &#123;&#x27;黑&#x27;, &#x27;马&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; fw.write(buffer); fw.write(&quot;\\r\\n&quot;); // 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去 fw.write(buffer, 0, 2); fw.write(&quot;\\r\\n&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; BufferedWriter（字符缓冲输出流）1234567891011121314151617181920public class BufferedWriterTest3 &#123; public static void main(String[] args) &#123; try ( Writer fw = new FileWriter(&quot;io-app2/src/itheima05out.txt&quot;, true); // 创建一个字符缓冲输出流管道包装原始的字符输出流 BufferedWriter bw = new BufferedWriter(fw); )&#123; bw.write(&#x27;a&#x27;); bw.write(97); bw.write(&#x27;磊&#x27;); bw.newLine(); bw.write(&quot;我爱你中国abc&quot;); bw.newLine(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; OutputStreamWriter（转换流） OutputStreamWriter类表示可以把OutputStream转换为Writer，它是字符输出流。 OutputStreamReader也是不能单独使用的，它内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。12345678910111213141516171819public class OutputStreamWriterTest3 &#123; public static void main(String[] args) &#123; // 指定写出去的字符编码。 try ( // 1、创建一个文件字节输出流 OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima07out.txt&quot;); // 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。 Writer osw = new OutputStreamWriter(os, &quot;GBK&quot;); // 3、把字符输出流包装成缓冲字符输出流 BufferedWriter bw = new BufferedWriter(osw); )&#123; bw.write(&quot;我是中国人abc&quot;); bw.write(&quot;我爱你中国123&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 87.4 打印流 PrintStream：字节打印流 System.out 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。 PrintStream 是 OutputStream 的子类 PrintWriter：字符打印流 PrintWriter 是 Writer 的子类123456789101112131415161718192021public class PrintTest1 &#123; public static void main(String[] args) &#123; try ( // 1、创建一个打印流管道 // PrintStream ps = new PrintStream(&quot;io-app2/src/itheima08.txt&quot;, Charset.forName(&quot;GBK&quot;)); // PrintStream ps = new PrintStream(&quot;io-app2/src/itheima08.txt&quot;); PrintWriter ps = new PrintWriter(new FileOutputStream(&quot;io-app2/src/itheima08.txt&quot;, true)); )&#123; ps.print(97); //文件中显示的就是:97 ps.print(&#x27;a&#x27;); //文件中显示的就是:a ps.println(&quot;我爱你中国abc&quot;); //文件中显示的就是:我爱你中国abc ps.println(true);//文件中显示的就是:true ps.println(99.5);//文件中显示的就是99.5 ps.write(97); //文件中显示a，发现和前面println方法的区别了吗？ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 87.5 序列化流 ObjectInputStream 12345678910111213141516171819202122232425262728// 注意：对象如果需要序列化，必须实现序列化接口。public class User implements Serializable &#123; private String loginName; private String userName; private int age; // transient 这个成员变量将不参与序列化。 private transient String passWord; public User() &#123; &#125; public User(String loginName, String userName, int age, String passWord) &#123; this.loginName = loginName; this.userName = userName; this.age = age; this.passWord = passWord; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;loginName=&#x27;&quot; + loginName + &#x27;\\&#x27;&#x27; + &quot;, userName=&#x27;&quot; + userName + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, passWord=&#x27;&quot; + passWord + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1234567891011121314public class Test2ObjectInputStream &#123; public static void main(String[] args) &#123; try ( // 1、创建一个对象字节输入流管道，包装 低级的字节输入流与源文件接通 ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;io-app2/src/itheima11out.txt&quot;)); )&#123; // 2. 读取object对象 User u = (User) input.readObject(); System.out.println(u); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ObjectOutputStream 123456789101112131415161718public class Test1ObjectOutputStream &#123; public static void main(String[] args) &#123; try ( // 1、创建一个对象字节输出流包装原始的字节 输出流。 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;io-app2/src/itheima11out.txt&quot;)); )&#123; // 2、创建一个Java对象。 User u = new User(&quot;admin&quot;, &quot;张三&quot;, 32, &quot;666888xyz&quot;); // 3、序列化对象到文件中去 oos.writeObject(u); System.out.println(&quot;序列化对象成功！！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 87.6 IO 设计模式 装饰器模式： 概念：Decorator Pattern，可以在不改变原有对象的情况下拓展其功能。装饰器模式通过组合，替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。12345678910// 例子：try (BufferedInputStream input = new BufferedInputStream(new FileInputStream(&quot;input.txt&quot;))) &#123; int content; long skip = input.skip(2); while ((content = input.read()) != -1) &#123; System.out.print((char) content); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 思考：为什么不直接弄一个BufferedFileInputStream（字符缓冲文件输入流）呢？1BufferedFileInputStream bfis = new BufferedFileInputStream(&quot;input.txt&quot;); InputStream的子类实在太多，继承关系也非常复杂。如果为每一个子类都定制一个对应的缓冲输入流，非常麻烦。 通过装饰器模式代替继承可以扩展原始类的功能。 适配器模式： 概念：Adapter Pattern，主要用于接口互不兼容的类的协调工作。被适配的对象或者类称为适配者(Adaptee)，作用于适配者的对象或者类称为适配器(Adapter) 。 适配器：InputStreamReader 和 OutputStreamWriter 就是两个适配器(Adapter)，它们两个也是字节流和字符流之间的桥梁。InputStreamReader 使用 StreamDecoder（流解码器）对字节进行解码，实现字节流到字符流的转换， OutputStreamWriter 使用StreamEncoder（流编码器）对字符进行编码，实现字符流到字节流的转换。 适配者：InputStream 和 OutputStream 的子类是适配者。1234// InputStreamReader 是适配器，FileInputStream 是被适配的类InputStreamReader input = new InputStreamReader(new FileInputStream(fileName), &quot;UTF-8&quot;);// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）BufferedReader bufferedReader = new BufferedReader(input); 88. IO模型88.1 BIO (Blocking I&#x2F;O) 定义： BIO 属于同步阻塞 IO 模型 。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。 缺点： 在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。 88.2 NIO (Non-blocking&#x2F;New I&#x2F;O) 定义： NIO 属于同步非阻塞 IO 模型。同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。 88.3 AIO (Asynchronous I&#x2F;O) 定义： AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是异步 IO 模型。 89. JVM 内存区域89.1 概述 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。 线程私有的： 程序计数器 虚拟机栈 本地方法栈 线程共享的： 堆 方法区 直接内存 (非运行时数据区的一部分) 89.2 线程私有：程序计数器(Program Counter Register) 概念： 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。 特点： 线程私有 生命周期：与线程共存亡 一块较小的内存空间,存储字节码行号； 是唯一一块不会出现OutOfMemoryError的内存区域； 作用： 字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，从而实现代码的流程控制； 多线程情况下，用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了。 89.3 线程私有：Java 虚拟机栈 概念： 描述的是Java方法执行的线程内存模型：每个方法被执行时，Java虚拟机都会同步创建一个栈帧（用于存储局部变量表、操作数栈、动态链接、方法返回地址），每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。 特点： 线程私有 生命周期：与线程共存亡 栈帧中存储局部变量表、操作数栈、动态链接、方法返回地址 会出现两种错误： StackOverFlowError：（stack内存不允许动态扩展时）当线程请求的栈的深度超过当前Java虚拟机栈的最大深度时报错； OutOfMemoryError：（stack内存允许动态扩展时）如果虚拟机的动态扩展栈时无法申请到足够的空间，则报异常。(HotSpot虚拟机是不支持动态扩展的，但如果是手动申请栈空间失败了也会报OOM异常) 89.4 线程私有：本地方法栈 概念： 基本功能和Java虚拟机栈基本一样。 和Java虚拟机栈的区别是： Java虚拟机栈描述Java方法的执行； 本地方法栈描述Native方法的执行。 89.5 线程共享：堆 特点： 唯一目的：存放实例对象（几乎所有的实例对象和数组都在这里分配内存） 线程共享 生命周期：与虚拟机共存亡 Java虚拟机所管制内存中最大的一块 GC的主要区域 最容易出现OutOfMemoryError错误 堆内存划分： 更好地回收内存，更快的分配内存。 不同版本堆内存划分： 在 JDK 7 版本及之前版本，堆内存被通常分为下面三部分： 新生代内存(Young Generation)(Eden 区、两个 Survivor 区 S0 和 S1 ) 老生代(Old Generation) 永久代(Permanent Generation) JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。 年轻代（Eden、S0、S1）、老年代 默认情况下，年轻代与老年代比例为1:2，可以通过参数 -xx:NewRatio 修改，NewRatio默认值是2 默认情况下Eden、S0、S1的比例是8:1:1，可以通过参数 -xx:SurvivorRatio 修改，SurvivorRatio默认值是8 89.6 线程共享：方法区 概念： 当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 特点： 线程共享 存储：已被虚拟机加载的类信息、静态变量、常量、即时编译器编译后的代码等数据 GC较少出现，但并非不出现 方法区和永久代的关系 方法区：是一个概念，并没有具体的实现（类似于接口） 永久代：是HotSpot虚拟机中对方法区的一种实现方式 （类似于接口的实现类） 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢? 永久代有JVM本身设置的固定内存大小上限，而元空间使用直接内存，受本机可用内存的限制，使得溢出的几率减小。 Java虚拟机能够加载多少类可直接由系统的实际可用空间来控制，使得能够加载更多的类。 89.7 线程共享：运行时常量池 特点： 方法区的一部分； 常量池将在类加载后存放到方法区的运行时常量池中； 当常量池无法再申请到内存时会抛出OutOfMemoryError错误 方法区的Class文件信息，Class常量池和运行时常量池的三者关系 89.8 线程共享：字符串常量池 概念： 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。123456// 在堆中创建字符串对象”ab“// 将字符串对象”ab“的引用保存在字符串常量池中String aa = &quot;ab&quot;;// 直接返回字符串常量池中字符串对象”ab“的引用String bb = &quot;ab&quot;;System.out.println(aa==bb); // true JDK 1.7 为什么要将字符串常量池移动到堆中？ 主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。 89.9 线程共享：直接内存 不是虚拟机运行时数据区的一部分 会导致OutOfMemoryError错误出现 本机直接内存的分配不会受到Java堆的限制，但是既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 90. HotSpot虚拟机对象90.1 对象的创建 Step1:类加载检查 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 Step2:分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 内存分配的两种方式 （补充内容，需要掌握）： 指针碰撞： 适用场合：堆内存规整（即没有内存碎片）的情况下。 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。 使用该分配方式的 GC 收集器：Serial, ParNew 空闲列表： 适用场合：堆内存不规整的情况下。 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。 使用该分配方式的 GC 收集器：CMS 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。 内存分配并发问题（补充内容，需要掌握） 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全： CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 Step3:初始化零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 Step4:设置对象头 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 Step5:执行 init 方法 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&lt;init&gt; 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 90.2 对象的访问定位 概念： 建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。 分类： 句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。 直接指针 如果使用直接指针访问，reference 中存储的直接就是对象的地址。 两种分类的优缺点： 这两种对象访问方式各有优势。 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。 使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 90. JVM垃圾回收90.1 垃圾回收机制 所有的对象首先会在Eden区进行分配，当Eden区满了之后会进行第1次Minor GC； 第1次GC之后仍然存活的对象，会复制到Survivor S0，同时对象年龄+1(此时年龄&#x3D;1)，然后清理其之前占用的内存； 第2次会对Eden+S0同时进行GC，仍然存活的对象会复制到Survivor S1，年龄+1，同时清理之前占用的内存(此时S0区会变成空)； 以此类推，每次都有一个Survivor区是空的； 当Survivor区域对象的年龄达到 -xx:MaxTenuringThreshold 设定的值(默认15)，会将此对象移到老年代，同时清空他们在年轻代占用的内存空间； 当老年代空间不够用了，会发生Full GC (回收整个堆内存)； 当某些大对象需要分配一块较大的连续空间时会直接进入老年代，而不会经过以上步骤。 90.2 死亡对象判断方法 引用计数法： 概念：给对象中添加一个引用计数器：每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。 缺点：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。 可达性分析算法： 概念：目前的主流算法。这个算法的基本思想就是通过一系列被称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。 对象可以被回收，就代表一定会被回收吗？ 被判定为需要回收的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。 90.3 垃圾回收算法 标记-清除算法 它的思想就是先标记（两次标记），再清除。 缺点： 效率不高（标记和清除两个过程效率都不高。） 会产生大量内存碎片（内存碎片是指内存的空间比较零碎，缺少大段的连续空间。这样假如突然来了一个大对象，会找不到足够大的连续空间来存放，于是不得不再触发一次gc。） 复制算法 概念：为了解决标记-清除算法的效率和内存碎片问题，复制算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 缺点： 可用内存变小：可用内存缩小为原来的一半。 不适合老年代：如果存活对象数量比较大，复制性能会变得很差。 标记-整理算法 概念：标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 缺点： 由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。 分代回收算法 概念：当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。 91. 类加载器91.1 类加载过程 类的生命周期： 类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution）（验证、准备和解析这三个阶段可以统称为连接（Linking）） 初始化（Initialization） 使用（Using） 卸载（Unloading） 类加载过程： 系统加载 Class 类型的文件主要三步：加载-&gt;连接-&gt;初始化。连接过程又可分为三步：验证-&gt;准备-&gt;解析。 91.1 类加载器 作用： 类加载器的主要作用就是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）。 字节码可以是 Java 源程序（.java文件）经过 javac 编译得来，也可以是通过工具动态生成或者通过网络下载得来。 其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。 类加载器加载规则 JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。 对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。 JVM 中内置了三个重要的 ClassLoader： **Bootstrap ClassLoader(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ %JAVA_HOME%/lib目录下的jar 包和类）以及被 -Xbootclasspath参数指定的路径下的所有类。 **Extension ClassLoader(扩展类加载器)**：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。 **Application Classloader(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。 91.2 双亲委派模型 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 findClass() 方法来加载类）。 91.3 双亲委派模型的好处 双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。 如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现两个不同的 Object 类。双亲委派模型可以保证加载的是 JRE 里的那个 Object 类，而不是你写的 Object 类。这是因为 AppClassLoader 在加载你的 Object 类时，会委托给 ExtClassLoader 去加载，而 ExtClassLoader 又会委托给 BootstrapClassLoader，BootstrapClassLoader 发现自己已经加载过了 Object 类，会直接返回，不会去加载你写的 Object 类。 92. 排查 OOM92.1 常见的 OOM 异常情况有两种 堆内存溢出 方法区溢出 92.2 堆内存溢出 java.lang.OutOfMemoryError: Java heap space ——&gt;java 堆内存溢出， 此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。 对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx 来修改。 92.3 方法区溢出 java.lang.OutOfMemoryError: PermGen space 或 java.lang.OutOfMemoryError：MetaSpace ——&gt;java 方法区溢出 一般出现在大量 Class、或者采用 cglib 等反射机制的情况，因为这些情况会产生大量的 Class 信息存储于方法区。过多的常量尤其是字符串也会导致方法区溢出。 这种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m -XX:MaxPermSize&#x3D;256m 的形式修改。 92.4 排查方式： 先获取内存的 Dump 文件，Dump 文件有两种方式来生成： 第一种是配置 JVM 启动参数，当触发了 OOM 异常的时候自动生成， 第二种是使用 jmap 工具来生成。 然后使用 MAT 工具来分析 Dump 文件。 如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类信息和 GC Roots 引用链的信息，就可以比较准确地定位泄漏代码的位置。 如果是普通的内存溢出，确实有很多占用内存的对象，那就只需要提升堆内存空间即可。","categories":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试-算法","slug":"面试-算法","date":"2021-06-08T11:50:53.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2021/06/08/面试-算法/","link":"","permalink":"https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/","excerpt":"","text":"1主要总结算法的模板题 1. 输入输出123常用的数据输入方法有两种，Scanner和BufferedReader。BufferedReader可以读一行，速度比Scanner快，所以数据较多的时候使用。注意BufferedReader用完记得关。 1.1 输入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// 1. 导入包import java.io.*; public class Main&#123; //2. 抛出IOException异常 public static void main(String[] args) throws IOException &#123; // 3. 定义BufferedReader类 // 最后不要忘了关闭reader BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); /** * 字符串 */ // 只读取一行字符串 String string1 = reader.readLine(); // 连续读取多行字符串 String string2; while((str = reader.readLine()) != null)&#123; //如果不为空，才进行下述操作 System.out.println(string2); &#125; /** * char */ // 一行一个char char ca = reader.readLine().charAt(0); // 一行一个char数组 char[] charArray = reader.readLine().toCharArray(); /** * 整型 */ // 一行一个整数 short short1 = Short.parseShort(reader.readLine()); int int1 = Integer.parseInt(reader.readLine()); long long1 = Long.parseLong(reader.readLine()); // 一行多个整数 String[] sList = reader.readLine().split(&quot; &quot;); //用空格分割，也可以用逗号分割 for (String s : sList)&#123; // String转为整数 System.out.println(Integer.parseInt(s)); &#125; // 转化为int数组 int[] arr = new int[s.length]; for(int i = 0; i &lt; s.length; i++)&#123; arr[i] = Integer.parseInt(s[i]); &#125; /** * 浮点型 */ // float float f = Float.parseFloat(reader.readLine()); // double double d = Double.parseDouble(reader.readLine()); /** * 大数 */ BigInteger bigInteger1 = new BigInteger(reader.readLine()); BigInteger bigInteger2 = new BigInteger(reader.readLine()); // 加 System.out.println(bigInteger1.add(bigInteger2)); // 减 System.out.println(bigInteger1.subtract(bigInteger2)); // 乘 System.out.println(bigInteger1.multiply(bigInteger2)); // 除 System.out.println(bigInteger1.divide(bigInteger2)); /** * 高精度浮点数 */ BigDecimal bigDecimal1 = new BigDecimal(reader.readLine()); BigDecimal bigDecimal2 = new BigDecimal(reader.readLine()); // 加 System.out.println(bigDecimal1.add(bigDecimal2)); // 减 System.out.println(bigDecimal1.subtract(bigDecimal2)); // 乘 System.out.println(bigDecimal1.multiply(bigDecimal2)); // 除 System.out.println(bigDecimal1.divide(bigDecimal2, 3, RoundingMode.HALF_UP)); // 第二个参数：保留小数位数；第三位参数：四舍五入模式 /** * 进制 */ // 字符串转2进制int int int2 = Integer.parseInt(reader.readLine(), 2); // 字符串转2进制大数 BigInteger bigInteger2 = new BigInteger(reader.readLine(), 2); /** * double格式化 */ // 导入包：import java.text.*; NumberFormat formatter; String s; double d = -1234.567; // 强制在整数部分加0：0，多几位就多几个0 formatter = new DecimalFormat(&quot;000000&quot;); s = formatter.format(d); System.out.println(s); // -001235 formatter = new DecimalFormat(&quot;00&quot;); s = formatter.format(d); System.out.println(s); // -1235 // 强制保留小数部分：0，有几个0就保留几位小数 formatter = new DecimalFormat(&quot;000000.00&quot;); s = formatter.format(d); System.out.println(s); // -001235.57 formatter = new DecimalFormat(&quot;.00&quot;); s = formatter.format(d); System.out.println(s); // -1235.57 /** * 排序 */ System.out.println(&quot;array默认升序_________________________________________________&quot;); //默认升序，从小到大 int[] arr = &#123;1,3,8,5,2,7&#125;; Arrays.sort(arr); System.out.println(Arrays.toString(arr)); System.out.println(&quot;array降序_______________________________________________&quot;); Integer[] arr2 = new Integer[]&#123;1,2,3,8,5&#125;; // 只支持包装类元素逆序 Arrays.sort(arr2,Collections.reverseOrder()); System.out.println(Arrays.toString(arr2)); System.out.println(&quot;List默认升序_______________________________________________&quot;); List&lt;Integer&gt; arrList = new ArrayList&lt;&gt;(); arrList.add(1);arrList.add(4);arrList.add(2);arrList.add(78);arrList.add(23); //集合工具类Collections，对集合进行升序排序 Collections.sort(arrList); System.out.println(Arrays.toString(arrList.toArray())); System.out.println(&quot;List降序__________________________________________________&quot;); Collections.sort(arrList,Collections.reverseOrder()); System.out.println(Arrays.toString(arrList.toArray())); // 关闭reader reader.close(); &#125;&#125; 1.2 输出123456789101112131415161718192021// 1. 单行输出System.out.println(result);// 2. 多行输出System.out.println(result1);System.out.println(result2);System.out.println(result3);// 3. 格式化输出System.out.printf(&quot;Formatted result: %.2f&quot;, floatValue);// 4. 输出数组或集合int[] array = &#123;1, 2, 3, 4, 5&#125;;for (int num : array) &#123; System.out.print(num + &quot; &quot;);&#125;// 5. 特殊字符输出System.out.println(&quot;Line 1\\nLine 2\\tTabbed&quot;); 2. 排序算法2.1 分类123456789101112131415161718192021222324graph LR;A(排序) --&gt; B(内部排序)A(排序) --&gt; C(外部排序)B --&gt; D(选择排序)B --&gt; E(插入排序)B --&gt; F(交换排序)B --&gt; G(归并排序)B --&gt; H(桶排序)C --&gt; I(多路归并)C --&gt; J(败者树)D --&gt; K(直接选择排序)D --&gt; L(堆排序)E --&gt; M(直接插入排序)E --&gt; N(希尔排序)F --&gt; O(冒泡排序)F --&gt; P(快速排序)H --&gt; Q(计数排序)H --&gt; R(基数排序) 2.2 时间复杂度和空间复杂度 排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 冒泡排序 O(n2) O(n2) O(n) O(1) 稳定 直接选择排序 O(n2) O(n2) O(n) O(1) 不稳定 直接插入排序 O(n2) O(n2) O(n) O(1) 稳定 快速排序 O(nlogn) O(n2) O(nlogn) O(logn) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 希尔排序 O(nlogn) O(ns) O(n) O(1) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 基数排序 O(N*M) O(N*M) O(N*M) O(M) 稳定 注：基数排序: 基数排序时间复杂度为O(N*M)，其中N为数据个数，M为数据位数。 记忆： 时间复杂度： 冒泡、选择、插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)）（一遍找元素O(n)，一遍找位置O(n)） 快速、堆、希尔、归并基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)） 稳定性： “快希选堆”（快牺牲稳定性） 排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。 2.3 原理 冒泡排序 原理：从数组最左端开始向右遍历，依次比较相邻元素大小，如果”左元素 &gt; 右元素”就交换它俩。遍历完成后，最大的元素会被移动到数组的最右端。 算法流程： 首先，对n个元素执行”冒泡”，将数组的最大元素交换至正确位置， 接下来，对剩余n-1个元素执行”冒泡”，将第二大元素交换至正确位置。 以此类推，经过n-1轮”冒泡”后，前n-1大的元素都被交换至正确位置。 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。 图示： 代码：123456789101112131415/* 冒泡排序 */void bubbleSort(int[] nums) &#123; // 外循环：未排序区间为 [0, i] for (int i = nums.length - 1; i &gt; 0; i--) &#123; // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; // 交换 nums[j] 与 nums[j + 1] int tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; &#125; &#125; &#125;&#125; 选择排序： 原理：轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。 算法流程： 初始状态下，所有元素未排序，即未排序（索引）区间为[0,n-1]。 选取区间[0,n-1]中的最小元素，将其与索引0处元素交换。完成后，数组前1个元素已排序。 选取区间[1,n-1]中的最小元素，将其与索引1处元素交换。完成后，数组前2个元素已排序。 以此类推。经过n-1轮选择与交换后，数组前n-1个元素已排序。 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。 图示： 代码：1234567891011121314151617/* 选择排序 */void selectionSort(int[] nums) &#123; int n = nums.length; // 外循环：未排序区间为 [i, n-1] for (int i = 0; i &lt; n - 1; i++) &#123; // 内循环：找到未排序区间内的最小元素 int k = i; for (int j = i + 1; j &lt; n; j++) &#123; if (nums[j] &lt; nums[k]) k = j; // 记录最小元素的索引 &#125; // 将该最小元素与未排序区间的首个元素交换 int temp = nums[i]; nums[i] = nums[k]; nums[k] = temp; &#125;&#125; 插入排序 原理：在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。 算法流程： 初始状态下，数组的第1个元素已完成排序。 选取数组的第2个元素作为base，将其插入到正确位置后，数组的前2个元素已排序。 选取第3个元素作为base，将其插入到正确位置后，数组的前3个元素已排序。 以此类推，在最后一轮中，选取最后一个元素作为base，将其插入到正确位置后，所有元素均已排序。 图示： 代码：12345678910111213/* 插入排序 */void insertionSort(int[] nums) &#123; // 外循环：已排序元素数量为 1, 2, ..., n for (int i = 1; i &lt; nums.length; i++) &#123; int base = nums[i], j = i - 1; // 内循环：将 base 插入到已排序部分的正确位置 while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) &#123; nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位 j--; &#125; nums[j + 1] = base; // 将 base 赋值到正确位置 &#125;&#125; 快速排序： 原理：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。 算法流程： 选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端。 设置一个循环，在每轮中使用i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。 循环执行步骤2，直到i和j相遇时停止，最后将基准数交换至两个子数组的分界线。 图示： 代码：123456789101112131415161718192021222324252627282930313233/* 元素交换 */void swap(int[] nums, int i, int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;&#125;/* 哨兵划分 */int partition(int[] nums, int left, int right) &#123; // 以 nums[left] 作为基准数 int i = left, j = right; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) j--; // 从右向左找首个小于基准数的元素 while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) i++; // 从左向右找首个大于基准数的元素 swap(nums, i, j); // 交换这两个元素 &#125; swap(nums, i, left); // 将基准数交换至两子数组的分界线 return i; // 返回基准数的索引&#125;/* 快速排序 */void quickSort(int[] nums, int left, int right) &#123; // 子数组长度为 1 时终止递归 if (left &gt;= right) return; // 哨兵划分 int pivot = partition(nums, left, right); // 递归左子数组、右子数组 quickSort(nums, left, pivot - 1); quickSort(nums, pivot + 1, right);&#125; 3. 链表3.1 读取链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); // 如果第一行表示节点个数，那就读取n int n = Integer.parseInt(reader.readLine()); String[] s = reader.readLine().split(&quot; &quot;); //用空格分割，也可以用逗号分割 // 创建虚拟头节点 LinkNode dummy = new LinkNode(0); // 创建当前指针 LinkNode current = dummy; for(int i = 0; i &lt; s.length; i++)&#123; // 当前值 int val = Integer.parseInt(s[i]); // 创建当前指针的后继 current.next = new LinkNode(val); // 指针向后移一位 current = current.next; &#125; // current指针最后指向null current.next = null; // head指针为虚拟头节点的直接后继 LinkNode head = dummy.next; // 输出链表，仅为演示，实际问题中可能要根据题目要求进行输出 LinkNode node = head; while (node != null) &#123; System.out.print(node.val + &quot; &quot;); node = node.next; &#125; // 关闭资源 reader.close(); &#125; // 辅助类：构建一个节点类，用于链表构建 static class LinkNode &#123; int val; LinkNode next; public LinkNode(int val)&#123; this.val = val; &#125; &#125;&#125; 3.2 插入节点 123456/* 在链表的节点 n0 之后插入节点 P */void insert(ListNode n0, ListNode P) &#123; ListNode n1 = n0.next; P.next = n1; n0.next = P;&#125; 3.3 删除节点 12345678910/* 删除链表的节点 n0 之后的首个节点 */void remove(ListNode n0) &#123; if (n0.next == null) return; // n0 -&gt; P -&gt; n1 // n0.next = n0.next.next; ListNode P = n0.next; ListNode n1 = P.next; n0.next = n1;&#125; 3.4 访问节点123456789/* 访问链表中索引为 index 的节点 */ListNode access(ListNode head, int index) &#123; for (int i = 0; i &lt; index; i++) &#123; if (head == null) return null; head = head.next; &#125; return head;&#125; 3.5 查找节点1234567891011/* 在链表中查找值为 target 的首个节点 */int find(ListNode head, int target) &#123; int index = 0; while (head != null) &#123; if (head.val == target) return index; head = head.next; index++; &#125; return -1;&#125; 3.6 模板题 移除链表元素12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null) return head; // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作 ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode cur = head; while (cur != null) &#123; if (cur.val == val) &#123; pre.next = cur.next; &#125; else &#123; pre = cur; &#125; cur = cur.next; &#125; return dummy.next; &#125;&#125; 设计链表:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990class MyLinkedList&#123; // 定义节点 class Node&#123; // 节点值 int val; // 下一节点的地址 Node next; // 构造器 public Node(int val)&#123; this.val = val; &#125; &#125; // 链表的长度 int size; // 虚拟头节点 Node head; // 1、初始化链表 public MyLinkedList()&#123; size = 0; // 定义这个虚拟头节点的值为0 head = new Node(0); &#125; // 2. addAtIndex方法 public void addAtIndex(int index, int val)&#123; // 当index大于size if (index&gt;size)&#123; return; &#125; // 当index小于0 if (index&lt;0)&#123; index=0; &#125; // current指针移动到index的前一个 Node current = head; for (int i=0; i&lt;index; i++)&#123; current = current.next; &#125; // 插入的节点 Node addNode = new Node(val); addNode.next = current.next; current.next = addNode; // 链表总数+1 size++; &#125; // 3. addAtHead方法 public void addAtHead(int val)&#123; addAtIndex(0, val); &#125; // 4. addAtTail方法 public void addAtTail(int val)&#123; addAtIndex(size, val); &#125; // 5. get方法 public int get(int index)&#123; // 逻辑判断 if (index&lt;0 || index&gt;size-1)&#123; return -1; &#125; // 遍历每个节点 Node current = head; for (int i=0; i&lt;=index; i++)&#123; current = current.next; &#125; return current.val; &#125; // 6. deleteAtIndex方法 public void deleteAtIndex(int index)&#123; // 逻辑判断 if (index&lt;0 || index&gt;size-1)&#123; return; &#125; Node current = head; for (int i=0; i&lt;index; i++)&#123; current = current.next; &#125; current.next = current.next.next; size--; &#125;&#125; 反转链表:1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode cur = head; ListNode pre = null; ListNode tem = null; while (cur!=null)&#123; // 保存下一个节点 tem = cur.next; cur.next = pre; // 两个指针都往后移一位 pre = cur; cur = tem; &#125; return pre; &#125;&#125; 两两交换链表中的节点:123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; // 0/1个节点的情况 if (head==null || head.next==null) return head; ListNode pre = head; ListNode cur = head.next; while (cur!=null)&#123; int tem = pre.val; pre.val = cur.val; cur.val = tem; if (cur.next==null || cur.next.next==null) return head; pre = pre.next.next; cur = cur.next.next; &#125; return head; &#125;&#125; 删除链表的倒数第N个节点:12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 虚拟指针 ListNode dummy = new ListNode(0, head); // 双指针 ListNode pre = dummy; ListNode cur = dummy; // current指针往前先移动n个 for (int i=1; i&lt;=n; i++)&#123; cur = cur.next; &#125; // pre和cur同时往后移动 while (cur.next!=null)&#123; cur = cur.next; pre = pre.next; &#125; // 删除节点 pre.next = pre.next.next; return dummy.next; &#125;&#125; 链表相交:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; // 虚拟头节点 ListNode dummyA = new ListNode(0); dummyA.next = headA; ListNode dummyB = new ListNode(0); dummyB.next = headB; // 长度 int lenA = 0; int lenB = 0; // 计算两个链表的长度 ListNode tmpA = dummyA; ListNode tmpB = dummyB; while (tmpA.next!=null)&#123; tmpA = tmpA.next; lenA++; &#125; while (tmpB.next!=null)&#123; tmpB = tmpB.next; lenB++; &#125; // 将最长的链表的指针往前移动|lenA-lenB| ListNode tmpA1 = dummyA; ListNode tmpB1 = dummyB; if (lenA&gt;lenB)&#123; int step = lenA - lenB; for (int i=0; i&lt;step; i++)&#123; tmpA1 = tmpA1.next; &#125; &#125;else&#123; int step = lenB - lenA; for (int i=0; i&lt;step; i++)&#123; tmpB1 = tmpB1.next; &#125; &#125; // tmpA1和tmpB1依次往后移动 while (tmpA1!=null &amp;&amp; tmpB1!=null)&#123; if (tmpA1==tmpB1)&#123; return tmpA1; &#125; tmpA1 = tmpA1.next; tmpB1 = tmpB1.next; &#125; return null; &#125;&#125; 环形链表II:12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; // 定义一个hashmap HashMap&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;(); // 定义一个虚拟头节点 ListNode dummy = new ListNode(0); dummy.next = head; // 定义索引 int index = 0; // 循环 while (dummy.next!=null)&#123; if (map.containsValue(dummy))&#123; return dummy; &#125;else&#123; map.put(index, dummy); index++; dummy = dummy.next; &#125; &#125; return null; &#125;&#125; 4. 数组4.1 读取数组123456789101112131415161718import java.io.*;public class Main&#123; public static void main(String[] args) throws IOException &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); // 如果第一行表示节点个数，那就读取n int n = Integer.parseInt(reader.readLine()); String[] s = reader.readLine().split(&quot; &quot;); //用空格分割，也可以用逗号分割 int[] nums = new int[s.length]; for (int i = 0; i &lt; s.length; i++)&#123; nums[i] = Integer.parseInt(s[i]); &#125; // 关闭资源 reader.close(); &#125;&#125; 4.2 访问元素12345/* 访问元素 */int access(int[] nums, int index) &#123; // 获取并返回随机元素 return nums[index];&#125; 4.3 插入元素123456789/* 在数组的索引 index 处插入元素 num */void insert(int[] nums, int num, int index) &#123; // 把索引 index 以及之后的所有元素向后移动一位 for (int i = nums.length - 1; i &gt; index; i--) &#123; nums[i] = nums[i - 1]; &#125; // 将 num 赋给 index 处元素 nums[index] = num;&#125; 4.4 删除元素1234567/* 删除索引 index 处元素 */void remove(int[] nums, int index) &#123; // 把索引 index 之后的所有元素向前移动一位 for (int i = index; i &lt; nums.length - 1; i++) &#123; nums[i] = nums[i + 1]; &#125;&#125; 4.5 遍历数组123456789101112/* 遍历数组 */void traverse(int[] nums) &#123; int count = 0; // 通过索引遍历数组 for (int i = 0; i &lt; nums.length; i++) &#123; count++; &#125; // 直接遍历数组 for (int num : nums) &#123; count++; &#125;&#125;c 4.6 查找元素12345678/* 在数组中查找指定元素 */int find(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == target) return i; &#125; return -1;&#125; 4.7 扩容数组1234567891011/* 扩展数组长度 */int[] extend(int[] nums, int enlarge) &#123; // 初始化一个扩展长度后的数组 int[] res = new int[nums.length + enlarge]; // 将原数组中的所有元素复制到新数组 for (int i = 0; i &lt; nums.length; i++) &#123; res[i] = nums[i]; &#125; // 返回扩展后的新数组 return res;&#125; 4.8 模板题 二分查找: 1234567891011121314151617181920class Solution &#123; public int search(int[] nums, int target) &#123; // 左 int left = 0; // 右 int right = nums.length - 1; while (left&lt;=right)&#123; // 中间 int middle = left + (right - left) / 2; if (nums[middle]&gt;target)&#123; right = middle - 1; &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; &#125;else &#123; return middle; &#125; &#125; return -1; &#125;&#125; 移除元素: 123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; // 1. 定义两个指针fast, slow int slow = 0; for (int fast=0; fast&lt;=nums.length-1; fast++)&#123; if (nums[fast] != val)&#123; nums[slow++] = nums[fast]; &#125; &#125; return slow; &#125;&#125; 有序数组的平方: 12345678910111213141516171819class Solution &#123; public int[] sortedSquares(int[] nums) &#123; // 双向双指针 int left = 0; int right = nums.length - 1; int index = nums.length - 1; int[] result = new int[nums.length]; while (left &lt;= right)&#123; if (nums[right]*nums[right] &gt; nums[left]*nums[left])&#123; result[index--] = nums[right]*nums[right]; right--; &#125;else&#123; result[index--] = nums[left]*nums[left]; left++; &#125; &#125; return result; &#125;&#125; 长度最小的子数组: 12345678910111213141516class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int left = 0; int sum = 0; int len = Integer.MAX_VALUE; for (int right=0; right&lt;nums.length; right++)&#123; sum += nums[right]; while (sum&gt;=target)&#123; len = Math.min(len, right-left+1); sum -= nums[left++]; &#125; &#125; return len == Integer.MAX_VALUE ? 0 : len; &#125;&#125; 螺旋矩阵II: 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[][] generateMatrix(int n) &#123; // 定义左右上下 int left = 0, right = n-1, top = 0, bottom = n-1; // 定义填充的总数和正填充的计数 int count = 1, target = n*n; // 定义返回的数组 int[][] returnList = new int[n][n]; // i表示遍历行，j表示遍历列 while (count&lt;=target)&#123; // 从左到右 for (int j=left; j&lt;=right; j++)&#123; returnList[top][j] = count++; &#125; top++; // 从上往下 for (int i=top; i&lt;=bottom; i++)&#123; returnList[i][right] = count++; &#125; right--; // 从右往左 for (int j=right; j&gt;=left; j--)&#123; returnList[bottom][j] = count++; &#125; bottom--; // 从下往上 for (int i=bottom; i&gt;=top; i--)&#123; returnList[i][left] = count++; &#125; left++; &#125; return returnList; &#125;&#125; 5. 栈5.1 基本操作123456789101112131415161718/* 初始化栈 */Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();/* 元素入栈 */stack.push(1);stack.push(2);/* 访问栈顶元素 */int peek = stack.peek();/* 元素出栈 */int pop = stack.pop();/* 获取栈的长度 */int size = stack.size();/* 判断是否为空 */boolean isEmpty = stack.isEmpty(); 5.2 基于链表实现栈 push：链表头插法 pop：删除头节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 基于链表实现的栈 */class LinkedListStack &#123; private ListNode stackPeek; // 将头节点作为栈顶 private int stkSize = 0; // 栈的长度 public LinkedListStack() &#123; stackPeek = null; &#125; /* 获取栈的长度 */ public int size() &#123; return stkSize; &#125; /* 判断栈是否为空 */ public boolean isEmpty() &#123; return size() == 0; &#125; /* 入栈 */ public void push(int num) &#123; ListNode node = new ListNode(num); node.next = stackPeek; stackPeek = node; stkSize++; &#125; /* 出栈 */ public int pop() &#123; int num = peek(); stackPeek = stackPeek.next; stkSize--; return num; &#125; /* 访问栈顶元素 */ public int peek() &#123; if (size() == 0) throw new IndexOutOfBoundsException(); return stackPeek.val; &#125; /* 将 List 转化为 Array 并返回 */ public int[] toArray() &#123; ListNode node = stackPeek; int[] res = new int[size()]; for (int i = res.length - 1; i &gt;= 0; i--) &#123; res[i] = node.val; node = node.next; &#125; return res; &#125;&#125; 5.3 基于数组实现栈 push：插入到数组尾部 pop：删除数组尾元素12345678910111213141516171819202122232425262728293031323334353637383940414243/* 基于数组实现的栈 */class ArrayStack &#123; private ArrayList&lt;Integer&gt; stack; public ArrayStack() &#123; // 初始化列表（动态数组） stack = new ArrayList&lt;&gt;(); &#125; /* 获取栈的长度 */ public int size() &#123; return stack.size(); &#125; /* 判断栈是否为空 */ public boolean isEmpty() &#123; return size() == 0; &#125; /* 入栈 */ public void push(int num) &#123; stack.add(num); &#125; /* 出栈 */ public int pop() &#123; if (isEmpty()) throw new IndexOutOfBoundsException(); return stack.remove(size() - 1); &#125; /* 访问栈顶元素 */ public int peek() &#123; if (isEmpty()) throw new IndexOutOfBoundsException(); return stack.get(size() - 1); &#125; /* 将 List 转化为 Array 并返回 */ public Object[] toArray() &#123; return stack.toArray(); &#125;&#125; 5.4 模板题 用栈实现队列: 123456789101112131415161718192021222324252627282930313233343536373839404142class MyQueue &#123; // 定义两个栈 Stack&lt;Integer&gt; stackIn; Stack&lt;Integer&gt; stackOut; // 构造函数 public MyQueue() &#123; stackIn = new Stack&lt;&gt;(); stackOut = new Stack&lt;&gt;(); &#125; // 入队列 public void push(int x) &#123; stackIn.push(x); &#125; // 出队列 public int pop() &#123; dumpstackIn(); return stackOut.pop(); &#125; // 返回队列开头元素 public int peek() &#123; dumpstackIn(); return stackOut.peek(); &#125; // 判断队列是否为空 public boolean empty() &#123; return stackIn.isEmpty() &amp; stackOut.isEmpty(); &#125; // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中 public void dumpstackIn()&#123; // 出队列：判断stackOut是否为空，不为空就返回 if (!stackOut.isEmpty())return; while (!stackIn.isEmpty())&#123; stackOut.push(stackIn.pop()); &#125; &#125;&#125; 用队列实现栈: 123456789101112131415161718192021222324252627282930313233343536373839404142class MyStack &#123; // 定义两个队列 Queue&lt;Integer&gt; queue1; Queue&lt;Integer&gt; queue2; // 构造器 public MyStack() &#123; queue1 = new LinkedList&lt;&gt;(); queue2 = new LinkedList&lt;&gt;(); &#125; // 入栈流程是： // 入栈元素放入queue2中 // 然后将queue1元素全部放入queue2中 // 最后queue1和queue2互换 public void push(int x) &#123; queue2.offer(x); // 先放在辅助队列中 while (!queue1.isEmpty())&#123; queue2.offer(queue1.poll()); &#125; Queue&lt;Integer&gt; queueTemp; queueTemp = queue1; queue1 = queue2; queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中 &#125; // 出栈 // queue2 public int pop() &#123; return queue1.poll(); &#125; // 返回栈顶元素 public int top() &#123; return queue1.peek(); &#125; // 判断是否为空 public boolean empty() &#123; return queue1.isEmpty(); &#125;&#125; 有效的括号: 12345678910111213141516171819202122232425class Solution &#123; public boolean isValid(String s) &#123; // if (s.length()%2!=0) return false; // 定义一个栈 Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); // 循环 for (int i=0; i&lt;=s.length()-1; i++)&#123; if (s.charAt(i) == &#x27;(&#x27;)&#123; stack.push(&#x27;)&#x27;); &#125;else if (s.charAt(i) == &#x27;&#123;&#x27;)&#123; stack.push(&#x27;&#125;&#x27;); &#125;else if (s.charAt(i) == &#x27;[&#x27;)&#123; stack.push(&#x27;]&#x27;); &#125;else if (stack.isEmpty() || stack.peek()!=s.charAt(i))&#123; return false; &#125;else &#123; stack.pop(); &#125; &#125; return stack.isEmpty(); &#125;&#125; 删除字符串中的所有相邻重复项: 12345678910111213141516171819202122class Solution &#123; public String removeDuplicates(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); Stack&lt;Character&gt; stack1 = new Stack&lt;&gt;(); for (int i=0; i&lt;=s.length()-1; i++)&#123; if (stack.isEmpty() || stack.peek()!=s.charAt(i))&#123; stack.push(s.charAt(i)); &#125;else&#123; stack.pop(); &#125; &#125; StringBuilder sb = new StringBuilder(); while (!stack.isEmpty())&#123; stack1.push(stack.pop()); &#125; while (!stack1.isEmpty())&#123; sb.append(stack1.pop()); &#125; return sb.toString(); &#125;&#125; 逆波兰表达式求值: 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int evalRPN(String[] tokens) &#123; // 1. 定义一个栈 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 2. 定义运算的两个变量 int a; int b; // 3. 对tokens进行遍历 for (String s : tokens)&#123; if (s.equals(&quot;+&quot;))&#123; b = stack.pop(); a = stack.pop(); stack.push(a+b); &#125;else if (s.equals(&quot;-&quot;))&#123; b = stack.pop(); a = stack.pop(); stack.push(a-b); &#125;else if (s.equals(&quot;*&quot;))&#123; b = stack.pop(); a = stack.pop(); stack.push(a*b); &#125;else if (s.equals(&quot;/&quot;))&#123; b = stack.pop(); a = stack.pop(); stack.push(a/b); &#125;else&#123; stack.push(Integer.valueOf(s)); &#125; &#125; return stack.peek(); &#125;&#125; 滑动窗口最大值: 1234567891011121314151617181920class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums.length == 0 || k == 0) return new int[0]; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); int[] res = new int[nums.length - k + 1]; for(int j = 0, i = 1 - k; j &lt; nums.length; i++, j++) &#123; // 删除 deque 中对应的 nums[i-1] if(i &gt; 0 &amp;&amp; deque.peekFirst() == nums[i - 1]) deque.removeFirst(); // 保持 deque 递减 while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j]) deque.removeLast(); deque.addLast(nums[j]); // 记录窗口最大值 if(i &gt;= 0) res[i] = deque.peekFirst(); &#125; return res; &#125;&#125; 前 K 个高频元素: 123456789101112131415161718192021222324class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; // 优先级队列，为了避免复杂 api 操作，pq 存储数组 // lambda 表达式设置优先级队列从大到小存储 o1 - o2 为从大到小，o2 - o1 反之 PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[1] - o2[1]); int[] res = new int[k]; // 答案数组为 k 个元素 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 记录元素出现次数 for(int num : nums) map.put(num, map.getOrDefault(num, 0) + 1); for(var x : map.entrySet()) &#123; // entrySet 获取 k-v Set 集合 // 将 kv 转化成数组 int[] tmp = new int[2]; tmp[0] = x.getKey(); tmp[1] = x.getValue(); pq.offer(tmp); if(pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; for(int i = 0; i &lt; k; i ++) &#123; res[i] = pq.poll()[0]; // 获取优先队列里的元素 &#125; return res; &#125;&#125; 6. 队列6.1 队列常用操作123456789101112131415161718/* 初始化队列 */Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();/* 元素入队 */queue.offer(1);queue.offer(2);/* 访问队首元素 */int peek = queue.peek();/* 元素出队 */int pop = queue.poll();/* 获取队列的长度 */int size = queue.size();/* 判断队列是否为空 */boolean isEmpty = queue.isEmpty(); 6.2 基于链表实现队列 push：添加到链表尾部 pop：删除链表头节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 基于链表实现的队列 */class LinkedListQueue &#123; private ListNode front, rear; // 头节点 front ，尾节点 rear private int queSize = 0; public LinkedListQueue() &#123; front = null; rear = null; &#125; /* 获取队列的长度 */ public int size() &#123; return queSize; &#125; /* 判断队列是否为空 */ public boolean isEmpty() &#123; return size() == 0; &#125; /* 入队 */ public void push(int num) &#123; // 尾节点后添加 num ListNode node = new ListNode(num); // 如果队列为空，则令头、尾节点都指向该节点 if (front == null) &#123; front = node; rear = node; // 如果队列不为空，则将该节点添加到尾节点后 &#125; else &#123; rear.next = node; rear = node; &#125; queSize++; &#125; /* 出队 */ public int pop() &#123; int num = peek(); // 删除头节点 front = front.next; queSize--; return num; &#125; /* 访问队首元素 */ public int peek() &#123; if (size() == 0) throw new IndexOutOfBoundsException(); return front.val; &#125; /* 将链表转化为 Array 并返回 */ public int[] toArray() &#123; ListNode node = front; int[] res = new int[size()]; for (int i = 0; i &lt; res.length; i++) &#123; res[i] = node.val; node = node.next; &#125; return res; &#125;&#125; 6.3 双向队列常用操作1234567891011121314151617181920/* 初始化双向队列 */Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();/* 元素入队 */deque.offerLast(1); // 添加至队尾deque.offerFirst(3); // 添加至队首/* 访问元素 */int peekFirst = deque.peekFirst(); // 队首元素int peekLast = deque.peekLast(); // 队尾元素/* 元素出队 */int popFirst = deque.pollFirst(); // 队首元素出队int popLast = deque.pollLast(); // 队尾元素出队/* 获取双向队列的长度 */int size = deque.size();/* 判断双向队列是否为空 */boolean isEmpty = deque.isEmpty(); 6.4 基于双向链表实现双向队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/* 双向链表节点 */class ListNode &#123; int val; // 节点值 ListNode next; // 后继节点引用 ListNode prev; // 前驱节点引用 ListNode(int val) &#123; this.val = val; prev = next = null; &#125;&#125;/* 基于双向链表实现的双向队列 */class LinkedListDeque &#123; private ListNode front, rear; // 头节点 front ，尾节点 rear private int queSize = 0; // 双向队列的长度 public LinkedListDeque() &#123; front = rear = null; &#125; /* 获取双向队列的长度 */ public int size() &#123; return queSize; &#125; /* 判断双向队列是否为空 */ public boolean isEmpty() &#123; return size() == 0; &#125; /* 入队操作 */ private void push(int num, boolean isFront) &#123; ListNode node = new ListNode(num); // 若链表为空，则令 front, rear 都指向 node if (isEmpty()) front = rear = node; // 队首入队操作 else if (isFront) &#123; // 将 node 添加至链表头部 front.prev = node; node.next = front; front = node; // 更新头节点 // 队尾入队操作 &#125; else &#123; // 将 node 添加至链表尾部 rear.next = node; node.prev = rear; rear = node; // 更新尾节点 &#125; queSize++; // 更新队列长度 &#125; /* 队首入队 */ public void pushFirst(int num) &#123; push(num, true); &#125; /* 队尾入队 */ public void pushLast(int num) &#123; push(num, false); &#125; /* 出队操作 */ private Integer pop(boolean isFront) &#123; // 若队列为空，直接返回 null if (isEmpty()) return null; int val; // 队首出队操作 if (isFront) &#123; val = front.val; // 暂存头节点值 // 删除头节点 ListNode fNext = front.next; if (fNext != null) &#123; fNext.prev = null; front.next = null; &#125; front = fNext; // 更新头节点 // 队尾出队操作 &#125; else &#123; val = rear.val; // 暂存尾节点值 // 删除尾节点 ListNode rPrev = rear.prev; if (rPrev != null) &#123; rPrev.next = null; rear.prev = null; &#125; rear = rPrev; // 更新尾节点 &#125; queSize--; // 更新队列长度 return val; &#125; /* 队首出队 */ public Integer popFirst() &#123; return pop(true); &#125; /* 队尾出队 */ public Integer popLast() &#123; return pop(false); &#125; /* 访问队首元素 */ public Integer peekFirst() &#123; return isEmpty() ? null : front.val; &#125; /* 访问队尾元素 */ public Integer peekLast() &#123; return isEmpty() ? null : rear.val; &#125; /* 返回数组用于打印 */ public int[] toArray() &#123; ListNode node = front; int[] res = new int[size()]; for (int i = 0; i &lt; res.length; i++) &#123; res[i] = node.val; node = node.next; &#125; return res; &#125;&#125; 7. 哈希表7.1 哈希表常用操作1234567891011121314151617181920212223242526272829303132/* 初始化哈希表 */Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();/* 添加操作 */// 在哈希表中添加键值对 (key, value)map.put(12836, &quot;小哈&quot;); map.put(15937, &quot;小啰&quot;); map.put(16750, &quot;小算&quot;); map.put(13276, &quot;小法&quot;);map.put(10583, &quot;小鸭&quot;);/* 查询操作 */// 向哈希表输入键 key ，得到值 valueString name = map.get(15937);/* 删除操作 */// 在哈希表中删除键值对 (key, value)map.remove(10583);/* 遍历哈希表 */// 遍历键值对 key-&gt;valuefor (Map.Entry &lt;Integer, String&gt; kv: map.entrySet()) &#123; System.out.println(kv.getKey() + &quot; -&gt; &quot; + kv.getValue());&#125;// 单独遍历键 keyfor (int key: map.keySet()) &#123; System.out.println(key);&#125;// 单独遍历值 valuefor (String val: map.values()) &#123; System.out.println(val);&#125; 8. 树8.1 二叉树 二叉树常见术语： 根节点 root node：位于二叉树顶层的节点，没有父节点。 叶节点 leaf node：没有子节点的节点，其两个指针均指向。 边 edge：连接两个节点的线段，即节点引用（指针）。 节点所在的层 level：从顶至底递增，根节点所在层为 1 。 节点的度 degree：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。 二叉树的高度 height：从根节点到最远叶节点所经过的边的数量。 节点的深度 depth：从根节点到该节点所经过的边的数量。 节点的高度 height：从最远叶节点到该节点所经过的边的数量。 二叉树分类： 完美二叉树（满二叉树） 完全二叉树 完满二叉树 平衡二叉树 二叉树基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 /* 二叉树节点类 */ class TreeNode &#123; int val; // 节点值 TreeNode left; // 左子节点引用 TreeNode right; // 右子节点引用 TreeNode(int x) &#123; val = x; &#125; &#125; /* 初始化二叉树 */ // 初始化节点 TreeNode n1 = new TreeNode(1); TreeNode n2 = new TreeNode(2); TreeNode n3 = new TreeNode(3); TreeNode n4 = new TreeNode(4); TreeNode n5 = new TreeNode(5); // 构建引用指向（即指针） n1.left = n2; n1.right = n3; n2.left = n4; n2.right = n5; /* 插入与删除节点 */ TreeNode P = new TreeNode(0); // 在 n1 -&gt; n2 中间插入节点 P n1.left = P; P.left = n2; // 删除节点 P n1.left = n2; ``` ![](面试-算法/树_2.png)- 读取二叉树： ```java import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main&#123; //4.输入二叉树 public static void main(String[] args) throws IOException &#123; //获取键盘一行的输入，以enter键为结束标志 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String[] s = reader.readLine().split(&quot; &quot;); //用空格分割，也可以用逗号分割 //用数组按层级遍历顺序存储二叉树的节点 TreeNode[] tree = new TreeNode[s.length]; for(int i = 0; i &lt; tree.length; i++)&#123; int val_i = Integer.parseInt(s[i]); if(val_i == -1)&#123; tree[i] = null; //-1代表null &#125;else&#123; tree[i] = new TreeNode(val_i); &#125; &#125; //再遍历一边，给左右子树赋值 for(int i = 0; i * 2 + 2 &lt; tree.length; i++)&#123; if(tree[i] != null)&#123; tree[i].left = tree[i * 2 + 1]; tree[i].right = tree[i * 2 + 2]; &#125; &#125; TreeNode root = tree[0]; //root是最终得到的二叉树根节点 &#125; //辅助类：构造树需要的结点类 static class TreeNode &#123; int val; TreeNode left, right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; &#125; 8.2 二叉树遍历 层序遍历：本质上属于广度优先遍历 breadth-first traversal，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。12345678910111213141516171819/* 层序遍历 */List&lt;Integer&gt; levelOrder(TreeNode root) &#123; // 初始化队列，加入根节点 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); // 初始化一个列表，用于保存遍历序列 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); // 队列出队 list.add(node.val); // 保存节点值 if (node.left != null)&#123; queue.offer(node.left); // 左子节点入队 &#125; if (node.right != null)&#123; queue.offer(node.right); // 右子节点入队 &#125; &#125; return list;&#125; 前序、中序、后序遍历：都属于「深度优先遍历 depth-first traversal」，它体现了一种“先走到尽头，再回溯继续”的遍历方式。1234567891011121314151617181920212223242526272829/* 前序遍历 */void preOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树 list.add(root.val); preOrder(root.left); preOrder(root.right);&#125;/* 中序遍历 */void inOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树 inOrder(root.left); list.add(root.val); inOrder(root.right);&#125;/* 后序遍历 */void postOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点 postOrder(root.left); postOrder(root.right); list.add(root.val);&#125; 8.3 二叉树数组表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 数组表示下的二叉树类 */class ArrayBinaryTree &#123; private List&lt;Integer&gt; tree; /* 构造方法 */ public ArrayBinaryTree(List&lt;Integer&gt; arr) &#123; tree = new ArrayList&lt;&gt;(arr); &#125; /* 节点数量 */ public int size() &#123; return tree.size(); &#125; /* 获取索引为 i 节点的值 */ public Integer val(int i) &#123; // 若索引越界，则返回 null ，代表空位 if (i &lt; 0 || i &gt;= size()) return null; return tree.get(i); &#125; /* 获取索引为 i 节点的左子节点的索引 */ public Integer left(int i) &#123; return 2 * i + 1; &#125; /* 获取索引为 i 节点的右子节点的索引 */ public Integer right(int i) &#123; return 2 * i + 2; &#125; /* 获取索引为 i 节点的父节点的索引 */ public Integer parent(int i) &#123; return (i - 1) / 2; &#125; /* 层序遍历 */ public List&lt;Integer&gt; levelOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 直接遍历数组 for (int i = 0; i &lt; size(); i++) &#123; if (val(i) != null) res.add(val(i)); &#125; return res; &#125; /* 深度优先遍历 */ private void dfs(Integer i, String order, List&lt;Integer&gt; res) &#123; // 若为空位，则返回 if (val(i) == null) return; // 前序遍历 if (order == &quot;pre&quot;) res.add(val(i)); dfs(left(i), order, res); // 中序遍历 if (order == &quot;in&quot;) res.add(val(i)); dfs(right(i), order, res); // 后序遍历 if (order == &quot;post&quot;) res.add(val(i)); &#125; /* 前序遍历 */ public List&lt;Integer&gt; preOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;pre&quot;, res); return res; &#125; /* 中序遍历 */ public List&lt;Integer&gt; inOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;in&quot;, res); return res; &#125; /* 后序遍历 */ public List&lt;Integer&gt; postOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;post&quot;, res); return res; &#125;&#125; 8.4 二叉搜索树 二叉搜索树(binary search tree)满足以下条件： 对于根节点，左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值。 任意节点的左、右子树也是二叉搜索树，即同样满足条件 1. 。 查找节点 若 cur.val &lt; num ，说明目标节点在 cur 的右子树中，因此执行 cur &#x3D; cur.right 。 若 cur.val &gt; num ，说明目标节点在 cur 的左子树中，因此执行 cur &#x3D; cur.left 。 若 cur.val &#x3D; num ，说明找到目标节点，跳出循环并返回该节点。123456789101112131415161718/* 查找节点 */TreeNode search(int num) &#123; TreeNode cur = root; // 循环查找，越过叶节点后跳出 while (cur != null) &#123; // 目标节点在 cur 的右子树中 if (cur.val &lt; num) cur = cur.right; // 目标节点在 cur 的左子树中 else if (cur.val &gt; num) cur = cur.left; // 找到目标节点，跳出循环 else break; &#125; // 返回目标节点 return cur;&#125; 插入节点 查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（遍历至None）时跳出循环。 在该位置插入节点：初始化节点 num ，将该节点插入当前的位置。12345678910111213141516171819202122232425262728/* 插入节点 */void insert(int num) &#123; // 若树为空，则初始化根节点 if (root == null) &#123; root = new TreeNode(num); return; &#125; TreeNode cur = root, pre = null; // 循环查找，越过叶节点后跳出 while (cur != null) &#123; // 找到重复节点，直接返回 if (cur.val == num) return; pre = cur; // 插入位置在 cur 的右子树中 if (cur.val &lt; num) cur = cur.right; // 插入位置在 cur 的左子树中 else cur = cur.left; &#125; // 插入节点 TreeNode node = new TreeNode(num); if (pre.val &lt; num) pre.right = node; else pre.left = node;&#125; 删除节点： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 删除节点 */void remove(int num) &#123; // 若树为空，直接提前返回 if (root == null) return; TreeNode cur = root, pre = null; // 循环查找，越过叶节点后跳出 while (cur != null) &#123; // 找到待删除节点，跳出循环 if (cur.val == num) break; pre = cur; // 待删除节点在 cur 的右子树中 if (cur.val &lt; num) cur = cur.right; // 待删除节点在 cur 的左子树中 else cur = cur.left; &#125; // 若无待删除节点，则直接返回 if (cur == null) return; // 子节点数量 = 0 or 1 if (cur.left == null || cur.right == null) &#123; // 当子节点数量 = 0 / 1 时， child = null / 该子节点 TreeNode child = cur.left != null ? cur.left : cur.right; // 删除节点 cur if (cur != root) &#123; if (pre.left == cur) pre.left = child; else pre.right = child; &#125; else &#123; // 若删除节点为根节点，则重新指定根节点 root = child; &#125; &#125; // 子节点数量 = 2 else &#123; // 获取中序遍历中 cur 的下一个节点 TreeNode tmp = cur.right; while (tmp.left != null) &#123; tmp = tmp.left; &#125; // 递归删除节点 tmp remove(tmp.val); // 用 tmp 覆盖 cur cur.val = tmp.val; &#125;&#125; 8.5 AVL树9. 堆9.1 基础问题 概念： 大顶堆 max heap：任意节点的值大于等于其子节点的值。 小顶堆 min heap：任意节点的值小于等于其子节点的值。 堆常用操作: 1234567891011121314151617181920212223242526272829303132/* 初始化堆 */// 初始化小顶堆Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);/* 元素入堆 */maxHeap.offer(1);maxHeap.offer(3);maxHeap.offer(2);maxHeap.offer(5);maxHeap.offer(4);/* 获取堆顶元素 */int peek = maxHeap.peek(); // 5/* 堆顶元素出堆 */// 出堆元素会形成一个从大到小的序列peek = maxHeap.poll(); // 5peek = maxHeap.poll(); // 4peek = maxHeap.poll(); // 3peek = maxHeap.poll(); // 2peek = maxHeap.poll(); // 1/* 获取堆大小 */int size = maxHeap.size();/* 判断堆是否为空 */boolean isEmpty = maxHeap.isEmpty();/* 输入列表并建堆 */minHeap = new PriorityQueue&lt;&gt;(Arrays.asList(1, 3, 2, 5, 4)); 9.2 建堆操作 堆的存储与表示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* 获取左子节点索引 */int left(int i) &#123; return 2 * i + 1;&#125;/* 获取右子节点索引 */int right(int i) &#123; return 2 * i + 2;&#125;/* 获取父节点索引 */int parent(int i) &#123; return (i - 1) / 2; // 向下整除&#125;/* 访问堆顶元素 */int peek() &#123; return maxHeap.get(0);&#125;/* 元素入堆 */void push(int val) &#123; // 添加节点 maxHeap.add(val); // 从底至顶堆化 siftUp(size() - 1);&#125;/* 从节点 i 开始，从底至顶堆化 */void siftUp(int i) &#123; while (true) &#123; // 获取节点 i 的父节点 int p = parent(i); // 当“越过根节点”或“节点无须修复”时，结束堆化 if (p &lt; 0 || maxHeap.get(i) &lt;= maxHeap.get(p)) break; // 交换两节点 swap(i, p); // 循环向上堆化 i = p; &#125;&#125;/* 元素出堆 */int pop() &#123; // 判空处理 if (isEmpty()) throw new IndexOutOfBoundsException(); // 交换根节点与最右叶节点（即交换首元素与尾元素） swap(0, size() - 1); // 删除节点 int val = maxHeap.remove(size() - 1); // 从顶至底堆化 siftDown(0); // 返回堆顶元素 return val;&#125;/* 从节点 i 开始，从顶至底堆化 */void siftDown(int i) &#123; while (true) &#123; // 判断节点 i, l, r 中值最大的节点，记为 ma int l = left(i), r = right(i), ma = i; if (l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(ma)) ma = l; if (r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(ma)) ma = r; // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出 if (ma == i) break; // 交换两节点 swap(i, ma); // 循环向下堆化 i = ma; &#125;&#125; 9.3 Top-K 问题 给定一个长度为无序数组nums，请返回数组中前 k 大的元素。1234567891011121314151617/* 基于堆查找数组中最大的 k 个元素 */Queue&lt;Integer&gt; topKHeap(int[] nums, int k) &#123; Queue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(); // 将数组的前 k 个元素入堆 for (int i = 0; i &lt; k; i++) &#123; heap.offer(nums[i]); &#125; // 从第 k+1 个元素开始，保持堆的长度为 k for (int i = k; i &lt; nums.length; i++) &#123; // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆 if (nums[i] &gt; heap.peek()) &#123; heap.poll(); heap.offer(nums[i]); &#125; &#125; return heap;&#125; 10. 图10.1 基于邻接矩阵的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* 基于邻接矩阵实现的无向图类 */class GraphAdjMat &#123; List&lt;Integer&gt; vertices; // 顶点列表，元素代表“顶点值”，索引代表“顶点索引” List&lt;List&lt;Integer&gt;&gt; adjMat; // 邻接矩阵，行列索引对应“顶点索引” /* 构造方法 */ public GraphAdjMat(int[] vertices, int[][] edges) &#123; this.vertices = new ArrayList&lt;&gt;(); this.adjMat = new ArrayList&lt;&gt;(); // 添加顶点 for (int val : vertices) &#123; addVertex(val); &#125; // 添加边 // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引 for (int[] e : edges) &#123; addEdge(e[0], e[1]); &#125; &#125; /* 获取顶点数量 */ public int size() &#123; return vertices.size(); &#125; /* 添加顶点 */ public void addVertex(int val) &#123; int n = size(); // 向顶点列表中添加新顶点的值 vertices.add(val); // 在邻接矩阵中添加一行 List&lt;Integer&gt; newRow = new ArrayList&lt;&gt;(n); for (int j = 0; j &lt; n; j++) &#123; newRow.add(0); &#125; adjMat.add(newRow); // 在邻接矩阵中添加一列 for (List&lt;Integer&gt; row : adjMat) &#123; row.add(0); &#125; &#125; /* 删除顶点 */ public void removeVertex(int index) &#123; if (index &gt;= size()) throw new IndexOutOfBoundsException(); // 在顶点列表中移除索引 index 的顶点 vertices.remove(index); // 在邻接矩阵中删除索引 index 的行 adjMat.remove(index); // 在邻接矩阵中删除索引 index 的列 for (List&lt;Integer&gt; row : adjMat) &#123; row.remove(index); &#125; &#125; /* 添加边 */ // 参数 i, j 对应 vertices 元素索引 public void addEdge(int i, int j) &#123; // 索引越界与相等处理 if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) throw new IndexOutOfBoundsException(); // 在无向图中，邻接矩阵沿主对角线对称，即满足 (i, j) == (j, i) adjMat.get(i).set(j, 1); adjMat.get(j).set(i, 1); &#125; /* 删除边 */ // 参数 i, j 对应 vertices 元素索引 public void removeEdge(int i, int j) &#123; // 索引越界与相等处理 if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) throw new IndexOutOfBoundsException(); adjMat.get(i).set(j, 0); adjMat.get(j).set(i, 0); &#125; /* 打印邻接矩阵 */ public void print() &#123; System.out.print(&quot;顶点列表 = &quot;); System.out.println(vertices); System.out.println(&quot;邻接矩阵 =&quot;); PrintUtil.printMatrix(adjMat); &#125;&#125; 10.2 基于邻接表的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* 基于邻接表实现的无向图类 */class GraphAdjList &#123; // 邻接表，key: 顶点，value：该顶点的所有邻接顶点 Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList; /* 构造方法 */ public GraphAdjList(Vertex[][] edges) &#123; this.adjList = new HashMap&lt;&gt;(); // 添加所有顶点和边 for (Vertex[] edge : edges) &#123; addVertex(edge[0]); addVertex(edge[1]); addEdge(edge[0], edge[1]); &#125; &#125; /* 获取顶点数量 */ public int size() &#123; return adjList.size(); &#125; /* 添加边 */ public void addEdge(Vertex vet1, Vertex vet2) &#123; if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2) throw new IllegalArgumentException(); // 添加边 vet1 - vet2 adjList.get(vet1).add(vet2); adjList.get(vet2).add(vet1); &#125; /* 删除边 */ public void removeEdge(Vertex vet1, Vertex vet2) &#123; if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2) throw new IllegalArgumentException(); // 删除边 vet1 - vet2 adjList.get(vet1).remove(vet2); adjList.get(vet2).remove(vet1); &#125; /* 添加顶点 */ public void addVertex(Vertex vet) &#123; if (adjList.containsKey(vet)) return; // 在邻接表中添加一个新链表 adjList.put(vet, new ArrayList&lt;&gt;()); &#125; /* 删除顶点 */ public void removeVertex(Vertex vet) &#123; if (!adjList.containsKey(vet)) throw new IllegalArgumentException(); // 在邻接表中删除顶点 vet 对应的链表 adjList.remove(vet); // 遍历其他顶点的链表，删除所有包含 vet 的边 for (List&lt;Vertex&gt; list : adjList.values()) &#123; list.remove(vet); &#125; &#125; /* 打印邻接表 */ public void print() &#123; System.out.println(&quot;邻接表 =&quot;); for (Map.Entry&lt;Vertex, List&lt;Vertex&gt;&gt; pair : adjList.entrySet()) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for (Vertex vertex : pair.getValue()) tmp.add(vertex.val); System.out.println(pair.getKey().val + &quot;: &quot; + tmp + &quot;,&quot;); &#125; &#125;&#125; 10.3 图的遍历 广度优先遍历： 1234567891011121314151617181920212223242526/* 广度优先遍历 BFS */// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点List&lt;Vertex&gt; graphBFS(GraphAdjList graph, Vertex startVet) &#123; // 顶点遍历序列 List&lt;Vertex&gt; res = new ArrayList&lt;&gt;(); // 哈希表，用于记录已被访问过的顶点 Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;(); visited.add(startVet); // 队列用于实现 BFS Queue&lt;Vertex&gt; que = new LinkedList&lt;&gt;(); que.offer(startVet); // 以顶点 vet 为起点，循环直至访问完所有顶点 while (!que.isEmpty()) &#123; Vertex vet = que.poll(); // 队首顶点出队 res.add(vet); // 记录访问顶点 // 遍历该顶点的所有邻接顶点 for (Vertex adjVet : graph.adjList.get(vet)) &#123; if (visited.contains(adjVet)) continue; // 跳过已被访问过的顶点 que.offer(adjVet); // 只入队未访问的顶点 visited.add(adjVet); // 标记该顶点已被访问 &#125; &#125; // 返回顶点遍历序列 return res;&#125; 深度优先遍历： 1234567891011121314151617181920212223/* 深度优先遍历 DFS 辅助函数 */void dfs(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) &#123; res.add(vet); // 记录访问顶点 visited.add(vet); // 标记该顶点已被访问 // 遍历该顶点的所有邻接顶点 for (Vertex adjVet : graph.adjList.get(vet)) &#123; if (visited.contains(adjVet)) continue; // 跳过已被访问过的顶点 // 递归访问邻接顶点 dfs(graph, visited, res, adjVet); &#125;&#125;/* 深度优先遍历 DFS */// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点List&lt;Vertex&gt; graphDFS(GraphAdjList graph, Vertex startVet) &#123; // 顶点遍历序列 List&lt;Vertex&gt; res = new ArrayList&lt;&gt;(); // 哈希表，用于记录已被访问过的顶点 Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;(); dfs(graph, visited, res, startVet); return res;&#125; 10.4 拓扑排序11. 搜索12. 分治13. 回溯算法14. 动态规划15. 贪心算法","categories":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试-数据库","slug":"面试-数据库","date":"2021-06-08T11:50:53.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2021/06/08/面试-数据库/","link":"","permalink":"https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员? 数据库 : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。 数据库管理系统 : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。 数据库系统 : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。 数据库管理员 : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。 2. 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？ 元组：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。 码：码就是能唯一标识实体的属性，对应表中的列。 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。 主码 : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。 外码 : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。 主属性：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。 非主属性： 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。 3. 什么是 ER 图？我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。 ER 图 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。 ER 图由下面 3 个要素组成： 实体：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。 下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。 4. 数据库范式了解吗?数据库范式有 3 种： 1NF(第一范式)：每个列都不可以再拆分。 2NF(第二范式)：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。 3NF(第三范式)：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。 在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。 5. 主键和外键有什么区别? **主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。 **外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。 6. drop、delete 与 truncate 区别？6.1 用法不同 drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。 truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。 delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。 6.2 属于不同的数据库语言truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。 DML 语句和 DDL 语句区别： DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。 DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。 另外，由于select不会对表进行破坏，所以有的地方也会把select单独区分开叫做数据库查询语言 DQL（Data Query Language）。 6.3 执行速度不同一般来说：drop &gt; truncate &gt; delete。 delete命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。 truncate命令执行的时候不会产生数据库日志，因此比delete要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。 drop命令会把表占用的空间全部释放掉。 7. 数据库设计通常分为哪几步? 需求分析 : 分析用户的需求，包括数据、功能和性能需求。 概念结构设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图。 逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。 数据库实施 : 包括编程、测试和试运行 数据库的运行和维护 : 系统的运行与数据库的日常维护。 8. NoSQL8.1 NoSQL是什么？ 概念： NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值对、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。 NoSQL 能否存储关系型数据？ NoSQL 数据库可以存储关系型数据，它们与关系型数据库的存储方式不同。 NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。 8.2 SQL 和 NoSQL 有什么区别？ SQL 数据库 NoSQL 数据库 数据存储模型 结构化存储，具有固定行和列的表格 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边 发展历程 开发于 1970 年代，重点是减少数据重复 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本 例子 Oracle、MySQL、Microsoft SQL Server、PostgreSQL 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph ACID 属性 提供原子性、一致性、隔离性和持久性 (ACID) 属性 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。 性能 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。 扩展 垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表 横向（增加服务器的方式横向扩展，通常是基于分片机制） 用途 普通企业级的项目的数据存储 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化 查询语法 结构化查询语言 (SQL) 数据访问语法可能因数据库而异 8.3 NoSQL 数据库有什么优势？ 灵活性： NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。 可扩展性： NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。 高性能： NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。 强大的功能： NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。 8.4 NoSQL 数据库有哪些类型？NoSQL 数据库主要可以分为下面四种类型： 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。 文档：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。 9. 字符集MySQL 字符编码集中有两套 UTF-8 编码实现：**utf8** 和 **utf8mb4**。 如果使用 utf8 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。 9.1 何为字符集？字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 字符集 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。 9.2 有哪些常见的字符集？ 常见的字符集有 ASCII、GB2312、GBK、UTF-8……。 不同的字符集的主要区别在于： 可以表示的字符范围 编码方式 9.3 ASCII ASCII (American Standard Code for Information Interchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。 ASCII 码长度是一个字节也就是 8 个 bit，ASCII 字符集共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。 0（48），A（65），a（97） 9.4 GB2312 对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。 GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。 9.5 GBK GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。 9.6 GB18030 GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。 9.7 BIG5 BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。 9.8 UTF-8 UTF-8（8-bit Unicode Transformation Format） UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-8 是目前使用最广的一种字符编码。 10. MySQL 字符集 通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。 MySQL 字符编码集中有两套 UTF-8 编码实现： **utf8**：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。 **utf8mb4**：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。 因此，如果你需要存储emoji类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为utf8mb4 而不是utf8 ，要不然存储的时候就会报错了。 11. SQL语句知识点总结11.1 SQL 分类 数据定义语言（DDL） 概念：数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。 功能：定义数据库对象。 核心指令： CREATE、ALTER、DROP。 数据操纵语言（DML） 概念：数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。 功能：访问数据，因此其语法都是以读写数据库为主。 核心指令：INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。 事务控制语言（TCL） 概念：事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。 核心指令： COMMIT、ROLLBACK。 数据控制语言（DCL） 概念：数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。 核心指令： GRANT、REVOKE。 11.2 增删改查 插入数据：INSERT INTO 语句用于向表中插入新记录。 12INSERT INTO user(username, password, email)VALUES (&#x27;admin&#x27;, &#x27;admin&#x27;, &#x27;xxxx@163.com&#x27;); 更新数据：UPDATE 语句用于更新表中的记录。 123UPDATE userSET username=&#x27;robot&#x27;, password=&#x27;robot&#x27;WHERE username = &#x27;root&#x27;; 删除数据 DELETE 语句用于删除表中的记录。12DELETE FROM userWHERE username = &#x27;robot&#x27;; TRUNCATE TABLE 可以清空表，也就是删除所有行。1TRUNCATE TABLE user; 查询数据 关键字： SELECT 语句用于从数据库中查询数据。 DISTINCT 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。 LIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 ASC：升序（默认） DESC：降序 查询单列 12SELECT prod_nameFROM products; 查询多列 12SELECT prod_id, prod_name, prod_priceFROM products; 查询所有列 12SELECT *FROM products; 查询不同的值 12SELECT DISTINCTvend_id FROM products; 限制查询结果 12345-- 返回前 5 行SELECT * FROM mytable LIMIT 5;SELECT * FROM mytable LIMIT 0, 5;-- 返回第 3 ~ 5 行SELECT * FROM mytable LIMIT 2, 3; 排序 order by 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 desc 关键字。 order by 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。 12SELECT * FROM productsORDER BY prod_price DESC, prod_name ASC; 分组：**group by**： 分组 12SELECT cust_name, COUNT(cust_address) AS addr_numFROM Customers GROUP BY cust_name; 分组后排序 123SELECT cust_name, COUNT(cust_address) AS addr_numFROM Customers GROUP BY cust_nameORDER BY cust_name DESC; **having**： having 用于对汇总的 group by 结果进行过滤。 having 一般都是和 group by 连用。 where 和 having 可以在相同的查询中。 使用 WHERE 和 HAVING 过滤数据 12345SELECT cust_name, COUNT(*) AS numFROM CustomersWHERE cust_email IS NOT NULLGROUP BY cust_nameHAVING COUNT(*) &gt;= 1; **having vs where**： where：过滤过滤指定的行，后面不能加聚合函数（分组函数）。where 在group by 前。 having：过滤分组，一般都是和 group by 连用，不能单独使用。having 在 group by 之后。 12. SQL面试题总结13. MySQL索引详解13.1 索引介绍 概念：索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。 作用：索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。 数据结构：索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了B+树作为索引结构。 13.2 索引的优缺点 优点： 使用索引可以大大加快数据的检索速度（大大减少检索的数据量，这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点： 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。 使用索引一定能提高查询性能吗? 大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。 13.3 索引的分类 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。 按「字段个数」分类：单列索引、联合索引。 13.4 MySQL索引使用有哪些注意事项呢 哪些情况会导致索引失效: like通配符可能导致索引失效。 查询条件包含or，可能导致索引失效 如何字段类型是字符串，where时一定用引号括起来，否则索引失效 对索引列运算（如，+、-、*、&#x2F;），索引失效。 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。 在索引列上使用mysql的内置函数，索引失效。 索引字段上使用is null， is not null，可能导致索引失效。 索引字段上使用（！&#x3D; 或者 &lt; &gt;，not in）时，可能会导致索引失效。 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。 mysql估计使用全表扫描要比使用索引快,则不使用索引。 索引不适合哪些场景 数据量少的不适合加索引 更新比较频繁的也不适合加索引 区分度低的字段不适合加索引（如性别） 13.5 数据库索引结构为什么要用B+树，为什么不用二叉树？ MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。 要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I&#x2F;0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I&#x2F;0 的操作次数内完成。 二分查找树：二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。 自平衡二叉树：为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。而树的高度决定于磁盘 I&#x2F;O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I&#x2F;O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。 B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有： B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。 B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化； B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。 14. 执行一条 select 语句，期间发生了什么？14.1 MySQL 的架构 MySQL 的架构共分为两层：Server 层和存储引擎层， Server 层负责建立连接、分析和执行 SQL。 存储引擎层负责数据的存储和提取。 14.2 SQL的select语句的执行流程 连接器：建立连接，管理连接、校验用户身份； 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块； 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型； 执行 SQL：执行 SQL 共有三个阶段： 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。 优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划； 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端； 15. MySQL事务15.1 事务是什么 就是用户定义的一系列数据库操作，这些操作可以视为一个完成的逻辑处理工作单元，要么全部执行，要么全部不执行，是不可分割的工作单元。 15.2 MySQL事务四大特性（ACID）： 原子性（Atomicity）：一个事务被作为一个整体执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。不会结束在中间某个环节。事务在执行过程中如果发生异常，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性（Consistency）：指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转100块钱，不管成功与否，A和B的总金额是不变的。 隔离性（Isolation）：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable） 持久性（Durability）：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中，即便系统故障也不会丢失。 15.3 MySQL事务四大特性（ACID）实现原理： 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。 隔离性：通过锁以及MVCC，使事务相互隔离开。 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。 15.4 MySQL数据隔离级别 MySQL 里有四个隔离级别：Read uncommttied（可以读取未提交数据）、Read committed（可以读取已提交数据）、Repeatable read（可重复读）、Serializable（可串行化）。 在 InnoDB 中，默认为 Repeatable 级别，InnoDB 中使用一种被称为 next-key locking 的策略来避免幻读（phantom）现象的产生。 不同的事务隔离级别会导致不同的问题： 隔离级别 脏读 不可重复读 幻读 读未提交（Read uncommttied） &amp;#10004; &amp;#10004; &amp;#10004; 读已提交（Read committed） &amp;#10008; &amp;#10004; &amp;#10004; 可重复读（Repeatable read） &amp;#10008; &amp;#10008; &amp;#10004; 可串行化（Serializable） &amp;#10008; &amp;#10008; &amp;#10008; 15.5 MVCC原理参考：https://www.modb.pro/db/40241 概念：MVCC（Multi-Version Concurrency Control）多版本并发控制，是数据库控制并发访问的一种手段。MVCC只在 读已提交(RC) 和 可重复度（RR） 这两种事务隔离级别下才有效。MVCC是数据库引擎（InnoDB）层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能 实现： InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。 MVCC 最大的好处：读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。 详细描述MVCC： 创建一张测试表并写入测试数据，进行实验：12345678910111213141516171819create database likecolumn;use likecolumn;CREATE TABLE `t1` (`id` int(11) NOT NULL AUTO_INCREMENT,`a` int(11) NOT NULL,`b` int(11) NOT NULL,PRIMARY KEY (`id`),KEY `idx_c` (`a`)) ENGINE=InnoDB CHARSET=utf8mb4;insert into t1(a,b) values (1,1),(2,2); 序号 session 1 session 2 1 set session transaction_isolation&#x3D;’READCOMMITTED’; &#x2F;* 设置会话隔离级别为 RC*&#x2F; set session transaction_isolation&#x3D;’READCOMMITTED’;&#x2F;* 设置会话隔离级别为 RC*&#x2F; 2 select * from t1; 3 begin; 4 update t1 set b&#x3D;666 where a&#x3D;1; 5 begin; 6 select * from t1; 7 commit; 8 select * from t1; 9 commit; 这里解释一下上面的实验过程，在 session1 开启一个事务更新了 a&#x3D;1 这行记录，但还没提交的情况下，在 session2 中，满足 a&#x3D;1 这条记录，b 的值还是原始值 1，而不是 session1 更新之后的 666，那么在数据库层面，这是怎么实现的呢？ 其实 InnoDB 就是通过 MVCC 和 UNDO LOG 来实现的。 MVCC 的实现原理 对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列： ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。 事务 ID：记录最后一次修改该记录的事务 ID。 回滚指针：指向这条记录的上一个版本。 我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图： 如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b&#x3D;666 where a&#x3D;1 时，大致步骤如下： 数据库会先对满足 a&#x3D;1 的行加排他锁； 然后将原记录复制到 undo 表空间中； 修改 b 字段的值为 666，修改事务 ID 为 2； 并通过隐藏的回滚指针指向 undo log 中的历史记录； 事务提交，释放前面对满足 a&#x3D;1 的行所加的排他锁。 在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是来自 undolog 中。 因此可以总结出 MVCC 实现的原理大致是：InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。 16. 说一下什么是幻读，脏读，不可重复读？16.1 脏读：脏读是指一个事务中访问到了另外一个事务未提交的数据，如下所示： 会话1 会话2 begin begin update table set age&#x3D;10 where id&#x3D;1 select age from table where id&#x3D;1 commit commit 如果会话 2 更新 age 为 10，但是在 commit 之前，会话 1 希望得到 age，那么会获得的值就是更新前的值。或者如果会话 2 更新了值但是执行了 rollback，而会话 1 拿到的仍是 10。这就是脏读。 16.2 不可重复读：一个事务读取同一条记录2次，得到的结果不一致： 会话1 会话2 begin begin select age from table where id&#x3D;1 update table set age&#x3D;10 where id&#x3D;1 commit select age from table where id&#x3D;1 commit 由于在读取中间变更了数据，所以会话 1 事务查询期间的得到的结果就不一样了。 16.3 幻读：一个事务读取2次，得到的记录条数不一致： 会话1 会话2 begin begin select age from table where id&gt;2 insert into table(id, age) values(5, 10) commit select age from table where id&gt;2 commit 上图很明显的表示了这个情况，由于在会话 1 之间插入了一个新的值，所以得到的两次数据就不一样了。 17. 说一下什么是内连接、外连接、交叉连接、笛卡尔积呢？例子图示： 17.1 内连接（inner join）： 概念：取得两张表中满足存在连接匹配关系的记录。 例子：12select * from Student sinner join Course c on s.C_S_Id=c.C_Id 17.2 外连接（outer join）： 概念：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。 分类：左外连接（left join &#x2F; left outer join）、右外连接（right join &#x2F; right outer join）和全外连接（full join &#x2F; full outer join） 左外连接：满足on条件表达式，左外连接是以左表为准，返回左表所有的数据，与右表匹配的则有值，没有匹配的则以空（null）取代。12select * from Student sleft join Course c on s.C_S_Id=c.C_Id 右外连接：满足on条件表达式，右外连接是以右表为准，返回右表所有的数据，与左表匹配的则有值，没有匹配的则以空（null）取代。12select * from Student sright join Course c on s.C_S_Id=c.C_Id 全外连接：满足on条件表达式，返回两个表符合条件的所有行，a表没有匹配的则a表的列返回null，b表没有匹配的则b表的列返回null，即返回的是左连接和右连接的并集。12select * from Student sfull join Course c on s.C_S_Id=c.C_Id 17.3 交叉连接（cross join）： 概念：显示两张表所有记录一一对应，没有匹配关系进行筛选，也被称为：笛卡尔积。比如A表有10条记录，B表有100条记录，那么笛卡尔积关联查询结果就是10*100&#x3D;1000条记录，一般我们要避免笛卡尔积的出现。 例子：12select * from Student scross join Course c 1234// 加上条件返回满足条件表达式的两个表的行：select * from Student scross join Course c where s.C_S_Id=c.C_Id 18. SQL优化18.1 整体思路 查看执行计划 explain 如果有告警信息，查看告警信息 show warnings; 查看SQL涉及的表结构和索引信息 根据执行计划，思考可能的优化点 按照可能的优化点执行表结构变更、增加索引、SQL改写等操作 查看优化后的执行时间和执行计划 如果优化效果不明显，重复第四步操作 18.2 SQL慢查询优化案例 表结构： 123456789101112131415161718192021222324252627CREATE TABLE `a`( `id` int(11) NOT NULLAUTO_INCREMENT, `seller_id` bigint(20) DEFAULT NULL, `seller_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL, `gmt_create` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`));CREATE TABLE `b`( `id` int(11) NOT NULLAUTO_INCREMENT, `seller_name` varchar(100) DEFAULT NULL, `user_id` varchar(50) DEFAULT NULL, `user_name` varchar(100) DEFAULT NULL, `sales` bigint(20) DEFAULT NULL, `gmt_create` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`));CREATE TABLE `c`( `id` int(11) NOT NULLAUTO_INCREMENT, `user_id` varchar(50) DEFAULT NULL, `order_id` varchar(100) DEFAULT NULL, `state` bigint(20) DEFAULT NULL, `gmt_create` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`)); 有问题的查询SQL: a，b，c 三张表关联，查询用户17 在当前时间前后10个小时的订单情况，并根据订单创建时间升序排列 1234567891011121314select a.seller_id, a.seller_name, b.user_name, c.statefrom a, b, cwhere a.seller_name = b.seller_name and b.user_id = c.user_id and c.user_id = 17 and a.gmt_create BETWEEN DATE_ADD(NOW(), INTERVAL – 600 MINUTE) AND DATE_ADD(NOW(), INTERVAL 600 MINUTE)order by a.gmt_create; 先查看各表数据量 12345select &#x27;a&#x27;, count(*) from aunionselect &#x27;b&#x27;, count(*) from bunionselect &#x27;c&#x27;, count(*) from c; 查看原sql执行时间1234567891011121314select a.seller_id, a.seller_name, b.user_name, c.statefrom a, b, cwhere a.seller_name = b.seller_name and b.user_id = c.user_id and c.user_id = 17 and a.gmt_create BETWEEN DATE_ADD(NOW(), INTERVAL – 600 MINUTE) AND DATE_ADD(NOW(), INTERVAL 600 MINUTE)order by a.gmt_create; 查看执行计划 explain123456789101112131415explain select a.seller_id, a.seller_name, b.user_name, c.statefrom a, b, cwhere a.seller_name = b.seller_name and b.user_id = c.user_id and c.user_id = 17 and a.gmt_create BETWEEN DATE_ADD(NOW(), INTERVAL – 600 MINUTE) AND DATE_ADD(NOW(), INTERVAL 600 MINUTE)order by a.gmt_create; 执行计划中几个重要字段的解释说明 字段 解释 id 每个被独立执行的操作标识，标识对象被操作的顺序，id值越大，先被执行，如果相同，执行顺序从上到下 select_type 查询中每个select 字句的类型 table 被操作的对象名称，通常是表名，但有其他格式 partitions 匹配的分区信息(对于非分区表值为NULL) type 连接操作的类型 possible_keys 可能用到的索引 key 优化器实际使用的索引(最重要的列) 从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL。当出现ALL时表示当前SQL出现了“坏味道” key_len 被优化器选定的索引键长度，单位是字节 ref 表示本行被操作对象的参照对象，无参照对象为NULL rows 查询执行所扫描的元组个数（对于innodb，此值为估计值） filtered 条件表上数据被过滤的元组个数百分比 extra 执行计划的重要补充信息，当此列出现Using filesort , Using temporary 字样时就要小心了，很可能SQL语句需要优化 通过观察执行计划和SQL语句，确定初步优化方案 SQL中where条件字段类型要跟表结构一致，表中user_id为varchar(50)类型，实际SQL用的int类型，存在隐式转换，也未添加索引。将b和c表 user_id 字段改成int类型。 因存在b表和c表关联，将b和c表user_id创建索引 因存在a表和b表关联，将a和b表 seller_name字段创建索引 利用复合索引消除临时表和排序12345alter table b modify `user_id` int(10) DEFAULT NULL;alter table c modify `user_id` int(10) DEFAULT NULL;alter table c add index `idx_user_id`(`user_id`);alter table b add index `idx_user_id_sell_name`(`user_id`,`seller_name`);alter table a add index `idx_sellname_gmt_sellid`(`gmt_create`,`seller_name`,`seller_id`); 查看优化后的执行时间 继续查看优化后的执行计划 这里只看到查询需要扫描的元素比较大，不过还看到了有两处告警信息，直接查看告警信息 1show warnings; Cannot use range access on index ‘idx_sellname_gmt_sellid’ due to type or collation conversion on field ‘get_create’，这句话是告诉你由于gmt_create列发生了类型转换所以无法走索引。查看SQL建表语句发现gmt_create字段被设计成了varchar类型，在SQL查询时需要转化成时间格式做查询，确实不能走索引。所以需要调整一下gmt_create字段格式 1alter table a modify &quot;gmt_create&quot; datetime DEFAULT NULL; 修改字段后再来查看执行时间 再观察优化后的执行计划 18.3 SQL优化要点 在表中建立索引，优先考虑where、group by使用到的字段。 尽量避免使用select *，返回无用的字段会降低查询效率，如：SELECT * FROM t。 优化方式：使用具体的字段代替*，只返回使用到的字段。 尽量避免使用in和not in，会导致数据库引擎放弃索引进行全表扫描，如：SELECT * FROM t WHERE id IN (2,3)、SELECT * FROM t1 WHERE username IN (SELECT username FROM t2)。 优化方式： 如果是连续数值，可以用between代替，如：SELECT * FROM t WHERE id BETWEEN 2 AND 3； 如果是子查询，可以用exists代替，如：SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE t1.username = t2.username)。 尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描。如：SELECT * FROM t WHERE id = 1 OR id = 3。 优化方式：可以用union代替or，如：SELECT * FROM t WHERE id = 1 UNION SELECT * FROM t WHERE id = 3 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 （PS：如果or两边的字段是同一个，如例子中这样。貌似两种方式效率差不多，即使union扫描的是索引，or扫描的是全表） 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。如：SELECT * FROM t WHERE username LIKE &#39;%li%&#39; 优化方式：尽量在字段后面使用模糊查询。如：SELECT * FROM t WHERE username LIKE &#39;li%&#39; 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如：SELECT * FROM t WHERE score IS NULL 优化方式：可以给字段添加默认值0，对0值进行判断。如：SELECT * FROM t WHERE score = 0 尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。如：SELECT * FROM t2 WHERE score/10 = 9、SELECT * FROM t2 WHERE SUBSTR(username,1,2) = &#39;li&#39; 优化方式：可以将表达式、函数操作移动到等号右侧。如：SELECT * FROM t2 WHERE score = 10*9、SELECT * FROM t2 WHERE username LIKE &#39;li%&#39; 当数据量大时，避免使用where 1&#x3D;1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如：SELECT * FROM t WHERE 1=1 优化方式：用代码拼装sql时进行判断，没where加where，有where加and。 19. 分库分表19.1 什么是分库分表:分库分表是在海量数据下，由于单库、表数据量过大，导致数据库性能持续下降的问题，演变出的技术方案。 通过一定的规则，将原本数据量大的数据库拆分成多个单独的数据库，将原本数据量大的表拆分成若干个数据表，使得单一的库、表性能达到最优的效果（响应速度快），以此提升整体数据库性能。 19.2 分库分表方案: 垂直分库：垂直分库一般来说按照业务和功能的维度进行拆分，将不同业务数据分别放到不同的数据库中。垂直分库把一个库的压力分摊到多个库，提升了一些数据库性能，但并没有解决由于单表数据量过大导致的性能问题，所以就需要配合后边的分表来解决。 例子：按业务类型对数据分离，剥离为多个数据库，像订单、支付、会员、积分相关等表放在对应的订单库、支付库、会员库、积分库。不同业务禁止跨库直连，获取对方业务数据一律通过API接口交互，这也是微服务拆分的一个重要依据。 垂直分表：垂直分表针对业务上字段比较多的大表进行的，一般是把业务宽表中比较独立的字段，或者不常用的字段拆分到单独的数据表中，是一种大表拆小表的模式。 例子：一张t_order订单表上有几十个字段，其中订单金额相关字段计算频繁，为了不影响订单表t_order的性能，就可以把订单金额相关字段拆出来单独维护一个t_order_price_expansion扩展表，这样每张表只存储原表的一部分字段，通过订单号order_no做关联，再将拆分出来的表路由到不同的库中。 水平分库：水平分库是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，以此实现水平扩展，是一种常见的提升数据库性能的方式。 例子：db_orde_1、db_order_2两个数据库内有完全相同的t_order表，我们在访问某一笔订单时可以通过对订单的订单编号取模的方式 订单编号 mod 2 （数据库实例数） ，指定该订单应该在哪个数据库中操作。 水平分表：水平分表是在同一个数据库内，把一张大数据量的表按一定规则，切分成多个结构完全相同表，而每个表只存原表的一部分数据。 例子：例如：一张t_order订单表有900万数据，经过水平拆分出来三个表，t_order_1、t_order_2、t_order_3，每张表存有数据300万，以此类推。 19.3 数据存在哪个库的表 分库分表以后会出现一个问题，一张表会出现在多个数据库里，到底该往哪个库的哪个表里存呢？ 常见的有 取模算法 、范围限定算法、范围+取模算法 、预定义算法 取模算法： 概念：关键字段取模（对hash结果取余数 hash(XXX) mod N)，N为数据库实例数或子表数量）是最为常见的一种路由方式。 例子：以t_order订单表为例，先给数据库从 0 到 N-1进行编号，对 t_order订单表中order_no订单编号字段进行取模hash(order_no) mod N，得到余数i。i&#x3D;0存第一个库，i&#x3D;1存第二个库，i&#x3D;2存第三个库，以此类推。 缺点：取模算法对集群的伸缩支持不太友好，集群中有N个数据库实例hash(user_id) mod N，当某一台机器宕机，本应该落在该数据库的请求就无法得到处理，这时宕掉的实例会被踢出集群。此时机器数减少算法发生变化hash(user_id) mod N-1，同一用户数据落在了在不同数据库中，等这台机器恢复，用user_id作为条件查询用户数据就会少一部分。 范围限定算法： 概念：范围限定算法以某些范围字段，如时间或ID区拆分。 例子：用户表t_user被拆分成t_user_1、t_user_2、t_user_3三张表，后续将user_id范围为1 ~ 1000w的用户数据放入t_user_1，1000~ 2000w放入t_user_2，2000~3000w放入t_user_3，以此类推。按日期范围划分同理。 缺点：由于连续分片可能存在数据热点，比如按时间字段分片时，如果某一段时间（双11等大促）订单骤增，存11月数据的表可能会被频繁的读写，其他分片表存储的历史数据则很少被查询，导致数据倾斜，数据库压力分摊不均匀。 范围+取模算法： 为了避免热点数据的问题，我们可以对上范围算法优化一下。 这次我们先通过范围算法定义每个库的用户表t_user只存1000w数据，第一个db_order_1库存放userId从1 ~ 1000w，第二个库10002000w，第三个库20003000w，以此类推。 每个库里再把用户表t_user拆分成t_user_1、t_user_2、t_user_3等，对userd进行取模路由到对应的表中。 有效的避免数据分布不均匀的问题，数据库水平扩展也简单，直接添加实例无需迁移历史数据。 地理位置分片： 地理位置分片其实是一个更大的范围，按城市或者地域划分，比如华东、华北数据放在不同的分片库、表。 预定义算法： 预定义算法是事先已经明确知道分库和分表的数量，可以直接将某类数据路由到指定库或表中，查询的时候亦是如此。 20. MySQL都有哪些锁呢？ 按照 锁的粒度 划分可以分成： 表锁：表级锁是mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。 页锁：页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。 行锁：行级锁是mysql中锁定粒度最细的一种锁。表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。 按照 使用的方式 划分可以分为： 共享锁：又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。 排它锁：又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。 按照 思想 的划分： 乐观锁 悲观锁 21. Redis基础21.1 什么是Redis与传统数据库不同的是，Redis 的数据是存在内存中的，读写速度非常快，被广泛应用于缓存。 21.2 Redis为什么这么快？ Redis 基于内存，内存的访问速度是磁盘的上千倍； Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用； Redis 内置了多种优化过后的数据结构实现，性能非常高。 22. Redis应用 缓存： 分布式锁：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。 消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。 23. Redis数据结构23.1 基本数据结构 Redis 共有 5 种基本数据结构：String（字符串）、Hash（散列）、List（列表）、Set（集合）、Zset（有序集合）。 String（字符串）： String 是 Redis 中最简单同时也是最常用的一个数据结构。 应用场景：把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。 Hash（哈希） 概念：Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象。 应用场景：对象数据存储场景，比如用户信息、商品信息、文章信息等。 List（列表） 概念：Redis用双端链表实现List 应用场景：信息流展示（最新文章、最新动态）；消息队列（功能过于简单且存在很多缺陷，不建议这样做）。 Set（集合） 概念：Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择。 应用场景：需要存放的数据不能重复的场景，点赞，或点踩，收藏等，可以放到set中实现 Zset（有序集合） 概念：Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 应用场景：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜等等。 总结 数据类型 说明 String 一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。 Hash 一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。 List Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 Set 无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。 Zset 和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 23.2 特殊数据结构除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构：Bitmap、HyperLogLog、GEO。 Bitmap 概念：Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。 应用场景：需要保存状态信息（0&#x2F;1 即可表示）的场景。举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。 HyperLogLog 概念：HyperLogLog 是一种有名的基数计数概率算法。 应用场景：数量量巨大（百万、千万级别以上）的计数场景。举例：热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计。 Geospatial index 概念：Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。 应用场景：需要管理使用地理空间数据的场景。举例：附近的人。 总结 数据类型 说明 Bitmap 你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。 HyperLogLog Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。 Geospatial index Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。 24. Redis持久化机制24.1 概念：redis是一个内存数据库，一旦服务器宕机，内存中的数据将全部丢失。所以，对 Redis 来说，实现数据的持久化，避免从后端数据库中进行恢复，是至关重要的。 24.2 分类经典的redis的持久化机制分为两种：快照（snapshotting，RDB）和只追加文件（append-only file, AOF）；4.0之后，redis又提供了一种RDB和AOF的混合持久化机制。 24.3 各自的实现机制，优缺点 rdb就是把某时刻的数据以二进制的形式固化到磁盘上，优点是二进制存储，结构压缩紧凑，方便传输，适用于备份容灾，缺点是实时性不高，单纯rdb，很难保证数据的可靠性，容易造成数据丢失； aof则是以日志的形式记录数据的变更信息，相对于rdb，其数据实时性较高，一定程度上保证了数据的安全可靠，但是，其文件大小容易暴增，如果aof刷盘频繁的话，还会影响redis性能。 而混合型则是在一个文件中同时使用rdb和aof格式，集上述两种的优势于一身 24.4 RDB备份一般什么时候进行 rdb有三种触发方式。 第一种，save命令触发，这种是堵塞式的，一般不推荐使用； 第二种是bgsave命令触发，执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求； 第三种就是根据业务情况自动触发，在某个固定时间段内，如果出现了指定次数的数据变更则进行rdb。 24.5 AOF重写机制 当有命令触发或AOF达到一定大小后，会触发AOF文件重写。重写时，redis会fork一个子进程出来，在子进程中，将内存中所有数据通过redis写命令写入到一个新的AOF文件；AOF写完后，再删除旧的AOF文件，将新的AOF文件更名为旧的AOF文件。 在fork后，子进程负责将内存中的数据写入新的AOF文件；同时，父进程中，如果有新的数据变更，会将其变更记录写到rewrite_buf中；待子进程写完后，通过信号通知父进程，父进程收到通知后，继续将rewrite_buf中的变更信息写入到新的AOF文件，这样新的aof文件就不会缺失数据了。 25. Redis线程模型25.1 线程模型redis 内部使用文件事件处理器 file event handler，它是单线程的，所以redis才叫做单线程模型。它采用IO多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中 25.2 redis是单线程为什么效率还这么高 纯内存操作。 核心是基于非阻塞的 IO 多路复用机制。 C 语言实现，语言更接近操作系统，执行速度相对会更快。 单线程反而避免了多线程的频繁上下文切换问题，避免了多线程可能产生的竞争问题。 26. Redis内存管理Redis主要通过控制内存上限和回收策略实现内存管理。 26.1 设置内存上限 Redis使用maxmemory参数限制最大可用内存。 限制内存的目的主要有： 用于缓存场景， 当超出内存上限maxmemory时使用LRU等删除策略释放空间。 防止所用内存超过服务器物理内存。 26.2 内存回收策略 删除过期键对象 惰性删除 定期删除 内存使用达到maxmemory上限时触发内存溢出控制策略。 27. Redis事务27.1 Redis是否支持事务？redis是支持事务的，他能保证一系列的命令要么全部执行，要么全部不执行 27.2 Redis隔离级别 传统的数据库事务的隔级别分为读未提交、读提交、可重复读、可序化四个级别；其他，读提交解决了脏读问题，可重复读解决了不可重复度问题，可序化解决了幻读问题。 在redis中，他的事务实现机制跟传统的数据库差异较大，如果一定要对接这几种隔离级别的话，我觉得是可序化。 在redis中，其事务是将多个redis命令通过multi指示命令入队，然后通过exec命令逐个执行队列中的所有命令。 首先脏读，在redis事务中，如果事务没提交，即事务队列中的命令没执行的话，该事务对数据的改变不会在redis内存数据中体现出来，这样，别的事务就不会读到未提交的数据，即不可能出现脏读； 再考虑到redis的单线程出来模型，通过exec执行事务队列中多条命令时，不会存在其他redis命令的并发执行，这样的话，在redis事务中，天然解决了不可重复度问题。 同时，也由于redis的单线程模型，不存在多事务并发执行，所以，幻读问题在redis中也是不存在的。 所以说，如果要对接传统数据库事务隔离级别的话，redis实现了可序化的隔离级别。 27.3 相比传统数据库，redis的事务有什么不足的地方 相比传统数据库，redis事务最大的不足，我觉得是不支持回滚；在传统数据库中，如果事务中途执行错误，是支持回滚的，在redis中，这个不支持。 redis不支持回滚，那么如果事务中途出现错误了会怎么样呢？ 这里有两种情况：第一种，命令入队时，如果redis命令格式错误，则会导致整个事务都不执行；第二种，如果执行命令时，其中某个命令出错，会继续执行完其他所有命令 你怎么看待redis事务不支持回滚特性的？ 这里比较赞同redis作者的解析，redis作者认为，事务中途的错误都是由于开发者的编码错误造成的；而同时，没有任何机制能够避免程序员自己造成的错误，所以redis采用了简单、高效的无回滚事务处理机制。 27.4 redis事务中，有类似传统数据库中的锁机制吗？在redis事务中，通过watch实现了CAS式的乐观锁 28. Redis生产问题28.1 缓存穿透 概念：当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。 发生的情况： 业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据； 黑客恶意攻击，故意大量访问某些读取不存在数据的业务； 解决方案： 限制非法请求； 设置缓存空值或者默认值； 使用过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。 28.2 缓存击穿 概念：如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。 解决方案： 互斥锁方案，保证同一时间只有一个业务线程更新缓存 不给热点数据设置过期时间，由后台异步更新缓存。 28.3 缓存雪崩 概念：当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。 发生原因： 大量数据同时过期 Redis 故障宕机 解决方案： 大量数据同时过期 均匀设置过期时间 互斥锁 Redis 故障宕机 服务熔断或请求限流机制； 构建 Redis 缓存高可靠集群； 31. 主从同步32. 部署方式","categories":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试-简历","slug":"面试-简历","date":"2021-06-08T11:50:53.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2021/06/08/面试-简历/","link":"","permalink":"https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%80%E5%8E%86/","excerpt":"","text":"1. JVM内存结构2. GC算法3. 对象创建过程4. OOM问题排查5. IOC6. AOP7. 自动装配8. 优化SQL9. 表结构设计10. 分库分表11. 主从同步12. 持久化13. 淘汰机制14. kafka负载均衡15. kafka消息可靠性保证16. leader选举17. 分区分配策略18. 三握四挥 概念：三次握手和四次挥手是TCP协议中用来建立和终止TCP连接的过程。 三次握手：是建立一个TCP连接的过程，需要三个步骤： 客户端发送连接请求报文段， 服务器收到请求并发送确认报文段， 客户端收到确认并发送确认报文段。 四次挥手是终止一个TCP连接的过程，需要四个步骤： 客户端发送终止请求报文段， 服务器收到请求并发送确认报文段， 客户端收到确认并发送确认报文段， 服务器收到确认并终止连接。 19. 滑动窗口 概念：滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量。 20. 粘包 什么是TCP粘包问题： TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。 21. 项目21.1 自我介绍21.2 仓库管理系统 背景： 首先我本科的时候在学校的慈善助学超市当过志愿者，这个超市是由省慈善总会拨款资助的，里面的工作人员都是学生担任。 我在里面当志愿者的时候发现他们记录购买和分发的生活用品都是使用纸质的本子记录，效率很低，同时容易出现数量对不上的问题。所以我就和同学组队一起做了一个仓库管理系统，希望能够提高助学超市的商品的管理效率。 项目开发： 在这个项目里，我们使用maven来进行依赖控制，使用git进行版本控制，用jira来管理任务和bug。 我使用junit编写单元测试，根据真实的业务数据来编写案例，而且在编写代码时，我会非常注意编码规范，比如定义变量时会让人一看就理解 ，在关键代码地方多写注释，在if等条件里不会写太复杂，一个方法不会写太长。而且，一旦遇到我的bug，我会第一时间跟进，并会和相关对应的人一起解决掉。 技术： 我们这个项目用到了SpringBoot框架， 其中用DataSource连接MySQL数据库， 在控制层里用到了@RequestMapping注解来编写业务处理方法。 在业务代码里，使用@Autowired注解来以IOC的方式引入类，还用到了@Service和@Component注解。 当我们从数据库里拿到数据后，会用包含@Entity和@Table注解的模型类来映射数据。 在这个项目里，我们还用到了@Transactional注解来定义事务，这个注解是作用在Service层上的， 在这个项目里，我们还用到多个Java集合类和异常处理类。 应背八股文： 1 @Service和@Component注解的差别？ 2 各种Restful请求格式以及各种http请求返回码。 3 @Transactional事务里的事务隔离级别和事务传播机制概念。 4 Spring依赖注入概念和@Autowired的用法。 5 Spring Bean的生命周期。 6 甚至可能还会问Spring Boot启动流程以及底层源码。 内存调优： 在本项目里，我会非常注意内存的使用性能，并在项目里有过排查分析OOM的项目经验，我在编码的时候，也会非常注意内存性能，同时我也了解过JVM内存结构以及GC算法。 OOM： 先获取内存的 Dump 文件，配置 JVM 启动参数，当触发了 OOM 异常的时候自动生成， 然后使用 MAT 工具来分析 Dump 文件。 内存性能： 在写代码时，我会非常注意，在try…catch…finally里关闭Connection和大的集合， 一些大的对象用好以后，我会及时把它们设置成null，以此提升它们的回收时间， 在for等循环里，我不会频繁地操作String对象，因为会产生大量内存碎片。 同时，我会非常谨慎地使用finalize方法（事先看下），因为这可能会导致对象无法回收。 在数据同步的业务场景里，我用到了弱引用（或软引用），以此提升数据对象的回收时间。 应背八股文： JVM内存结构 GC（垃圾回收）流程 数据库调优 1 索引的数据结构（比如B+树），建索引的语句，索引的种类，尤其是复合索引以及对应的回表和最左匹配原则。 2 索引的正确用法，以及哪些情况下用不到索引，比如where a !&#x3D; ‘xx’可能就用不到。 3 索引的代价（会占硬盘，以及大批量读写时会重建索引，所以性能慢），以及在小表里，无需建索引。 4 执行计划的概念，以及通过执行计划排查慢sql时该注意的点（避免全表扫描，设置合理的关联表方式等）。 5 三范式和反范式相关概念，因为你提到了。 6 事务隔离级别里的脏读等概念，以及事务传播机制，尤其地，你要具体说出你项目里用的是哪个。","categories":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Github+Hexo博客创建","slug":"Github-Hexo博客创建","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/Github-Hexo博客创建/","link":"","permalink":"https://wxzhou.top/2020/05/05/Github-Hexo%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/","excerpt":"","text":"参考文章：https://www.cnblogs.com/huanhao/p/hexobase.html 1. 准备阶段1.1 安装nodejs下载地址：http://nodejs.cn/download/选择Windows安装包.msi安装过程中’Add to PATH’然后点Next继续就行了 1.2 安装Git下载地址：https://git-scm.com/ 1.3 验证nodejs是否安装配置成功右键点击Git Bash Here，在里面执行下面命令 12node -vnpm -v 如果输出了版本号，证明配置成功，如果没有版本号，则检查是否成功配置环境变量 1.4 安装cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org 1.5 检查cnpm是否安装成功1cnpm -v 2. 安装Hexo和初始化博客2.1 安装Hexo1cnpm install hexo-cli -g 2.2 初始化博客选择一个文件夹，然后右键打开git bash例如：在F盘新建了一个blog文件夹，就在blog文件夹下打开git bash然后执行 1hexo init 到Install dependencies的时候你可能会卡住，这是大多数人基本都会遇到的 我们只需要在这里的时候结束命令，按Ctrl + C就可以结束命令 然后执行下面这个命令，就可以使用国内的镜像为你完成博客的初始化工作 1cnpm install 等待命令完成后，就完成了初始化，现在就可以预览我们的博客了 执行下面这个命令 1hexo s 3. 更换主题3.1 hexo的所有主题都在下面这个地址1[https://hexo.io/themes/](https://hexo.io/themes/) 3.2 下载主题1git clone 复制的地址 themes/主题名字 4. 修改配置文件在博客的目录下有一个叫_config.yml的文件找到themes这一行，然后将主题名字修改为模板名称 1theme: 模板名称 4. 部署博客4.1 创建密钥创建一个git秘钥，打开git bash（不要求在哪个目录）不管出现什么信息，你只需要回车就可以了 1ssh-keygen -t rsa -C “your_email@youremail.com“ 然后执行 1cat ~/.ssh/id_rsa.pub 会输出你的秘钥，我们复制输出信息就行了 在GitHub中点击头像，点击Settings –&gt; SSH····· –&gt; New SSH Key 4.2 连接GitHub然后在git bash中执行 1ssh -T git@github.com 在博客根目录下打开git bash执行 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 4.3 上传安装上传插件 1cnpm install hexo-deployer-git --save 在博客根目录下打开git bash，执行下面的命令就可以上传了 1hexo g -d 新建文章 1hexo new post 文章标题","categories":[{"name":"Blog","slug":"Blog","permalink":"https://wxzhou.top/categories/Blog/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://wxzhou.top/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://wxzhou.top/tags/Hexo/"}]},{"title":"Java-day01-Java入门","slug":"day01-Java入门","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day01-Java入门/","link":"","permalink":"https://wxzhou.top/2020/05/05/day01-Java%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、 Java背景知识在正式开干之前，我们先了解一下Java的背景知识，方便以后你在和大家聊Java的时候可以说到一块去。 1.1 Java语言的历史 Java是哪家公司的产品？ Java是美国Sun（Stanford University Network，斯坦福大学网络公司）公司在1995年推出的一门计算机高级编程语言。但是在2009年是Sun公司被Oracle（甲骨文）公司给收购了，所以目前Java语言是Oracle公司所有产品。 Java名称的来历？ 早期这门语言的名字其实不叫Java，当时称为Oak（橡树的意思），为什么叫橡树呢？原因是因为Sun公司的门口种了很多橡树，但是后来由于商标注册时，Oak商标已经其他公司注册了，所以后面改名为Java了。那么有人好奇为什么叫Java呢？Java是印度的一个岛屿，上面盛产咖啡，可能是因为他们公司的程序员喜欢喝咖啡，所以就改名为Java了。 Java的创始人是谁？ 说完Java名称的来历之后，接下来我们聊聊Java的祖师爷是谁？ Java的联合创始人有很多，但是行业普遍认可的Java的创始人 是詹姆斯●高斯林，被称为Java之父 1.2 Java能做什么了解了Java语言的历史之后，接下来，大家比较关心的问题可能是Java到底能做什么了？ 其实Java能做的事情非常多，它可以做桌面应用的开发、企业互联网应用开发、移动应用开发、服务器系统开发、大数据开发、游戏开发等等。 12345678910111213141516171.桌面应用开发：能够在电脑桌面运行的软件 举例：财务管理软件、编写程序用的IDEA开发工具等，可以用Java语言开发 2.企业级应用开发：大型的互联网应用程序 举例：淘宝、京东、大家每天都用的tlias教学管理系统等3.移动应用开发：运行的Android手机端的软件 举例：QQ客户端、抖音APP等4.服务器系统：应用程序的后台（为客户端程序提供数据） 举例：服务器系统为用户推荐那你喜爱的视频5.大数据开发：大数据是一个互联网开发方向 举例：目前最火的大数据开发平台是Hadoop，就是用Java语言开发的6.游戏开发：游戏本质上是给用户提供娱乐的软件，有良好的交互感受 举例：我的世界MineCraft就是用Java语言开发的 虽然Java能做的事情非常多，但并不是每一个方向都被市场认可（比如桌面应用使用Java语言开发就不太方便，而使用C#语言是比较推荐的）。目前Java的主流开发方向是使用Java开发企业级互联网应用程序（很多公司的OA系统，客户关系管理系统，包括传智播客使用教学实施管理系统都是用Java语言开发的） 1.3 Java的技术体系说完Java语言能做什么之后，接下来我们再给同学们介绍一下Java的技术体系。所谓技术体系，就是Java为了满足不同的应用场景提供了不同的技术版本，主要有三个版本。 Java SE（Java Standard Edition）：叫做标准版，它是后面两个版本的基础，也就是学习后面两个版本必须先学习JavaSE。我们基础班现阶段学习的就是这个版本中的技术。 Java EE（Java Enterprise Edition）: 叫做企业版，它是为企业级应用开发提供的一套解决方案。在后面就业班课程中主要学习这个版本中的技术。 Java ME（Java Micro Edition）：叫做小型版，它为开发移动设备的应用提供了一套解决方案。目前已经不被市场认可（淘汰），取而代之的是基于Android系统的应用开发。 Java语言的相关背景就给大家介绍到这里了，这些内容小伙伴们也不用刻意去记，简单了解一下就可以了。下面我们在简要回顾一下 12345678910111213141.Java是什么？ 答：Java是一门高级编程语言 2.Java是哪家公司的产品？ 答：Java以前是Sun公司的产品，现在Java是属于Oracle公司的产品 3.Java之父是谁？ 答：詹姆斯●高斯林 4.Java主流的开发方向是什么？ 答：企业级互联网应用开发 5.Java技术平台有哪些？ 答：JavaSE（标准版）、JavaEE（企业版）、JavaME（小型版） 二、 Java快速入门上一章我们给小伙伴们介绍了Java的相关背景，你们现在是不是就想马上用一下Java呀？先不着急，我们得先得安装Java的开发环境，才能使用Java语言开发程序（ps: 就像你先需要安装微信，才能使用微信和朋友聊天是一样的）。 这里所说的Java开发环境，实际上就是Java官方提供的一个软件，叫做JDK（全称是Java Develop Kit），翻译过来意思就是Java开发工具包。我们先要到官网上去下载JDK，然后安装在自己的电脑上，才可以在自己的电脑上使用JDK来开发Java程序 JDK的版本有很多，下图是JDK版本更新的历程图，有LTS标识的是长期支持版本（意思就是Oracle会不定期更新）。目前公司中用得最多的版本是JDK8版本，在目前这套课程中我们为了将一些新特性会使用JDK17版本。 下面已经给小伙伴们提供了详细的JDK下载和安装过程的截图，大家只需要按照步骤操作就行。 2.1 JDK下载和安装 JDK的下载 这是JDK下载的官方网址 https://www.oracle.com/java/technologies/downloads/，你需要把该网址复制到浏览器的地址栏，敲回车 进入网址后，选择JDK17版本，找到Windows标签，选择x64 Installer版本。如下图所示 下载完成之后，在你下载的目录下会出现一个JDK的安装包，如下图所示 到这JDK的下载就完成了，接下来就需要按照下面的步骤完成JDK安装. JDK的安装 双击安装包，按照下图引导，点击下一步即可安装。需要注意的是安装JDK后不像你安装QQ一样会在桌面上显示一个图标，JDK安装后桌面上没有图标！！！ 如何验证安装成功了呢？ 刚才不是让你记住安装目录吗？你记住了吗？如果你自己修改过目录，就打开你自己修改的目录（呀！！忘记了o(╥﹏╥)o，那我帮不了你了，谁让你不认真听讲的）；如果没有修改安装目录，默认在C:\\Program Files\\Java\\jdk-17.0.3目录下。 在文件资源管理器打开JDK的安装目录的bin目录，会发现有两个命令工具 javac.exe java.exe ，这就是JDK提供给我们使用的编译工具和运行工具，如下图所示 我们现在就使用一下 javac.exe java.exe 这两个工具，测试一下JDK是否可用 第一步：在JDK的bin目录，地址栏输入cmd，回车 输入完cmd回车后，会出现一个黑窗口，专业说法叫命令行窗口 第二步：在命令行窗口中输入 javac -version回车，然后输入java -version回车 如果出现下面红色框框的提示正确版本号，和我们安装的JDK版本号一致，就说明JDK安装成功 做完以上步骤之后，恭喜小伙伴^_^，你的电脑上就已经有Java的开发环境了，接下来可以开发Java程序了。 2.2 cmd常见命令前面测试JDK是否安装成功，需要在黑窗口中输入javac -version和java -version 这其实就是JDK查看编译工具和运行工具版本号的命令。 这种输入命令的和电脑交互的方式，称之为命令行交互。也就是说，可以使用命令指挥电脑做事情。接下来我们了解几种Windows系统常见的命令，后面可能会用到。 下面是Windows系统常见的命令以及作用，小伙伴们可以自己试一试。需要注意的是，每敲完一条命令之后，马上敲回车就表示执行这条命名。 123456E: //切换到E盘cd [目录] //进入指定的目录cd .. //退回到上一级目录cd / //退回到根目录dir //显示当前目录下所有的内容cls //清空屏幕 2.3 Java入门程序上一节我们已经安装好了JDK，接下来，我们就正式开始开发第一个入门Java程序。按照国际惯例，学习任何一本编程语言第一个案例都叫做 Hello World，意思是向世界问好，从此开用程序和世界沟通的大门。 编写Java程序的步骤 编写一个Java程序需要经过3个步骤：编写代码，编译代码，运行代码 编写代码：任何一个文本编辑器都可以些代码，如Windows系统自带的记事本 编译代码：将人能看懂的源代码（.java文件）转换为Java虚拟机能够执行的字节码文件（.class文件） 运行代码：将字节码文件交给Java虚拟机执行 编写第一个Java入门程序 按照下面提供的步骤，一步一步的完成第一个Java入门程序的编写、编译和执行。 第一步：新建一个后缀为.java的文本文件HelloWorld.java，用记事本编写代码如下。 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot; HelloWorld &quot;); &#125;&#125; 第二步：进入HelloWorld.java文件所在目录，在地址栏输入cmd回车，即可在此处打开命令行窗口。 编译：在命令行窗口输入编译命令javac HelloWorld完成编译，编译后会生成一个HelloWorld.class文件。 第三步：再接着输入java HelloWorld就可以运行了，运行结果如下。 2.4 Java程序中常见的问题刚才小伙伴们在编写第一个HelloWorld程序的时候，是不是很容易报错啊？ 我观察过第一次写代码，90%的同学都会有些小问题的，比如单词写错了！ 括号少写一个！等等！ 我想给大家说的是，写错代码都是很正常的，一个什么错都犯过的程序员，才是真正的程序员。 下面我们把程序中常见的问题，总结一下。大家在写代码时注意一下这些问题就可以了 Windows的文件扩展名没有勾选 代码写了，但是忘记保存了 文件名和类名不一致。 英文大小写错误，单词拼写错误，存在中文符号，找不到main方法。 括号不配对。 编译或执行工具使用不当。 文件扩展名没有打开 下图中文件扩展名的勾勾没有勾选，就会导致你创建的文件是普通的文本文件（.txt）文件，而不是java文件。 正确做法是把文件扩展名的勾选上 文件名和类名不一致 你看下图中，文件名是HelloWorld，但是类名是Helloworld看出区别了吗？一个是大写的W，一个是小写的w。 不仔细看还真看不出来。 **正确写法是文件名叫HelloWorld，类名也叫HelloWorld** 单词大小写错吴 下图中不是string和system这两个单词都写错了， 这里是严格区分大小写的 正确写法是String和System 主方法写错了 下图所示，主方法的名称写成了mian，这是错误的。 主方法正确写法：必须是 public static void main(String[] args)&#123;&#125;，一个字母都不能错。 标点符号写错了 下图中打印语句最后的分号，写成功中文分号； 正确写法应该是英文分号 ; 不仔细看还真看不出区别，要小心 2.5 JDK的组成在前几节课中我们已经安装了JDK，并且开发了一个Java入门程序，用javac命令编译，用Java命令运行，但是对于Java程序的执行原理并没有过多的介绍。 下面我们把JDK的组成，以及跨平台原理给大家介绍一下，有利于同学们理解Java程序的执行过程。 JDK由JVM、核心类库、开发工具组成，如下图所示 下面分别介绍一下JDK中每一个部分是用来干什么的 123456789101112- 什么是JVM? 答：JDK最核心的组成部分是JVM（Java Virtual Machine），它是Java虚拟机，真正运行Java程序的地方。 - 什么是核心类库？ 答：它是Java本身写好的一些程序，给程序员调用的。 Java程序员并不是凭空开始写代码，是要基于核心类库提供的一些基础代码，进行编程。 - 什么是JRE? 答：JRE（Java Runtime Enviroment），意思是Java的运行环境；它是由JVM和核心类库组成的；如果你不是开发人员，只需要在电脑上安装JRE就可以运行Java程序。 - 什么是开发工具呢？ 答：Java程序员写好源代码之后，需要编译成字节码，这里会提供一个编译工具叫做javac.exe，编写好源代码之后，想要把class文件加载到内存中运行，这里需要用到运行工具java.exe。 除了编译工具和运行工具，还有一些其他的反编译工具、文档工具等待... JDK、JRE的关系用一句话总结就是：用JDK开发程序，交给JRE运行 2.6 Java的跨平台原理学完JDK的组成后，我们知道Java程序的执行是依赖于Java虚拟机的。就是因为有了Java虚拟机所以Java程序有一个重要的特性叫做跨平台性。 什么是跨平台行呢？ 所谓跨平台指的是用Java语言开发的程序可以在多种操作系统上运行，常见的操作系统有Windows、Linux、MacOS系统。 如果没有跨平台性，同一个应用程序，想要在多种操作系统上运行，需要针对各个操作系统单独开发应用。比如微信有Windows版本、MacOS版本、Android版本、IOS版本 为什么Java程序可以跨平台呢？ 跨平台性的原理是因为在不同版本的操作系统中安装有不同版本的Java虚拟机，Java程序的运行只依赖于Java虚拟机，和操作系统并没有直接关系。从而做到一处编译，处处运行。 2.7 JDK环境变量配置JDK安装后，接下我们来学习一个补充知识，叫做Path环境变量 什么是Path环境变量？ Path环境变量是让系统程序的路径，方便程序员在命令行窗口的任意目录下启动程序； 如何配置环境变量呢？ 比如把QQ的启动程序，配置到Path环境变量下就可以在任意目录下启动QQ，按照一下步骤操作。 第一步：先找到QQ启动程序所在的目录C:\\Program Files (x86)\\Tencent\\QQ\\Bin，复制这个路径 第二步：按照下面的步骤，找到Path环境变量。 首先找到此电脑，右键点击属性，可以按照下面的界面；点击【高级系统设置】，再点击【环境变量】 双击Path后，点击新建，把QQ启动目录粘贴进来，不要忘记点确定哦^_^ 第三步：配置好之后，检查是否配置成功 121.Win+R 输入cmd回车，打开命令行窗口2.输入QQScLanucher，可以看到QQ启动了 将JDK配置到Path路径下 上面我们配置了QQ的启动目录到Path环境变量位置，那么接下来，我们把JDK的bin目录配置到Path环境变量下，这样就可以在任意目录下启动javac和java命令来完成编译和运行了。 第一步：找到JDK的bin目录C:\\Program Files\\Java\\jdk-17.0.3\\bin，复制一下 第二步：将JDK的bin目录粘贴在Path环境变量后面 第三步：检测否配置成功 12341.按住Win+R输入cmd 回车，打开命令行创建2.输入javac -version 看提示信息是否显示你安装JDK的版本号 输入java -version 看提示信息是否显示你安装JDK的版本号【如果显示版本号都是JDK17就表示配置安装成功】 你如果按照前面的操作到这里，就说明JDK环境变量已经配置好了，后面使用JDK命令可以在任意目录下运行。 三、Java开发工具大家刚才写代码的时候都是用记事本写的，但是有没有觉得记事本写代码不太方便啊！记事本写代码单词写错了没有提示，格式也不好调整，写代码之后还需要我们到命令行使用javac命令手动编译，然后运行。 有没有一种软件能够将写代码、编译、运行等工具集成到一起呢？ 有，这就是集成开发环境（Integrated Development Environment ，简称IDE）。除此之外，IDEA还有代码提示、检查代码错误等功能，从而提高程序员的开发效率。 IDE有很多种，常见的Eclipse、MyEclipse、Intellij IDEA、JBuilder、NetBeans等。但是这些IDE中目前比较火的是Intellij IDEA（以下简称IDEA），被众多Java程序员视为最好用的Java集成开发环境，所以我们课程中就以IDEA为开发工具来编写代码，以后大家去公司也建议用IDEA作为开发环境。 3.1 IDEA下载和安装为了引导大家正确的完成IDEA的下载和安装，给小伙伴们单独提供了一个文档《IDEA安装、使用、配置.pdf》，文档中提供了IDEA详细的安装和使用步骤，大家只需要按照文档的步骤一步一步操作就行。 3.2 IDEA编写Java程序上一节我们安装好了IDEA之后，接下来我们就可以使用IDEA开发一个HelloWorld程序玩一玩！目的是让大家知道在IDEA中开发Java程序的步骤。 想要在IDEA正确的写一个Java程序，必须先认识一下IDEA的管理Java程序的工程结构。 第一步：首先得在IDEA中创建一个Project（工程、也叫项目），后面统称为工程。 第二步：需要在Project中创建Module（模块），一个工程中可以包含多个模块 第三步：需要在Module中新建Package（包），一个模块中可以有多个包 第四步：需要在Package中新建Class（类），一个包中可以包含多个类 软件工程其实类似于建筑工程，我们对比建筑工程来理解。 Project（工程）：你可以理解成小区的院子 Module（模块）：你可以理解成小区院子里面的每一栋楼 Package（包）：你可以理解成每一栋楼的一层 Class（类）：你可以理解成每一层的住户 在实际开发中比如淘宝网站这样的工程，但是由于功能很多，所以就把淘宝网站分为不同的模块，首页是一个模块、购物车是一个模块、订单也是一个模块； 创建工程Project 创建工程的步骤比较多，在《IDEA安装、使用、配置.pdf》中提供的详细的引导步骤，照着一步一步的操作就行。 用浏览器打开《IDEA安装、使用、配置.pdf》点击左侧的导航栏可以定位到对应的位置，每一个部分都有截图步骤 3.4 IDEA各种配置刚才有同学在使用IDEA编写程序时，可能会觉得字体比较小，背景色是黑色的，注释是灰色的，看不清，长时间可能对眼睛不好。我们可以通过IDEA相关的设置，把字体调大一点，背景色调为护眼色，注释也调为绿色。 主题配置 字体配置 背景色配置 把背景色的颜色值，调为204、238、200；就是豆沙绿的护眼色了 更多配置，大家可以参考《IDEA安装、使用、配置.pdf》 3.5 常用快捷键讲完IDEA相关配置之后，接下来给大家讲一个很重要的IDEA的使用技巧，这就是IDEA的快捷键，所谓快捷键就是通过键盘上的按键组合起来，就可以帮我们生成代码。使用快捷键可以大大提高我们的开发效率。 下面是几种常见的快捷键，以及他们的作用，大家可以自己试试 快捷键 功能效果 main&#x2F;psvm、sout、… 快速键入相关代码 Ctrl + D 复制当前行数据到下一行 Ctrl + Y 删除所在行，建议用Ctrl + X Ctrl + ALT + L 格式化代码 ALT + SHIFT + ↑ , ALT + SHIFT + ↓ 上下移动当前代码 Ctrl + &#x2F; , Ctrl + Shift + &#x2F; 对代码进行注释(讲注释的时候再说) 快捷键其实有很多，这里列举的是现阶段我们用得比较多的，现在记住不也不要紧，以后经常用，用着用着就记住了。 在后面的课程中讲到一些新的知识点时，还有会继续给大家讲一些新的快捷键。 四. Java基础语法前面讲到的所有内容，都是为Java程序开发做一些准备工作，我们还没有正式教大家如何编写代码。 想要编写Java代码，就必须学习Java的语法，学习语法最主要做到下面两点就可以了 记住语法格式 明确这种语法格式能达到什么效果 这里需要给大家说明一点：语法格式是Java语言的设计者规定好的，我们不用关心它为什么这么写，因为它造出来就是这么写的。 4.1 注释我们先从最简单的语法开始学习，先来学习注释！ 什么是注释？ 注释是解释说明程序的问题，方便自己和别人阅读代码 注释有哪几种？格式怎样？ 1234567891011121.单行注释： //后面根解释文字2.多行注释 /* 这里写注释文字 可以写多行 */3.文档注释 /** 这里写文档注释 也可以写多行，文档注释可以利用JDK的工具生成帮助文档 */ 下面用注释解释一段代码 123456789101112131415161718/**目标：学会使用注释 这是程序的讲解注释*/public class NoteDemo&#123; //这是程序的主方法，是程序的入口 public static void main(String[] args)&#123; System.out.println(&quot;我开始学习Java程序，好嗨皮~~&quot;); /* 窗前明月光 疑是地上霜 举头望明月 低头思故乡 */ System.out.println(&quot;播仔&quot;); System.out.println(&quot;deli&quot;); &#125;&#125; 再多学一招：每次手动加注释比较麻烦，也可以使用快捷键加注释 12Ctrl + / 单行注释（对当前行进行注释）Ctrl + Shift + / 对选中的代码进行多行注释。 4.2 字面量学习完注释之后，我们来学习一个全新的知识点叫字面量。 什么是字面量？ 大家不要被这个词搞晕了，它其实很简单，我们知道计算机是来处理数据的，字面量其实就是告诉程序员数据在程序中的书写格式。下面是常用的数据在程序中的书写格式 编写程序，在命令行打印输出各种类型的字面值 12345678910111213141516171819202122232425262728/*目标：需要同学们掌握常见数据在程序中的书写格式*/public class LiteralDemo&#123; public static void main(String[] args)&#123; //1.整数 System.out.println(666); //2.小数 System.out.println(3.66); //3.字符: 字符必须用单引号引起来 System.out.println(&#x27;a&#x27;); System.out.println(&#x27;0&#x27;); System.out.println(&#x27;中&#x27;); System.out.println(&#x27; &#x27;); //空格也算字符 //特殊字符：\\t表示制表符 \\n表示换行 System.out.println(&#x27;\\t&#x27;); //这相当于一个tab键，专业叫做制表符 System.out.println(&#x27;\\n&#x27;); //这是换行的意思 //4.字符串：字符串是双引号引起来的 System.out.println(&quot;我爱你中国abc&quot;); //5.布尔值：只有两个值true和false System.out.println(true); System.out.println(false); &#125;&#125; 总结一下：对于字面量，大家只要能够正确写出各种数据就可以了 4.3 变量学习完字面量之后，接下来我们再来学习变量。对于变量的学习路径如下所示 先认识什么是变量？ 学习为什么要用变量？ 学习变量有啥应用场景？ 什么是变量？ 变量是用来记录程序中的数据的。其本质上是内存中的一块区域，你可以把这块区域理解成一个小盒子。 我们通过先通过一段代码演示一下，并解释变量的含义 12int age = 18;System.out.println(a); 当执行int age = 18; 这句代码时，JVM会在内存中申请一块区域，在这个区域中存储了一个整数18，给这个区域取的名字叫age； 相当于在盒子中存了一个数据18，这个盒子的名字是age，当我们打印age时，就是从盒子中把盒子中的数据取出来再打印。 为什么要用变量呢？ 使用变量来记录数据，对于数据的管理更为灵活。比如我们有多个地方用到一个整数10, 1234567891011121314//1.假设4多个地方用到整数10; 现在我想把10改为20，这时你得一条语句一条语句的修改System.out.println(10);System.out.println(10);System.out.println(10);System.out.println(10);//2.同样这里还是在多个地方用到整数10，你可以先用一个变量记录这个整数10int x = 10;//然后在需要用到整数10的地方，用x代替就行；//如果我们把x值改了，那么后面用到x的值的地方就都一起改变了System.out.println(x);System.out.println(x);System.out.println(x);System.out.println(x); 变量有应用场景? 变量的应用场景无处不在，只要是程序中能发生变化的数据，都可以用变量存储。比如：你微信钱包中的余额，你微信的昵称，你微信的个性签名； 余额随着你花钱是不是在变少，昵称和个性签名也可以经常修改。 123456789101112131415161718192021222324252627//比如：你现在有188.8元，一会要发100元，再收20元。double money = 188.8;//发100元money = money - 100;//再收20元money = money + 20;//再打印money记录的值是多少System.out.println(money);//再比如：公交车大人2元，小孩一元，公交车经过2站//第一站：3个大人1个小孩上车//第二站：1个大人1个小孩上车，请问一共上了多少人，一共收入多少钱？//刚开始公交车箱子里没有钱，用money2表示箱子里的钱int money2 = 0;//刚开始公交车上也没有人，用count变量表示上车的人数int count = 0;//经过两站的人数：第一站3人，第二站1人，总的人数是3+1count = 3+1;//经过两站的钱数：money2 = money2+3*2+1; //经过第一站后money2 = money2+2+1; //经过第二站后//打印人数和钱数System.out.println(count);System.out.println(money); 变量的注意事项 在上节课已经给大家讲了变量的基本使用，变量在实际开发中用得特别多，关于变量使用注意事项需要给大家交代一下。 讲这些注意事项目的是让大家知道，有哪些写法是允许，有哪些写法是不允许的，能分辨对错，并知道为什么错。 123456789101112131415161718191.变量定义在哪个&#123;&#125;范围内，就只在哪个大括号内有效。变量的有效范围称之为变量的作用域 &#123; int a = 10; System.out.println(a); //这是是对的 &#125; System.out.println(a); //这里会出错2.在同一个作用域内，不能有两个同名的变量 &#123; int a = 10; int a = 20; //这里会出错 &#125; 3.变量没有初始化只，不能直接使用 int a; //仅仅定义了变量，但是没有初始值 System.out.println(a); //这里会出错4.变量可以定义在同一行 如：int a=10, b=20; //a和b都是int类型 到此有关变量的所有使用方式，以及变量需要注意的问题，就学习完了。 我们再总结一下几点 变量是用来记录程序中的数据的，可以把变量理解成内存中的小盒子，盒子里放的东西就是变量记录的数据 变量的定义格式： 数据类型 变量名 = 初始值; 变量记录的数据程序运行过程中是可以发生改变的：变量名 = 值; 4.4 关键字学完变量之后，我们再来认识一下Java的关键字。 什么是关键字？ 关键字是java语言中有特殊含义的单词。比如用int表示整数，用double表示小数，等等！ 关键字有哪些？ 我们学习Java的语法其本质就是学习这些关键字的含义，一共有50多个关键字，我们不是一次性把这些关键字学完，会在后续的课程中每天学一点，慢慢得你就都学会了。 abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return strictfp short static super switch synchronized this throw throws transient try void volatile while 如何识别那些单词是关键字？ 现在我们不用知道这些关键字是什么意思，主要能够根据特点识别那些是关键字就可以了 123关键字的特点： 1.关键字都是小写的 2.关键字在idea中有特殊颜色标记（如果你没有修改关键字的颜色，默认是蓝色的） 下图中红色框住的单词都是关键字；没有框住的单词都不是关键字 4.5 标志符接下来我们学习一下标志符，所谓标志符其实就是我们自己取的名字。像前面我们取的类名，变量名其实都是标志符。 讲标志符的目的，是让大家知道取名字的规则，不能让我们随即便瞎取。有些规则是强制要求的，不遵守就会报错。还有一些规则是我们建议大家遵守的，这样取名字显得我们更加专业^_^。 12345678910111213141516强制要求：必须遵守，不遵守就会报错 1.最好是字母、数字、下划线、$组成 2.不能以数字开头 3.不能是Java的关键字建议遵守：按照下面的方式取名字会显得更加专业 1.所有的名字要见名知意，便于自己和别人阅读 举例： class Student&#123;&#125; //一看这个类就知道表示一个学生 int age =10; //一看这个变量就知道表示年龄 2.类名：首字母大写（大驼峰命名） 举例： class Student&#123;&#125; 3.变量名：第二个单词开始首字母大写（小驼峰命名） 举例： double money = 6.88; double applePrice = 7.5; 到此，恭喜小伙伴们，今天所有的内容就学习完了，加油奥利给！！！","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day03-Java流程控制","slug":"day03-Java流程控制","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day03-Java流程控制/","link":"","permalink":"https://wxzhou.top/2020/05/05/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"各位同学，今天我们学习一个全新的知识——程序流程控制。什么是流程控制呢？说白了就是控制程序的执行顺序。 先给同学们介绍一下，程序有哪些流程控制、以及Java提供了哪些方案来控制程序的执行顺序？ 程序的流程控制一般分为3种：顺序结构、分支结构、循环结构 顺序结构：就是不加任何控制，代码从main方法开始自上而下执行 分支结构：就是根据条件判断是true还是false，有选择性的执行哪些代码。在Java语言中提供了两个格式if 、 switch 循环结构：就是控制某一段代码重复执行。在Java语言中提供了三种格式，for、while、do-while 以上就是我们今天要学习的课程内容 一、分支结构1.1 if分支各位同学，接下来我们学习分支结构的第一种形式——if分支。 if它的作用，是用于对条件进行判断，判断的结果只可能有两个值true或者false，然后根据条件判断的结果来决定执行那段代码。 1. if分支的应用场景有哪些呢？ 比如，在火车站、地铁站等公共场所，会对过往的旅客测体温。如果体温在37度以内，就属于正常的；如果体温在37读以上，测体温的装置就会报警。 再比如，你在使用微信付钱时，微信内部的程序会先判断你的余额是否足够，如果足够就可以支付成功；如果余额不足，就会提示支付失败。 2. if分支的格式 接下来，我们来看一看if分支在Java语言中长什么样子呢？在Java中if分支有三种格式。 接下来我们用一些实际案例给大家演示一下if语句的应用，以及每一种if语句的执行流程。 3. if 第一种形式 if 第一种形式的代码格式，和执行流程如下图所示 123if 第一种形式执行流程如下： 如果 条件表达式 为true，就执行下面的语句体 如果 条件表达式 为false,就不执行 12345// 需求：测量用户体温，发现体温高于37度就报警。double t = 36.9;if(t &gt; 37)&#123; System.out.println(&quot;这个人的温度异常，把他赶紧带走~~&quot;);&#125; 4. if 第二种形式 if 第二种形式的代码格式，和执行流程如下图所示 123if 第二种形式执行流程如下： 如果 条件表达式 为true,就执行下面的语句体1 如果 条件表达式 为false,就执行else下面的语句体2 12345678// 需求2：发红包，你的钱包余额是99元，现在要发出90元// 如果钱够触发发红包的动作，如果钱不够，则提示：余额不足。double money = 19;if(money &gt;= 90)&#123; System.out.println(&quot;发红包成功了~&quot;);&#125;else &#123; System.out.println(&quot;余额不足~~&quot;);&#125; 5. if 第三种形式 if 第三种形式的代码格式，和执行流程如下图所示 123456789101112if 第三种形式执行流程如下： 如果 条件表达式1 为true,就执行下面的代码1; 如果 条件表达式1 为false，就继续判断条件表达式2; 如果 条件表达式2 为true，就执行下面的语句体; 如果 条件表达式2 为false，就继续判断条件语句体3; 如果 条件表达式3 为true,就执行下面的语句体3 如果 条件表达式3 为false,就继续判断后面的表达式; .... 如果前面所有条件表达式判断都为false，就执行最后的else语句中的代码 12345678910111213// 需求3：某个公司有一个绩效系统，根据员工的打分输出对应的绩效级别。[0,60) D [60,80) C [80,90) B [90,100] Aint score = 298;if(score &gt;= 0 &amp;&amp; score &lt; 60) &#123; System.out.println(&quot;您的绩效级别是： D&quot;);&#125;else if(score &gt;= 60 &amp;&amp; score &lt; 80)&#123; System.out.println(&quot;您的绩效级别是： C&quot;);&#125;else if(score &gt;= 80 &amp;&amp; score &lt; 90)&#123; System.out.println(&quot;您的绩效级别是： B&quot;);&#125;else if(score &gt;= 90 &amp;&amp; score &lt;= 100)&#123; System.out.println(&quot;您的绩效级别是： A&quot;);&#125;else &#123; System.out.println(&quot;您录入的分数有毛病~~&quot;);&#125; 6. if 使用的几个常见问题 同学们在第一次写if 代码时，经常一不小心会出现一些问题。下面把同学们可能出现的问题给大家看一看，以后大家要避免出现这些问题。 第1个问题：if的()后面不能写分号; 否则if下面的语句与if无关 第2个问题：if后面的大括号，如果只有一行代码，大括号可以省略 7. if 分支小结 关于if分支结构的几种格式，以及各种格式的执行流程，还有if在什么场景下使用我们就讲完了。下面我们总结一下 if分支有什么作用？举几个应用场景？ 12345- if作用：if分支可以根据条件，选择执行某段程序- if应用场景 比如1：测量用户体温，发现体温高于37度就报警 比如2:发红包，你的钱包余额是99元，现在要发出90元 比如3:根据员工的绩效打分输出对应的绩效级别 if分支的格式有几种，执行流程是什么样的？ 1.2 switch分支学完if 分支之后，接下来我们来学习分支结构的第二种形式——switch分支。 1. switch分支的执行流程 switch 分支的作用，是通过比较值来决定执行哪条分支代码。先看一下switch分支的格式和执行流程 下面通过案例来演示一下 12345678910/*需求：做个电子备忘录，在控制台分别输出周一到周五的工作安排 周一：埋头苦干，解决bug 周二： 请求大牛程序员帮忙 周三：今晚啤酒、龙虾、小烧烤 周四：主动帮助新来的女程序解决bug 周五：今晚吃鸡 周六：与王婆介绍的小芳相亲 周日：郁郁寡欢、准备上班。*/ 1234567891011121314151617181920212223242526String week = &quot;周三&quot;;switch (week)&#123; case &quot;周一&quot;: System.out.println(&quot;埋头苦干，解决bug&quot;); break; case &quot;周二&quot;: System.out.println(&quot;请求大牛程序员帮忙&quot;); break; case &quot;周三&quot;: System.out.println(&quot;今晚啤酒、龙虾、小烧烤&quot;); break; case &quot;周四&quot;: System.out.println(&quot;主动帮助新来的女程序解决bug&quot;); break; case &quot;周五&quot;: System.out.println(&quot;今晚吃鸡&quot;); break; case &quot;周六&quot;: System.out.println(&quot;与王婆介绍的小芳相亲&quot;); break; case &quot;周日&quot;: System.out.println(&quot;郁郁寡欢、准备上班&quot;); break; default: System.out.println(&quot;您输入的星期信息不存在~~~&quot;);&#125; 2. if 、switch如何选择 学习完switch 分支之后，有同学可能会想，已经了有if分支，为什么还有switch分支呢？感觉上面的案例用if分支也能做啊？ 那我们在具体应用场景下如何选择呢？ 如果单从功能上来讲，if 分支 的功能是更加强大的，switch分支能做的事情if 分支都能做。但是具体用哪一种分支形式，也是有一些使用原则的 12- 如果是对一个范围进行判断，建议使用if分支结构- 如果是与一个一个的值比较的时候，建议使用switch分支结构 1.3 switch 注意事项各位同学，接下来我们学习swtich的注意事项。同学们掌握这些注意事项之后，就可以避免入坑了，也可以应对一些面试笔试题。 1234567- 1.表达式类型只能是byte、short、int、char JDK5开始支持枚举，JDK7开始支持String 不支持double、float、double - 2.case给出的值不允许重复，且只能是字面量，不能是变量。 - 3.正常使用switch的时候，不要忘记写break，否则会出现穿透现象。 1. 演示switch语句匹配的数据类型 各位同学，如果下图所示，可以自己分别用变量a、b放在switch语句中匹配试一试，如果遇到不支持的写法，IDEA会报错的。 2. 演示case后面的值，只能是字面量不能是变量 各位同学，也可以自己试试，下图箭头指向的位置只能写字面量，不能写变量 3. 演示case穿透现象 当switch语句中没有遇到break，就会直接穿透到下一个case语句执行，直到遇到break为止。 这种语法设计也是有它的用处的，当多个case语句想要执行同一段代码时，可以利用case穿透现象，提高代码复用性。 比如：我们下面程序中，想要让周二、周三、周四，都请大牛程序员来写代码。 二、循环结构各位同学，接下来我们学习循环结构。循环结构可以控制一段代码重复执行。循环结构有for循环、while循环、do-while循环。 2.1 for循环——格式和流程这里首先来学习for循环，同学们重点掌握for循环的书写格式，并理解for循环的执行流程。 1. for循环的格式和流程 为了让大家更直观的理解for循环的执行流程，我们直接来看具体的案例代码。 比如：我们想要在控制台打印输出3个HelloWorld 1234//需求：打印3行Hello Worldfor(int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;Hello World&quot;);&#125; 如下图所示，是按照下面的① ② ③ ④， ② ③ ④… 的顺序来执行的； 当②条件为true时，再依次执行③④代码，然后回到②继续判断 当②条件为false时，就结束循环 具体执行的每一步可以看下面的图解 通过上面的案例演示，最后我们再总结一下for循环的格式 123456789//for循环格式：for (初始化语句; 循环条件; 迭代语句) &#123; 循环体语句(重复执行的代码);&#125;初始化语句：一般是定义一个变量，并给初始值循环条件：一般是一个关系表达式，结果必须是true或者false迭代语句：用于对条件进行控制，一般是自增或者自减循环语句体：需要重复执行的代码 2. for循环有哪些应用场景 通过上面的学习，我们已经知道了for循环怎么编写，并且也知道了它的执行流程。 那么具体在哪些实际场景下使用呢？其实只要是重复做的事情，都可以用循环语句来做 比如：在京东的网页上展示100台手机信息，我们只需要把展示数据的代码写一份，重复执行就可以了。 再比如：再我们教学管理系统中，有很多班级需要展示在页面上，我们没必要每一个班级都写一份展示数据代码，只需要写一份重复执行就可以了。 2.2 for循环案例1——求和学完for循环的格式和流程之后，我们再通过案例来巩固一下。通过这个案例，主要是让同学们掌握一种使用程序来求和的思想。 1234//1.掌握使用for循环批量产生数据。for (int i = 1; i &lt;= 100; i++) &#123; System.out.println(i);&#125; 12345求和的思路分析： 1)首先需要定义一个求和变量，一般命名为sum 2)再遍历得到所有需要求和的数据(1~100之间的所有整数) 3)让需要求和的数据和sum累加， 结果：所有数据累加完之后最终sum就是所有数据的和 12345678//2.需求：求1~100中所有整数的和int sum = 0;//定义一个循环，先产生1-100，这100个数for (int i = 1; i &lt;= 100; i++) &#123; //每产生一个数据，就把这个数和sum累加 sum += i; //sum = sum + i;&#125;System.out.println(&quot;1-100的数据和：&quot; + sum); 分析上面代码的执行过程： 123456i=1时：sum=0+1; sum=1;i=2时：sum=1+2; sum=3;i=3时：sum=3+3; sum=6;i=4时：sum=6+4; sum=10;...i=100时: sum+=99; sum=5050 2.2 for循环案例2——求奇数和需求：求1~100之间奇数的和 1. 代码写法一 12345求奇数和的思路（只是求和的数据变成了奇数，思路和前面没有变化） 1)首先需要定义一个求和变量，这里命名为sum1 2)再遍历得到所有需要求和的数据(1~100之间的所有奇数) 3)让需要求和的数据和sum1累加， 结果：所有数据累加完之后最终sum1就是所有数据的和 123456789//1)定义一个变量用于求和int sum1 = 0;//2)定义一个循环产生1-100之间的奇数for (int i = 1; i &lt; 100; i+=2) &#123; // i = 1 3 5 7 ... //3)让需要求和的数据和sum1累加， sum1 += i;&#125;System.out.println(&quot;1-100之间的奇数和：&quot; + sum1); 以上代码的执行流程分析 1234567初始化sum1=0;当i=1时：sum1+=1; sum1=1;当i=3时：sum1+=3; sum1=4;当i=5时：sum1+=5; sum1=9;...当i=99时：sum1+=99; sum1=2500 2. 代码写法二 12345求奇数和的思路（只是求和的数据变成了奇数，思路和前面没有变化） 1)首先需要定义一个求和变量，这里命名为sum2 2)再遍历得到所有需要求和的数据(1~100之间的所有整数) 3)在求和之前先对数据判断，如果是奇数，才和sum1累加；否则什么也不干 结果：所有数据累加完之后最终sum1就是所有数据的和 123456789101112//1)首先需要定义一个求和变量，这里命名为sum2int sum2 = 0; //2)再遍历得到所有需要求和的数据(1~100之间的所有整数)for (int i = 1; i &lt;= 100; i++) &#123; //i = 1 2 3 4 5 6 ... 99 100 //3)在求和之前先对数据判断，如果是奇数，才和sum1累加；否则什么也不干 if(i % 2 == 1)&#123; // i = 1 3 5 7 9 ... 99 sum2 += i; &#125;&#125;System.out.println(&quot;1-100之间的奇数和：&quot; + sum2); for循环小结 今天关于for循环，我们学习这几个案例就够了，重点还是掌握for循环的执行流程。在以后，我们还会经常用到for循环，用多了，你就会越来越熟悉了。但是在具体场景下，还是需要具体问题具体分析。 2.3 while循环——格式和流程各位同学，接下来我们学习第二种循环结构——while循环。 我们先来认识一下while循环长什么样子，然后按照格式写一个while循环的基础案例 1234567// 需求：打印5行Hello Worldint i = 0;while (i &lt; 5) &#123; // i = 0 1 2 3 4 System.out.println(&quot;Hello World&quot;); i++;&#125; 代码的执行流程如下图所示：按照① ②③④ ②③④ … 的流程执行 如果②步骤为true，才循环执行③④步骤 如果②步骤为false，则循环结束 for、while如何选择 学到这里，细心的同学可能会发现while循环和for循环的执行流程是一样的。那他们是不是可以通用呢？ 从功能来说：能够用for循环做的，都能用while循环做。 使用规范上来说：知道循环几次，建议使用for；不知道循环几次建议使用while 2.3 while循环案例——折纸案例各位同学，上一节我们已经学习了while循环的基本使用。下面我们通过一个案例再将while循环的使用巩固一下，主要目的还是想让大家知道什么使用while循环来完成需求。 案例需求如下： 1需求：世界最高山峰珠穆朗玛峰高度是：8848.86米=8848860毫米，假如我有一张足够大的它的厚度是0.1毫米。请问：该纸张折叠多少次，可以折成珠穆朗玛峰的高度？ 我们来分析一下该怎么做 123456789101112131415分析：首先由于不知道折叠多少次，我们可以选择用while循环 1)纸张的初始化厚度为0.1毫米，珠峰的高度为8848860毫米 double peakHeight = 8848860; double paperThickness = 0.1; 2)每次折叠纸张的厚度为原来的两倍，这是需要循环执行的 while(纸张厚度&lt;8848860)&#123; 纸张厚度*=2; &#125; 3)需要求折叠的次数，可以用一个变量来记录折叠的次数 int 次数 = 0; while(纸张厚度&lt;8848860)&#123; 纸张厚度*=2; 次数++; //每次折叠次数累加 &#125; 结果：等循环结束之后，打印记录次数的值，就是折叠多少次了。 按照上面分析的思路把代码写出来 123456789101112131415// 1、定义变量记住珠穆朗玛峰的高度和纸张的高度。double peakHeight = 8848860;double paperThickness = 0.1;// 3、定义一个变量count用于记住纸张折叠了多少次int count = 0;// 2、定义while循环控制纸张开始折叠while (paperThickness &lt; peakHeight) &#123; // 把纸张进行折叠，把纸张的厚度变成原来的2倍。 paperThickness = paperThickness * 2; count++;&#125;System.out.println(&quot;需要折叠多少次：&quot; + count);System.out.println(&quot;最终纸张的厚度是：&quot; + paperThickness); 2.4 do-while循环——格式和流程各位同学，接下来我们学习循环结构的第三种格式——do-while循环。 们先来认识一下while循环长什么样子，然后按照格式写一个while循环的基础案例。 如下图所示：do-while循环的执行流程，是按照① ②③④ ②③④… 的顺序执行的。 我们会发现，do-while循环的特点是先执行，再判断的。即使条件不成立，也会先执行一次。 下面我们把三种循环的区别给同学们总结一下 1234567891. for循环 和 while循环（先判断后执行）; do...while （先执行后判断） 2.for循环和while循环的执行流程是一模一样的， 功能上无区别，for能做的while也能做，反之亦然。 如果已知循环次数建议使用for循环，如果不清楚要循环多少次建议使用while循环。 3 for循环中控制循环的变量只在循环中使用 while循环中，控制循环的变量在循环后还可以继续使用 2.6 死循环同学们在写代码时，可能一不小心把代码写成了死循环，所谓死循环就是停不下来的循环。 接下来，带着同学们认识几种死循环的写法。然后再说一下死循环有什么用。 1234567891011121314//for死循环for ( ; ; )&#123; System.out.println(&quot;Hello World1&quot;);&#125;//while死循环while (true) &#123; System.out.println(&quot;Hello World2&quot;);&#125;//do-while死循环do &#123; System.out.println(&quot;Hello World3&quot;);&#125;while (true); 死循环有什么应用场景呢？ 最典型的是可以用死循环来做服务器程序， 比如百度的服务器程序就是一直在执行的，你随时都可以通过浏览器去访问百度。如果哪一天百度的服务器停止了运行，有就意味着所有的人都永不了百度提供的服务了。 对于这样的应用我们目前了解一下就可以了。对于目前来说我们只要知道代码格式该怎么写，能达到什么效果就行。 2.8 循环嵌套各位同学，接下来我们学习一种在实际工作中很常用的循环形式——循环嵌套。 所谓循环嵌套，就是一个循环中又包含另一个循环（就是同学们常说的，套娃^_^），下面我们通过案例代码演示一下。 循环嵌套执行流程：外部循环每循环一次，内部循环会全部执行完一轮。 12345678910111213141516171819202122i=0时; i&lt;3为true; 进入循环 //j的取值从0到5,执行一轮，打印5次&quot;我爱你&quot; for(int j = 1; j &lt;= 5; j++) &#123; System.out.println(&quot;我爱你：&quot; + i); &#125; 内层循环执行完之后，执行外层的i++; i的值1 i=1时：i&lt;3为true; 进入循环 //j的取值从0到5,又执行一轮，打印5次&quot;我爱你&quot; for(int j = 1; j &lt;= 5; j++) &#123; System.out.println(&quot;我爱你：&quot; + i); &#125; 内层循环执行完之后，执行外层的i++; i的值2 i=2时：i&lt;3为true; 进入循环 //j的取值从0到5,再执行一轮，打印5次&quot;我爱你&quot; for(int j = 1; j &lt;= 5; j++) &#123; System.out.println(&quot;我爱你：&quot; + i); &#125; 内层循环执行完之后，执行外层的i++; i的值3 i=3时：i&lt;3为false; 外层循环结束 理解问循环嵌套的执行流程之后，我们再写一个案例来巩固一下 12345需求：在控制台使用 * 打印出4行5列的矩形 **** **** **** **** 12345678910111213141516//1)先写一个循环用来在一行中打印5个&quot;*&quot;for (int j = 1; j &lt;= 5; j++) &#123; System.out.print(&quot;*&quot;); // 不换行&#125;System.out.println(); //换行System.out.println(&quot;-----------------&quot;);//2)再将第一步的代码套一层循环，执行4次，就可以打印4行for (int i = 1; i &lt;= 4; i++) &#123; for (int j = 1; j &lt;= 5; j++) &#123; System.out.print(&quot;*&quot;); // 不换行 &#125; System.out.println(); //换行&#125; 总结一下，对于嵌套循环重点理解这句话：外部循环每循环一次，内部循环会全部执行完一轮。 2.9 跳转语句 break 、continue前面我们学习了循环结构，在中间我们还接触了死循环的一些形式，那么我想要在循环过程中提前跳出循环怎么做呢？ 这里就需要用到跳转语句，需要用到break和continue两个关键字。我们先来认识一下这两个关键字的作用 break作用：跳出并结束当前所在循环的执行 continue作用：结束本次循环，进入下一次循环 案例1：演示break的使用，提前终止循环的执行 12345678910// 1、break:跳出并结束当前所在循环的执行。// 场景：假如你又有老婆了，你犯错了，你老婆罚你说：5句我爱你// 说到第三句的时候心软了，让你别再说了。for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;我爱你：&quot; + i); if(i == 3)&#123; // 说明已经说完了第三句了，心软了。 break; // 跳出并结束当前所在循环的执行。 &#125;&#125; 案例2：演示continue的使用，结束循环中的一次，继续下一次循环 12345678910// 2、continue:跳出当前循环的当次执行，直接进入循环的下一次执行。// 场景: 假如你有老婆，你犯错了，你老婆罚你洗碗5天。// 第三天的时候，你表现很好，第三天不用洗碗，但是不解恨，第四天还是要继续的。for (int i = 1; i &lt;= 5; i++) &#123; if(i == 3) &#123; // 已经到了第三天，第三天不用洗的。 continue; &#125; System.out.println(&quot;洗碗：&quot; + i);&#125; 需要注意的是break和continue不是任何地方都可以使用的 2.10 循环结构总结到这里关于循环结构的所有内容就都已经学习完了，我们再把几种循环结构在什么场景下使用，再总结一下。 12345678910111. 什么是流程控制 答：流程控制是用来控制程序的执行顺序的 2. 分支结构if和switch，如何选择？ 答：if分支：一般用于对一个范围进行判断 switch分支：对一个一个值进行匹配 3. for循环和while循环、do-while如何循环 答：知道循环次数用for、不知道循环次数用while 想要先执行，再判断，用do-while 三、生成随机数各位同学，接下来我们再学习一个新的知识——生成随机数。 生成随机数其实在很多场景下都很实用，比如，在课堂上可以写一个随机点名器点同学起来回答问题；再比如公司年会可以随机抽奖等。 3.1 如何产生一个随机数生成随机数的功能，其实 Java已经给我们提供了，在JDK中提供了一个类叫做Random，我们只需要调用Random这个类提供的功能就可以了。 1234567891011121314// 目标：掌握使用Random生成随机数的步骤。// 1、导包。import java.util.Random; (idea会自动完成)import java.util.Random;public class RandomDemo1 &#123; public static void main(String[] args) &#123; // 2、创建一个Random对象，用于生成随机数。 Random r = new Random(); // 3、调用Random提供的功能：nextInt得到随机数。 for (int i = 1; i &lt;= 20; i++) &#123; int data = r.nextInt(10); // 0 - 9 System.out.println(data); &#125; &#125;&#125; 3.2 猜数字小游戏各位同学，接下来我们通过一个案例把前面的流程控制、跳转语句、随机数综合运用一下； 如果能把这个案例写出来，说明你对今天的知识点掌握得挺好了。 1234567891011121314需求： 随机生成一个1-100之间的数据，提示用户猜测，猜大提示过大，猜小提示过小，直到猜中 结束游戏分析： 1.先随机生成一个1-100之间的数据。 谁可以帮你生成随机数啊？ 是不是要用到Random？ 2.定义一个死循环让用户可以一直猜测。 用户猜的数据从哪里来啊？ 是不是要用到Scanner? 3.在死循环里，每次让用户录入的数据和随机数进行比较 如果比随机数大：提示猜大了 如果比随机数小：提示猜小了 如果和随机数相同：提示恭喜你猜中了 12345678910111213141516171819202122232425262728import java.util.Random;import java.util.Scanner;public class RandomTest2 &#123; public static void main(String[] args) &#123; // 1、随机产生一个1-100之间的数据，做为中奖号码。 Random r = new Random(); int luckNumber = r.nextInt(100) + 1; // 2、定义一个死循环，让用户不断的猜测数据 Scanner sc = new Scanner(System.in); while (true) &#123; // 提示用户猜测 System.out.println(&quot;请您输入您猜测的数据：&quot;); int guessNumber = sc.nextInt(); // 3、判断用户猜测的数字与幸运号码的大小情况 if(guessNumber &gt; luckNumber)&#123; System.out.println(&quot;您猜测的数字过大~~&quot;); &#125;else if(guessNumber &lt; luckNumber)&#123; System.out.println(&quot;您猜测的数字过小~~&quot;); &#125;else &#123; System.out.println(&quot;恭喜您，猜测成功了，可以买单了~~&quot;); break; // 结束死循环 &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day02-类型转换、运算符","slug":"day02-类型转换、运算符","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day02-类型转换、运算符/","link":"","permalink":"https://wxzhou.top/2020/05/05/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"一、数据的表示详解昨天我们学习了变量，我们知道变量可以用来记录数据的。那么数据在计算机底层是以什么形式表示的呢？下面我们就学习一下数据在计算机中的底层原理。 1.1 整数在计算机中的存储原理其实任何数据在计算机中都是以二进制表示的。那这里肯定有人问，什么是二进制啊？所谓二进制其实就是一种数据的表示形式，它的特点是逢2进1。 数据的表示形式除了二进制（逢2进1），八进制（逢8进1）、还有十进制（逢10进1）、十六进制（逢10进1）等。 对于二进制绝大多数同学，应该是非常陌生的。 没关系！来，大家跟着我的思路，你就知道二进制是怎么表示数据的了。 1234567891011121314151617181920212223241.二进制中只有0和1两个数 首先十进制的0和二进制的0是一样的，十进制的1和二进制的1也是 一样的。但是十进制中 有2，但是二进制中就没有2了2.那么二进制是如何表示十进制的2呢？ 1+ 1 —————————— 10 这里两个1相加，结果为2，由于二进制满2进1，所以最终结果10 3.那么二进制是如何表示十进制的3呢？ 前面我们已经知道二进制10表示十进制的2，那么二进制10+1就表示十进制的3啊！ 10+ 1————————— 11 十进制的3对应的二进制是114.那么二进制是如何表示十进制4的呢？ 前面我们已经知道二进制11表示十进制的4，那么11+1就表示十进制的5啊 11+ 1————————— 100 十进制的5对应的二进制是100你找到规律了吗？ 你能不能依次写出5的二进制、6的二进制？ 前面每算一个二进制数据都是采用+1的方式，逢2进1，一个一个算出来的。有没有更快的算出十进制对应二进制的方法呢？ 这里学习一种方式：叫做除2取余法。 除2取余法 1234567891011121314151617181920211.怎么做呢？ 答：让十进制数据连续除以2，直到商为0，余数反转2.举例1：把十进制6转换为二进制 商 余数 6/2 3 0 3/2 1 1 1/2 0 1 然后把余数反转：6对应的二进制是110 3.举例2： 把十进制13转换为二进制 商 余数 13/2 6 1 6/2 3 0 3/2 1 1 1/2 0 1 然后把余数反转：10对应的二进制是1101 4.练习1：你能把十进制7转换为二进制吗？ 自己试试吧！ 关于变量记录的数据在计算机中如何表示我们就先学习到这里。 计算机的最小存储单位 前面我们已经知道计算机表示数据是用二进制来的， 这里我又要抛出一个问题来了！ 我现在想要在计算机中存储一个整数6，转换为二进制是110，那么计算机中只是存110吗三位数字吗？ 其实不是的，计算机中最小的存储单位是字节（Byte），一个字节占8位（bit），也就是说即使这个数据不足8位也需要用8位来存储。 我们随便找到一个文件，看文件的属性，可以看到文件的大小都是以字节为单位的。 1.2 字符在计算机中的存储原理通过上一节的学习，我们知道了整数是如何在计算机中如何存储的？那么字符在计算机中是如何存储的呢？ 其实字符并不是直接存储的，而是把每一个字符编为一个整数，存储的是字符对应整数的二进制形式。美国人搞了一套字符和整数的对应关系表，叫做ASCII编码表。 1234ASCII编码表中字符编码的规律： 1.字符0对应48，后面的1,2,3,4...9 对应的十进制整数依次往后顺延 2.字符a对应97，后面的b,c,d,e...z 对应的十进制整数依次往后顺延 3.字符A对应65，后面的B,C,D,E...Z 对应的十进制整数依次往后顺延 需要注意的是，在ASCII编码表中是不包含汉字的。汉字在其他编码表中，后面我们会单独介绍。关于字符在计算机中的存储学到这就可以了。 1.3 图片视频声音的存储原理 图片的存储 通过上面的学习我们已经知道整数和字符是如何存储的，最终都是要转换为二进制数据的，对吧！ 那图片、声音、视频又是如何存储的呢？我们也来了解一下 我们从图片开始，如果你把一张图片不断的放大，你会看到有马赛克的效果。你会发现图片中的每一个细节是由一个一个的小方格组成的，每一个小方格中其实就是一种颜色。任何一种颜色可以使用三原色来表示，简称RGB，其中R（红色），G（绿色），B（蓝色），而RGB中每一种颜色又用一个字节的整数来表示，最小值是0最大值是255 123456RGB（0,0,0）表示黑色RGB（255,255,255）表示白色RGB（255,0,0） 表示红色RGB（255,255,0） 表示红色和绿色混合为黄色RGB（255,0,255） 表示红色和蓝色混合为紫色... 你在画图板的颜色编辑器中可以通过指定RGB的值，来调整得到任意的颜色。一张图片实际上就是有很多个小方块的颜色组成的，而每一种颜色又是由RGB三原色的整数表示的，整数最终会转换为二进制进行存储。 视频的存储 实际上视频和图片是一样的，把多张图片连续播放，在一秒钟内连续播放24张以上，由于人眼存在视觉暂留现象，人眼感受不到画面切换的时间间隔，就认为是连续的视频了。 声音的存储 了解过物理的同学肯定知道，声音是以波的形式传播的。我们可以把声波在表示在一个坐标系上，然后在坐标系上取一些点，把这些点的坐标值以二进制的形式存储到计算机中，这就是声音的存储原理。 1.4 数据的其他表示形式 二进制到十进制的转换 前面我们学习了十进制可以转二进制，采用的是除2取余法，那么我们反过来能不能把二进制转换为十进制呢？ 这里给大家介绍一种计算方式叫做：8421码 为了便于理解，我们先在看一下十进制怎么转十进制，主要是为了让大家看到演化过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471.十进制转十进制 比如我们把12345进行分解： 12345 = 10000 + 2000 + 300 + 40 + 5 = 1*10^4 + 2*10^3 + 3*10^2 + 5*10^0 我们发现： 在十进制中如果把十进制的每一位从右往左从0开始编一个号，假设这一位数字是a, 那么这一位数表示的值就是：a*10^n； ----------------------------------------------------------------------二2.二进制转十进制： 类比十进制： 如果把二进制的每一位从从右往左0开始编一个号用n表示，假设二进制的每一位是a， 那么这一位表示的十进制值是：a*2^n 1)假设二进制的每一位都是1： 128 64 32 16 8 4 2 1 每一位表示的十进制：a*2^n 7 6 5 4 3 2 1 0 编号：n 1 1 1 1 1 1 1 1 二进制的每一位：a 二进制 十进制 11111111 = 1*2^7 + 1*2^6 + 1*2^5 + ... + 1*2^0 = 128 + 64 + 32 + ... + 1 = 255 2)假设二进制的为0010001 128 64 32 16 8 4 2 1 每一位表示的十进制：a*2^n 7 6 5 4 3 2 1 0 编号：n 0 0 1 0 0 0 0 1 二进制的每一位：a 二进制 十进制 00001101 = 0*2^7 + 0*2^6 + 1*2^5 + ... + 1*2^0 = 0 + 0 + 32 + ... + 1 = 33 3)8421码：从右往左给二进制的每一位数依次按照1 2 4 8...标记 128 64 32 16 8 4 2 1 0 0 1 0 0 0 0 1 ----------------------------- 只需要将1位上的数字加起来，就是二进制对应的十进制 二进制 十进制 00001101 = 8+4+1 = 13 0000111 = 4+2+1 = 7 0001111 = 8+4+2+1 = 25 二进制转八进制 前面我们说计算机中数据都是采用二进制来存储的，但是二进制阅读和编写起来都不太方便。为了便于阅读和书写，又推出了八进制、十六进制。 1234567891.运算规则： 把二进制的每三位一组合，然后对每三位用8421码进行计算，最后拼接到一起 原因：因为111，的值是7, 再大满7就需要往进位了。 2.把二进制11001110转换为八进制数据 01 100 001 二进制每三位一组合 1 4 1 每一组进行8421码运算 ---------- 八进制：141 二进制转十六进制 1234567891011121314151.运算规则： 把二进制的每四位一组合，然后对每四位用8421码进行计算，最后拼接到一起 原因：因为1111，的值是15, 再大1满16了就需要往进位了。 2.举例：把二进制11001110转换为十六进制数据 0110 0001 二进制每四位一组合 6 1 每一组进行8421码运算 ---------- 十六进制：61 3.练习：把111100转换为十六进制 0011 1100 3 12 由于十六进制中有a,b,c,d,e,f分别表示10,11,12,13,14,15 ----------- 十六进制：3c 1.5 不同进制在Java程序中的书写格式1234System.out.pirntln(&#x27;a&#x27;+1); //98System.out.pirntln(0b01100001); //97System.out.pirntln(0141); //97System.out.pirntln(0x61); //97 二、数据类型详解在前面的课程中，我们学过了变量的定义，在定义变量时我们是要声明数据类型的，这里的数据类型是用来规定变量存储什么类型的数据。 比如int a = 10; 这里的int就是限制变量只能存储整数； 除了int这种数据类型Java还提供了很多其他的数据类型。Java的数据类型整体上来说分为两大类： 基本数据类型、引用数据类型。 我们今天主要学习基本数据类型，基本数据类型一共有4类8种，每一种数据类型占用的内存空间不一样，能够表示的数据范围也不一样。如下图所示 需要我们注意的是，随便写一个整数或者小数的字面量，它也是有默认数据类型的 12- 比如23，它默认就为int类型；如果加上后缀L，则为long类型；- 比如23.8，它默认为double类型；如果加上后缀F，则为float类型; 下面定义各种类型的变量，将这8种基本数据类型都用一下。 12345678910111213141516171819202122232425262728293031323334353637public class TypeDemo1 &#123; public static void main(String[] args) &#123; // 目标：掌握8种基本数据类型，用来定义变量。 // 1、整型 byte number = 98; System.out.println(number); short number2 = 9000; int number3 = 12323232; // 默认 // 注意：随便写一个整型字面量，默认是int类型的，73642422442424虽然没有超过long的范围，但是它超过了本身int的范围了。 // 如果希望随便写一个整型字面量是long类型的，需要在其后面加上L/l long number4 = 73642422442424L; // 2、浮点型 //注意: //随便写一个小数字面量，默认当成double类型对待的， //如果希望这个小数是float类型的，需要在后面加上：F/f float score1 = 99.5F; double score2 = 99.8; // 默认定义方案。 // 3、字符型 char ch1 = &#x27;a&#x27;; char ch2 = &#x27;中&#x27;; char ch3 = &#x27;国&#x27;; // 4、布尔型 boolean b1 = true; boolean b2 = false; // 引用数据类型：String. // String代表的是字符串类型，定义的变量可以用来记住字符串。 String name = &quot;黑马&quot;; System.out.println(name); &#125;&#125; 三、数据类型转换3.1 自动类型转换各位同学，接下来我们来学习类型转换的知识。为什么要学习类型转换呢？因为在我们实际开发中可能存在将某种类型变量的值，赋值给另一个类型的变量；也可能存在多种数据类型的数据一起运算的情况。 在以上情况中，其实都会涉及到类型转换。类型转换的形式总体分为2种，一种是自动类型转换，一种是强制类型转换。 这里先学习自动类型转换 什么是自动类型转换呢？ 123答：自动类型转换指的是，数据范围小的变量可以直接赋值给数据范围大的变量 byte a = 12; int b = a; //这里就发生了自动类型转换(把byte类型转换int类型) 自动类型转换的原理是怎样的？ 1答：自动类型转换其本质就是在较小数据类型数据前面，补了若干个字节 除了byte和int之间的转换之外，其他类型也可以转换，转换顺序如下图所示 下面我们通过代码演示一下，自动类型转换的各种形式。 1234567891011121314151617public class TypeConversionDemo1 &#123; public static void main(String[] args) &#123; // 目标：理解自动类型转换机制。 byte a = 12; int b = a; // 发生了自动类型转换了 System.out.println(a); System.out.println(b); int c = 100; // 4 double d = c;// 8 发生了自动类型转换了 System.out.println(d); char ch = &#x27;a&#x27;; // &#x27;a&#x27; 97 =&gt; 00000000 01100001 int i = ch; // 发生了自动类型转换了 =&gt; 00000000 00000000 00000000 01100001 System.out.println(i); &#125;&#125; 表达式的自动类型转换 自动类型转换还有另外一种形式，就是表达式的自动类型转换。所谓表达式指的是几个变量或者几个数据一起参与运算的式子。 如果同一个表达式中，出现不同类型的变量或者数据一起运算，这种情况下运算结果是一个什么数据类型呢？需要遵守下面的两条运算规则： 121.多种数据类型参与运算，其结果以大的数据类型为准2.byte,short,char 三种类型数据在和其他类型数据运算时，都会转换为int类型再运算 接下来我们来看代码演示，自己试一试 123456789101112131415161718192021222324public class TypeConversionDemo2 &#123; public static void main(String[] args) &#123; // 目标：掌握表达式的自动类型转换机制。 byte a = 10; int b = 20; long c = 30; long rs = a + b + c; System.out.println(rs); double rs2 = a + b + 1.0; System.out.println(rs2); byte i = 10; short j = 30; int rs3 = i + j; System.out.println(rs3); // 面试笔试题： 即使两个byte运算，结果也会提升为int byte b1 = 110; byte b2 = 80; int b3 = b1 + b2; System.out.println(b3); &#125;&#125; 3.2 强制类型转换前面我们学习了自动类型转换，我们知道可以将数据类型小的数据可以直接赋值给数据范围大的变量。 那反过来，能不能将数据范围大的数据直接赋值给数据范围小的变量呢？ 答案是会报错。 因为数据范围大的数据，赋值给数据范围小的变量，它有可能装不下；就像把一个大桶的水倒入一个小桶中，有溢出的风险。 什么是强制类型转换 但是你强行将范围大的数据，赋值给范围小的变量也是可以的，这里就需要用到强制类型转换。下面是强制类型转换的格式 1目标数据类型 变量名 = (目标数据类型)被转换的数据; 下面是强制类型转换的代码演示 1234567891011121314151617public class TypeConversionDemo3 &#123; public static void main(String[] args) &#123; // 目标：掌握强制类型转换。 int a = 20; byte b = (byte) a; // ALT + ENTER 强制类型转换。 System.out.println(a); System.out.println(b); int i = 1500; byte j = (byte) i; System.out.println(j); double d = 99.5; int m = (int) d; // 强制类型转换 System.out.println(m); // 丢掉小数部分，保留整数部分 &#125;&#125; 强制类型转换的原理 强制类型转换的原理，其实就是强行把前面几个字节砍掉，但是有数据丢失的风险。 到这有关数据类型和数据类型转换的内容，我们就学习完了。大家能够知道什么时候会发生自动类型转换，以及如何进行强制类型转换就可以了。 四、运算符接下来，给同学们讲解一个在开发中用得很多的一块内容，叫做运算符。 大家知道计算机是用来处理数据的，处理数据就少不了对数据的计算，想要对数据进行计算就必须用到运算符。 运算符就是参与运算的符号。Java提供的运算符有很多种，可以分为算术下面几种 基本算术运算符 自增自减运算符 赋值运算符 关系运算符 逻辑运算符 三元运算符 3.1 算术运算符先从最基本的算术运算符开始学习，算术运算符有 + - * / % ，其中*表示乘法，/表示除法，%表示取余数 需要我们注意以下几点 12/: 两个整数相除，结果也是一个整数%: 表示两个数相除，取余数 需要我们注意的是：+符号除了用于加法运算，还可以作为连接符。**+符号与字符串运算的时候是用作连接符的，其结果依然是一个字符串**。 下面通过代码演示一下各种算术运算符的运算效果 12345678910111213141516171819202122232425262728public class OperatorDemo1 &#123; public static void main(String[] args) &#123; // 目标：掌握基本的算术运算符的使用。 int a = 10; int b = 2; System.out.println(a + b); System.out.println(a - b); System.out.println(a * b); // 20 System.out.println(a / b); // 5 System.out.println(5 / 2); // 2.5 ==&gt; 2 System.out.println(5.0 / 2); // 2.5 int i = 5; int j = 2; System.out.println(1.0 * i / j); // 2.5 System.out.println(a % b); // 0 System.out.println(3 % 2); // 1 System.out.println(&quot;---------------------------------------&quot;); // 目标2：掌握使用+符号做连接符的情况。 int a2 = 5; System.out.println(&quot;abc&quot; + a2); // &quot;abc5&quot; System.out.println(a2 + 5); // 10 System.out.println(&quot;itheima&quot; + a2 + &#x27;a&#x27;); // &quot;itheima5a&quot; System.out.println(a2 + &#x27;a&#x27; + &quot;itheima&quot;); // 102itheima &#125;&#125; 3. 2 自增自减运算符接下来，学习一种比较常用的运算符：++和-- ++读作自增，--读作自减； 运算规则如下 需要我们注意的是，自增自减只能对变量进行操作，不能操作字面量。具体使用时也分为两种情况，如下: 12345678910111213141.单独使用：++或者--放在变量前面没有区别 int a =10; a++; //11 --a; //10 System.out.println(a); //102.混合使用：++或者--放在变量或者前面运算规则稍有不通过 //++在后：先做其他事情，再做自增和自减 int a = 10; int b = a++; //等价于 int b = a; a++; //++在前：先自增或者自减，再做其他运输 int x = 10; int y = --x; //等价于x--; int y = x; 下面通过代码演示一下++和--的用法 12345678910111213141516171819202122232425262728public class OperatorDemo2 &#123; public static void main(String[] args) &#123; // 目标：掌握自增自减运算符的使用。 int a = 10; // a++; // a = a + 1 ++a; System.out.println(a); // a--; // a = a - 1 --a; System.out.println(a); // 自增自减只能操作变量不能操作字面量的，会报错！ //System.out.println(2++); System.out.println(&quot;--------------------------------------&quot;); int i = 10; int rs = ++i; // 先加后用 System.out.println(rs); System.out.println(i); int j = 10; int rs2 = j++; // 先用后加 System.out.println(rs2); System.out.println(j); &#125;&#125; 3.3 赋值运算符接下来，我们学习赋值运算符。基本的赋值运算符其实就是=号，意思就是把右边的数据赋值给左边的变量。 1int a = 10; //将数据10赋值给左边的变量a 除了基本的赋值运算符，我们这里主要学习一下扩展的赋值运算符。有+= -= *= /= %= 我们以+=为例来看一下它的运算规则，其他的运算符运算同理分析即可 12345int a = 10;//+=解析：在a原来记录值10的基础上累加5，将结果重新赋值给a; a+=5; //最终打印a的值为15System.out.println(a); 下面通过一个首发红包的例子给大家演示一下 123456789101112131415161718192021222324public class OperatorDemo3 &#123; public static void main(String[] args) &#123; // 目标：掌握扩展赋值运算符的使用。 // += // 需求：收红包 double a = 9.5; double b = 520; a += b; // a = (double)(a + b); System.out.println(a); // -= 需求：发红包 double i = 600; double j = 520; i -= j; // i = (double)(i - j); System.out.println(i); int m = 10; int n = 5; // m *= n; // 等价形式： m = (int)(m * n) // m /= n; // 等价形式： m = (int)(m / n) m %= n; // 等价形式： m = (int)(m % n) System.out.println(m); &#125;&#125; 学完扩展赋值运算符的基本使用之后，接下来我们看一个面试题 12345678910问题1：下面的代码否有问题？ byte x = 10; byte y = 30; x = x + y; //这句代码有问题，因为两个byte类型数据相加，会提升为int类型; 问题2：下面的代码是否有问题？ byte x = 10; byte y = 30; x+=3; //这句代码没有问题，因为这里有隐含的强制类型转换 //x+=3; 等价于 byte x = (byte)(x+y); 到这里赋值运算符就学习完了，稍微总结一下 123451.基本赋值运算符： =符号含义： 把右边的值赋值给左边的变量 2.扩展赋值运算符： += -= *= /= %=符号含义：将右边的数据和左边的变量相加、相减、相乘、相除、取余数后，将结果重新赋值给左边的变量。 3.4 关系运算符接下来我们学习一个，在实际代码中用得很多，但是又非常简单的运算符，叫关系运算符。关系运算符（也叫比较运算符）。 下图是每一种关系运算符的符号及作用，每一个关系运算符的结果都是false 下面通过代码来家演示一下，各种关系运算符的效果 12345678910111213141516171819202122232425public class OperatorDemo4 &#123; public static void main(String[] args) &#123; // 目标：掌握关系运算符的基本使用。 int a = 10; int b = 5; boolean rs = a &gt; b; System.out.println(rs); System.out.println(a &gt;= b); // 要么a大于b,或者a等于b System.out.println(2 &gt;= 2); // true System.out.println(a &lt; b); System.out.println(a &lt;= b); // false System.out.println(2 &lt;= 2); // true System.out.println(a == b); // false System.out.println(5 == 5); // true // 注意了：判断是否相等一定是用 == ，=是用来赋值的。 // System.out.println(a = b); System.out.println(a != b); // true System.out.println(10 != 10); // false System.out.println(false ^ true ^ false); &#125;&#125; 现在我们只需要知道每一种关系运算符的运算效果就行了，关于关系运算符的实际运用需要在后面学习了流程控制语句才能实际用到。 关系运算符在程序中常用于条件判断，根据条件判断的结果是true还是false，来决定后续该执行哪些操作。 3.5 逻辑运算符学习完关系运算符之后，接下来我们学习一下逻辑运算符。我们来看一下逻辑运算符有哪些。 逻辑运算符是用来将多个条件放在一起运算，最终结果是true或者false 下面我们通过几个案例来演示一下逻辑运算符的使用 12//需求1：要求手机必须满足尺寸大于等于6.95，且内存必须大于等于8.//需求2：要求手机要么满足尺寸大于等于6.95，要么内存必须大于等于8. 1234567891011121314151617181920212223242526272829303132333435363738394041public class OperatorDemo5 &#123; public static void main(String[] args) &#123; // 目标：掌握逻辑运算符的使用。 // 需求：要求手机必须满足尺寸大于等于6.95，且内存必须大于等于8. double size = 6.8; int storage = 16; // 1、&amp; 前后的条件的结果必须都是true ,结果才是true. boolean rs = size &gt;= 6.95 &amp; storage &gt;= 8; System.out.println(rs); // 需求2：要求手机要么满足尺寸大于等于6.95，要么内存必须大于等于8. // 2、| 只要多个条件中有一个是true,结果就是true. boolean rs2 = size &gt;= 6.95 | storage &gt;= 8; System.out.println(rs2); // 3、!取反的意思 System.out.println(!true); // false System.out.println(!false); // true System.out.println(!(2 &gt; 1)); // false // 4、^ 前后条件的结果相同时返回false，不同时返回true. System.out.println(true ^ true); // false System.out.println(false ^ false); // false System.out.println(true ^ false); // true System.out.println(false ^ true); // true // 5、&amp;&amp; 左边为false，右边不执行。 int i = 10; int j = 20; // System.out.println(i &gt; 100 &amp;&amp; ++j &gt; 99); System.out.println(i &gt; 100 &amp; ++j &gt; 99); System.out.println(j); // 6、|| 左边是true ，右边就不执行。 int m = 10; int n = 30; // System.out.println(m &gt; 3 || ++n &gt; 40); System.out.println(m &gt; 3 | ++n &gt; 40); System.out.println(n); &#125;&#125; 到这里关于逻辑运算符的规则记学习完了，给你一个运算表达式你能分析出结果就行。至于逻辑运算符的实际运用，需要在学习了流程控制语句之后，才能实际用到。 逻辑运算符在程序中常用于组合几个条件判断，根据条件判断的结果是true还是false，来决定后续该执行哪些操作。 3.6 三元运算符接下来，我们学习今天最后一种运算符，叫做三元运算符。 先认识一下三元运算符的格式： 1关系表达式? 值1 : 值2; 三元运算的执行流程：首先计算关系表达式的值，如果关系表达式的值为true，则返回值1；如果关系表达式的值为false, 则返回值2； 如下图所示：判断学生的成绩是否&gt;&#x3D;60，如果为true，就考试通过；如果为false，就成绩不合格。 接下来通过代码来演示一下，目的是让大家掌握三元运算符的格式和执行流程。 1234567891011121314151617181920212223242526public class OperatorDemo6 &#123; public static void main(String[] args) &#123; // 目标：掌握三元运算符的基本使用。 double score = 58.5; String rs = score &gt;= 60 ? &quot;成绩及格&quot; : &quot;成绩不及格&quot;; System.out.println(rs); // 需求2：找出2个整数中的较大值，并输出。 int a = 99; int b = 69; int max = a &gt; b ? a : b; System.out.println(max); // 需求3：找3个整数中的较大值。 int i = 10; int j = 45; int k = 34; // 找出2个整数中的较大值。 int temp = i &gt; j ? i : j; // 找出temp与k中的较大值。 int max2 = temp &gt; k ? temp : k; System.out.println(max2); &#125;&#125; 3.7 运算优先级最后我们在给大家介绍一下运算符的优先级，如果你想要知道各个运算符的优先级，哪些先算哪些后算，可以参考下面这张图 从图中我们发现，&amp;&amp;运算比||运算的优先级高，所以&amp;&amp;和||同时存在时，是先算&amp;&amp;再算||； 比如下面的代码 12//这里&amp;&amp;先算 相当于 true || false 结果为trueSystem.out.println(10 &gt; 3 || 10 &gt; 3 &amp;&amp; 10 &lt; 3); // true 最后给大家说一下，在实际开发中，其实我们很少考虑运算优先级， 因为如果你想让某些数据先运算，其实加()就可以了，这样阅读性更高。 12//有括号先算 相当于 true &amp;&amp; false 结果为falseSystem.out.println((10 &gt; 3 || 10 &gt; 3) &amp;&amp; 10 &lt; 3); //false 五、案例技术：获取用户键盘输入的数据最后给大家讲一个案例技术，这个技术现在其实有一些超前，因为需要用到后面学习的知识。但是在这里讲可以让我们的学习体验度更好一点，前面案例中参与运算的数据都是在程序中写死的，下面我们想让自己键盘录入数据，然后参与程序的运行。 键盘录入这个事情，其实并不是我们自己做的，而是Java本身就提供了这样的功能，我们按照它的要求，去调用就行。 我们在安装JDK的时候，其实JDK中就已经包含了一些Java写好的代码，我们把Java写好的代码直接拿过来用就行。 1比如：Scanner就是Java提供给我们用于键盘录入数据的类，为了录入不同类型的数据，还提供了不同的功能，每一个功能会有不同的名称，我们只需要调用Scanner提供的功能就可以完成键盘录入数据。 大家只需要按照下面的步骤编写代码，就可以键盘录入数据了 1234567891011121314151617【第1步】：在class类上导包：一般不需要我们自己做，idea工具会自动帮助我们 导包的。 import java.util.Scanner; 【第2步】：得到一个用于键盘扫描器对象（照抄代码就行，固定格式） //Scanner是键盘扫描器对象(你就把它理解成一个东西)，这个东西有录入的功能 //sc是给这个东西取的名字 Scanner sc = new Scanner(System.in);【第3步】：开始调用sc的功能，来接收用户键盘输入的数据。 //sc这个东西有键盘录入整数的功能，这个功能的名字叫nextInt() //.表示表示调用的意思 int age = sc.nextInt(); System.out.println(&quot;我的年龄是:&quot;+age); //sc这个东西还有键盘录入字符串的功能，这个功能的名字叫next String name = sc.next(); System.out.println(&quot;我的姓名是:&quot;+name); 下面是完整代码演示 12345678910111213141516public class ScannerDemo1 &#123; public static void main(String[] args) &#123; // 1、导包:一般不需要我们自己做，idea工具会自动帮助我们 导包的。 // 2、抄写代码：得到一个键盘扫描器对象（东西） Scanner sc = new Scanner(System.in); // 3、开始 调用sc的功能，来接收用户键盘输入的数据。 System.out.println(&quot;请您输入您的年龄：&quot;); int age = sc.nextInt(); // 执行到这儿，会开始等待用户输入一个整数，直到用户按了回车键，才会拿到数据。 System.out.println(&quot;您的年龄是：&quot; + age); System.out.println(&quot;请您输入您的名字：&quot;); String name = sc.next(); // 执行到这儿，会开始等待用户输入一个字符串，直到用户按了回车键，才会拿到数据。 System.out.println(name + &quot;欢迎您进入系统~~&quot;); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day04-Java数组","slug":"day04-Java数组","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day04-Java数组/","link":"","permalink":"https://wxzhou.top/2020/05/05/day04-Java%E6%95%B0%E7%BB%84/","excerpt":"","text":"一、认识数组先来认识一下什么数组 1. 什么数组数组就是一个容器，用来存一批同种类型的数据的。 比如：想要存储 20,10,80,60,90 这些数据。 我们可以把代码写成这样 1int[] array = &#123;20,10,80,60,90&#125;; 比如：想要存储 “牛二“,“西门“,“全蛋“ 这些数据。我们可以把代码写成这样 1String[] names = &#123;&quot;牛二&quot;, &quot;西门&quot;, &quot;全蛋&quot;&#125;; 2. 数组的应用场景有变量，为什么还要有数组呢？ 比如，我们要做一个点名器 如果用变量来做的话，代码是这样子的 如果用数组来做的话，代码是这样子的 一对比我们发现数组的写法比变量的写法更加简洁，所以我们可以得出一个结论 结论：遇到批量数据的存储和操作时，数组比变量更适合 二、数组的定义和访问各位同学，我们已经知道数组是用来干什么的。那么如何使用Java语言写一个数组呢？这里就需要学习一下数组的初始化格式。 数组有两种初始化的方式，一种是静态初始化、一种是动态初始化。我们先用静态初始化来学习数组的操作。 2.1 数组的静态初始化所谓静态初始化指的是：在定义数组时直接给数组中的数据赋值。 1. 静态初始化标准格式： 1数据类型[] 变量名 = new 数据类型[]&#123;元素1,元素2,元素3&#125;; 按照格式定义int类型、double类型数组 1234//定义数组，用来存储多个年龄int[] ages = new int[]&#123;12, 24, 36&#125;//定义数组，用来存储多个成绩double[] scores = new double[]&#123;89.9, 99.5, 59.5, 88.0&#125;; 2. 静态初始化简化格式 Java语言的设计者为了简化定义数组的写法，还为静态初始化提供了一种简化写法 1数据类型[] 变量名 = &#123;元素1,元素2,元素3&#125;; 使用简化格式定义int类型、double类型数组 1234//定义数组，用来存储多个年龄int[] ages = &#123;12, 24, 36&#125;//定义数组，用来存储多个成绩double[] scores = &#123;89.9, 99.5, 59.5, 88.0&#125;; 3. 注意哟！！ 定义数组时， 数据类型[] 数组名 也可写成 数据类型 数组名[] 123//以下两种写法是等价的。但是建议大家用第一种，因为这种写法更加普遍int[] ages = &#123;12, 24, 36&#125;;int ages[] = &#123;12, 24, 36&#125; 4. 数组在计算机中的基本原理 我们知道数组是怎么定义的之后，那么接下来看一下数组在计算机中的基本原理。 我们以int[] ages = &#123;12,24,36&#125;;这句话为例，看一下这句话到底在计算机中做了那些事情。 首先，左边int[] ages 表示定义了一个数组类型的变量，变量名叫ages 其次，右边&#123;12,24,36&#125;表示创建一个数组对象，你完全可以把它理解成一个能装数据的东西。这个对象在内存中会有一个地址值[I@4c873330，每次创建一个数组对象都会有不用的地址值。 然后，把右边的地址值[I@4c873330赋值给左边的ages变量 所以，ages变量就可以通过地址值，找到数组这个东西。 2.2 数组的元素访问各位同学，通过刚才的学习，我们知道数组是用来存储数据的。那么数组中存储的数据又如何访问呢？这里所说的访问，意思就是获取中数组中数据的值、或者给数组中的数据赋值。 这里先给大家统一几个概念，数组中存储的数据我们叫做元素；而且数组中的每一个元素都有一个编号与之对应，我们把这个编号叫做索引，这个索引是从0依次递增的整数。如下图所示 要想访问数组中的元素，格式如下 12//数组名可以找到数组对象的地址，再通过索引就可以定位到具体的元素了数组名[索引] 接下来用代码来演示一下 123456789101112131415//索引： 0 1 2int[] arr = &#123;12, 24, 36&#125;;// 1、访问数组的全部数据System.out.println(arr[0]); //12System.out.println(arr[1]); //24System.out.println(arr[2]); //36//下面代码没有3索引，会出现ArrayIndexOutOfBoundsException 索引越界异常//System.out.println(arr[3]); // 2、修改数组中的数据arr[0] = 66;arr[2] = 100;System.out.println(arr[0]); //66System.out.println(arr[1]); 0System.out.println(arr[2]); //100 除了访问数组中的元素，我们可以获取数组中元素的个数，后面我们统称为数组的长度。 12345678// 3、访问数组的元素个数：数组名.lengthSystem.out.println(arr.length);// 技巧：获取数组的最大索引: arr.length - 1(前提是数组中存在数据)System.out.println(arr.length - 1);int[] arr2 = &#123;&#125;;System.out.println(arr2.length - 1); 2.3 数组的遍历各位同学，接下来我们学习一个对数组最最最常见的操作——数组遍历。所谓遍历意思就是将数组中的元素一个一个的取出来。 我们刚才学习了数组中元素的访问，访问元素必须用到索引，如下列代码。 1234int[] ages = &#123;12, 24, 36&#125;;System.out.println(ages[0]);System.out.println(ages[1]);System.out.println(ages[2]); 但是，如果数组中有很多很多元素，索引靠自己一个一个数肯定是不行的！我们可以使用for循环从0开始一直遍历到长度-1的位置，就可以获取所有的索引了。 当你获取到每一个索引，那么每一个元素不就获取到了吗？上代码吧 12345int[] ages = &#123;12, 24, 36&#125;;for (int i = 0; i &lt; ages.length; i++) &#123; // i的取值 = 0,1,2 System.out.println(ages[i]); &#125; 2.4 数组静态初始化案例学习完数组的静态初始化之后，接下来我们做一个练习题来巩固一下。 12345678910需求：某部门5名员工的销售额分别是：16、26、36、6、100，请计算出他们部门的总销售额。需求分析： 1.看到有16、26、36、6、100这5个数据数据，而且数据值很明确; 1)想到,可以使用数组静态初始化把这5个数据存起来 2.请计算出他们部门的总销售额（这不就是求数组中数据的和吗？） 2)必须先将数组中所有的元素遍历出来 3)想要求和，得先有一个求和变量sum 4)再将每一个元素和求和变量sum进行累加（求和思想） 按照分析的思路来写代码 12345678910111213// 1、定义一个数组存储5名员工的销售额//索引 0 1 2 3 4int[] money = &#123;16, 26, 36, 6, 100&#125;;// 3、定义一个变量用于累加求和int sum = 0;// 2、遍历这个数组中的每个数据。for (int i = 0; i &lt; money.length; i++) &#123; // i = 0 1 2 3 4 sum += money[i];&#125;System.out.println(&quot;员工的销售总额：&quot; + sum); 2.5 数组的动态初始化各位同学，刚才我们初始化数组时，都是直接将元素写出来。但是还有另一个初始化数组的方式叫 动态初始化。 动态初始化不需要我们写出具体的元素，而是指定元素类型和长度就行。格式如下 12//数据类型[] 数组名 = new 数据类型[长度];int[] arr = new int[3]; 下面是动态初始化数组的原理图。我们发现int[] arr 其实就是一个变量，它记录了数组对象的地址值，而且数组中的元素默认值是0。 注意： 使用动态初始化定义数组时，根据元素类型不同，默认值也有所不同。 关于数组动态初始化的格式和原理，咱们就先学习到这里。 2.6 数组动态初始化案例各位同学，接下来我们做一个数组动态初始化的案例。 12345678910案例需求： 某歌唱比赛，需要开发一个系统：可以录入6名评委的打分，录入完毕后立即输出平均分做 选手得分需求分析： 1.需要录入6名评委的分数，可以用一个数组来保存。 因为在评委没有录入分数之前，还不确定数组中应该存哪些数据。 所以可以使用数组的动态初始化 2.遍历数组中的每一个位置，并录入分数，将分数存入数组中 3.遍历数组中的每一个元素，对元素求和 代码如下 12345678910111213141516171819// 1、定义一个动态初始化的数组，负责后期存储6个评委的打分。double[] scores = new double[6];Scanner sc = new Scanner(System.in);// 2、遍历数组中的每个位置，录入评委的分数，存入到数组中去for (int i = 0; i &lt; scores.length; i++) &#123; // i = 0 1 2 3 4 5 System.out.println(&quot;请您输入当前第&quot; + (i + 1) +&quot;个评委的分数：&quot;); double score = sc.nextDouble(); scores[i] = score;&#125;// 3、遍历数组中的每个元素进行求和double sum = 0;for (int i = 0; i &lt; scores.length; i++) &#123; sum += scores[i];&#125;System.out.println(&quot;选手最终得分是：&quot; + sum / scores.length); 三、数组在计算机中的执行原理好的各位同学，在前面我们已经学习了数组的基本使用，也理解了数组的基本原理。由于数组是一个容器，变量也是一个容器，在理解他们执行原理的时候，有些同学就容易搞混，现在我把他们放在一起带着大家回顾一下他们的会执行原理，顺便带着大家详细理解一下Java程序的执行的内存原理。 3.1 数组的执行原理，Java程序的执行原理我们以下面的代码，来讲解变量、数组的执原理。 12345678910111213141516171819public class ArrayDemo1 &#123; public static void main(String[] args) &#123; int a = 10; System.out.println(a); int[] arr = new int[]&#123;11, 22, 33&#125;; System.out.println(arr); System.out.println(arr[1]); arr[0] = 44; arr[1] = 55; arr[2] = 66; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 前面我们给大家讲过，程序是在内存中执行的。实际上Java程序是把编译后的字节码加载到Java虚拟机中执行的。 Java为了便于虚拟机执行Java程序，将虚拟机的内存划分为 方法区、栈、堆、本地方法栈、寄存器 这5块区域。同学们需要重点关注的是 方法区、栈、堆。 下面把每一个块内存区域作用介绍一下，我们大致只需要知道每一部分存储什么内容就行。 方法区：字节码文件先加载到这里 栈：方法运行时所进入的内存区域，由于变量在方法中，所以变量也在这一块区域中 堆：存储new出来的东西，并分配地址。由于数组是new 出来的，所以数组也在这块区域。 下面是上面案例执行的内存原理如下图所示，按照① ② ③ ④ ⑤ ⑥ 的标记的顺序来看 总结一下int a = 10与 int[] arr = new int[]&#123;11,22,33&#125;的区别 a是一个变量，在栈内存中，a变量中存储的数据就是10这个值。 arr也是一个变量，在栈中，存储的是数组对象在堆内存中的地址值 1234// 这里的int a是一个基本类型变量，存储的是一个数值int a = 10 ; //这里的int[] arr是一个引用类型的变量，存储的是一个地址值int[] arr = new int[]&#123;44,55,66&#125;; 3.2 多个变量指向同一个数组的问题各位同学，我们了解了数组在内存中的执行原理。我们知道数组类型的变量，指向的是堆内存中数组对象的地址。但是在实际开发中可能存在一种特殊情况，就是多个变量指向同一个数组对象的形式。 讲解这个知识点的目的，是让同学们注意多个变量指向同一个数组对象存在什么问题？ 我们先看一段代码 123456789101112131415161718192021public class ArrayDemo2 &#123; public static void main(String[] args) &#123; // 目标：认识多个变量指向同一个数组对象的形式，并掌握其注意事项。 int[] arr1 = &#123;11, 22, 33&#125;; // 把int类型的数组变量arr1赋值给int类型的数组变量arr2 int[] arr2 = arr1; System.out.println(arr1); System.out.println(arr2); arr2[1] = 99; System.out.println(arr1[1]); arr2 = null; // 拿到的数组变量中存储的值是null System.out.println(arr2); //System.out.println(arr2[0]); //System.out.println(arr2.length); &#125;&#125; 我们重点关注这一段代码 刚执行完int[] arr1 = &#123;11,22,33&#125;;时，内存原理如下 当执行完int[] arr2 = arr1;后，内存原理如下 当执行到arr2[1]=99;时，内存原理如下 总结一下： 两个变量指向同一个数组时，两个变量记录的是同一个地址值。 当一个变量修改数组中的元素时，另一个变量去访问数组中的元素，元素已经被修改过了。 到这里有关数组的基本操作，和内存原理我们就全部学习完了。 四、数组专项练习接下来我们做一些专项练习题，把数组的常见操作练习一下。在学习这个案例时，重点掌握数组求最值的思路，代码只是用来表达你的思路的。 4.1 数组求最值1需求：定义一个int类型数组，求数组中元素的最大值，并打印最大值 我们先看一下选美比赛，是怎么选出颜值最高的人的。然后再以此思路，来写代码找出数组中元素的最大值。 1234数组求最大值思路： 1)先找出数组中0索引的元素，假设为最大值，用max表示【擂主】 2)遍历后面的每一个元素和max比较，把较大的元素值重新赋值给max(擂主换人) 3)最后max就是所有元素的最大值(最后站在台上的擂主) 1234567891011121314151617181920public class Test1 &#123; public static void main(String[] args) &#123; // 1、把颜值数据拿到程序中来，用数组装起来 int[] faceScores = &#123;15, 9000, 10000, 20000, 9500, -5&#125;; // 2、定义一个变量用于最终记住最大值。 int max = faceScores[0]; // 3、从数组的第二个位置开始遍历。 for (int i = 1; i &lt; faceScores.length; i++) &#123; // i = 1 2 3 4 5 // 判断一下当前遍历的这个数据，是否大于最大值变量max存储的数据， //如果大于，当前遍历的数据需要赋值给max if(faceScores[i] &gt; max )&#123; max = faceScores[i]; &#125; &#125; System.out.println(&quot;最高颜值是：&quot; + max); &#125;&#125; 总结一下： 通过这个案例，我们主要掌握求最值的思路，以后不管遇到求最大值还是最小值，编程思路都是一样的，不同的可能是数据不同。 4.2 数组元素反转12需求：某个数组有5个数据：10,20,30,40,50，请将这个数组中的数据进行反转。 [10, 20, 30, 40, 50] 反转后 [50, 40, 30, 20, 10] 数组元素反转的核心，其实是数组中两个数据的交换。我们可以认为两个数据分别存储在两个水杯中。想要交换两个水杯中的东西，我们得借助第三个水杯，如下图所示 数组中元素交换，就是用的借用第三方变量的思想。 我们把数组中的每一个元素当做一个水杯，然后索引控制哪两个元素互换位置。 怎么样，才能达到元素反转的效果呢？我们只需将第一个和最后一个元素互换、第二个和倒数第二个互换、依次内推…. 如下图所示 怎么样写代码，才能达到上面的效果呢？我们继续分析 123451.每次交换，需要有左右两边的两个索引，我们可以用i和j表示 刚开始i=0，j=数组长度-1;2.每次让i和j索引位置的两个元素互换位置 arr[i]和arr[j]互换位置3.每次还完位置之后，让i往右移动一位，让j往前移动一位 具体代码如下 123456789101112131415161718192021222324public class Test2 &#123; public static void main(String[] args) &#123; // 目标：完成数组反转。 // 1、准备一个数组 int[] arr = &#123;10, 20, 30, 40, 50&#125;; // 2、定义一个循环，设计2个变量，一个在前，一个在后 for (int i = 0, j = arr.length - 1; i &lt; j; i++, j--) &#123; // arr[i] arr[j] // 交换 // 1、定义一个临时变量记住后一个位置处的值 int temp = arr[j]; // 2、把前一个位置处的值赋值给后一个位置了 arr[j] = arr[i]; // 3、把临时变量中记住的后一个位置处的值赋值给前一个位置处 arr[i] = temp; &#125; // 3、遍历数组中的每个数据，看是否反转成功了 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; &#125;&#125; 总结一下： 通过上面的案例，需要我们掌握元素互换位置的编程思路；以后遇到数据互换问题，都这样做。 4.3 随机排名各位同学，通过数组元素反转的案例，我们学会了如何对两个数据进行交换。接下来，我们再学习随机排名案例，将数据交换的思路再巩固一下。 先来看一下需求 1需求：某公司开发部5名开发人员，要进行项目进展汇报演讲，现在采取随机排名后进行汇报。请先依次录入5名员工的工号，然后展示出一组随机的排名顺序。 分析一下随机排名的思路 1231.在程序中录入5名员工的工号存储起来 ---&gt; 使用动态初始化数组的方式。2.依次遍历数组中的每个数据。3.每遍历到一个数据，都随机一个索引值出来，让当前数据与该索引位置处的数据进行交换。 如下图所示，每次遍历到一个元素，随机将当前位置元素和随机索引元素换位置。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738public class Test3 &#123; public static void main(String[] args) &#123; // 目标：完成随机排名 // 1、定义一个动态初始化的数组用于存储5名员工的工号 int[] codes = new int[5]; // 2、提示用户录入5名员工的工号。 Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; codes.length; i++) &#123; // i = 0 1 2 3 4 System.out.println(&quot;请您输入第&quot; + (i + 1) +&quot;个员工的工号：&quot;); int code = sc.nextInt(); codes[i] = code; &#125; // 3、打乱数组中的元素顺序。 // [12, 33, 54, 26, 8] // i index Random r = new Random(); for (int i = 0; i &lt; codes.length; i++) &#123; // codes[i] // 每遍历到一个数据，都随机一个数组索引范围内的值。 //然后让当前遍历的数据与该索引位置处的值交换。 int index = r.nextInt(codes.length); // 0 - 4 // 定义一个临时变量记住index位置处的值 int temp = codes[index]; // 把i位置处的值赋值给index位置处 codes[index] = codes[i]; // 把index位置原来的值赋值给i位置处 codes[i] = temp; &#125; // 4、遍历数组中的工号输出即可 for (int i = 0; i &lt; codes.length; i++) &#123; System.out.print(codes[i] + &quot; &quot;); &#125; &#125;&#125; 到这有关数组的常见练习题我们就讲完了，待会我们在给同学们讲一个开发中用得比较多的工具叫做Debug调试。 五、Debug调试工具各位同学，为了让大家更好的理解代码的执行流程，这里给大家讲一个在开发中非常重要的工具——叫做Debug调试。 通过Debug调试，我们可以查看代码的执行流程。当你代码中有Bug但是又发现不了的时候，你就可以用Debug调试工具，查看执行流程，逐步分析是哪一行出现了问题。 Debug调试工具的使用步骤如下： 1234第一步：打断点，如下图的红色小圆点第二步：右键Debug方式启动程序，如下图右键菜单 启动后，代码会停留在打断点的这一行第三步：点击箭头按钮，一行一行往下执行","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day05-方法","slug":"day05-方法","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day05-方法/","link":"","permalink":"https://wxzhou.top/2020/05/05/day05-%E6%96%B9%E6%B3%95/","excerpt":"","text":"我们先来学习一下方法是什么 一、方法概述1.1 方法是什么 方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用。这句话什么意思呢？意思是，把一段功能代码围在一起，别人都可以来调用它。 下图是方法的完整格式 我们看一个需求，比如现在张工、李工两个人都需要求两个整数的和。不使用方法，代码如下。 123456789101112// 1、李工。int a = 10;int b = 20;int c = a+b;System.out.println(&quot;和是：&quot; + c);// 2、张工。int a1 = 10;int b1 = 20;int c1 = a1+b1;System.out.println(&quot;和是：&quot; + c1); 阅读上面的代码，我们不难发现。两次求和的代码中，除了求和的数据不一样，代码的组织结构完全一样。 像这种做相同事情的代码，就可以用方法进行封装。需要用到这段代码功能时，让别人调用方法就行。代码如下 123456789101112131415161718//目标：掌握定义方法的完整格式，搞清楚使用方法的好处。public class MethodDemo1 &#123; public static void main(String[] args) &#123; // 需求：假如现在很多程序员都要进行2个整数求和的操作。 // 1、李工。 int rs = sum(10, 20); System.out.println(&quot;和是：&quot; + rs); // 2、张工。 int rs2 = sum(30, 20); System.out.println(&quot;和是：&quot; + rs2); &#125; public static int sum(int a,int b) &#123; int c = a + b; return c; &#125;&#125; 1.2 方法的执行流程 当调用一个方法时，执行流程，按照下图中标注的序号执行。 ​ ① 通过sum方法名找到sum方法 ​ ② 把10传递给方法中的参数a ​ ③ 把20传递给方法中的参数b； ​ ④ 执行方法中的代码，此时int c=a+b;; 相当于 int c = 10+20; c的值为30 ​ return c 的含义是，把c的结果返回给调用处。 也就是调用sum方法的结果为30, 学习完方法的执行流程之后，下面有几个注意事项需要我们写代码时注意一下。 1.3 定义方法的注意点 方法的修饰符：暂时都使用public static 修饰。（目前看做是固定写法，后面是可以改动的） 方法申明了具体的返回值类型，内部必须使用return返回对应类型的数据。 形参列表可以有多个，甚至可以没有； 如果有多个形参，多个形参必须用“，”隔开，且不能给初始化值。 1.4 使用方法的好处 最好，我们总结一下，用方法有什么好处，可以归纳为下面2点： 提高了代码的复用性，提高了开发效率。 让程序的逻辑更清晰。 如下图所示：写好一个方法之后，每一个人都可以直接调用，而不用再重复写相同的代码。所以是提高了代码的复用性，不用写重复代码，自然也提高了开发效率。 那么让程序的逻辑更加清晰，是如何体现的呢？ 比如，我们后期会用所学习的技术，做一个ATM系统，ATM系统中有查看账户、存钱、取钱、修改密码等功能，到时候我们可以把每一个功能都写成一个方法。如下图所示，这样程序的逻辑就更加清晰了。 好了，关于方法是什么，以及方法的基本使用就学习到这里。 总结一下 1234567891011121314151.什么是方法？ 答：方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用2.方法的完整格式是什么样的？ //格式如下： 修饰符 返回值类型 方法名( 形参列表 )&#123; 方法体代码(需要执行的功能代码) return 返回值; &#125;3.方法要执行必须怎么办？ 必须调用才执行; //调用格式: 方法名(...);4.使用方法有什么好处？ 答：提高代码的复用性，提高开发效率，使程序逻辑更清晰。 二、方法的其他形式各位同学，刚才我们学习了定义完整格式的方法。但是实际开发中，需要按照方法解决的实际业务需求，设计出合理的方法形式来解决问题。 实际上设计一个合理的方法，需要重点关注下面两点 设计一个合理的方法的原则如下： 如果方法不需要返回数据，返回值类型必须申明成void（无返回值申明）, 此时方法内部不可以使用return返回数据。 方法如果不需要接收外部传递进来的数据，则不需要定义形参，且调用方法时也不可以传数据给方法。 没有参数，且没有返回值类型（void）的方法，称为值无参数、无返回值方法。此时调用方法时不能传递数据给方法。 接下来我们看几个案例代码，练习根据实际需求定义出合理的方法 需求1：写一个方法，打印3个”Hello World” 分析：需求已经非常明确，打印的是3个HelloWorld，在方法中直接循环3次就可以完成需求。不需要外部给方法传递数据，所以不需要参数。 需求2：写一个方法，打印若干个”Hello World”，具体多少个，有调用者指定 分析：需求不明确打印HelloWorld的个数，而是需要调用者指定。也就是说，调用者调用方法时需要给方法传递打印HelloWorld的个数。那么定义方法时，就需要写一个参数，来接收调用者传递过来的个数。 三、方法使用常见的问题各位同学，自己第一次写方法时，或多或少会可能会出现一些问题。下面把使用方法时，常见的问题整理一下。 目的是让同学们，以后写方法时避免出现这些问题。一旦出现这些问题，要知道是什么原因。 123456789101112131415- 1. 方法在内种没有先后顺序，但是不能把一个方法定义在另一个方法中。- 2. 方法的返回值类型写void（无返回申明）时，方法内不能使用return返回数据， 如果方法的返回值类型写了具体类型，方法内部则必须使用return返回对应类型的数据。- 3. return语句的下面，不能编写代码，属于无效的代码，执行不到这儿。- 4. 方法不调用就不会执行, 调用方法时，传给方法的数据，必须严格匹配方法的参数情况。- 5. 调用有返回值的方法，有3种方式： ① 可以定义变量接收结果 ② 或者直接输出调用， ③ 甚至直接调用；- 6. 调用无返回值的方法，只有1种方式： 只能直接调用。 四、方法的案例4.1 方法案例1 按照需求：定义方法如下 12345678910111213/*分析： 需要求1~n的和，由于n不确定是多少，所以就把n写成形式参数，n的具体值由调用者指定。 在方法中把n当做一个确定的数据来使用就行。*/public static int add(int n)&#123; int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; // i = 1 2 3 ... n sum += i; &#125; return sum;&#125; 定义好方法之后，在main方法中调用 1234567public static void main(String[] args) &#123; int rs = add(5); System.out.println(&quot;1-5的和是：&quot; + rs); //15 int rs = add(6); System.out.println(&quot;1-6的和是：&quot; + rs); //21&#125; 4.2 方法案例2 按照需求：定义方法如下 12345678910111213/*分析： 需求中，是要判断一个数是奇数还是偶数，但是并没有明确说，是哪一个数。 也就是说这个数可能是奇数，也可以能是偶数，是一个能够变化的数。 把这个数写成方法的形式参数，就可以达到这个目的。因为调用方法时，调用者可以给传递 奇数，也可以传递偶数。*/public static void judge(int number)&#123; if(number % 2 == 0)&#123; System.out.println(number + &quot;是一个偶数！&quot;); &#125;else &#123; System.out.println(number + &quot;是一个奇数！&quot;); &#125;&#125; 定义好方法之后，在main方法中调用 1234public static void main(String[] args) &#123; judge(7); //调用后打印：7是一个奇数 judge(8); //调用后打印：8是一个偶数&#125; 五、方法在计算机中的执行原理各位同学，刚才我们已经写了好几个方法并成功调用了。但是不知道同学们奇不奇怪一个问题。方法在计算机的内存中到底是怎么干的呢？ 为了让大家更加深刻的理解方法的执行过程，接下来，给同学们讲一下方法在计算机中的执行原理。理解方法的执行原理，对我们以后知识的学习也是有帮助的。 我们知道Java程序的运行，都是在内存中执行的，而内存区域又分为栈、堆和方法区。那Java的方法是在哪个内存区域中执行呢？ 答案是栈内存。 每次调用方法，方法都会进栈执行；执行完后，又会弹栈出去。 方法进栈和弹栈的过程，就类似于手枪子弹夹，上子弹和击发子弹的过程。最后上的一颗子弹是，第一个打出来的；第一颗上的子弹，是最后一个打出来的。 假设在main方法中依次调用A方法、B方法、C方法，在内存中的执行流程如下： 每次调用方法，方法都会从栈顶压栈执行没执行 每个方法执行完后，会从栈顶弹栈出去 5.1 有返回值的方法，内存分析下面我们分析一下，求两个整数和的代码，在内存中的执行原理。 12345678910public class MethodDemo &#123; public static void main(String[] args) &#123; int rs = sum(10, 20); System.out.println(rs); &#125; public static int sum(int a, int b )&#123; int c = a + b; return c; &#125;&#125; 如下图所示：以上代码在内存中的执行过程，按照①②③④⑤⑥⑦的步骤执行. 5.2 无返回值的方法，内存分析刚才我们分析的是有有参数有返回值的方法内存原理。下面再分析一个无返回值、无参数的内存原理。 123456789101112131415161718public class Demo2Method &#123; public static void main(String[] args) &#123; study(); &#125; public static void study()&#123; eat(); System.out.println(&quot;学习&quot;); sleep(); &#125; public static void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; public static void sleep()&#123; System.out.println(&quot;睡觉&quot;); &#125;&#125; 总结一下 123451.方法的运行区域在哪里？ 答：栈内存。 2.栈有什么特点？方法为什么要在栈中运行自己？ 答：先进后出。保证一个方法调用完另一个方法后，可以回来继续执行。 六、方法参数的传递机制各位同学，刚才我们学习了方法运行的原理，相信大家对方法的运行过程有更加深刻的认识。但是方法参数的传递过程还需要，还需要进一步学习一下。 因为我们刚才演示的一些方法中传递的参数都是基本类型，实际上参数还可以是传递引用类型。接下来，学习一下当参数是基本类型时、和参数是引用类型时的区别。 先记住一个结论：Java的参数传递机制都是：值传递 所谓值传递：指的是在传递实参给方法的形参的时候，传递的是实参变量中存储的值的副本。 同学们肯定想知道，形参是什么？实参又是什么呢？ 请看下面这个张图 6.1 参数传递的基本类型数据接下来，看一下方法参数传递是基本类型数据时，内存中是怎么执行的。 我们把参数传递的结论再复习一下：Java的参数传递机制都是：值传递，传递的是实参存储的值的副本。 6.3 参数传递的是引用数据类型接下来，看一下方法的参数是引用类型的数据时，内存中是怎么执行的。 我们发现调用change方法时参数是引用类型，实际上也是值传递，只不过参数传递存储的地址值。此时change方法和main方法中两个方法中各自有一个变量arrs，这两个变量记录的是同一个地址值[I@4c873330，change方法把数组中的元素改了，main方法在访问时，元素已经被修改了。 总结一下： 12341.基本类型和引用类型的参数在传递的时候有什么不同？ = 都是值传递 - 基本类型的参数传递存储的数据值。 - 引用类型的参数传递存储的地址值。 七、方法参数传递案例7.1 方法参数传递案例1123456789101112需求：输出一个int类型的数组内容，要求输出格式为：[11, 22, 33, 44, 55]。分析： 1.方法是否需要接收数据进行处理？ 方法要打印int类型数组中的元素，打印哪一个数组需求并不明确； 所以可以把int数组写成参数，让调用者指定 2.方法是否需要返回数据？ 方法最终的目的知识打印数组中的元素。 不需要给调用者返回什么，所以不需要返回值，返回值类型写void 3.方法内部的业务：遍历数组，并输出相应的内容 代码如下 12345678910111213141516171819202122232425262728293031323334public class MethodTest3 &#123; public static void main(String[] args) &#123; // 目标：完成打印int类型的数组内容。 int[] arr = &#123;10, 30, 50, 70&#125;; printArray(arr); int[] arr2 = null; printArray(arr2); int[] arr3 = &#123;&#125;; printArray(arr3); &#125; /* 参数：int[] arr表示要被打印元素的数组，需要调用者传递 */ public static void printArray(int[] arr)&#123; if(arr == null)&#123; System.out.println(arr); // null return; // 跳出当前方法 &#125; System.out.print(&quot;[&quot;); // 直接遍历接到的数组元素 for (int i = 0; i &lt; arr.length; i++) &#123; if(i == arr.length - 1)&#123; System.out.print(arr[i]); &#125;else &#123; System.out.print(arr[i] + &quot;, &quot;); &#125; &#125; System.out.println(&quot;]&quot;); &#125;&#125; 7.2 方法参数传递案例2123456789101112需求：比较两个int类型的数组是否一样，返回true或者false分析： 1.方法是否需要接收数据进行处理？ 因为，方法中需要两个int数组比较，但是需求并不明确是哪两个数组； 所以，需要接收两个int类型的数组，形参声明为：int[] arr1，int[] arr2 2.方法是否需要返回数据？ 因为,方法最终的结果需要true或者false; 所以，返回值类型是boolean 3. 方法内部的业务：判断两个数组内容是否一样。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MethodTest4 &#123; public static void main(String[] args) &#123; // 目标：完成判断两个int类型的数组是否一样。 int[] arr1 = &#123;10, 20, 30&#125;; int[] arr2 = &#123;10, 20, 30&#125;; System.out.println(equals(arr1, arr2)); &#125; /* 参数： int[] arr1, 参与比较的第一个int数组 int[] arr2 参与比较的第二个int数组 返回值: 返回比较的结果true或者false */ public static boolean equals(int[] arr1, int[] arr2)&#123; // 1、判断arr1和arr2是否都是null. if(arr1 == null &amp;&amp; arr2 == null)&#123; return true; // 相等的 &#125; // 2、判断arr1是null，或者arr2是null. if(arr1 == null || arr2 == null) &#123; return false; // 不相等 &#125; // 3、判断2个数组的长度是否一样，如果长度不一样，直接返回false. if(arr1.length != arr2.length)&#123; return false; // 不相等 &#125; // 4、两个数组的长度是一样的，接着比较它们的内容是否一样。 // arr1 = [10, 20, 30] // arr2 = [10, 20, 30] for (int i = 0; i &lt; arr1.length; i++) &#123; // 判断当前位置2个数组的元素是否不一样，不一样直接返回false if(arr1[i] != arr2[i])&#123; return false; // 不相等的 &#125; &#125; return true; // 两个数组是一样的。 &#125;&#125; 八、方法重载接下来，我们学习一个开发中很重要的一个方法的形式——叫方法重载。 所谓方法重载指的是：一个类中，出现多个相同的方法名，但是它们的形参列表是不同的，那么这些方法就称为方法重载了。 我们在这里要能够认识，哪些是重载的方法。 下面案例中有多个test方法，但是参数列表都不一样，它们都是重载的方法。调用时只需要通过参数来区分即可。 1234567891011121314151617181920212223242526272829public class MethodOverLoadDemo1 &#123; public static void main(String[] args) &#123; // 目标：认识方法重载，并掌握其应用场景。 test(); test(100); &#125; public static void test()&#123; System.out.println(&quot;===test1===&quot;); &#125; public static void test(int a)&#123; System.out.println(&quot;===test2===&quot; + a); &#125; void test(double a)&#123; &#125; void test(double a, int b)&#123; &#125; void test(int b, double a)&#123; &#125; int test(int a, int b)&#123; return a + b; &#125;&#125; 我们认识了方法重载，那么方法重载有哪些应用场景呢？ 一般在开发中，我们经常需要为处理一类业务，提供多种解决方案，此时用方法重载来设计是很专业的。 比如，我们现在看一个案例 12345需求：开发武器系统，功能需求如下： 可以默认发一枚武器。 可以指定地区发射一枚武器。 可以指定地区发射多枚武器。 上面的几个需求中，不管以什么样的方式发武器，其实最终的目的都是发武器。 所以我们可以设计几个名称相同的方法，这样调用者调用起来就不用记那么多名字了 代码如下： 1234567891011121314151617181920public class MethodTest2 &#123; public static void main(String[] args) &#123; // 目标：掌握方法重载的应用场景。 fire(); fire(&quot;岛国2&quot;); fire(&quot;米国&quot;, 999); &#125; public static void fire()&#123; fire(&quot;岛国&quot;); &#125; public static void fire(String country)&#123; fire(country, 1); &#125; public static void fire(String country, int number)&#123; System.out.println(&quot;发射了&quot; + number + &quot;枚武器给&quot; + country); &#125;&#125; 总结一下： 123456789101.什么是方法重载？ 答：一个类中，多个方法的名称相同，但它们形参列表不同。2.方法重载需要注意什么？ - 一个类中，只要一些方法的名称相同、形参列表不同，那么它们就是方法重载了， 其它的都不管（如：修饰符，返回值类型是否一样都无所谓）。 - 形参列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称。 3、方法重载有啥应用场景？ 答：开发中我们经常需要为处理一类业务，提供多种解决方案，此时用方法重载来设计是很 专业的。 九、return单独使用各位同学，关于方法的定义，我们还剩下最后一种特殊用法，就是在方法中单独使用return语句，可以用来提前结束方法的执行。 如，下面的chu方法中，当除数为0时，就提前结束方法的执行。 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;开始&quot;); chu(10 , 0); System.out.println(&quot;结束&quot;); &#125; public static void chu(int a , int b)&#123; if(b == 0)&#123; System.err.println(“您的数据有误！！不执行！！”); return; // 直接跳出并结束当前chu方法的执行 &#125; int c = a / b; System.out.println(&quot;除法结果是：&quot;+c); &#125;&#125; 今天的课程就到此结束了","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day06-Java编程案例（专题）","slug":"day06-Java编程案例（专题）","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day06-Java编程案例（专题）/","link":"","permalink":"https://wxzhou.top/2020/05/05/day06-Java%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%93%E9%A2%98%EF%BC%89/","excerpt":"","text":"各位同学，前面我们已经学习过很多Java的基础知识了，主要有变量、数组、运算符、流程控制、方法等。但是对于这些知识点的运用，掌握得还不是很熟练，所以今天我们专门花一天时间，给同学们讲几个专项练习题，把前面所学习的知识巩固一下。 同时通过这些专项练习题，积攒大家的代码量，以便提升大家的编程能力和编程思维。这里所说的编程思维就是使用Java技术解决问题的思维方式；编程能力就是按照编程思维编写代码的能力。 想要提升编程思维和编程能力，在这里给同学们一些学习上的建议： 编程思维、编程能力不是一朝一夕形成的，需要大量思考，练习和时间的沉淀。 具体措施：前期，建议先模仿；后期，自然就能创新了；勤于练习代码，勤于思考，孰能生巧。 中国的航空母舰、战斗机，这些技术都是先模仿，再创新的，而且的模仿的周期是非常长的。所以同学们在使用Java技术解决问题时，也是先模仿一些特定问题的解决思路，以后遇到同类型的问题，就采用同一种思维模式来做就行。 案例一：买飞机票各位同学，我们先来学习第一个案例《飞机买票》，先仔细阅读一下案例需求 我们来分析一下，这个需求该如何实现。前面我跟同学们讲过，将来我们去做一些需求，都是一个一个方法来实现的，所以在这里我们也采用方法来编写。 这个方法如何编写呢？采用下面的方式来思考 123456789101.首先，考虑方法是否需要接收数据处理？ 阅读需求我们会发现，不同月份、不同原价、不同舱位类型优惠方案都不一样； 所以，可以将原价、月份、舱位类型写成参数 2.接着，考虑方法是否有返回值？ 阅读需求我们发现，最终结果是求当前用户的优惠票价 所以，可以将优惠票价作为方法的返回值。 3.最后，再考虑方法内部的业务逻辑 先使用if判断月份是旺季还是淡季，然后使用switch分支判断是头等舱还是经济舱，计算 票价 代码如下 12345678910111213141516171819202122232425262728293031323334public class Test1 &#123; public static void main(String[] args) &#123; // 目标：完成买飞机票的案例。 double price = calculate(1000, 11, &quot;头等舱&quot;); System.out.println(&quot;优惠价是：&quot; + price); &#125; public static double calculate(double price,int month,String type)&#123; // 1、判断当前月份是淡季还是旺季 if(month &gt;= 5 &amp;&amp; month &lt;= 10) &#123; // 旺季 // 2、判断仓位类型。 switch (type)&#123; case &quot;头等舱&quot;: price *= 0.9; // price = price * 0.9; break; case &quot;经济舱&quot;: price *= 0.85; break; &#125; &#125;else &#123; // 淡季 switch (type)&#123; case &quot;头等舱&quot;: price *= 0.7; // price = price * 0.7; break; case &quot;经济舱&quot;: price *= 0.65; break; &#125; &#125; return price; &#125;&#125; 案例二：开发验证码各位同学，接下来，我们学习第二个案例《开发验证码》，同样先阅读一下案例需求 分析一下，需求是要我们开发一个程序，生成指定位数的验证码。考虑到实际工作中生成验证码的功能很多地方都会用到，为了提高代码的复用性，我们还是把生成验证码的功能写成方法比较好。 那生成验证码的方法该怎么写呢？按照下面的三个步骤进行思考 1234567891011121.首先，考虑方法是否需要接收数据处理？ 要求生成指定位数的验证码，到底多少位呢？让调用者传递即可 所以，需要一个参数，用来表示验证码的位数2.接着，考虑方法是否需要有返回值？ 该方法的结果，就是为了得到验证码 所以，返回值就是验证码；3.最后，再考虑方法内部的业务逻辑 1)先按照方法接收的验证码位数n,循环n次 2)每次循环，产生一个字符，可以是数字字符、或者大小写字母字符 3)定义一个String类型的变量用于记住产生的每位随机字符 按照思路，编写代码如下 123456789101112131415161718192021222324252627282930313233343536public class Test2 &#123; public static void main(String[] args) &#123; // 目标：完成生成随机验证码。 System.out.println(createCode(8)); &#125; public static String createCode(int n)&#123; //1)先按照方法接收的验证码位数n,循环n次 Random r = new Random(); //3)定义一个String类型的变量用于记住产生的每位随机字符 String code = &quot;&quot;; for (int i = 1; i &lt;= n; i++) &#123; // i = 1 2 3 4 5 //2)每次循环，产生一个字符，可以是数字字符、或者大小写字母字符 // 思路：随机一个0 1 2之间的数字出来，0代表随机一个数字字符，1、2代表随机大写字母，小写字母。 int type = r.nextInt(3); // 0 1 2 switch (type) &#123; case 0: // 随机一个数字字符 code += r.nextInt(10); // 0 - 9 code = code + 8 break; case 1: // 随机一个大写字符 A 65 Z 65+25 (0 - 25) + 65 char ch1 = (char) (r.nextInt(26) + 65); code += ch1; break; case 2: // 随机一个小写字符 a 97 z 97+25 (0 - 25) + 97 char ch2 = (char) (r.nextInt(26) + 97); code += ch2; break; &#125; &#125; return code; &#125;&#125; 案例三：评委打分各位同学，接下来，我们学习第三个案例《评委打分》，同样先阅读一下案例需求 我们把上面的需求还是用方法来编写。 123456789101112131415161.首先，考虑方法是否需要接收数据来处理？ 需求中说，有多个评委的打分，但是到底多少个评委呢？ 可以由调用者传递 所以，我们可以把评委的个数写成参数；2.接着，考虑方法是否需要有返回值？ 需求中，想要的最终结果是平均分 所以，返回值就是平均分；3.最后，再考虑方法内部的业务逻辑 1)假设评委的个位为n个，那么就需要n个评委的分数，首先可以新建一个长度为n的数组， 用来存储每一个评委的分数 2)循环n次，使用Scanner键盘录入n个1~100范围内的整数，并把整数存储到数组中 3)求数组中元素的总和、最大值、最小值 4)最后再计算平均值； 平均值 = (和-最大值-最小值)/(数组.length-2); 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Test3 &#123; public static void main(String[] args) &#123; // 目标：完成评委打分案例。 System.out.println(&quot;当前选手得分是：&quot; + getAverageScore(6)); &#125; public static double getAverageScore(int n)&#123; // 1、定义一个动态初始化的数组，负责后期存入评委的打分 int[] scores = new int[n]; // 6 // scores = [0, 0, 0, 0, 0, 0] // 2、遍历数组的每个位置，依次录入评委的分数 Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; scores.length; i++) &#123; // i = 0 1 2 3 4 5 System.out.println(&quot;请您录入第&quot;+ (i + 1) +&quot;个评委的分数：&quot;); int score = sc.nextInt(); scores[i] = score; &#125; // 3、从数组中计算出总分，找出最高分，最低分。 int sum = 0; // 求总分用的变量 int max = scores[0]; // 求最大值的 int min = scores[0]; // 求最小值的。 // 遍历数组找出这些数据的。 for (int i = 0; i &lt; scores.length; i++) &#123; // i = 0 1 2 3 4 5 int score = scores[i]; // 求和 sum += score; // 求最大值 if(score &gt; max)&#123; max = score; &#125; // 求最小值 if(score &lt; min)&#123; min = score; &#125; &#125; // 4、计算出平均分并返回 return 1.0 * (sum - min - max) / (number - 2); &#125;&#125; 案例四：数字加密各位同学，接下来我们学习第四个案例《数字加密》，我们还是先阅读一下案例需求 仔细阅读需求后发现，简答来说该需求要做的事情，就是把一个4位数的整数，经过一系列的加密运算（至于怎么运算，待会再详细分析），得到一个新的整数。 我们还是把这个需求用方法来实现，按照下面的思维模式进行分析 123456789101112131.首先，考虑方法是否需要接收数据处理？ 需要一个4位数，至于是哪一个数，让方法的调用者传递。 所以，方法的参数，就是这个需要加密的四位数2.接着，考虑方法是否需要有返回值？ 方法最终的结果是一个加密后的数据 所以，返回值就表示为加密后的数据。3.最后，再考虑方法内部的业务逻辑，这里的业务逻辑就是那一系列的加密运算 1)先要把4位数整数拆分为，4个数字，用一个数组保存起来 2)再将数组中的每一个元素加5，再对10取余 3)最后将数组中的元素反转， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Test4 &#123; public static void main(String[] args) &#123; // 目标：完成数字加密程序的开发。 System.out.println(&quot;加密后的结果是：&quot; + encrypt(8346)); &#125; public static String encrypt(int number)&#123; // number = 1983 // 1、把这个密码拆分成一个一个的数字，才可以对其进行加密啊。 int[] numbers = split(number); // numbers = [1, 9, 8, 3] // 2、遍历这个数组中的每个数字，对其进行加密处理。 for (int i = 0; i &lt; numbers.length; i++) &#123; // i = 0 1 2 3 numbers[i] = (numbers[i] + 5) % 10; &#125; // numbers = [6, 4, 3, 8] // 3、对数组反转，把对数组进行反转的操作交给一个独立的方法来完成 reverse(numbers); // numbers = [8, 3, 4, 6] // 4、把这些加密的数字拼接起来做为加密后的结果返回即可。 String data = &quot;&quot;; for (int i = 0; i &lt; numbers.length; i++) &#123; data += numbers[i]; &#125; return data; &#125; public static void reverse(int[] numbers) &#123; // 反转数组的 // numbers = [6, 4, 3, 8] // i j for (int i = 0, j = numbers.length - 1; i &lt; j; i++,j--) &#123; // 交换i和j位置处的值。 // 1、把后一个位置处的值交给一个临时变量先存起来 int temp = numbers[j]; // 2、把前一个位置处的值赋值给后一个位置处 numbers[j] = numbers[i]; // 3、把后一个位置处原来的值（由临时变量记住着）赋值给前一个位置 numbers[i] = temp; &#125; &#125; public static int[] split(int number) &#123; // number = 1983 int[] numbers = new int[4]; numbers[0] = number / 1000; numbers[1] = (number / 100) % 10; numbers[2] = (number / 10) % 10; numbers[3] = number % 10; return numbers; &#125;&#125; 案例五：数组拷贝各位同学，接下来我们学习第五个案例《数组拷贝》，我们还是先阅读一下案例需求 仔细阅读需求发现，想要实现的效果就是：给定一个数组，然后经过我们编写的程序，得到一个和原数组一模一样的数组。 我们也采用一个方法来编写，按照下面的思维模式来思考 1234567891011121.首先，考虑方法是否需要接收数据处理？ 该方法的目的是拷贝数组，拷贝哪一个数组呢？ 需要调用者传递 所以，参数应该是一个数组2.接着，考虑方法是否需要有返回值？ 该方法最终想要得到一个新数组 所以，返回值是拷贝得到的新数组3.最后，考虑方法内部的业务逻辑？ 1)创建一个新的数组，新数组的长度和元素数组一样 2)遍历原数组，将原数组中的元素赋值给新数组 3)最终将新数组返回 123456789101112131415161718192021222324252627282930313233343536373839404142public class Test5 &#123; public static void main(String[] args) &#123; // 目标：掌握数组拷贝。 int[] arr = &#123;11, 22, 33&#125;; int[] arr2 = copy(arr); printArray(arr2); // 注意：这个不是拷贝数组，叫把数组变量赋值给另一个数组变量。 // int[] arr3 = arr; // arr3[1] = 666; // System.out.println(arr[1]); arr2[1] = 666; System.out.println(arr[1]); &#125; public static int[] copy(int[] arr)&#123; // arr = [11, 22, 33] // 0 1 2 // 1、创建一个长度一样的整型数组出来。 int[] arr2 = new int[arr.length]; // arr2 = [0, 0, 0] // 0 1 2 // 2、把原数组的元素值对应位置赋值给新数组。 for (int i = 0; i &lt; arr.length; i++) &#123; // i = 0 1 2 arr2[i] = arr[i]; &#125; return arr2; &#125; public static void printArray(int[] arr)&#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(i==arr.length-1 ? arr[i] : arr[i] + &quot;, &quot;); &#125; System.out.println(&quot;]&quot;); &#125;&#125; 案例六：抢红包各位同学，接下来我们学习第六个案例《抢红包》，我们还是先阅读一下案例需求 我们还是把这个案例用一个方法来编写，同样按照下面的模式来分析 12345678910111213141516171.首先，考虑方法是否需要接收数据处理？ 需要接收5个红包，至于是哪5个红包，可以有调用者传递；把5个红包的数值，用数组来存 储。 所以，参数就是一个数组 2.接着，考虑方法是否需要有返回值？ 按照需求的效果，抢完红包就直接打印了，不需要返回值3.最后，考虑方法内部的业务逻辑是怎么的？ 思考：红包实际上是数组中的元素，抢红包实际上随机获取数组中的元素；而且一个红包只能抢一次，怎么做呢？我们可以把数组中获取到元素的位置，置为0,下次再或者这个位置的元素一判断为0，再重新获取新的元素，依次内推，直到把数组中所有的元素都获取完。 我们我们把抽红包的思路再整理一下： 1)首先，写一个循环，循环次数为数组的长度 2)每次循环，键盘录入，提示&quot;用户录入任意键抽奖：&quot; 3)随机从数组中产生一个索引，获取索引位置的元素，这个元素就表示抽的红包 如果值不为0，则打印如：&quot;恭喜您，您抽中了520元&quot;,把这个位置元素置为0 如果值为0，则说明这个红包被抽过，重新循环到第2步，重新抽奖 【注意：如果当前这一次没有抽中，这一次抽奖机会被浪费掉了，我们可以把控 制循环的次数自减一下】 1234567891011121314151617181920212223242526272829303132public class Test6 &#123; public static void main(String[] args) &#123; int[] moneys = &#123;100,999,50,520,1314&#125;; start(moneys); &#125; //开始抽奖 public static void start(int[] moneys)&#123; //1)首先，写一个循环，循环次数为数组的长度 for (int i = 0; i &lt; moneys.length; i++) &#123; //2)每次循环，键盘录入，提示&quot;用户录入任意键抽奖：&quot; while (true)&#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;用户录入任意键抽奖：&quot;); String msg = sc.next(); //3)随机从数组中产生一个索引，获取索引位置的元素，这个元素就表示抽的红包 Random r = new Random(); int index = r.nextInt(moneys.length); int money = moneys[index]; if(money!=0)&#123; //如果值不为0，则打印如：&quot;恭喜您，您抽中了520元&quot; System.out.println(&quot;恭喜您，您抽中了&quot;+money+&quot;元&quot;); moneys[index] = 0; break; &#125;else &#123; //如果值为0，则说明这个红包被抽过，重新循环到第2步，重新抽奖 //此时这一次抽奖机会被浪费掉了，可以把控制循环的次数自减一下 i--; &#125; &#125; &#125; &#125;&#125; 案例七：找素数各位同学，接下来我们学习第七个案例《找素数》，我们还是先阅读一下案例需求 首先我们得统一认识一下什么是素数：只能被1和本身整除的数是素数，比如：3、7是素数，9,21不是素数（因为9可以被3整除，21可以被3和7整除） 再思考题目需求该怎么做？打印输出101~200之间的素数，并求有多少个？，我们也是把这个需求写成一个方法，还是按照三个步骤分析方法如何编写。 12345678910111213141516171819202122231.首先，考虑方法是否需要接收数据处理？ 该方法是求一个范围内的素数，一个范围需要两个数据来确定，比如：101~200 所以，方法需要两个参数来接收范围的开始值start，和范围的结束值end 2.接着，考虑方法是否需要返回值？ 该方法需要求一个范围内的素数的个数 所以，返回值就是素数的个数3.最后，考虑方法内部的业务逻辑 思考：怎么判断一个数是素数呢？要仅仅抓住，素数的要求:“只能被1和本身整除的数是素数”。我们可以从反向思考，如果这个数只要能被除了1和本身以外的数整除，那么这个数就不是素数。 //比如1：判断9是否为素数 int num = 9; boolean flag = true; //规定flag等于true表示num是素数；否则表示num不是素数 //如果这个数num只要能被除了1和本身以外的数整除，那么这个数就不是素数。 for(int j=2; j&lt;9-1; j++)&#123; //当j=3时，num%j == 9%3 == 0; if(num%j==0)&#123; //说明num=9; 表示一个素数。把flag改为false; flag = false; &#125; &#125; 把上面的代码循环执行，每次循环然后把num换成start~end之间的整数即可。 编写代码如下 1234567891011121314151617181920212223242526272829303132public class Test7 &#123; public static void main(String[] args) &#123; // 目标：完成找素数。 System.out.println(&quot;当前素数的个数是：&quot; + search(101, 200)); &#125; public static int search(int start, int end)&#123; int count = 0; // start = 101 end = 200 // 1、定义一个for循环找到101到200之间的每个数据 for (int i = start; i &lt;= end ; i++) &#123; // i = 101 102 103 ... 199 200 // 信号位思想 boolean flag = true; // 假设的意思：默认当前i记住的数据是素数。 // 2、判断当前i记住的这个数据是否是素数。 for (int j = 2; j &lt;= i / 2; j++) &#123; if(i % j == 0)&#123; // i当前记住的这个数据不是素数了 flag = false; break; &#125; &#125; // 3、根据判定的结果决定是否输出i当前记住的数据：是素数才输出展示。 if(flag)&#123; System.out.println(i); count++; &#125; &#125; return count; &#125;&#125; 案例八：模拟双色球[拓展案例]各位同学，接下来我们学习第八个案例《模拟双色球》，我们还是先阅读一下案例需求 这个案例我们可以采用方法方法来完成 第一个方法，让用户手动投注，产生一注双色球彩票 第二个方法，由系统随机产生一注双色球彩票开奖号码 第三个方法，判断传入两组号码，用于判断彩票的中奖情况 8.1 手动投注编写一个方法，让用户手动投注，产生一注双色球彩票，思路分析 12345678910111213141.首先，考虑方法是否需要接收数据处理？ 双色球彩票的规则非常明确，没有什么数据需要传递给方法。 所以，不需要参数2.接着，考虑方法是否需要返回值？ 方法最终的结果是需要一注双色球彩票的号码，一注彩票有7个号码，可以用一个数组来存 所以，返回值是一个数组3.最后，考虑方法内部的业务逻辑怎么编写？ 1)首先需要准备一个int类型数组，长度为7; 用于存储产生的投注号码 2)循环遍历数组的前6个元素，采用键盘录入的方式，给前区6个红球赋值 要求录入的整数在1~33范围内，同时录入的整数在数组中不能已存在，否则重新录入 3)最后再录入一个整数，给后区一个蓝球赋值 要求整数必须在1~16范围内 手动投注代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 1、设计一个方法，用于让用户投注一组号码并返回（前6个是红球号码，最后1个是蓝球号码 ）*/public static int[] userSelectNumbers()&#123; // 2、创建一个整型数组，用于存储用户投注的7个号码（前6个是红球号码，最后1个是蓝球号码 ） int[] numbers = new int[7]; // numbers = [0, 0, 0, 0, 0, 0, 0] // 0 1 2 3 4 5 6 Scanner sc = new Scanner(System.in); // 3、遍历前6个位置，让用户依次投注6个红球号码，存入 for (int i = 0; i &lt; numbers.length - 1; i++) &#123; // i = 0 1 2 3 4 5 while (true) &#123; // 4、开始让用户为当前位置投注一个红球号码（1-33之间，不能重复） System.out.println(&quot;请您输入第&quot; + (i + 1) + &quot;个红球号码（1-33之间，不能重复）：&quot;); int number = sc.nextInt(); // 5、先判断用户输入的红球号码是否在1-33之间 if(number &lt; 1 || number &gt; 33)&#123; System.out.println(&quot;对不起，您输入的红球号码不在1-33之间，请确认！&quot;); &#125;else &#123; // 号码是在1-33之间了，接着还要继续判断这个号码是否重复，不重复才可以使用。 if(exist(numbers, number))&#123; // number当前这个红球号码是重复了。 System.out.println(&quot;对不起，您当前输入的红球号码前面选择过，重复了，请确认！&quot;); &#125;else &#123; // number记住的这个号码没有重复了，就可以使用了。 numbers[i] = number; break; // 结束当次投注，结束了当前死循环。 &#125; &#125; &#125; &#125; // 6、投注最后一个蓝球号码。 while (true) &#123; System.out.println(&quot;请您输入最后1个蓝球号码（1-16）：&quot;); int number = sc.nextInt(); if(number &lt; 1 || number &gt; 16)&#123; System.out.println(&quot;对不起，您输入的蓝球号码范围不对！&quot;); &#125;else &#123; numbers[6] = number; break; // 蓝球号码录入成功，结束死循环 &#125; &#125; return numbers;&#125; 每键盘录入一个号码，需要判断这个号码在数组中是否存在，存在返回true；不存在返回false 1234567891011121314private static boolean exist(int[] numbers, int number) &#123; // 需求：判断number这个数字是否在numbers数组中存在。 // numbers = [12, 25, 18, 0, 0, 0, 0] // number = 12 for (int i = 0; i &lt; numbers.length; i++) &#123; if(numbers[i] == 0)&#123; break; &#125; if(numbers[i] == number)&#123; return true; &#125; &#125; return false;&#125; 为了打印一注彩票的号码（数组中的元素），把打印数组中的元素也写成方法。 1234567public static void printArray(int[] arr) &#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(i == arr.length - 1 ? arr[i] : arr[i] + &quot;, &quot;); &#125; System.out.println(&quot;]&quot;);&#125; 在main方法中测试，运行看能不能产生一注彩票号码 12345678public class Test8 &#123; public static void main(String[] args) &#123; // 目标：完成双色球系统的开发。 int[] userNumbers = userSelectNumbers(); System.out.println(&quot;您投注的号码：&quot;); printArray(userNumbers); &#125;&#125; 8.2 随机开奖号码编写一个方法，让用户自动机选投注，产生一注双色球彩票，思路分析 12345678910111213141.首先，考虑方法是否需要接收数据处理？ 双色球彩票的规则非常明确，没有什么数据需要传递给方法。 所以，不需要参数2.接着，考虑方法是否需要返回值？ 方法最终的结果是需要一注双色球彩票的号码，一注彩票有7个号码，可以用一个数组来存 所以，返回值是一个数组3.最后，考虑方法内部的业务逻辑怎么编写？ 1)首先需要准备一个int类型数组，长度为7; 用于存储产生的投注号码 2)循环遍历数组的前6个元素，采用生成随机数的的方式，给前区6个红球赋值 要求生成的随机数在1~33范围内，同时随机的整数数组中不能已存在，否则重新生产 3)最后再随机一个整数，给后区一个蓝球赋值 要求随机整数必须在1~16范围内 机选号码，代码如下 12345678910111213141516171819202122232425262728/** 2、设计一个方法：随机一组中奖号码出来（6个红球号码，1个蓝球号码 ）*/public static int[] createLuckNumbers()&#123; // 1、创建一个整型数组，用于存储这7个号码 int[] numbers = new int[7]; Random r = new Random(); // 2、遍历前6个位置处，依次随机一个红球号码存入（1-33 不重复） for (int i = 0; i &lt; numbers.length - 1; i++) &#123; // i = 0 1 2 3 4 5 while (true) &#123; // 3、为当前这个位置随机一个红球号码出来存入。 //1 - 33 ==&gt; -1 ===&gt; (0 , 32) + 1 int number = r.nextInt(33) + 1; // 4、判断这个号码是否之前出现过（红球号码不能重复）。 if(!exist(numbers, number))&#123; // number不重复。 numbers[i] = number; //结束死循环，代表找到了当前这个位置的一个不重复的红球号码了。 break; &#125; &#125; &#125; // 3、录入一个蓝球号码。 1-16 numbers[6] = r.nextInt(16) + 1; return numbers;&#125; 在main方法中测试，看是否能够产生一注彩票 1234567891011121314public class Test8 &#123; public static void main(String[] args) &#123; // 目标：完成双色球系统的开发。 //用户手动投注 int[] userNumbers = userSelectNumbers(); System.out.println(&quot;您投注的号码：&quot;); printArray(userNumbers); //生成中奖号码 int[] luckNumbers = createLuckNumbers(); System.out.println(&quot;中奖的号码：&quot;); printArray(luckNumbers); &#125;&#125; 8.3 判断是否中奖编写一个方法，判断用户的彩票号码是否中奖，具体中奖规则如下 6个红球+1个蓝球 ，奖金1000万 6个红球+0个蓝球，奖金500万 5个红球+1个蓝球，奖金3000块 5个红球+0个蓝球，或者4个红球+1个蓝球，奖金200块 4个红球+0个蓝球，或者3个红球+1个蓝球，奖金10块 小于3个红球+1个蓝球，奖金5块 如果前面的都不成立，就中奖，算你为福利事业做贡献了。 编写方法的思路如下 1234567891011121314151.首先，考虑方法是否需要接收数据处理？ 判断彩票是否中奖，需要有两组号码；一组号码是彩票号码，一组号码是开奖号码 所以，参数需要有两个数组2.接着，考虑方法是否需要返回值？ 方法不需要返回结果，中了奖，直接将奖项打印输出就行了。 【注意：这只是提供一种代码的编写方案，你将中奖的金额返回也行】3.最后，考虑方法内部的业务逻辑怎么编写？ 1)定义两个变量redCount和blueCount用来记录，红球的个数和蓝球的个数 2)遍历两个数组中前6个元素(红球)，判断两个数组中有没有相同元素 如果找到一个相同元素，则redCount++ 3)比较两个数组中最后一个元素(蓝球)是否相同 如果相同，则blueCount++ 4)根据红球和蓝球的命中个数，打印输出对应的奖项 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** 3、设计一个方法，用于判断用户的中奖情况 */public static void judge(int[] userNumbers,int[] luckNumbers)&#123; // userNumbers = [12, 14, 16, 18, 23, 26, 8] // luckNumbers = [16, 17, 18, 19, 26, 32, 8] // 2、分别定义2个变量用于记住红球命中了几个以及蓝球命中了几个 int redCount = 0; int blueCount = 0; // 先判断红球命中的数量。 // 遍历用户投注的号码的前6个红球 for (int i = 0; i &lt; userNumbers.length - 1; i++) &#123; // userNumbers[i] // 开始遍历中奖号码的前6个红球号码，看用户当前选择的这个号码是否命中了 for (int j = 0; j &lt; luckNumbers.length - 1; j++) &#123; if(userNumbers[i] == luckNumbers[j])&#123; redCount++; break; &#125; &#125; &#125; // 3、判断蓝球是否命中了 blueCount = userNumbers[6] == luckNumbers[6] ? 1 : 0; System.out.println(&quot;您命中的红球数量是：&quot; + redCount); System.out.println(&quot;您命中的蓝球数量是：&quot; + blueCount); // 4、判断中奖详情，并输出结果 if(redCount == 6 &amp;&amp; blueCount == 1)&#123; System.out.println(&quot;恭喜您，中奖1000万，可以开始享受人生了~~~&quot;); &#125;else if(redCount == 6 &amp;&amp; blueCount == 0)&#123; System.out.println(&quot;恭喜您，中奖500万，可以稍微开始享受人生了~~~&quot;); &#125;else if(redCount == 5 &amp;&amp; blueCount == 1)&#123; System.out.println(&quot;恭喜您，中奖3000元，可以出去吃顿小龙虾了~&quot;); &#125;else if(redCount == 5 &amp;&amp; blueCount == 0 || redCount == 4 &amp;&amp; blueCount == 1)&#123; System.out.println(&quot;恭喜您，中了小奖：200元~&quot;); &#125;else if(redCount == 4 &amp;&amp; blueCount == 0 || redCount == 3 &amp;&amp; blueCount == 1)&#123; System.out.println(&quot;中了10元~&quot;); &#125;else if( redCount &lt; 3 &amp;&amp; blueCount == 1)&#123; System.out.println(&quot;中了5元~&quot;); &#125;else &#123; System.out.println(&quot;感谢您对福利事业做出的巨大贡献~~~&quot;); &#125;&#125; 在main方法中测试，检测是否中奖的方法是否正确 1234567891011121314151617public class Test8 &#123; public static void main(String[] args) &#123; // 目标：完成双色球系统的开发。 //用户投注 int[] userNumbers = userSelectNumbers(); System.out.println(&quot;您投注的号码：&quot;); printArray(userNumbers); //随机产生一个中奖号码 int[] luckNumbers = createLuckNumbers(); System.out.println(&quot;中奖的号码：&quot;); printArray(luckNumbers); //判断用户投注的号码是否中奖 judge(userNumbers, luckNumbers); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day07-Java面向对象基础","slug":"day07-Java面向对象基础","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day07-Java面向对象基础/","link":"","permalink":"https://wxzhou.top/2020/05/05/day07-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"接下来，我们要学习的是Java中最核心的课程——面向对象编程。 一、面向对象入门各位同学，为什么说面向对象是Java最核心的课程呢？因为写Java程序是有套路的，而面向对象就是写Java程序的套路；你如果不知道面向对象编程，那么你Java语言就算白学了。 那这种编程套路是咋回事呢？ 接下来，我们通过一个案例快速的认识一下。 现在假设我们需要处理的是学生的姓名、语文成绩、数学成绩这三个数据，要求打印输出这个学生的总成绩，和平均成绩。 遇到这样的需求，我们以前都会定义方法来做，如下图所示 注意：这里每一个方法有三个参数 定义好方法之后，我们调用方法的时候，需要给每一个方法传递三个实际参数 在上面案例中，这种编程方式是一种面向过程的编程方式。所谓面向过程，就是编写一个的方法，有数据要进行处理就交给方法来处理。 但是实际上姓名、语文成绩、数学成绩三个数据可以放在一起，组合成一个对象，然后让对象提供方法对自己的数据进行处理。这种方式称之为面向对象编程。 总结一些：所谓编写对象编程，就是把要处理的数据交给对象，让对象来处理。 二、深刻认识面向对象好的各位同学，在上一节课我们已经用面向对象的编程套路，处理了学生数据。接下来我们就要搞清楚，面向对象的几个最核心问题了。 我们把这三个问题搞明白，那么你对面向对象的理解就很到位。 2.1 面向对象编程有什么好处？先来看第一个问题，面向对象编程到底有什么好处呢？ 那就不得不谈，Java的祖师爷对这个世界的理解了。 Java的祖师爷，詹姆斯高斯林认为，在这个世界中 万物皆对象！任何一个对象都可以包含一些数据，数据属于哪个对象，就由哪个对象来处理。 这样的话，只要我们找到了对象，其实就找到了对数据的处理方式。 所以面向对象编程的好处，用一句话总结就是：面向对象的开发更符合人类的思维习惯，让编程变得更加简单、更加直观。 2.2 程序中对象到底是个啥？说完面向对象编程有什么好处之后，这里有同学可能会有问题了，你刚才举的例子中，“汽车”、“手机”、“蔡徐坤”是一个实实在在的东西，你说是一个对象好理解。那我们程序中的对象到底是个啥呢？ 对象实质上是一种特殊的数据结构。这种结构怎么理解呢？ 你可以把对象理解成一张表格，表当中记录的数据，就是对象拥有的数据。 这就是程序中的对象到底是个啥！ 一句话总结，对象其实就是一张数据表，表当中记录什么数据，对象就处理什么数据。 2.3 对象是怎么出来的？刚刚我们讲到对象就是一张数据表，那么这个数据表是怎么来的呢？这张表是不会无缘无故存在的，因为Java也不知道你这个对象要处理哪些数据，所以这张表需要我们设计出来。 用什么来设计这张表呢？就是类（class），类可以理解成对象的设计图，或者对象的模板。 我们需要按照对象的设计图创造一个对象。设计图中规定有哪些数据，对象中就只能有哪些数据。 一句话总结：对象可以理解成一张数据表，而数据表中可以有哪些数据，是有类来设计的。 三、对象在计算机中的执行原理各位同学，前面我们已经带同学写了面向对象的代码，也知道对象到底是咋回事。如果我们再搞清楚对象在计算机中的执行原理，那我们对面向对象的理解就更加专业了。 按照我们之前讲的数组的执行原理，数组变量记录的其实数数组在堆内存中的地址。其实面向对象的代码执行原理和数组的执行原理是非常类似的。 其实Student s1 = new Student();这句话中的原理如下 Student s1表示的是在栈内存中，创建了一个Student类型的变量，变量名为s1 而new Student()会在堆内存中创建一个对象，而对象中包含学生的属性名和属性值 同时系统会为这个Student对象分配一个地址值0x4f3f5b24 接着把对象的地址赋值给栈内存中的变量s1，通过s1记录的地址就可以找到这个对象 当执行s1.name=“播妞”时，其实就是通过s1找到对象的地址，再通过对象找到对象的name属性，再给对象的name属性赋值为播妞; 搞明白Student s1 = new Student();的原理之后，Student s2 = new Student();原理完全一样，只是在堆内存中重新创建了一个对象，又有一个新的地址。s2.name是访问另对象的属性。 四、类和对象的一些注意事项各位同学，前面几节课我们已经入门了。接下来，关于面向对象有一些细枝末节的东西需要给大家交代一下。 我把这些注意事项已经列举在下面了，我们把几个不好理解的解释一下就可以了（标记方框），其他的大大家一看就能理解。 第一条：一个代码文件中，可以写多个class类，但是只能有一个是public修饰，且public修饰的类必须和文件名相同。 假设文件名为Demo1.java，这个文件中假设有两个类Demo1类和Student类，代码如下 12345678//public修饰的类Demo1，和文件名Demo1相同public class Demo1&#123; &#125;class Student&#123; &#125; 第二条：对象与对象之间的数据不会相互影响，但是多个变量指向同一个对象会相互影响。 如下图所示，s1和s2两个变量分别记录的是两个对象的地址值，各自修改各自属性值，是互不影响的。 如下图所示，s1和s2两个变量记录的是同一个对象的地址值，s1修改对象的属性值，再用s2访问这个属性，会发现已经被修改了。 五、this关键字各位同学，接下来我们学习几个面向对象的小知识点，这里我们先认识一下this关键字是什么含义，再说一下this的应用场景。 this是什么呢？ this就是一个变量，用在方法中，可以拿到当前类的对象。 我们看下图所示代码，通过代码来体会这句话到底是什么意思。哪一个对象调用方法方法中的this就是哪一个对象 上面代码运行结果如下 this有什么用呢？ 通过this在方法中可以访问本类对象的成员变量。我们看下图代码，分析打印结果是多少 分析上面的代码s3.score=325，调用方法printPass方法时，方法中的this.score也是325； 而方法中的参数score接收的是250。执行结果是 关于this关键字我们就学习到这里，重点记住这句话：哪一个对象调用方法方法中的this就是哪一个对象 六、构造器好同学们，接下来我们学习一个非常实用的语法知识——叫做构造器。 关于构造器，我们掌握下面几个问题就可以了： 什么是构造器？ 掌握构造器的特点？ 构造器的应用场景？ 构造器有哪些注意事项？ 我们一个问题一个问题的来学习，先来学习什么是构造器？ 什么是构造器？ 构造器其实是一种特殊的方法，但是这个方法没有返回值类型，方法名必须和类名相同。 如下图所示：下面有一个Student类，构造器名称也必须叫Student；也有空参数构造器，也可以有有参数构造器。 认识了构造器之后，接着我们看一下构造器有什么特点。 构造器的特点？ 在创建对象时，会调用构造器。 也就是说 new Student()就是在执行构造器，当构造器执行完了，也就意味着对象创建成功。 当执行new Student(&quot;播仔&quot;,99)创建对象时，就是在执行有参数构造器，当有参数构造器执行完，就意味着对象创建完毕了。 关于构造器的特点，我们记住一句话：new 对象就是在执行构造方法 构造器的应用场景？ 其实构造器就是用来创建对象的。可以在创建对象时给对象的属性做一些初始化操作。如下图所示： 构造器的注意事项？ 学习完构造器的应用场景之后，接下来我们再看一下构造器有哪些注意事项。 121.在设计一个类时，如果不写构造器，Java会自动生成一个无参数构造器。2.一定定义了有参数构造器，Java就不再提供空参数构造器，此时建议自己加一个无参数构造器。 关于构造器的这几个问题我们再总结一下。掌握这几个问题，构造方法就算完全明白了。 1234567891011121.什么是构造器？ 答：构造器其实是一种特殊的方法，但是这个方法没有返回值类型，方法名必须和类名相 同。 2.构造器什么时候执行？ 答：new 对象就是在执行构造方法；3.构造方法的应用场景是什么？ 答：在创建对象时，可以用构造方法给成员变量赋值4.构造方法有哪些注意事项？ 1)在设计一个类时，如果不写构造器，Java会自动生成一个无参数构造器。 2)一定定义了有参数构造器，Java就不再提供空参数构造器，此时建议自己加一个无参数构 造器。 七、封装性各位同学，接下来我们再学习一个面向对象很重要的特征叫做——封装性。 1. 什么是封装呢？ 所谓封装，就是用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理数据的方法，都设计到一个对象中去。 比如：在设计学生类时，把学生对象的姓名、语文成绩、数学成绩三个属性，以及求学生总分、平均分的方法，都封装到学生对象中来。 现在我们已经知道什么是封装了。那我们学习封装，学习个啥呢？ 其实在实际开发中，在用类设计对事处理的数据，以及对数据处理的方法时，是有一些设计规范的。 封装的设计规范用8个字总结，就是：合理隐藏、合理暴露 比如，设计一辆汽车时，汽车的发动机、变速箱等一些零件并不需要让每一个开车的知道，所以就把它们隐藏到了汽车的内部。 把发动机、变速箱等这些零件隐藏起来，这样做其实更加安全，因为并不是所有人都很懂发动机、变速箱，如果暴露在外面很可能会被不懂的人弄坏。 在设计汽车时，除了隐藏部分零件，但是还是得合理的暴露一些东西出来，让司机能够操纵汽车，让汽车跑起来。比如：点火按钮啊、方向盘啊、刹车啊、油门啊、档把啊… 这些就是故意暴露出来让司机操纵汽车的。 好了，到现在我们已经理解什么是封装的一些规范了。就是：合理暴露、合理隐藏 2. 封装在代码中的体现 知道什么是封装之后，那封装在代码中如何体现呢？一般我们在设计一个类时，会将成员变量隐藏，然后把操作成员变量的方法对外暴露。 这里需要用到一个修饰符，叫private，被private修饰的变量或者方法，只能在本类中被访问。 如下图所示，private double score; 就相当于把score变量封装在了Student对象的内部，且不对外暴露，你想要在其他类中访问score这个变量就，就不能直接访问了； 如果你想给Student对象的score属性赋值，得调用对外暴露的方法setScore(int score)，在这个方法中可以对调用者传递过来的数据进行一些控制，更加安全。 当你想获取socre变量的值时，就得调用对外暴露的另一个方法 getScore() 关于封装我们就学习到这里了。 八、实体JavaBean接下来，我们学习一个面向对象编程中，经常写的一种类——叫实体JavaBean类。我们先来看什么是实体类？ 1. 什么是实体类？ 实体类就是一种特殊的类，它需要满足下面的要求： 接下来我们按照要求，写一个Student实体类； 写完实体类之后，我们看一看它有什么特点？ 其实我们会发现实体类中除了有给对象存、取值的方法就没有提供其他方法了。所以实体类仅仅只是用来封装数据用的。 知道实体类有什么特点之后，接着我们看一下它有哪些应用场景？ 2. 实体类的应用场景 在实际开发中，实体类仅仅只用来封装数据，而对数据的处理交给其他类来完成，以实现数据和数据业务处理相分离。如下图所示 在实际应用中，会将类作为一种数据类型使用。如下图所示，在StudentOperator类中，定义一个Student类型的成员变量student，然后使用构造器给student成员变量赋值。 然后在Student的printPass()方法中，使用student调用Student对象的方法，对Student对象的数据进行处理。 到这里，我们已经学习了JavaBean实体类的是什么，以及它的应用场景，我们总结一下 12345671.JavaBean实体类是什么？有啥特点 JavaBean实体类，是一种特殊的；它需要私有化成员变量，有空参数构造方法、同时提供 getXxx和setXxx方法； JavaBean实体类仅仅只用来封装数据，只提供对数据进行存和取的方法 2.JavaBean的应用场景？ JavaBean实体类，只负责封装数据，而把数据处理的操作放在其他类中，以实现数据和数 据处理相分离。 九、面向对象综合案例学习完面向对象的语法知识之后。接下来，我们做一个面向对象的综合案例——模仿电影信息系统。 需求如下图所示 1. 想要展示系统中全部的电影信息（每部电影：编号、名称、价格） 2. 允许用户根据电影的编号（id），查询出某个电影的详细信息。 运行程序时，能够根据用户的选择，执行不同的功能，如下图所示 按照下面的步骤来完成需求 1. 第一步：定义电影类首先每一部电影，都包含这部电影的相关信息，比如：电影的编号（id）、电影的名称（name）、电影的价格（price）、电影的分数（score）、电影的导演（director）、电影的主演（actor）、电影的简介（info）。 为了去描述每一部电影，有哪些信息，我们可以设计一个电影类（Movie），电影类仅仅只是为了封装电影的信息，所以按照JavaBean类的标准写法来写就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Movie &#123; private int id; private String name; private double price; private double score; private String director; private String actor; private String info; public Movie() &#123; &#125; public Movie(int id, String name, double price, double score, String director, String actor, String info) &#123; this.id = id; this.name = name; this.price = price; this.score = score; this.director = director; this.actor = actor; this.info = info; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; public String getDirector() &#123; return director; &#125; public void setDirector(String director) &#123; this.director = director; &#125; public String getActor() &#123; return actor; &#125; public void setActor(String actor) &#123; this.actor = actor; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125; 2. 第二步：定义电影操作类前面我们定义的Movie类，仅仅只是用来封装每一部电影的信息。为了让电影数据和电影数据的操作相分离，我们还得有一个电影操作类（MovieOperator）。 因为系统中有多部电影，所以电影操作类中MovieOperator，需要有一个Movie[] movies; 用来存储多部电影对象； 同时在MovieOperator类中，提供对外提供，对电影数组进行操作的方法。如printAllMovies()用于打印数组中所有的电影信息，searchMovieById(int id)方法根据id查找一个电影的信息并打印。 1234567891011121314151617181920212223242526272829303132333435363738public class MovieOperator &#123; //因为系统中有多部电影，所以电影操作类中，需要有一个Movie的数组 private Movie[] movies; public MovieOperator(Movie[] movies)&#123; this.movies = movies; &#125; /** 1、展示系统全部电影信息 movies = [m1, m2, m3, ...]*/ public void printAllMovies()&#123; System.out.println(&quot;-----系统全部电影信息如下：-------&quot;); for (int i = 0; i &lt; movies.length; i++) &#123; Movie m = movies[i]; System.out.println(&quot;编号：&quot; + m.getId()); System.out.println(&quot;名称：&quot; + m.getName()); System.out.println(&quot;价格：&quot; + m.getPrice()); System.out.println(&quot;------------------------&quot;); &#125; &#125; /** 2、根据电影的编号查询出该电影的详细信息并展示 */ public void searchMovieById(int id)&#123; for (int i = 0; i &lt; movies.length; i++) &#123; Movie m = movies[i]; if(m.getId() == id)&#123; System.out.println(&quot;该电影详情如下：&quot;); System.out.println(&quot;编号：&quot; + m.getId()); System.out.println(&quot;名称：&quot; + m.getName()); System.out.println(&quot;价格：&quot; + m.getPrice()); System.out.println(&quot;得分：&quot; + m.getScore()); System.out.println(&quot;导演：&quot; + m.getDirector()); System.out.println(&quot;主演：&quot; + m.getActor()); System.out.println(&quot;其他信息：&quot; + m.getInfo()); return; // 已经找到了电影信息，没有必要再执行了 &#125; &#125; System.out.println(&quot;没有该电影信息~&quot;); &#125;&#125; 3. 第三步：定义测试类最后，我们需要在测试类中，准备好所有的电影数据，并用一个数组保存起来。每一部电影的数据可以封装成一个对象。然后把对象用数组存起来即可。 123456789101112public class Test &#123; public static void main(String[] args) &#123; //创建一个Movie类型的数组 Movie[] movies = new Movie[4]; //创建4个电影对象，分别存储到movies数组中 movies[0] = new Movie(1,&quot;水门桥&quot;, 38.9, 9.8, &quot;徐克&quot;, &quot;吴京&quot;,&quot;12万人想看&quot;); movies[1] = new Movie(2, &quot;出拳吧&quot;, 39, 7.8, &quot;唐晓白&quot;, &quot;田雨&quot;,&quot;3.5万人想看&quot;); movies[2] = new Movie(3,&quot;月球陨落&quot;, 42, 7.9, &quot;罗兰&quot;, &quot;贝瑞&quot;,&quot;17.9万人想看&quot;); movies[3] = new Movie(4,&quot;一点就到家&quot;, 35, 8.7, &quot;许宏宇&quot;, &quot;刘昊然&quot;,&quot;10.8万人想看&quot;); &#125;&#125; 准备好测试数据之后，接下来就需要对电影数据进行操作。我们已经把对电影操作先关的功能写到了MovieOperator类中，所以接下来，创建MovieOperator类对象，调用方法就可以完成相关功能。 继续再main方法中，接着写下面的代码。 123456789101112131415161718192021222324// 4、创建一个电影操作类的对象，接收电影数据，并对其进行业务处理MovieOperator operator = new MovieOperator(movies);Scanner sc = new Scanner(System.in);while (true) &#123; System.out.println(&quot;==电影信息系统==&quot;); System.out.println(&quot;1、查询全部电影信息&quot;); System.out.println(&quot;2、根据id查询某个电影的详细信息展示&quot;); System.out.println(&quot;请您输入操作命令：&quot;); int command = sc.nextInt(); switch (command) &#123; case 1: // 展示全部电影信息 operator.printAllMovies(); break; case 2: // 根据id查询某个电影的详细信息展示 System.out.println(&quot;请您输入查询的电影id:&quot;); int id = sc.nextInt(); operator.searchMovieById(id); break; default: System.out.println(&quot;您输入的命令有问题~~&quot;); &#125;&#125; 到这里，电影信息系统就完成了。 小伙伴们，自己尝试写一下吧！！ 十、成员变量和局部变量的区别各位同学，面向对象的基础内容咱们已经学习完了。同学们在面向对象代码时，经常会把成员变量和局部变量搞混。所以现在我们讲一讲他们的区别。 如下图所示，成员变量在类中方法外，而局部变量在方法中。 到这里，我们关于面向对象的基础知识就学习完了。面向对象的核心点就是封装，将数据和数据的处理方式，都封装到对象中； 至于对象要封装哪些数据？对数据进行怎样的处理？ 需要通过类来设计。 需要注意的是，不同的人，对同一个对象进行设计，对象封装那些数据，提供哪些方法，可能会有所不同；只要能够完成需求，符合设计规范，都是合理的设计。","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day08-Java常用API","slug":"day08-Java常用API","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day08-Java常用API/","link":"","permalink":"https://wxzhou.top/2020/05/05/day08-Java%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"各位同学，我们前面已经学习了面向对象编程，使用面向编程这个套路，我们需要自己写类，然后创建对象来解决问题。但是在以后的实际开发中，更多的时候，我们是利用面向编程这种套路，使用别人已经写好的类来编程的。 这就是我们今天要学习的内容——常用API（全称是Application Program Interface 应用程序接口），说人话就是：别人写好的一些程序，给咱们程序员直接拿去调用。 Java官方其实已经给我们写好了很多很多类，每一个类中又提供了一系列方法来解决与这个类相关的问题。 比如String类，表示字符串，提供的方法全都是对字符串操作的。 比如ArrayList类，表示一个容器，提供的方法都是对容器中的数据进行操作的。 像这样的类还有很多，Java把这些类是干什么用的、类中的每一个方法是什么含义，编写成了文档，我们把这个文档称之为API文档。 1. 我们为什么要学习别人写好的程序呢？ ​ 在行业中有这么一句话：“不要重复造轮子”。这里所说的轮子就是别人已经写过的程序。意思就是不要写重复的程序，因为程序是用来解决问题的，如果这个问题别人已经解决过，并且这个解决方案也得到了市场认可，那就不用再自己重复写这个程序了。 ​ Java已经发展了20多年，在这20多年里，已经积累类了很多问题的解决方案，基本上现在我们遇到的问题，在这20多年里，早就有人解决过。 ​ 所以我们把面向对象的高级知识学习完之后，Java语言的语法知识就已经学习完了。剩下的所有内容都是是学习一个一个的API，通过调用API提供的方法来解决实际问题。 2. 我们要学习哪些API Java的API文档中，有那么多的类，是所有的类都要学习吗？并不是 ，虽然Java提供了很多个类，但是并不是所有类都得到了市场认可，我们只学习一些在工作中常用的就行。 除了Java官方提供的API，还一些第三方的公司或者组织也会提供一些API，甚至比Java官方提供的API更好用，在需要的时候我们也会告诉大家怎么用。 3. 今天我们主要学习两个类，一个是String类、还有一个是ArrayList类。 字符串的应用场景是非常多的，可以说是无处不在。 比如，在用户登录时，需要对用户名和密码进行校验，这里的用户名和密码都是String 再比如，在和网友聊天时，其实输入的文字就是一个一个字符串 再比如，在百度上搜索时，搜素的关键词，也是字符串 学习完String类之后，还会学习一个类ArrayList 大家知道数组是一个容器，有数组干嘛还要集合呢？ 因为数字的长度是固定的，一旦创建不可改变。 比如数组的长度为3，想要存储第4个元素就存不进去了。 使用集合就可以解决上面的问题，集合可以根据需要想存多少个元素就存多少个元素。 二、包1. 什么是包 在学习API类之前，我们先要学习包。因为Java官方提供的类有很多，为了对这些类进行分门别类的管理，别人把写好的类都是放在不同的包里的。 包其实类似于文件夹，一个包中可以放多个类文件。如下图所示 建包的语法格式： 123456//类文件的第一行定义包package com.itheima.javabean;public class 类名&#123; &#125; 2. 在自己的程序中，调用其他包中的程序，需要注意下面一个问题 如果当前程序中，要调用自己所在包下的其他程序，可以直接调用。（同一个包下的类，互相可以直接调用） 如果当前程序中，要调用其他包下的程序，则必须在当前程序中导包, 才可以访问！ 导包格式： import 包名.类名 如果当前程序中，要调用Java.lang包下的程序，不需要我们导包的，可以直接使用。 如果当前程序中，要调用多个不同包下的程序，而这些程序名正好一样，此时默认只能导入一个程序，另一个程序必须带包名访问。 三、String类1. String类概述各位同学，接下来我们学习String这个类，也就是学对字符串进行处理。为什么要学习字符串处理呢？因为在开发中对于字符串的处理还是非常常见的。 比如：在用户登录时，用户输入的用户名和密码送到后台，需要和正确的用户名和密码进行校验，这就需要用到String类提供的比较功能。 再比如：同学们在直播留言时，有些小伙伴可能不太文明说了一些脏话，后台检测到你输入的是脏话，就会用***把脏话屏蔽掉。这也需要用到String类提供的替换功能 Java为了方便我们处理字符串，所以给我们提供了一个String类来代表字符串，这个类就是java.lang包下。 按照面向对象的编程思想，对于字符串的操作，只需要创建字符串对象，用字符串对象封装字符串数据，然后调用String类的方法就可以了。 2. String创建对象接下来我们打开String类的API，看一下String类的对象如何创建。如下图所示 String类的API中，有这么一句话：“Java程序中的所有字符串字面值（如”abc”）都是字符串的实例实现”。这里所说的实例实现，其实指的就是字符串对象。 意思就是：所有Java的字符串字面值，都是字符串对象。 所以创建String对象的第一种方式就有了 123String s1 = &quot;abc&quot;; //这里&quot;abc&quot;就是一个字符串对象，用s1变量接收String s2 = &quot;黑马程序员&quot;; //这里的“黑马程序员”也是一个字符串对象，用s2变量接收 创建String对象还有第二种方式，就是利用String类的构造方法创建String类的对象。 我们前面学习过类的构造方法，执行构造方法需要用到new关键字。new String(参数)就是在执行String类的构造方法。 下面我们演示通过String类的构造方法，创建String类的对象 123456789101112131415161718// 1、直接双引号得到字符串对象，封装字符串数据String name = &quot;黑马666&quot;;System.out.println(name);// 2、new String创建字符串对象，并调用构造器初始化字符串String rs1 = new String();System.out.println(rs1); // &quot;&quot;String rs2 = new String(&quot;itheima&quot;);System.out.println(rs2);char[] chars = &#123;&#x27;a&#x27;, &#x27;黑&#x27;, &#x27;马&#x27;&#125;;String rs3 = new String(chars);System.out.println(rs3);byte[] bytes = &#123;97, 98, 99&#125;;String rs4 = new String(bytes);System.out.println(rs4); 关于String类是用来干什么的，以及String类对象的创建我们就学习到这里。最后总结一下 1234561. String是什么，可以做什么？ 答：String代表字符串，可以用来创建对象封装字符串数据，并对其进行处理。2.String类创建对象封装字符串数据的方式有几种？ 方式一： 直接使用双引号“...” 。 方式二：new String类，调用构造器初始化字符串对象。 3. String类的常用方法各位同学，在上一节课中，我们学习了如何通过字符串对象封装数据，接下来我们学习调用String类的方法对象字符串数据进行处理。 这里已经将String类的常用方法，给同学们挑出来了，我们先快速的认识一下。为什么是快速认识一下呢？因为API真正的作用是来解决业务需求的，如果不解决业务需求，只是记API是很难记住的。 所以API的正确打开方式是，先找到这个类，把这个类中的方法先用代码快速过一遍，有一个大概印象就行。然后再具体的案例中，选择你需要的方法来用就行。 下面我们就把String类中的方法，按照方法的调用规则，先快速过一遍。（注意：第一次调用API方法，都是看着API方法来调用用的，不是背的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class StringDemo2 &#123; public static void main(String[] args) &#123; //目标：快速熟悉String提供的处理字符串的常用方法。 String s = &quot;黑马Java&quot;; // 1、获取字符串的长度 System.out.println(s.length()); // 2、提取字符串中某个索引位置处的字符 char c = s.charAt(1); System.out.println(c); // 字符串的遍历 for (int i = 0; i &lt; s.length(); i++) &#123; // i = 0 1 2 3 4 5 char ch = s.charAt(i); System.out.println(ch); &#125; System.out.println(&quot;-------------------&quot;); // 3、把字符串转换成字符数组，再进行遍历 char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; System.out.println(chars[i]); &#125; // 4、判断字符串内容，内容一样就返回true String s1 = new String(&quot;黑马&quot;); String s2 = new String(&quot;黑马&quot;); System.out.println(s1 == s2); // false System.out.println(s1.equals(s2)); // true // 5、忽略大小写比较字符串内容 String c1 = &quot;34AeFG&quot;; String c2 = &quot;34aEfg&quot;; System.out.println(c1.equals(c2)); // false System.out.println(c1.equalsIgnoreCase(c2)); // true // 6、截取字符串内容 (包前不包后的) String s3 = &quot;Java是最好的编程语言之一&quot;; String rs = s3.substring(0, 8); System.out.println(rs); // 7、从当前索引位置一直截取到字符串的末尾 String rs2 = s3.substring(5); System.out.println(rs2); // 8、把字符串中的某个内容替换成新内容，并返回新的字符串对象给我们 String info = &quot;这个电影简直是个垃圾，垃圾电影！！&quot;; String rs3 = info.replace(&quot;垃圾&quot;, &quot;**&quot;); System.out.println(rs3); // 9、判断字符串中是否包含某个关键字 String info2 = &quot;Java是最好的编程语言之一，我爱Java,Java不爱我！&quot;; System.out.println(info2.contains(&quot;Java&quot;)); System.out.println(info2.contains(&quot;java&quot;)); System.out.println(info2.contains(&quot;Java2&quot;)); // 10、判断字符串是否以某个字符串开头。 String rs4 = &quot;张三丰&quot;; System.out.println(rs4.startsWith(&quot;张&quot;)); System.out.println(rs4.startsWith(&quot;张三&quot;)); System.out.println(rs4.startsWith(&quot;张三2&quot;)); // 11、把字符串按照某个指定内容分割成多个字符串，放到一个字符串数组中返回给我们 String rs5 = &quot;张无忌,周芷若,殷素素,赵敏&quot;; String[] names = rs5.split(&quot;,&quot;); for (int i = 0; i &lt; names.length; i++) &#123; System.out.println(names[i]); &#125; &#125;&#125; 演示完String类的这些方法之后，我们对字符串有哪些方法，就已经有一个大致印象了。至少知道String字符串能干哪些事情。 至于String类的这些方法是否都记住了，这个还需要通过一些案例训练，在用的过程中去找哪个方法能够解决你的实际需求，就用哪个方法。同一个方法用的次数多个，自然就记住了。 4. String的注意事项在上一节，我们学习了字符串的一些常用方法，在实际工作中用这些方法解决字符串的常见问题是完全足够的，但是在面试时可能会问一些原理性的东西。 所以把字符串原理性的内容，就当做注意事项来学习一下。一共有下面的2点： 注意事项1：String类的对象是不可变的对象 我们先看一段代码，分析这段代码的结果 以上代码中，先定义了一个String变量 name第一次赋值为“黑马”; 然后对name变量记录的字符串进行两次拼接，第一次拼接“程序员”，第二次拼接“播妞”；我们发现得到的结果是：黑马程序员播妞 这里问题就来了，你不是是说：String类的对象是不可变的字符串对象吗？我看name的值变了呀！！！ 下面我们就解释一下，String是不可变对象到底是什么含义。 需要注意的是：只要是以“”方式写出的字符串对象，会在堆内存中的字符串常量池中存储。 执行第一句话时，会在堆内存的常量池中，创建一个字符串对象“黑马”，然后把“黑马”的地址赋值给String name 当执行第二句话时，又会再堆内存的常量池中创建一个字符串“程序员”，和“黑马”拼接，拼接之后还会产生一个新的字符串对象”黑马程序员“，然后将新产生的“黑马程序员”对象的地址赋值给String name变量。 此时你会发现，之前创建的字符串对象“黑马”内容确实是没有改变的。所以说String的对象是不可变的。 注意事项2：字符串字面量和new出来字符串的区别 只要是以“...”方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份。如下图一所示 但通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中。如下图二所示 总结一下，字符串的注意事项。 1231. String是不可变字符串对象2. 只要是以“...”方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份；3. 但通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中。 5. String案例一：用户登录案例接下来给大家做一个案例，使用字符串的功能完成登录案例。案例需求如下： 12345分析一下完成案例的步骤： 1.首先，从登录界面上可以得出，需要让用户输入登录名和密码 2.设计一个登录方法，对用户名和密码进行校验 3.调用登录方法，根据方法的返回结果，判断登录是否成功。 4.如果登录失败，循环登录3次，结束循环；如果登录成功，跳出循环; 案例分析的步骤完成代码 123456789101112131415161718192021222324252627282930313233343536373839404142/** 目标：完成用户的登录案例。 */public class StringTest4 &#123; public static void main(String[] args) &#123; // 1、开发一个登录界面 for (int i = 0; i &lt; 3; i++) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请您输入登录名称：&quot;); String loginName = sc.next(); System.out.println(&quot;请您输入登录密码：&quot;); String passWord = sc.next(); // 5、开始调用登录方法，判断是否登录成功 boolean rs = login(loginName, passWord); if(rs)&#123; System.out.println(&quot;恭喜您，欢迎进入系统~~&quot;); break; // 跳出for循环，代表登录完成 &#125;else &#123; System.out.println(&quot;登录名或者密码错误，请您确认~~&quot;); &#125; &#125; &#125; /** 2、开发一个登录方法，接收用户的登录名和密码，返回认证的结果 */ public static boolean login(String loginName, String passWord)&#123; // 3、准备一份系统正确的登录名和密码 String okLoginName = &quot;itheima&quot;; String okPassWord = &quot;123456&quot;; // 4、开始正式判断用户是否登录成功 /*if(okLoginName.equals(loginName) &amp;&amp; okPassWord.equals(passWord))&#123; // 登录成功的 return true; &#125;else &#123; return false; &#125;*/ return okLoginName.equals(loginName) &amp;&amp; okPassWord.equals(passWord); &#125;&#125; 6. String案例二：随机产生验证码接下来学习一个再工作中也比较常见的案例，使用String来开发验证码。需求如下： 123456789根据需求分析，步骤如下： 1.首先，设计一个方法，该方法接收一个整型参数，最终要返回对应位数的随机验证码。 2.方法内定义2个字符串变量： 1个用来记住生成的验证码，1个用来记住要用到的全部字符。 3.定义for循环控制生成多少位随机字符 4.每次得到一个字符范围内的随机索引 5.根据索引提取该字符，把该字符交给code变量连接起 6.循环结束后，在循环外返回code即可。 7.在主方法中调用生成验证码的方法 根据步骤完成代码 12345678910111213141516171819202122232425262728293031import java.util.Random;/** 目标：完成随机产生验证码，验证码的每位可能是数字、大写字母、小写字母 */public class StringTest5 &#123; public static void main(String[] args) &#123; System.out.println(createCode(4)); System.out.println(createCode(6)); &#125; /** 1、设计一个方法，返回指定位数的验证码 */ public static String createCode(int n)&#123; // 2、定义2个变量 //一个是记住最终产生的随机验证码 //一个是记住可能用到的全部字符 String code = &quot;&quot;; String data = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; Random r = new Random(); // 3、开始定义一个循环产生每位随机字符 for (int i = 0; i &lt; n; i++) &#123; // 4、随机一个字符范围内的索引。 int index = r.nextInt(data.length()); // 5、根据索引去全部字符中提取该字符 code += data.charAt(index); // code = code + 字符 &#125; // 6、返回code即可 return code; &#125;&#125; 关于String的案例，我们先练习到这里。以后遇到对字符串进行操作的需求，优先找String类有没有提供对应的方法。 四、ArrayList类1. ArrayList快速入门学习完String类之后，接下来再学习一个类——叫ArrayList。 ArrayList表示一种集合，它是一个容器，用来装数据的，类似于数组。那有了数组，为什么要有集合呢？ 因为数组一旦创建大小不变，比如创建一个长度为3的数组，就只能存储3个元素，想要存储第4个元素就不行。而集合是大小可变的，想要存储几个元素就存储几个元素，在实际工作中用得更多。 然后集合有很多种，而ArrayList只是众多集合中的一种，跟多的集合我们在就业班的课程中再学习。如下图所示： 集合该怎么学呢？1. 首先你要会创建集合对象，2. 然后能够调用集合提供的方法对容器中的数据进行增删改查，3. 最后知道集合的一些特点就可以了。 2. ArrayList常用方法想要使用ArrayList存储数据，并对数据进行操作： 第一步：创建ArrayList容器对象。一般使用空参数构造方法，如下图所示： 第二步：调用ArrayList类的常用方法对容器中的数据进行操作。常用方法如下： 接下来我们把ArrayList集合的这些方法快速的熟悉一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**目标：要求同学们掌握如何创建ArrayList集合的对象，并熟悉ArrayList提供的常用方法。 */public class ArrayListDemo1 &#123; public static void main(String[] args) &#123; // 1、创建一个ArrayList的集合对象 // ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 从jdk 1.7开始才支持的 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;黑马&quot;); list.add(&quot;黑马&quot;); list.add(&quot;Java&quot;); System.out.println(list); // 2、往集合中的某个索引位置处添加一个数据 list.add(1, &quot;MySQL&quot;); System.out.println(list); // 3、根据索引获取集合中某个索引位置处的值 String rs = list.get(1); System.out.println(rs); // 4、获取集合的大小（返回集合中存储的元素个数） System.out.println(list.size()); // 5、根据索引删除集合中的某个元素值，会返回被删除的元素值给我们 System.out.println(list.remove(1)); System.out.println(list); // 6、直接删除某个元素值，删除成功会返回true，反之 System.out.println(list.remove(&quot;Java&quot;)); System.out.println(list); list.add(1, &quot;html&quot;); System.out.println(list); // 默认删除的是第一次出现的这个黑马的数据的 System.out.println(list.remove(&quot;黑马&quot;)); System.out.println(list); // 7、修改某个索引位置处的数据，修改后会返回原来的值给我们 System.out.println(list.set(1, &quot;黑马程序员&quot;)); System.out.println(list); &#125;&#125; 3. ArrayList应用案例1接下来，我们学习一个ArrayList的应用案例，需求如下： 我们分析一下这个案例的步骤该如何实现： 1234561.用户可以选购多个商品，可以创建一个ArrayList集合，存储这些商品2.按照需求，如果用户选择了&quot;枸杞&quot;批量删除，应该删除包含&quot;枸杞&quot;的所有元素 1)这时应该遍历集合中每一个String类型的元素 2)使用String类的方法contains判断字符串中是否包含&quot;枸杞&quot; 3)包含就把元素删除3.输出集合中的元素，看是否包含&quot;枸杞&quot;的元素全部删除 按照分析的步骤，完成代码 1234567891011121314151617181920212223242526272829public class ArrayListTest2 &#123; public static void main(String[] args) &#123; // 1、创建一个ArrayList集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;枸杞&quot;); list.add(&quot;Java入门&quot;); list.add(&quot;宁夏枸杞&quot;); list.add(&quot;黑枸杞&quot;); list.add(&quot;人字拖&quot;); list.add(&quot;特级枸杞&quot;); list.add(&quot;枸杞子&quot;); System.out.println(list); //运行结果如下： [Java入门, 宁夏枸杞, 黑枸杞, 人字拖, 特级枸杞, 枸杞子] // 2、开始完成需求：从集合中找出包含枸杞的数据并删除它 for (int i = 0; i &lt; list.size(); i++) &#123; // i = 0 1 2 3 4 5 // 取出当前遍历到的数据 String ele = list.get(i); // 判断这个数据中包含枸杞 if(ele.contains(&quot;枸杞&quot;))&#123; // 直接从集合中删除该数据 list.remove(ele); &#125; &#125; System.out.println(list); //删除后结果如下：[Java入门, 黑枸杞, 人字拖, 枸杞子] &#125;&#125; 运行完上面代码，我们会发现，删除后的集合中，竟然还有黑枸杞，枸杞子在集合中。这是为什么呢？ 枸杞子被保留下来，原理是一样的。可以自行分析。 那如何解决这个问题呢？这里打算给大家提供两种解决方案： 集合删除元素方式一：每次删除完元素后，让控制循环的变量i--就可以了；如下图所示 具体代码如下： 12345678910111213// 方式一：每次删除一个数据后，就让i往左边退一步for (int i = 0; i &lt; list.size(); i++) &#123; // i = 0 1 2 3 4 5 // 取出当前遍历到的数据 String ele = list.get(i); // 判断这个数据中包含枸杞 if(ele.contains(&quot;枸杞&quot;))&#123; // 直接从集合中删除该数据 list.remove(ele); i--; &#125;&#125;System.out.println(list); 集合删除元素方式二：我们只需要倒着遍历集合，在遍历过程中删除元素就可以了 具体代码如下： 12345678910111213// 方式二：从集合的后面倒着遍历并删除// [Java入门, 人字拖]// ifor (int i = list.size() - 1; i &gt;= 0; i--) &#123; // 取出当前遍历到的数据 String ele = list.get(i); // 判断这个数据中包含枸杞 if(ele.contains(&quot;枸杞&quot;))&#123; // 直接从集合中删除该数据 list.remove(ele); &#125;&#125;System.out.println(list); 4. ArrayList应用案例2各位同学，上一个ArrayList应用案例中，我们往集合存储的元素是String类型的元素，实际上在工作中我们经常往集合中自定义存储对象。 接下来我们做个案例，用来往集合中存储自定义的对象，先阅读下面的案例需求： 分析需求发现： 在外卖系统中，每一份菜都包含，菜品的名称、菜品的原价、菜品的优惠价、菜品的其他信息。那我们就可以定义一个菜品类（Food类），用来描述每一个菜品对象要封装那些数据。 接着再写一个菜品管理类（FoodManager类），提供展示操作界面、上架菜品、浏览菜品的功能。 首先我们先定义一个菜品类（Food类），用来描述每一个菜品对象要封装那些数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Food &#123; private String name; //菜品名称 private double originalPrice; //菜品原价 private double specialPrice; //菜品优惠价 private String info; //菜品其他信息 public Food() &#123; &#125; public Food(String name, double originalPrice, double specialPrice, String info) &#123; this.name = name; this.originalPrice = originalPrice; this.specialPrice = specialPrice; this.info = info; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getOriginalPrice() &#123; return originalPrice; &#125; public void setOriginalPrice(double originalPrice) &#123; this.originalPrice = originalPrice; &#125; public double getSpecialPrice() &#123; return specialPrice; &#125; public void setSpecialPrice(double specialPrice) &#123; this.specialPrice = specialPrice; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125; 接下来写一个菜品管理类，提供上架菜品的功能、浏览菜品的功能、展示操作界面的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class FoodManager&#123; //为了存储多个菜品，预先创建一个ArrayList集合； //上架菜品时，其实就是往集合中添加菜品对象 //浏览菜品时，其实就是遍历集合中的菜品对象，并打印菜品对象的属性信息。 private ArrayList&lt;Food&gt; foods = new ArrayList&lt;&gt;(); //为了在下面的多个方法中，能够使用键盘录入，提前把Scanner对象创建好； private Scanner sc = new Scanner(System.in); /** 1、商家上架菜品 */ public void add()&#123; System.out.println(&quot;===菜品上架==&quot;); // 2、提前创建一个菜品对象，用于封装用户上架的菜品信息 Food food = new Food(); System.out.println(&quot;请您输入上架菜品的名称：&quot;); String name = sc.next(); food.setName(name); System.out.println(&quot;请您输入上架菜品的原价：&quot;); double originalPrice = sc.nextDouble(); food.setOriginalPrice(originalPrice); System.out.println(&quot;请您输入上架菜品的优惠价：&quot;); double specialPrice = sc.nextDouble(); food.setSpecialPrice(specialPrice); System.out.println(&quot;请您输入上架菜品的其他信息：&quot;); String info = sc.next(); food.setInfo(info); // 3、把菜品对象添加到集合容器中去 foods.add(food); System.out.println(&quot;恭喜您，上架成功~~~&quot;); &#125; /** 2、菜品；浏览功能 */ public void printAllFoods()&#123; System.out.println(&quot;==当前菜品信息如下：==&quot;); for (int i = 0; i &lt; foods.size(); i++) &#123; Food food = foods.get(i); System.out.println(&quot;菜品名称：&quot; + food.getName()); System.out.println(&quot;菜品原价：&quot; + food.getOriginalPrice()); System.out.println(&quot;菜品优惠价：&quot; + food.getSpecialPrice()); System.out.println(&quot;其他描述信息：&quot; + food.getInfo()); System.out.println(&quot;------------------------&quot;); &#125; &#125; /** 3、专门负责展示系统界面的 */ public void start()&#123; while (true) &#123; System.out.println(&quot;====欢迎进入商家后台管理系统=====&quot;); System.out.println(&quot;1、上架菜品（add）&quot;); System.out.println(&quot;2、浏览菜品（query）&quot;); System.out.println(&quot;3、退出系统（exit）&quot;); System.out.println(&quot;请您选择操作命令：&quot;); String command = sc.next(); switch (command) &#123; case &quot;add&quot;: add(); break; case &quot;query&quot;: printAllFoods(); break; case &quot;exit&quot;: return; // 结束当前方法！ default: System.out.println(&quot;您输入的操作命令有误~~&quot;); &#125; &#125; &#125;&#125; 最后在写一个测试类Test，在测试类中进行测试。其实测试类，只起到一个启动程序的作用。 123456public class Test &#123; public static void main(String[] args) &#123; FoodManager manager = new FoodManager(); manager.start(); &#125;&#125; 运行结果如下：需要用户输入add、query或者exit，选择进入不同的功能。 好了，如果你能够把这个案例写出来，说明你对面向对象的思维封装数据，以及使用ArrayList容器存储数据，并对数据进行处理这方面的知识已经运用的很熟悉了。","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day09-Java基础综合项目（ATM系统）","slug":"day09-Java基础综合项目（ATM系统）","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day09-Java基础综合项目（ATM系统）/","link":"","permalink":"https://wxzhou.top/2020/05/05/day09-Java%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E9%A1%B9%E7%9B%AE%EF%BC%88ATM%E7%B3%BB%E7%BB%9F%EF%BC%89/","excerpt":"","text":"一、ATM项目介绍1. ATM系统功能介绍 大家都应该去过银行的ATM机上取过钱，每次取钱的时候，首先需要用户把卡插入机器，然后机器会自动读取你的卡号，由用户输入密码，如果密码校验通过，就会进入ATM机的主操作界面：有查询、取款、存款、转账等业务功能，用户选择哪个功能就执行对应预先设定好的程序。 由于没有图形化界面编程，所以我们是做不出界面效果的，但是我们可以在控制台模拟ATM机的各项功能。 如下图所示：运行程序时，进入登录界面，在此界面可以登录、或者开户。 在登录界面，如果用户录入2就进入用户开户的功能：如下图所示 在登录界面，如果用户录入1就进入用户登录的功能：如下图所示： 各位同学，你可能会觉得这个案例功能怎么这么多啊！ 太复杂了，其实也没你想得那么复杂。接下来，我将手把手带领大家把这个ATM系统完成。 2. ATM系统中我们会用到哪些技术呢？ 如下图所示：该项目涵盖了我们前面所学习的所有知识点，包括面向对象编程、集合容器的使用、流程控制、常用的API（比如String的运用）等。 3. 完成ATM系统，我们能收获什么 二、项目架构搭建、欢迎界面设计接下来，我们带着大家开始开发这个ATM系统。首先我们来完成项目的架构搭建、和欢迎界面的设计。 首先我们来分析一下，开发这个ATM系统的流程： 由于每一个账户都包含一些个人信息，比如：卡号、姓名、性别、密码、余额、每次取现额度等等。所以，首先可以设计一个Account类，用来描述账户对象需要封装那些数据。 紧接着，定义一个ATM类，用来表示ATM系统，负责提供所有的业务需求。 比如：展示ATM系统的欢迎页面、开户、登录、转账等功能。 最后，定义一个测试类Test，负责启动我们开发好的ATM系统，进行测试。 第一步：先来完成Account类的编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//首先可以设计一个Account类，来描述账户对象需要封装哪些数据。public class Account &#123; private String cardId; //卡号 private String userName; //用户名 private char sex; //性别 private String passWord;//密码 private double money; //余额 private double limit; // 限额 public String getCardId() &#123; return cardId; &#125; public void setCardId(String cardId) &#123; this.cardId = cardId; &#125; public String getUserName() &#123; return userName + ( sex == &#x27;男&#x27; ? &quot;先生&quot; : &quot;女士&quot;); &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; public double getLimit() &#123; return limit; &#125; public void setLimit(double limit) &#123; this.limit = limit; &#125;&#125; 第二步：编写一个ATM类，负责对每一个账户对象进行管理 1234public class ATM &#123; //创建一个存储账户对象的集合；后面每开一个账户，就往集合中添加一个账户对象 private ArrayList&lt;Account&gt; accounts = new ArrayList&lt;&gt;(); &#125; 第三步：在ATM类中，编写欢迎界面 1234567891011121314151617181920212223242526272829public class ATM &#123; //创建一个存储账户对象的集合；后面每开一个账户，就往集合中添加一个账户对象 private ArrayList&lt;Account&gt; accounts = new ArrayList&lt;&gt;(); //为了后面键盘录入方便一点，先创建好一个Scanner对象 private Scanner sc = new Scanner(System.in); /**启动ATM系统 展示欢迎界面 */ public void start()&#123; while (true) &#123; System.out.println(&quot;===欢迎您进入到了ATM系统===&quot;); System.out.println(&quot;1、用户登录&quot;); System.out.println(&quot;2、用户开户&quot;); System.out.println(&quot;请选择：&quot;); int command = sc.nextInt(); switch (command)&#123; case 1: // 用户登录 System.out.println(&quot;进入登录功能&quot;); break; case 2: // 用户开户 System.out.println(&quot;进入开户功能&quot;); break; default: System.out.println(&quot;没有该操作~~&quot;); &#125; &#125; &#125;&#125; 三、开户功能实现接下来，我们完成开户功能的实现。需求如下： 为了系统的代码结构更加清晰，在ATM类中，写一个开户的方法。 步骤如下： 1、创建一个账户对象，用于封装用户的开户信息 2、需要用户输入自己的开户信息，赋值给账户对象 输入账户名，设置给账户对象 输入性别，如果性别是&#39;男&#39;或者&#39;女&#39;，将性别设置给账户对象；否则重新录入性别知道录入正确为止。 输入账户、并且输入两次密码，只有两次密码相同，才将账户和密码设置给账户对象。 输入提现限额，并且设置给账户对象 3、输出开户成功，的提示语句。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** 完成用户开户操作 */private void createAccount()&#123; System.out.println(&quot;==系统开户操作==&quot;); // 1、创建一个账户对象，用于封装用户的开户信息 Account acc = new Account(); // 2、需要用户输入自己的开户信息，赋值给账户对象 System.out.println(&quot;请您输入您的账户名称：&quot;); String name = sc.next(); acc.setUserName(name); while (true) &#123; System.out.println(&quot;请您输入您的性别：&quot;); char sex = sc.next().charAt(0); // &quot;男&quot; if(sex == &#x27;男&#x27; || sex == &#x27;女&#x27;)&#123; acc.setSex(sex); break; &#125;else &#123; System.out.println(&quot;您输入的性别有误~只能是男或者女~&quot;); &#125; &#125; while (true) &#123; System.out.println(&quot;请您输入您的账户密码：&quot;); String passWord = sc.next(); System.out.println(&quot;请您输入您的确认密码：&quot;); String okPassWord = sc.next(); // 判断2次密码是否一样。 if(okPassWord.equals(passWord))&#123; acc.setPassWord(okPassWord); break; &#125;else &#123; System.out.println(&quot;您输入的2次密码不一致，请您确认~~&quot;); &#125; &#125; System.out.println(&quot;请您输入您的取现额度：&quot;); double limit = sc.nextDouble(); acc.setLimit(limit); // 重点：我们需要为这个账户生成一个卡号（由系统自动生成。8位数字表示，不能与其他账户的卡号重复：会在下节课详细讲解） //TODO 这里先留着，待会把生成卡号的功能写好，再到这里调用 // 3、把这个账户对象，存入到账户集合中去 accounts.add(acc); System.out.println(&quot;恭喜您，&quot; + acc.getUserName() + &quot;开户成功，您的卡号是：&quot; + acc.getCardId());&#125; 到这里，开户功能其实只完成的一大半。如果细心的同学可能会发现，开户功能中并没有给账户设置卡号。 因为生成卡号比较麻烦，所以在下一节，我们单独来写一个方法用于生成卡号。 四、生成卡号各位同学，刚才在完成开户功能的时候，并没有生成卡号，所以我们接着把生成卡号的功能完成。 第一步：先在ATM类中，写一个判断卡号是否存在的功能。 遍历存储Account对象的集合，得到每一个Account对象，获取对象的卡号 如果卡号存在，返回该卡号对应的Account对象 如果卡号不存在，返回null 123456789101112/** 根据卡号查询账户对象返回 accounts = [c1, c2, c3 ...]*/private Account getAccountByCardId(String cardId)&#123; // 遍历全部的账户对象 for (int i = 0; i &lt; accounts.size(); i++) &#123; Account acc = accounts.get(i); // 判断这个账户对象acc中的卡号是否是我们要找的卡号 if(acc.getCardId().equals(cardId))&#123; return acc; &#125; &#125; return null; // 查无此账户，这个卡号不存在的&#125; 第二步：再在ATM类中，写一个生成卡号的功能 1、先随机产生8个[0,9]范围内的随机数，拼接成一个字符串 2、然后再调用getAccountByCardId方法，判断这个卡号字符串是否存在 3、判断生成的卡号是否存在 如果生成的卡号不存在，说明生成的卡号是有效的，把卡号返回， 如果生成的卡号存在，说明生成的卡号无效，循环继续生产卡号。 12345678910111213141516171819/** 返回一个8位 数字的卡号，而且这个卡号不能与其他账户的卡号重复 */private String createCardId()&#123; while (true) &#123; // 1、定义一个String类型的变量记住8位数字作为一个卡号 String cardId = &quot;&quot;; // 2、使用循环，循环8次，每次产生一个随机数给cardId连接起来 Random r = new Random(); for (int i = 0; i &lt; 8; i++) &#123; int data = r.nextInt(10); // 0 - 9 cardId += data; &#125; // 3、判断cardId中记住的卡号，是否与其他账户的卡号重复了，没有重复，才可以做为一个新卡号返回。 Account acc = getAccountByCardId(cardId); if(acc == null)&#123; // 说明cardId没有找到账户对象，因此cardId没有与其他账户的卡号重复，可以返回它做为一个新卡号 return cardId; &#125; &#125;&#125; 写完生成卡号的功能后，在开户功能的TODO位置，调用生成卡号的功能，并且将生成的卡号设置到账户对象中。 五、登录功能各位同学，在上面我们已经完成了开户功能。接下来我们来编写登录功能，编写登录功能的时候我们要满足一下需求： ① 如果系统没有任何账户对象，则不允许登录。 ② 让用户输入登录的卡号，先判断卡号是否正确，如果不正确要给出提示。 ③ 如果卡号正确，再让用户输入账户密码，如果密码不正确要给出提示，如果密码也正确，则给出登录成功的提示。 登录功能具体实现步骤如下： 1、判断系统中是否存在账户对象，存在才能登录，如果不存在，我们直接结束登录操作 2、输入登录的卡号，并判断卡号是否存在 3、如果卡号不存在，直接给出提示 4、如果卡号存在，接着输入用户密码，并判断密码是否正确 5、如果密码也正确，则登录成功，并且记录当前的登录账户 12345678910111213141516171819202122232425262728293031323334353637/** 完成用户的登录操作 */private void login()&#123; System.out.println(&quot;==系统登录==&quot;); // 1、判断系统中是否存在账户对象，存在才能登录，如果不存在，我们直接结束登录操作 if(accounts.size() == 0)&#123; System.out.println(&quot;当前系统中无任何账户，请先开户再来登录~~&quot;); return; // 跳出登录操作。 &#125; // 2、系统中存在账户对象，可以开始进行登录操作了 while (true) &#123; System.out.println(&quot;请您输入您的登录卡号：&quot;); String cardId = sc.next(); // 3、判断这个卡号是否存在啊？ Account acc = getAccountByCardId(cardId); if(acc == null)&#123; // 说明这个卡号不存在。 System.out.println(&quot;您输入的登录卡号不存在，请确认~~&quot;); &#125;else &#123; while (true) &#123; // 卡号存在了，接着让用户输入密码 System.out.println(&quot;请您输入登录密码：&quot;); String passWord = sc.next(); // 4、判断密码是否正确 if(acc.getPassWord().equals(passWord))&#123; loginAcc = acc; // 密码正确了，登录成功了 System.out.println(&quot;恭喜您，&quot; + acc.getUserName() + &quot;成功登录了系统，您的卡号是：&quot; + acc.getCardId()); //TODO 把展示登录界面的功能写成一个方法，写好了再回来调用。 return; // 跳出并结束当前登录方法 &#125;else &#123; System.out.println(&quot;您输入的密码不正确，请确认~~&quot;); &#125; &#125; &#125; &#125;&#125; 六、展示用户操作界面登录成功之后，需要显示登录后的用户操作界面。效果如下 写成一个方法，用来展示登录成功的操作界面，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** 展示登录后的操作界面的 */private void showUserCommand()&#123; while (true) &#123; System.out.println(loginAcc.getUserName() + &quot;您可以选择如下功能进行账户的处理====&quot;); System.out.println(&quot;1、查询账户&quot;); System.out.println(&quot;2、存款&quot;); System.out.println(&quot;3、取款&quot;); System.out.println(&quot;4、转账&quot;); System.out.println(&quot;5、密码修改&quot;); System.out.println(&quot;6、退出&quot;); System.out.println(&quot;7、注销当前账户&quot;); System.out.println(&quot;请选择：&quot;); int command = sc.nextInt(); switch (command)&#123; case 1: //TODO 查询当前账户 break; case 2: //TODO 存款 break; case 3: //TODO取款 break; case 4: //TOD 转账 break; case 5: //TODO 密码修改 return;// 跳出并结束当前方法 case 6: //TODO 退出 System.out.println(loginAcc.getUserName() + &quot;您退出系统成功！&quot;); return; // 跳出并结束当前方法 case 7: // 注销当前登录的账户 if(deleteAccount())&#123; // 销户成功了，回到欢迎界面 return; &#125; break; default: System.out.println(&quot;您当前选择的操作是不存在的，请确认~~&quot;); &#125; &#125;&#125; 写好用户操作界面的方法之后，再到登录成功的位置调用，登录成功后，马上显示用户操作界面。刚才在哪里打了一个TODO标记的，回去找找。 到这里，登录功能就写好了。 六、查询账户、退出 查询账户：在用户操作界面，选择1查询当前账户信息。效果如下： 登录成功的时候，已经把当前账户对象用一个成员变量存储了 ，所以直接按照如下格式打印账户对象的属性信息即可。 这里也写成一个方法 1234567891011/**展示当前登录的账户信息*/private void showLoginAccount()&#123; System.out.println(&quot;==当前您的账户信息如下：==&quot;); System.out.println(&quot;卡号：&quot; + loginAcc.getCardId()); System.out.println(&quot;户主：&quot; + loginAcc.getUserName()); System.out.println(&quot;性别：&quot; + loginAcc.getSex()); System.out.println(&quot;余额：&quot; + loginAcc.getMoney()); System.out.println(&quot;每次取现额度：&quot; + loginAcc.getLimit());&#125; 写好方法之后，到用户操作界面调用。如下图所示 退出功能：其实就是将ATM系统中，在用户界面选择6时，直接结束程序。 七、存款各位同学，接下来来完成存款操作。 我们把存款功能也写成一个方法，具体步骤如下： 键盘录入要存入的金额 在原有余额的基础上，加上存入金额，得到新的余额 再将新的余额设置给当前账户对象 12345678910/** 存钱 */private void depositMoney() &#123; System.out.println(&quot;==存钱操作==&quot;); System.out.println(&quot;请您输入存款金额：&quot;); double money = sc.nextDouble(); // 更新当前登录的账户的余额。 loginAcc.setMoney(loginAcc.getMoney() + money); System.out.println(&quot;恭喜您，您存钱：&quot; + money + &quot;成功，存钱后余额是：&quot; + loginAcc.getMoney());&#125; 写好存款的方法之后，在case 2:的下面调用depositMoney()方法 到这里，存款功能就写好了。 八、取款各位同学，接下来我们写一下取款的功能。 把取款的功能也写成一个方法，具体步骤如下 1、判断账户余额是否达到了100元，如果不够100元，就不让用户取钱了 2、让用户输入取款金额 3、判断账户余额是否足够 如果余额足够， 继续判断当前取款金额是否超过了每次限额 如果超过限额，提示“每次只能取xxx限额的钱” 如果不超过限额，则在当前余额上减去取钱的金额，得到新的余额 并将新的余额设置给账户对象。 如果余额不足，提示“你的余额不足，你的账户余额是xxx元” 按照上面分析的步骤，代码如下 12345678910111213141516171819202122232425262728293031/** 取钱 */private void drawMoney() &#123; System.out.println(&quot;==取钱操作==&quot;); // 1、判断账户余额是否达到了100元，如果不够100元，就不让用户取钱了 if(loginAcc.getMoney() &lt; 100)&#123; System.out.println(&quot;您的账户余额不足100元，不允许取钱~~&quot;); return; &#125; // 2、让用户输入取款金额 while (true) &#123; System.out.println(&quot;请您输入取款金额：&quot;); double money = sc.nextDouble(); // 3、判断账户余额是否足够 if(loginAcc.getMoney() &gt;= money)&#123; // 账户中的余额是足够的 // 4、判断当前取款金额是否超过了每次限额 if(money &gt; loginAcc.getLimit())&#123; System.out.println(&quot;您当前取款金额超过了每次限额，您每次最多可取：&quot; + loginAcc.getLimit()); &#125;else &#123; // 代表可以开始取钱了。更新当前账户的余额即可 loginAcc.setMoney(loginAcc.getMoney() - money); System.out.println(&quot;您取款：&quot; + money + &quot;成功，取款后您剩余：&quot; + loginAcc.getMoney()); break; &#125; &#125;else &#123; System.out.println(&quot;余额不足，您的账户中的余额是：&quot; + loginAcc.getMoney()); &#125; &#125;&#125; 写好取钱方法之后，在case 3:的位置调用drawMoney()方法 九、转账各位同学，接下来我们来编写转账的功能。转账的意思就是，将一个账户的钱转入另一个账，具体的转账逻辑如下： 我们把转账功能也写成一个方法 1、判断系统中是否存在其他账户 2、判断自己的账户中是否有钱 3、真正开始转账了，输入对方卡号 4、判断对方卡号是否正确啊？ 5、如果卡号正确，就继续让用户输入姓氏， 并判断这个姓氏是否正确？ 如果姓氏不正确，给出提示“对不起，您姓氏有问题，转账失败！” 6、如果姓氏正确，继续判断这个转账金额是否超过自己的余额。 如果转账金额超过余额，给出提示“对不起，余额不足，转账失败！” 7、如果对方卡号存在、姓氏匹配、余额足够，就完成真正的转账操作 获取当前自己账户的余额，减去转账金额，就可以得到自己账户新的余额， 并将新的余额，设置给当前账户 并且获取对方的账户余额，加上转账金额，就可以得到对方账户新的余额， 并将新的余额，设置给对方账户 给出提示：“您转账成功了~~~” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** 转账 */private void transferMoney() &#123; System.out.println(&quot;==用户转账==&quot;); // 1、判断系统中是否存在其他账户。 if(accounts.size() &lt; 2)&#123; System.out.println(&quot;当前系统中只有你一个账户，无法为其他账户转账~~&quot;); return; &#125; // 2、判断自己的账户中是否有钱 if(loginAcc.getMoney() == 0)&#123; System.out.println(&quot;您自己都没钱，就别转了~~&quot;); return; &#125; while (true) &#123; // 3、真正开始转账了 System.out.println(&quot;请您输入对方的卡号：&quot;); String cardId = sc.next(); // 4、判断这个卡号是否正确啊？？ Account acc = getAccountByCardId(cardId); if(acc == null)&#123; System.out.println(&quot;您输入的对方的卡号不存在~~&quot;); &#125;else &#123; // 对方的账户存在，继续让用户认证姓氏。 String name = &quot;*&quot; + acc.getUserName().substring(1); // * + 马刘德华 System.out.println(&quot;请您输入【&quot; + name + &quot;】的姓氏：&quot;); String preName = sc.next(); // 5、判断这个姓氏是否正确啊 if(acc.getUserName().startsWith(preName)) &#123; while (true) &#123; // 认证通过了：真正转账了 System.out.println(&quot;请您输入转账给对方的金额：&quot;); double money = sc.nextDouble(); // 6、判断这个金额是否没有超过自己的余额。 if(loginAcc.getMoney() &gt;= money)&#123; // 7、转给对方了 // 更新自己的账户余额 loginAcc.setMoney(loginAcc.getMoney() - money); // 更新对方的账户余额 acc.setMoney(acc.getMoney() + money); System.out.println(&quot;您转账成功了~~~&quot;); return; // 跳出转账方法。。 &#125;else &#123; System.out.println(&quot;您余额不足，无法给对方转这么多钱，最多可转：&quot; + loginAcc.getMoney()); &#125; &#125; &#125;else &#123; System.out.println(&quot;对不起，您认证的姓氏有问题~~&quot;); &#125; &#125; &#125;&#125; 写好修改转账功能之后，在case 4:这里调用。如下： 到这里，转账功能就写好了。 十、修改密码各位同学，接下来我们完成修改密码的功能。 把修改密码的功能也是写成一个方法，具体步骤如下 1、提醒用户输入当前密码 2、认证当前密码是否正确 如果认证密码错误，提示“您当前输入的密码不正确~~”；重新输入密码，再次认证密码是否正确。 3、如果认证密码正确，开始修改密码，修改密码时需要用户输入2次新密码 4、判断2次 密码是否一致 如果两次密码一致，就将新密码设置给当前账户对象，密码修改成功 如果两次密码不一直，则给出提示“您输入的2次密码不一致~~”；重新输入新密码，并确认密码。 12345678910111213141516171819202122232425262728293031323334/** 账户密码修改 */private void updatePassWord() &#123; System.out.println(&quot;==账户密码修改操作==&quot;); while (true) &#123; // 1、提醒用户认证当前密码 System.out.println(&quot;请您输入当前账户的密码：&quot;); String passWord = sc.next(); // 2、认证当前密码是否正确啊 if(loginAcc.getPassWord().equals(passWord))&#123; // 认证通过 while (true) &#123; // 3、真正开始修改密码了 System.out.println(&quot;请您输入新密码：&quot;); String newPassWord = sc.next(); System.out.println(&quot;请您再次输入密码：&quot;); String okPassWord = sc.next(); // 4、判断2次 密码是否一致 if(okPassWord.equals(newPassWord))&#123; // 可以真正开始修改密码了 loginAcc.setPassWord(okPassWord); System.out.println(&quot;恭喜您，您的密码修改成功~~~&quot;); return; &#125;else &#123; System.out.println(&quot;您输入的2次密码不一致~~&quot;); &#125; &#125; &#125;else &#123; System.out.println(&quot;您当前输入的密码不正确~~&quot;); &#125; &#125;&#125; 写好修改密码的功能之后。在case 5:的位置调用updatePassWord()方法。如下图所示 好了，到这里修改密码的功能就写好了。 十一、注销各位同学，接下来我们完成最后一个功能，注销功能。 这里把注销功能也写成一个方法，具体步骤如下 1、先确认是否需要注销账户，让用户输入y或者n 如果输入y，表示确认 如果输入n，表示取消注销操作 2、输入y后，继续判断当前用户的账户是否有钱 如果账户有钱，提示：“对不起，您的账户中存钱金额，不允许销” 如果账户没有钱，则把当前账户对象，从系统的集合中删除，完成注销。 按照上面的步骤代码如下 123456789101112131415161718192021222324/** 销户操作 */private boolean deleteAccount() &#123; System.out.println(&quot;==进行销户操作==&quot;); // 1、问问用户是否确定要销户啊 System.out.println(&quot;请问您确认销户吗？y/n&quot;); String command = sc.next(); switch (command) &#123; case &quot;y&quot;: // 确实要销户 // 2、判断用户的账户中是否有钱：loginAcc if(loginAcc.getMoney() == 0) &#123; // 真的销户了 accounts.remove(loginAcc); System.out.println(&quot;您好，您的账户已经成功销户~~&quot;); return true; &#125;else &#123; System.out.println(&quot;对不起，您的账户中存钱金额，不允许销户~~&quot;); return false; &#125; default: System.out.println(&quot;好的，您的账户保留！！&quot;); return false; &#125;&#125; 注销功能写好之后，在用户操作界面的case 7:位置调用deleteAccount()的方法。 代码如下 到这里注销账户的功能就写好了。","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day10-面向对象高级","slug":"day10-面向对象高级","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day10-面向对象高级/","link":"","permalink":"https://wxzhou.top/2020/05/05/day10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/","excerpt":"","text":"前面我们说过面向对象最核心的套路是：设计对象来处理数据，解决问题。 如果你把面向对象高级这一部分课程学好，你设计出来的对象将更加好用。 在正式学习面向对象高级课程之前，我给大家提一些学习上的建议。目前我们学习的面向对象高级部分的知识点，就像一个一个的螺丝钉，在学习过程中你可能并不知道这些螺丝钉是用在哪里的，解决的什么问题。必须等这些内容都学习完之后，才能知道用这些螺丝钉可以用来搞飞机、造航母、造火箭。 所以，现阶段我们在学习过程中，主要关注下面几点就可以了。等整个基础课程学习完之后，再慢慢感在到哪里用。 一、静态接下来，我们学习一下面向对象编程中很常见的一个关键字static. static读作静态，可以用来修饰成员变量，也能修饰成员方法。我们先来学习static修饰成员变量。 1.1 static修饰成员变量Java中的成员变量按照有无static修饰分为两种：类变量、实例变量。它们的区别如下图所示： 由于静态变量是属于类的，只需要通过类名就可以调用：**类名.静态变量** 实例变量是属于对象的，需要通过对象才能调用：**对象.实例变量** 下面是代码演示（注意静态变量，和实例变量是如何调用的） 为了让大家对于这两种成员变量的执行过程理解更清楚一点，在这里给大家在啰嗦几句，我们来看一下上面代码的内存原理。 最后总结一下 12- 1.类变量：属于类，在内存中只有一份，用类名调用- 2.实例变量：属于对象，每一个对象都有一份，用对象调用 1.2 static修饰成员变量的应用场景学习完static修饰成员变量的基本使用之后，接下来我们学习一下static修饰成员变量在实际工作中的应用。 在实际开发中，如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成类变量来记住。 我们看一个案例** 需求：系统启动后，要求用于类可以记住自己创建了多少个用户对象。** 第一步：先定义一个User类，在用户类中定义一个static修饰的变量，用来表示在线人数； 1234567public class User&#123; public static int number; //每次创建对象时，number自增一下 public User()&#123; User.number++; &#125;&#125; 第二步：再写一个测试类，再测试类中创建4个User对象，再打印number的值，观察number的值是否再自增。 123456789101112public class Test&#123; public static void main(String[] args)&#123; //创建4个对象 new User(); new User(); new User(); new User(); //查看系统创建了多少个User对象 System.out.println(&quot;系统创建的User对象个数：&quot;+User.number); &#125;&#125; 运行上面的代码，查看执行结果是：**系统创建的User对象个数：4** 1.3 static修饰成员方法各位同学，学习完static修饰成员变量之后，接下来我们学习static修饰成员方法。成员方法根据有无static也分为两类：类方法、实例方法 有static修饰的方法，是属于类的，称为类方法；调用时直接用类名调用即可。 无static修饰的方法，是属于对象的，称为实例方法；调用时，需要使用对象调用。 我们看一个案例，演示类方法、实例方法的基本使用 先定义一个Student类，在类中定义一个类方法、定义一个实例方法 123456789101112131415public class Student&#123; double score; //类方法： public static void printHelloWorld&#123; System.out.println(&quot;Hello World!&quot;); System.out.println(&quot;Hello World!&quot;); &#125; //实例方法（对象的方法） public void printPass()&#123; //打印成绩是否合格 System.out.println(score&gt;=60?&quot;成绩合格&quot;:&quot;成绩不合格&quot;); &#125;&#125; 在定义一个测试类，注意类方法、对象方法调用的区别 12345678910111213public class Test2&#123; public static void main(String[] args)&#123; //1.调用Student类中的类方法 Student.printHelloWorld(); //2.调用Student类中的实例方法 Student s = new Student(); s.printPass(); //使用对象也能调用类方法【不推荐，IDEA连提示都不给你，你就别这么用了】 s.printHelloWorld(); &#125;&#125; 搞清楚类方法和实例方法如何调用之后，接下来再啰嗦几句，和同学们聊一聊static修饰成员方法的内存原理。 123451.类方法：static修饰的方法，可以被类名调用，是因为它是随着类的加载而加载的； 所以类名直接就可以找到static修饰的方法 2.实例方法：非static修饰的方法，需要创建对象后才能调用，是因为实例方法中可能会访问实 例变量，而实例变量需要创建对象后才存在。 所以实例方法，必须创建对象后才能调用。 关于static修饰成员变量、和静态修饰成员方法这两种用法，到这里就学习完了。 1.4 工具类学习完static修饰方法之后，我们讲一个有关类方法的应用知识，叫做工具类。 如果一个类中的方法全都是静态的，那么这个类中的方法就全都可以被类名直接调用，由于调用起来非常方便，就像一个工具一下，所以把这样的类就叫做工具类。 我们写一个生成验证码的工具类 12345678910111213141516171819202122public class MyUtils&#123; public static String createCode(int n)&#123; //1.定义一个字符串，用来记录产生的验证码 String code = &quot;&quot;; //2.验证码是由所有的大写字母、小写字母或者数字字符组成 //这里先把所有的字符写成一个字符串，一会从字符串中随机找字符 String data = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKMNOPQRSTUVWXYZ&quot;; //3.循环n次，产生n个索引,再通过索引获取字符 Random r = new Random(); for(int i=0; i&lt;n; i++)&#123; int index = r.nextInt(data.length()); char ch = data.charAt(index); //4.把获取到的字符，拼接到code验证码字符串上。 code+=ch; &#125; //最后返回code,code的值就是验证码 return code; &#125;&#125; 接着可以在任何位置调用MyUtils的createCOde()方法产生任意个数的验证码 123456//比如这是一个登录界面public class LoginDemo&#123; public static void main(String[] args)&#123; System.out.println(MyUtils.createCode()); &#125;&#125; 123456//比如这是一个注册界面public class registerDemo&#123; public static void main(String[] args)&#123; System.out.println(MyUtils.createCode()); &#125;&#125; 工具类的使用就是这样子的，学会了吗？ 在补充一点，工具类里的方法全都是静态的，推荐用类名调用为了防止使用者用对象调用。我们可以把工具类的构造方法私有化。 1234567891011public class MyUtils&#123; //私有化构造方法：这样别人就不能使用构造方法new对象了 private MyUtils()&#123; &#125; //类方法 public static String createCode(int n)&#123; ... &#125;&#125; 1.5 static的注意事项各位同学，到现在在我们已经学会了static修饰的变量、方法如何调用了。但是有一些注意事项还是需要给大家说明一下，目的是让大家知道，使用static写代码时，如果出错了，要知道为什么错、如何改正。 123456789101112131415161718192021222324252627282930313233343536373839public class Student &#123; static String schoolName; // 类变量 double score; // 实例变量 // 1、类方法中可以直接访问类的成员，不可以直接访问实例成员。 public static void printHelloWorld()&#123; // 注意：同一个类中，访问类成员，可以省略类名不写。 schoolName = &quot;黑马&quot;; printHelloWorld2(); System.out.println(score); // 报错的 printPass(); // 报错的 ystem.out.println(this); // 报错的 &#125; // 类方法 public static void printHelloWorld2()&#123; &#125; // 实例方法 public void printPass2()&#123; &#125; // 实例方法 // 2、实例方法中既可以直接访问类成员，也可以直接访问实例成员。 // 3、实例方法中可以出现this关键字，类方法中不可以出现this关键字的 public void printPass()&#123; schoolName = &quot;黑马2&quot;; //对的 printHelloWorld2(); //对的 System.out.println(score); //对的 printPass2(); //对的 System.out.println(this); //对的 &#125;&#125; 1.6 static应用（代码块）各位同学，接下来我们再补充讲解一个知识点，叫代码块；代码块根据有无static修饰分为两种：静态代码块、实例代码块 我们先类学习静态代码块： 123456789public class Student &#123; static int number = 80; static String schoolName = &quot;黑马&quot;; // 静态代码块 static &#123; System.out.println(&quot;静态代码块执行了~~&quot;); schoolName = &quot;黑马&quot;; &#125;&#125; 静态代码块不需要创建对象就能够执行 12345678910public class Test &#123; public static void main(String[] args) &#123; // 目标：认识两种代码块，了解他们的特点和基本作用。 System.out.println(Student.number); System.out.println(Student.number); System.out.println(Student.number); System.out.println(Student.schoolName); // 黑马 &#125;&#125; 执行上面代码时，发现没有创建对象，静态代码块就已经执行了。 关于静态代码块重点注意：静态代码块，随着类的加载而执行，而且只执行一次。 再来学习一下实例代码块 实例代码块的作用和构造器的作用是一样的，用来给对象初始化值；而且每次创建对象之前都会先执行实例代码块。 123456789101112131415161718public class Student&#123; //实例变量 int age; //实例代码块：实例代码块会执行在每一个构造方法之前 &#123; System.out.println(&quot;实例代码块执行了~~&quot;); age = 18; System.out.println(&quot;有人创建了对象：&quot; + this); &#125; public Student()&#123; System.out.println(&quot;无参数构造器执行了~~&quot;); &#125; public Student(String name)&#123; System.out.println(&quot;有参数构造器执行了~~&quot;); &#125;&#125; 接下来在测试类中进行测试，观察创建对象时，实例代码块是否先执行了。 12345678public class Test &#123; public static void main(String[] args) &#123; Student s1 = new Student(); Student s2 = new Student(&quot;张三&quot;); System.out.println(s1.age); System.out.println(s2.age); &#125;&#125; 对于实例代码块重点注意：实例代码块每次创建对象之前都会执行一次 1.7 static应用（单例设计模式）各位同学，关于static的应用我们再补充一个使用的技巧，叫做单例设计模式。 所谓设计模式指的是，一类问题可能会有多种解决方案，而设计模式是在编程实践中，多种方案中的一种最优方案。 关于静态的使用到这里，我们就学习完了。 二、继承2.1 继承快速入门各位同学，我们继续学习面向对象相关内容。面向对象编程之所以能够能够被广大开发者认可，有一个非常重要的原因，是因为它有三大特征，继承、封装和多态。封装我们在基础班已经学过了，接下来我们学习一下继承。 接下来，我们演示一下使用继承来编写代码，注意观察继承的特点。 12345678910111213public class A&#123; //公开的成员 public int i; public void print1()&#123; System.out.println(&quot;===print1===&quot;); &#125; //私有的成员 private int j; private void print2()&#123; System.out.println(&quot;===print2===&quot;); &#125;&#125; 然后，写一个B类，让B类继承A类。在继承A类的同时，B类中新增一个方法print3 1234567891011public class B extends A&#123; public void print3()&#123; //由于i和print1是属于父类A的公有成员，在子类中可以直接被使用 System.out.println(i); //正确 print1(); //正确 //由于j和print2是属于父类A的私有成员，在子类中不可以被使用 System.out.println(j); //错误 print2(); &#125;&#125; 接下来，我们再演示一下，创建B类对象，能否调用父类A的成员。再写一个测试类 123456789101112public class Test&#123; public static void main(String[] args)&#123; B b = new B(); //父类公有成员，子类对象是可以调用的 System.out.println(i); //正确 b.print1(); //父类私有成员，子类对象时不可以调用的 System.out.println(j); //错误 b.print2(); //错误 &#125;&#125; 到这里，关于继承的基本使用我们就算学会了。为了让大家对继承有更深入的认识，我们来看看继承的内存原理。 这里我们只需要关注一点：子类对象实际上是由子、父类两张设计图共同创建出来的。 所以，在子类对象的空间中，既有本类的成员，也有父类的成员。但是子类只能调用父类公有的成员。 2.2 继承的好处各位同学，学习完继承的快速入门之后，接下来我们学习一下继承的好处，以及它的应用场景。 我们通过一个案例来学习 观察代码发现，我们会发现Teacher类中和Consultant类中有相同的代码；其实像这种两个类中有相同代码时，没必要重复写。 我们可以把重复的代码提取出来，作为父类，然后让其他类继承父类就可以了，这样可以提高代码的复用性。改造后的代码如下： 接下来使用继承来完成上面的案例，这里只演示People类和Teacher类，然后你尝试自己完成Consultant类。 先写一个父类 People，用来设计Teacher和Consultant公有的成员。 12345678910public class People&#123; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name=name; &#125;&#125; 再写两个子类Teacher继承People类，同时在子类中加上自己特有的成员。 123456789101112131415public class Teacher extends People&#123; private String skill; //技能 public String getSkill()&#123; return skill; &#125; public void setSkill(String skill)&#123; this.skill=skill; &#125; public void printInfo()&#123; System.out.println(getName()+&quot;具备的技能：&quot;+skill); &#125;&#125; 最后再写一个测试类，再测试类中创建Teacher、Consultant对象，并调用方法。 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 目标：搞清楚继承的好处。 Teacher t = new Teacher(); t.setName(&quot;播仔&quot;); t.setSkill(&quot;Java、Spring&quot;); System.out.println(t.getName()); System.out.println(t.getSkill()); t.printInfo(); &#125;&#125; 执行代码，打印结果如下： 关于继承的好处我们只需要记住：继承可以提高代码的复用性 2.3 权限修饰符各位同学，在刚才使用继承编写的代码中我们有用到两个权限修饰符，一个是public（公有的）、一个是private（私有的），实际上还有两个权限修饰符，一个是protected（受保护的）、一个是缺省的（不写任何修饰符）。 接下来我们就学习一下这四个权限修饰符分别有什么作用。 什么是权限修饰符呢？ 权限修饰符是用来限制类的成员（成员变量、成员方法、构造器…）能够被访问的范围。 每一种权限修饰符能够被访问的范围如下 下面我们用代码演示一下，在本类中可以访问到哪些权限修饰的方法。 1234567891011121314151617181920212223242526272829public class Fu &#123; // 1、私有:只能在本类中访问 private void privateMethod()&#123; System.out.println(&quot;==private==&quot;); &#125; // 2、缺省：本类，同一个包下的类 void method()&#123; System.out.println(&quot;==缺省==&quot;); &#125; // 3、protected: 本类，同一个包下的类，任意包下的子类 protected void protectedMethod()&#123; System.out.println(&quot;==protected==&quot;); &#125; // 4、public： 本类，同一个包下的类，任意包下的子类，任意包下的任意类 public void publicMethod()&#123; System.out.println(&quot;==public==&quot;); &#125; public void test()&#123; //在本类中，所有权限都可以被访问到 privateMethod(); //正确 method(); //正确 protectedMethod(); //正确 publicMethod(); //正确 &#125;&#125; 接下来，在和Fu类同一个包下，创建一个测试类Demo，演示同一个包下可以访问到哪些权限修饰的方法。 123456789public class Demo &#123; public static void main(String[] args) &#123; Fu f = new Fu(); // f.privateMethod(); //私有方法无法使用 f.method(); f.protectedMethod(); f.publicMethod(); &#125;&#125; 接下来，在另一个包下创建一个Fu类的子类，演示不同包下的子类中可以访问哪些权限修饰的方法。 123456789public class Zi extends Fu &#123; //在不同包下的子类中，只能访问到public、protected修饰的方法 public void test()&#123; // privateMethod(); // 报错 // method(); // 报错 protectedMethod(); //正确 publicMethod(); //正确 &#125;&#125; 接下来，在和Fu类不同的包下，创建一个测试类Demo2，演示一下不同包的无关类，能访问到哪些权限修饰的方法； 123456789101112public class Demo2 &#123; public static void main(String[] args) &#123; Fu f = new Fu(); // f.privateMethod(); // 报错 // f.method(); //报错 // f.protecedMethod();//报错 f.publicMethod(); //正确 Zi zi = new Zi(); // zi.protectedMethod(); &#125;&#125; 2.4 单继承、Object刚才我们写的代码中，都是一个子类继承一个父类，那么有同学问到，一个子类可以继承多个父类吗？ Java语言只支持单继承，不支持多继承，但是可以多层继承。就像家族里儿子、爸爸和爷爷的关系一样：一个儿子只能有一个爸爸，不能有多个爸爸，但是爸爸也是有爸爸的。 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; // 目标：掌握继承的两个注意事项事项。 // 1、Java是单继承的：一个类只能继承一个直接父类； // 2、Object类是Java中所有类的祖宗。 A a = new A(); B b = new B(); ArrayList list = new ArrayList(); list.add(&quot;java&quot;); System.out.println(list.toString()); &#125;&#125;class A &#123;&#125; //extends Object&#123;&#125;class B extends A&#123;&#125;// class C extends B , A&#123;&#125; // 报错class D extends B&#123;&#125; 2.5 方法重写各位同学，学习完继承之后，在继承的基础之上还有一个很重要的现象需要给大家说一下。 叫做方法重写。为了让大家能够掌握方法重写，我们先认识什么是方法重写，再说一下方法的应用场景。 什么是方法重写 当子类觉得父类方法不好用，或者无法满足父类需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的这个方法，这就是方法重写。 注意：重写后，方法的访问遵循就近原则。下面我们看一个代码演示 写一个A类作为父类，定义两个方法print1和print2 123456789public class A &#123; public void print1()&#123; System.out.println(&quot;111&quot;); &#125; public void print2(int a, int b)&#123; System.out.println(&quot;111111&quot;); &#125;&#125; 再写一个B类作为A类的子类，重写print1和print2方法。 1234567891011121314public class B extends A&#123; // 方法重写 @Override // 安全，可读性好 public void print1()&#123; System.out.println(&quot;666&quot;); &#125; // 方法重写 @Override public void print2(int a, int b)&#123; System.out.println(&quot;666666&quot;); &#125;&#125; 接下来，在测试类中创建B类对象，调用方法 12345678public class Test &#123; public static void main(String[] args) &#123; // 目标：认识方法重写，掌握方法重写的常见应用场景。 B b = new B(); b.print1(); b.print2(2, 3); &#125;&#125; 执行代码，我们发现真正执行的是B类中的print1和print2方法 知道什么是方法重写之后，还有一些注意事项，需要和大家分享一下。 12345- 1.重写的方法上面，可以加一个注解@Override,用于标注这个方法是复写的父类方法- 2.子类复写父类方法时，访问权限必须大于或者等于父类方法的权限 public &gt; protected &gt; 缺省- 3. 重写的方法返回值类型，必须与被重写的方法返回值类型一样，或者范围更小- 4. 私有方法、静态方法不能被重写，如果重写会报错。 关于这些注意事项，同学们其实只需要了解一下就可以了。实际上我们实际写代码时，只要和父类写的一样就可以（ 总结起来就8个字：声明不变，重新实现） 方法重写的应用场景 学习完方法重写之后，接下来，我们还需要大家掌握方法重写，在实际中的应用场景。方法重写的应用场景之一就是：子类重写Object的toString()方法，以便返回对象的内容。 比如：有一个Student类，这个类会默认继承Object类。 12345678910111213141516171819202122232425262728public class Student extends Object&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 其实Object类中有一个toString()方法，直接通过Student对象调用Object的toString()方法，会得到对象的地址值。 1234567public class Test &#123; public static void main(String[] args) &#123; Student s = new Student(&quot;播妞&quot;, 19); // System.out.println(s.toString()); System.out.println(s); &#125;&#125; 但是，此时不想调用父类Object的toString()方法，那就可以在Student类中重新写一个toSting()方法，用于返回对象的属性值。 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.d12_extends_override;public class Student extends Object&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 重新运行测试类，结果如下 好了，到这里方法什么是方法重写，以及方法重写的应用场景我们就学习完了。 2.6 子类中访问成员的特点各位同学，刚才我们已经学习了继承，我们发现继承至少涉及到两个类，而每一个类中都可能有各自的成员（成员变量、成员方法），就有可能出现子类和父类有相同成员的情况，那么在子类中访问其他成员有什么特点呢？ 原则：在子类中访问其他成员（成员变量、成员方法），是依据就近原则的 定义一个父类，代码如下 1234567public class F &#123; String name = &quot;父类名字&quot;; public void print1()&#123; System.out.println(&quot;==父类的print1方法执行==&quot;); &#125;&#125; 再定义一个子类，代码如下。有一个同名的name成员变量，有一个同名的print1成员方法； 12345678910111213141516public class Z extends F &#123; String name = &quot;子类名称&quot;; public void showName()&#123; String name = &quot;局部名称&quot;; System.out.println(name); // 局部名称 &#125; @Override public void print1()&#123; System.out.println(&quot;==子类的print1方法执行了=&quot;); &#125; public void showMethod()&#123; print1(); // 子类的 &#125;&#125; 接下来写一个测试类，观察运行结果，我们发现都是调用的子类变量、子类方法。 12345678public class Test &#123; public static void main(String[] args) &#123; // 目标：掌握子类中访问其他成员的特点：就近原则。 Z z = new Z(); z.showName(); z.showMethod(); &#125;&#125; 如果子类和父类出现同名变量或者方法，优先使用子类的；此时如果一定要在子类中使用父类的成员，可以加this或者super进行区分。 1234567891011121314151617181920public class Z extends F &#123; String name = &quot;子类名称&quot;; public void showName()&#123; String name = &quot;局部名称&quot;; System.out.println(name); // 局部名称 System.out.println(this.name); // 子类成员变量 System.out.println(super.name); // 父类的成员变量 &#125; @Override public void print1()&#123; System.out.println(&quot;==子类的print1方法执行了=&quot;); &#125; public void showMethod()&#123; print1(); // 子类的 super.print1(); // 父类的 &#125;&#125; 2.7 子类中访问构造器的特点各位同学，我们知道一个类中可以写成员变量、成员方法，还有构造器。在继承关系下，子类访问成员变量和成员方法的特点我们已经学过了；接下来再学习子类中访问构造器的特点。 我们先认识子类构造器的语法特点，再讲一下子类构造器的应用场景 子类中访问构造器的语法规则 首先，子类全部构造器，都会先调用父类构造器，再执行自己。 执行顺序，如下图按照① ② ③ 步骤执行： 子类访问构造器的应用场景 如果不想使用默认的super()方式调用父类构造器，还可以手动使用super(参数)调用父类有参数构造器。 在本类中访问自己的构造方法 刚才我们学习了通过super()和super(参数)可以访问父类的构造器。有时候我们也需要访问自己类的构造器。语法如下 12this(): 调用本类的空参数构造器this(参数): 调用本类有参数的构造器 最后我们被this和super的用法在总结一下 12345678910111213访问本类成员： this.成员变量 //访问本类成员变量 this.成员方法 //调用本类成员方法 this() //调用本类空参数构造器 this(参数) //调用本类有参数构造器 访问父类成员： super.成员变量 //访问父类成员变量 super.成员方法 //调用父类成员方法 super() //调用父类空参数构造器 super(参数) //调用父类有参数构造器 注意：this和super访问构造方法，只能用到构造方法的第一句，否则会报错。","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day12-面向对象高级","slug":"day12-面向对象高级","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day12-面向对象高级/","link":"","permalink":"https://wxzhou.top/2020/05/05/day12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/","excerpt":"","text":"今天学习的内容同学们学习起来会更轻松一些，有一些语法知识只需要了解一下就可以了，因为实际工作用得并不多。 我们先来了解第一个语法知识，内部类。 一、内部类 内部类是类中的五大成分之一（成员变量、方法、构造器、内部类、代码块），如果一个类定义在另一个类的内部，这个类就是内部类。 当一个类的内部，包含一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。 比如：汽车、的内部有发动机，发动机是包含在汽车内部的一个完整事物，可以把发动机设计成内部类。 123456public class Car&#123; //内部类 public class Engine&#123; &#125;&#125; 内部类有四种形式，分别是成员内部类、静态内部类、局部内部类、匿名内部类。 我们先来学习成员内部类 1.1 成员内部类成员内部类就是类中的一个普通成员，类似于成员变量、成员方法。 12345678910111213141516171819202122232425262728293031323334353637public class Outer &#123; private int age = 99; public static String a=&quot;黑马&quot;; // 成员内部类 public class Inner&#123; private String name; private int age = 88; //在内部类中既可以访问自己类的成员，也可以访问外部类的成员 public void test()&#123; System.out.println(age); //88 System.out.println(a); //黑马 int age = 77; System.out.println(age); //77 System.out.println(this.age); //88 System.out.println(Outer.this.age); //99 &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125;&#125; 成员内部类如何创建对象，格式如下 1234//外部类.内部类 变量名 = new 外部类().new 内部类();Outer.Inner in = new Outer().new Inner();//调用内部类的方法in.test(); 总结一下内部类访问成员的特点 既可以访问内部类成员、也可以访问外部类成员 如果内部类成员和外部类成员同名，可以使用**类名.this.成员**区分 1.2 静态内部类静态内部类，其实就是在成员内部类的前面加了一个static关键字。静态内部类属于外部类自己持有。 1234567891011121314public class Outer &#123; private int age = 99; public static String schoolName=&quot;黑马&quot;; // 静态内部类 public static class Inner&#123; //静态内部类访问外部类的静态变量，是可以的； //静态内部类访问外部类的实例变量，是不行的 public void test()&#123; System.out.println(schoolName); //99 //System.out.println(age); //报错 &#125; &#125;&#125; 静态内部类创建对象时，需要使用外部类的类名调用。 123//格式：外部类.内部类 变量名 = new 外部类.内部类();Outer.Inner in = new Outer.Inner();in.test(); 1.3 局部内部类局部内部类是定义在方法中的类，和局部变量一样，只能在方法中有效。所以局部内部类的局限性很强，一般在开发中是不会使用的。 1234567891011121314public class Outer&#123; public void test()&#123; //局部内部类 class Inner&#123; public void show()&#123; System.out.println(&quot;Inner...show&quot;); &#125; &#125; //局部内部类只能在方法中创建对象，并使用 Inner in = new Inner(); in.show(); &#125;&#125; 1.4 匿名内部类 1.4.1 认识匿名内部类，基本使用 各位同学，接下来学习一种再实际开发中用得最多的一种内部类，叫匿名内部类。相比于前面几种内部类，匿名内部类就比较重要的。 我们还是先认识一下什么是匿名内部类？ 匿名内部类是一种特殊的局部内部类；所谓匿名，指的是程序员不需要为这个类声明名字。 下面就是匿名内部类的格式： 1234new 父类/接口(参数值)&#123; @Override 重写父类/接口的方法;&#125; 匿名内部类本质上是一个没有名字的子类对象、或者接口的实现类对象。 比如，先定义一个Animal抽象类，里面定义一个cry()方法，表示所有的动物有叫的行为，但是因为动物还不具体，cry()这个行为并不能具体化，所以写成抽象方法。 123public abstract class Animal&#123; public abstract void cry();&#125; 接下来，我想要在不定义子类的情况下创建Animal的子类对象，就可以使用匿名内部类 12345678910111213public class Test&#123; public static void main(String[] args)&#123; //这里后面new 的部分，其实就是一个Animal的子类对象 //这里隐含的有多态的特性： Animal a = Animal子类对象; Animal a = new Animal()&#123; @Override public void cry()&#123; System.out.println(&quot;猫喵喵喵的叫~~~&quot;); &#125; &#125; a.eat(); //直线上面重写的cry()方法 &#125;&#125; 需要注意的是，匿名内部类在编写代码时没有名字，编译后系统会为自动为匿名内部类生产字节码，字节码的名称会以外部类$1.class的方法命名 匿名内部类的作用：简化了创建子类对象、实现类对象的书写格式。 1.4.2 匿名内部类的应用场景 学习完匿名内部类的基本使用之后，我们再来看一下匿名内部类在实际中的应用场景。其实一般我们会主动的使用匿名内部类。 只有在调用方法时，当方法的形参是一个接口或者抽象类，为了简化代码书写，而直接传递匿名内部类对象给方法。这样就可以少写一个类。比如，看下面代码 123public interface Swimming&#123; public void swim();&#125; 1234567891011121314151617181920212223public class Test&#123; public static void main(String[] args)&#123; Swimming s1 = new Swimming()&#123; public void swim()&#123; System.out.println(&quot;狗刨飞快&quot;); &#125; &#125;; go(s1); Swimming s1 = new Swimming()&#123; public void swim()&#123; System.out.println(&quot;猴子游泳也还行&quot;); &#125; &#125;; go(s1); &#125; //形参是Swimming接口，实参可以接收任意Swimming接口的实现类对象 public static void go(Swimming s)&#123; System.out.println(&quot;开始~~~~~~~~&quot;); s.swim(); System.out.println(&quot;结束~~~~~~~~&quot;); &#125;&#125; 二、枚举2.1 认识枚举 2.1.1 认识枚举、枚举的原理 同学们，接下来我们学习一个新的知识点，枚举。枚举是我们以后在项目开发中偶尔会用到的知识。话不多说，我们还是先来认识一下枚举。 枚举是一种特殊的类，它的格式是： 123public enum 枚举类名&#123; 枚举项1,枚举项2,枚举项3;&#125; 其实枚举项就表示枚举类的对象，只是这些对象在定义枚举类时就预先写好了，以后就只能用这几个固定的对象。 我们用代码演示一下，定义一个枚举类A，在枚举类中定义三个枚举项X, Y, Z 123public enum A&#123; X,Y,Z;&#125; 想要获取枚举类中的枚举项，只需要用类名调用就可以了 12345678public class Test&#123; public static void main(String[] args)&#123; //获取枚举A类的，枚举项 A a1 = A.X; A a2 = A.Y; A a3 = A.Z; &#125;&#125; 刚才说，枚举项实际上是枚举类的对象，这一点其实可以通过反编译的形式来验证（需要用到反编译的命令，这里不能直接将字节码拖进idea反编译） 我们会看到，枚举类A是用class定义的，说明枚举确实是一个类，而且X，Y，Z都是A类的对象；而且每一个枚举项都是被public static final 修饰，所以被可以类名调用，而且不能更改。 2.1.2 枚举深入 既然枚举是一个类的话，我们能不能在枚举类中定义构造器、成员变量、成员方法呢？答案是可以的。来看一下代码吧 12345678910111213141516171819202122public enum A&#123; //定义枚举项 X,Y,Z(&quot;张三&quot;); //枚举项后面加括号，就是在执行枚举类的带参数构造方法。 //定义空构造器 public A()&#123; &#125; //成员变量 private String name; //定义带参数构造器 public A(String name)&#123; this.name=name; &#125; //成员方法 public String getName()&#123; return name; &#125; ...&#125; 虽然枚举类中可以像类一样，写一些类的其他成员，但是一般不会这么写，如果你真要这么干的话，到不如直接写普通类来的直接。 2.2 枚举的应用场景刚才我们认识了一下什么是枚举，接下来我们看一下枚举在实际中的运用，枚举的应用场景是这样的：枚举一般表示一组信息，然后作为参数进行传输。 我们来看一个案例。比如我们现在有这么一个应用，用户进入应用时，需要让用户选择是女生、还是男生，然后系统会根据用户选择的是男生，还是女生推荐不同的信息给用户观看。 这里我们就可以先定义一个枚举类，用来表示男生、或者女生 123public class Constant&#123; BOY,GRIL&#125; 再定义一个测试类，完成用户进入系统后的选择 1234567891011121314151617public class Test&#123; public static void main(String[] args)&#123; //调用方法，传递男生 provideInfo(Constant.BOY); &#125; public static void provideInfo(Constant c)&#123; switch(c)&#123; case BOY: System.out.println(&quot;展示一些信息给男生看&quot;); break; case GRIL: System.out.println(&quot;展示一些信息给女生看&quot;); break; &#125; &#125;&#125; 最终再总结一下枚举的应用场景：枚举一般表示几个固定的值，然后作为参数进行传输。 三、泛型3.1 认识泛型所谓泛型指的是，在定义类、接口、方法时，同时声明了一个或者多个类型变量（如：），称为泛型类、泛型接口、泛型方法、它们统称为泛型。 比如我们前面学过的ArrayList类就是一个泛型类，我们可以打开API文档看一下ArrayList类的声明。 ArrayList集合的设计者在定义ArrayList集合时，就已经明确ArrayList集合时给别人装数据用的，但是别人用ArrayList集合时候，装什么类型的数据他不知道，所以就用一个&lt;E&gt;表示元素的数据类型。 当别人使用ArrayList集合创建对象时，new ArrayList&lt;String&gt; 就表示元素为String类型，new ArrayList&lt;Integer&gt;表示元素为Integer类型。 我们总结一下泛型的作用、本质： 泛型的好处：在编译阶段可以避免出现一些非法的数据。 泛型的本质：把具体的数据类型传递给类型变量。 3.2 自定义泛型类接下来我们学习一下自定义泛型类，但是有一些话需要给大家提前交代一下：泛型类，在实际工作中一般都是源代码中写好，我们直接用的，就是ArrayList这样的，自己定义泛型类是非常少的。 自定义泛型类的格式如下 1234//这里的&lt;T,W&gt;其实指的就是类型变量，可以是一个，也可以是多个。public class 类名&lt;T,W&gt;&#123; &#125; 接下来，我们自己定义一个MyArrayList泛型类，模拟一下自定义泛型类的使用。注意这里重点仅仅只是模拟泛型类的使用，所以方法中的一些逻辑是次要的，也不会写得太严谨。 123456789101112131415161718//定义一个泛型类，用来表示一个容器//容器中存储的数据，它的类型用&lt;E&gt;先代替用着，等调用者来确认&lt;E&gt;的具体类型。public class MyArrayList&lt;E&gt;&#123; private Object[] array = new Object[10]; //定一个索引，方便对数组进行操作 private int index; //添加元素 public void add(E e)&#123; array[index]=e; index++; &#125; //获取元素 public E get(int index)&#123; return (E)array[index]; &#125;&#125; 接下来，我们写一个测试类，来测试自定义的泛型类MyArrayList是否能够正常使用 12345678910111213141516public class Test&#123; public static void main(String[] args)&#123; //1.确定MyArrayList集合中，元素类型为String类型 MyArrayList&lt;String&gt; list = new MyArrayList&lt;&gt;(); //此时添加元素时，只能添加String类型 list.add(&quot;张三&quot;); list.add(&quot;李四&quot;); //2.确定MyArrayList集合中，元素类型为Integer类型 MyArrayList&lt;Integer&gt; list1 = new MyArrayList&lt;&gt;(); //此时添加元素时，只能添加String类型 list.add(100); list.add(200); &#125;&#125; 关于自定义泛型类，你们把这个案例理解，对于初学者来说，就已经非常好了。 3.3 自定义泛型接口在上一节中，我们已经学习了自定义泛型类，接下来我们学习一下泛型接口。泛型接口其实指的是在接口中把不确定的数据类型用&lt;类型变量&gt;表示。定义格式如下： 1234//这里的类型变量，一般是一个字母，比如&lt;E&gt;public interface 接口名&lt;类型变量&gt;&#123; &#125; 比如，我们现在要做一个系统要处理学生和老师的数据，需要提供2个功能，保存对象数据、根据名称查询数据，要求：这两个功能处理的数据既能是老师对象，也能是学生对象。 首先我们得有一个学生类和老师类 123public class Teacher&#123;&#125; 123public class Student&#123; &#125; 我们定义一个Data&lt;T&gt;泛型接口，T表示接口中要处理数据的类型。 12345public interface Data&lt;T&gt;&#123; public void add(T t); public ArrayList&lt;T&gt; getByName(String name);&#125; 接下来，我们写一个处理Teacher对象的接口实现类 1234567891011//此时确定Data&lt;E&gt;中的E为Teacher类型，//接口中add和getByName方法上的T也都会变成Teacher类型public class TeacherData implements Data&lt;Teacher&gt;&#123; public void add(Teacher t)&#123; &#125; public ArrayList&lt;Teacher&gt; getByName(String name)&#123; &#125;&#125; 接下来，我们写一个处理Student对象的接口实现类 1234567891011//此时确定Data&lt;E&gt;中的E为Student类型，//接口中add和getByName方法上的T也都会变成Student类型public class StudentData implements Data&lt;Student&gt;&#123; public void add(Student t)&#123; &#125; public ArrayList&lt;Student&gt; getByName(String name)&#123; &#125;&#125; 再啰嗦几句，在实际工作中，一般也都是框架底层源代码把泛型接口写好，我们实现泛型接口就可以了。 3.4 泛型方法同学们，接下来我们学习一下泛型方法。下面就是泛型方法的格式 123public &lt;泛型变量,泛型变量&gt; 返回值类型 方法名(形参列表)&#123; &#125; 下图中在返回值类型和修饰符之间有定义的才是泛型方法。 接下我们看一个泛型方法的案例 1234567891011121314public class Test&#123; public static void main(String[] args)&#123; //调用test方法，传递字符串数据，那么test方法的泛型就是String类型 String rs = test(&quot;test&quot;); //调用test方法，传递Dog对象，那么test方法的泛型就是Dog类型 Dog d = test(new Dog()); &#125; //这是一个泛型方法&lt;T&gt;表示一个不确定的数据类型，由调用者确定 public static &lt;T&gt; test(T t)&#123; return t; &#125;&#125; 3.5 泛型限定接着，我们来学习一个泛型的特殊用法，叫做泛型限定。泛型限定的意思是对泛型的数据类型进行范围的限制。有如下的三种格式 表示任意类型 表示指定类型或者指定类型的子类 表示指定类型或者指定类型的父类 下面我们演示一下，假设有Car作为父类，BENZ，BWM两个类作为Car的子类，代码如下 123456789101112131415161718192021222324252627282930313233343536373839class Car&#123;&#125;class BENZ extends Car&#123;&#125;class BWN extends Car&#123;&#125;public class Test&#123; public static void main(String[] args)&#123; //1.集合中的元素不管是什么类型，test1方法都能接收 ArrayList&lt;BWM&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;Benz&gt; list2 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(); test1(list1); test1(list2); test1(list3); //2.集合中的元素只能是Car或者Car的子类类型，才能被test2方法接收 ArrayList&lt;Car&gt; list4 = new ArrayList&lt;&gt;(); ArrayList&lt;BWM&gt; list5 = new ArrayList&lt;&gt;(); test2(list4); test2(list5); //2.集合中的元素只能是Car或者Car的父类类型，才能被test3方法接收 ArrayList&lt;Car&gt; list6 = new ArrayList&lt;&gt;(); ArrayList&lt;Object&gt; list7 = new ArrayList&lt;&gt;(); test3(list6); test3(list7); &#125; public static void test1(ArrayList&lt;?&gt; list)&#123; &#125; public static void test2(ArrayList&lt;? extends Car&gt; list)&#123; &#125; public static void test3(ArrayList&lt;? super Car&gt; list)&#123; &#125;&#125; 3.6 泛型擦除最后，关于泛型还有一个特点需要给同学们介绍一下，就是泛型擦除。什么意思呢？也就是说泛型只能编译阶段有效，一旦编译成字节码，字节码中是不包含泛型的。而且泛型只支持引用数据类型，不支持基本数据类型。 把下面的代码的字节码进行反编译 下面是反编译之后的代码，我们发现ArrayList后面没有泛型 四、常用API各位同学，恭喜大家，到目前位置我们关于面向对象的语法知识就全部学习完了。接下来我们就可以拿着这些语法知识，去学习一个一个的API方法，掌握的API方法越多，那么Java的编程能力就越强。 API（Application Programming interface）意思是应用程序编程接口，说人话就是Java帮我们写好的一些程序，如：类、方法等，我们直接拿过来用就可以解决一些问题。 我们要学习那些API呢？把下面一种图中的所有类的常用方法学会了，那我们JavaSE进阶的课程就算你全学会了。 很多初学者给我反应的问题是，这些API一听就会，但是就是记住不！送同学们一句话， “千里之行始于足下，多记、多查、多些代码、孰能生巧！” 4.1 Object类各位小伙伴，我们要学习的第一个API就是Object类。Object类是Java中所有类的祖宗类，因此，Java中所有类的对象都可以直接使用Object类中提供的一些方法。 按照下图的提示，可以搜索到你想要找的类 我们找到Object类的下面两个方法 4.1.1 toString()方法 我们先来学习toString()方法。 123public String toString() 调用toString()方法可以返回对象的字符串表示形式。 默认的格式是：“包名.类名@哈希值16进制” 假设有一个学生类如下 123456789public class Student&#123; private String name; private int age; public Student(String name, int age)&#123; this.name=name; this.age=age; &#125;&#125; 再定义一个测试类 123456public class Test&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;赵敏&quot;,23); System.out.println(s1.toString()); &#125;&#125; 打印结果如下 如果，在Student类重写toString()方法，那么我们可以返回对象的属性值，代码如下 1234567891011121314public class Student&#123; private String name; private int age; public Student(String name, int age)&#123; this.name=name; this.age=age; &#125; @Override public String toString()&#123; return &quot;Student&#123;name=‘&quot;+name+&quot;’, age=&quot;+age+&quot;&#125;&quot;; &#125;&#125; 运行测试类，结果如下 4.1.2 equals(Object o)方法 接下来，我们学习一下Object类的equals方法 12public boolean equals(Object o) 判断此对象与参数对象是否&quot;相等&quot; 我们写一个测试类，测试一下 1234567891011public class Test&#123; public static void main(String[] args)&#123; Student s1 = new Student(&quot;赵薇&quot;,23); Student s2 = new Student(&quot;赵薇&quot;,23); //equals本身也是比较对象的地址，和&quot;==&quot;没有区别 System.out.println(s1.equals(s2)); //false //&quot;==&quot;比较对象的地址 System.out.println(s1==s2); //false &#125;&#125; 但是如果我们在Student类中，把equals方法重写了，就按照对象的属性值进行比较 1234567891011121314151617181920212223242526public class Student&#123; private String name; private int age; public Student(String name, int age)&#123; this.name=name; this.age=age; &#125; @Override public String toString()&#123; return &quot;Student&#123;name=‘&quot;+name+&quot;’, age=&quot;+age+&quot;&#125;&quot;; &#125; //重写equals方法，按照对象的属性值进行比较 @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125;&#125; 再运行测试类，效果如下 总结一下Object的toString方法和equals方法 1234567public String toString() 返回对象的字符串表示形式。默认的格式是：“包名.类名@哈希值16进制” 【子类重写后，返回对象的属性值】 public boolean equals(Object o) 判断此对象与参数对象是否&quot;相等&quot;。默认比较对象的地址值，和&quot;==&quot;没有区别 【子类重写后，比较对象的属性值】 4.1.3 clone() 方法 接下来，我们学习Object类的clone()方法，克隆。意思就是某一个对象调用这个方法，这个方法会复制一个一模一样的新对象，并返回。 12public Object clone() 克隆当前对象，返回一个新对象 想要调用clone()方法，必须让被克隆的类实现Cloneable接口。如我们准备克隆User类的对象，代码如下 1234567891011121314151617181920212223public class User implements Cloneable&#123; private String id; //编号 private String username; //用户名 private String password; //密码 private double[] scores; //分数 public User() &#123; &#125; public User(String id, String username, String password, double[] scores) &#123; this.id = id; this.username = username; this.password = password; this.scores = scores; &#125; //...get和set...方法自己加上 @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 接着，我们写一个测试类，克隆User类的对象。并观察打印的结果 1234567891011public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; User u1 = new User(1,&quot;zhangsan&quot;,&quot;wo666&quot;,new double[]&#123;99.0,99.5&#125;); //调用方法克隆得到一个新对象 User u2 = (User) u1.clone(); System.out.println(u2.getId()); System.out.println(u2.getUsername()); System.out.println(u2.getPassword()); System.out.println(u2.getScores()); &#125;&#125; 我们发现，克隆得到的对象u2它的属性值和原来u1对象的属性值是一样的。 上面演示的克隆方式，是一种浅克隆的方法，浅克隆的意思：拷贝出来的对象封装的数据与原对象封装的数据一模一样（引用类型拷贝的是地址值）。如下图所示 还有一种拷贝方式，称之为深拷贝，拷贝原理如下图所示 下面演示一下深拷贝User对象 123456789101112131415161718192021222324252627public class User implements Cloneable&#123; private String id; //编号 private String username; //用户名 private String password; //密码 private double[] scores; //分数 public User() &#123; &#125; public User(String id, String username, String password, double[] scores) &#123; this.id = id; this.username = username; this.password = password; this.scores = scores; &#125; //...get和set...方法自己加上 @Override protected Object clone() throws CloneNotSupportedException &#123; //先克隆得到一个新对象 User u = (User) super.clone(); //再将新对象中的引用类型数据，再次克隆 u.scores = u.scores.clone(); return u; &#125;&#125; 4.2 Objects类Objects是一个工具类，提供了一些方法可以对任意对象进行操作。主要方法如下 下面写代码演示一下这几个方法 12345678910111213141516171819public class Test&#123; public static void main(String[] args)&#123; String s1 = null; String s2 = &quot;itheima&quot;; //这里会出现NullPointerException异常，调用者不能为null System.out.println(s1.equals(s2)); //此时不会有NullPointerException异常，底层会自动先判断空 System.out.println(Objects.equals(s1,s2)); //判断对象是否为null，等价于== System.out.println(Objects.isNull(s1)); //true System.out.println(s1==null); //true //判断对象是否不为null，等价于!= System.out.println(Objects.nonNull(s2)); //true System.out.println(s2!=null); //true &#125;&#125; 4.3 基本类型包装类同学们，接下来我们学习一下包装类。为什么要学习包装类呢？因为在Java中有一句很经典的话，万物皆对象。Java中的8种基本数据类型还不是对象，所以要把它们变成对象，变成对象之后，可以提供一些方法对数据进行操作。 Java中8种基本数据类型都用一个包装类与之对一个，如下图所示 我们学习包装类，主要学习两点： 创建包装类的对象方式、自动装箱和拆箱的特性； 利用包装类提供的方法对字符串和基本类型数据进行相互转换 4.2.1 创建包装类对象 我们先来学习，创建包装类对象的方法，以及包装类的一个特性叫自动装箱和自动拆箱。我们以Integer为例，其他的可以自己学，都是类似的。 123456789101112131415161718//1.创建Integer对象，封装基本类型数据10Integer a = new Integer(10);//2.使用Integer类的静态方法valueOf(数据)Integer b = Integer.valueOf(10);//3.还有一种自动装箱的写法（意思就是自动将基本类型转换为引用类型）Integer c = 10;//4.有装箱肯定还有拆箱（意思就是自动将引用类型转换为基本类型）int d = c;//5.装箱和拆箱在使用集合时就有体现ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();//添加的元素是基本类型，实际上会自动装箱为Integer类型list.add(100);//获取元素时，会将Integer类型自动拆箱为int类型int e = list.get(0); 4.2.2 包装类数据类型转换 在开发中，经常使用包装类对字符串和基本类型数据进行相互转换。 把字符串转换为数值型数据：包装类.parseXxx(字符串) 12public static int parseInt(String s) 把字符串转换为基本数据类型 将数值型数据转换为字符串：包装类.valueOf(数据); 12public static String valueOf(int a) 把基本类型数据转换为 写一个测试类演示一下 12345678910111213//1.字符串转换为数值型数据String ageStr = &quot;29&quot;;int age1 = Integer.parseInt(ageStr);String scoreStr = 3.14;double score = Double.prarseDouble(scoreStr);//2.整数转换为字符串，以下几种方式都可以（挑中你喜欢的记一下）Integer a = 23;String s1 = Integer.toString(a);String s2 = a.toString();String s3 = a+&quot;&quot;;String s4 = String.valueOf(a);","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day11-面向对象高级","slug":"day11-面向对象高级","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day11-面向对象高级/","link":"","permalink":"https://wxzhou.top/2020/05/05/day11-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/","excerpt":"","text":"今天我们继续学习面向对象的语法知识，我们今天学习的主要内容是：多态、抽象、接口。 学会这些语法知识，可以让我们编写代码更灵活，代码的复用性更高。 一、多态接下来，我们学习面向对象三大特征的的最后一个特征——多态。 1.1 多态概述 什么是多态？ 多态是在继承、实现情况下的一种现象，表现为：对象多态、行为多态。 比如：Teacher和Student都是People的子类，代码可以写成下面的样子 1.2 多态的好处各位同学，刚才我们认识了什么是多态。那么多态的写法有什么好处呢？ 在多态形式下，右边的代码是解耦合的，更便于扩展和维护。 怎么理解这句话呢？比如刚开始p1指向Student对象，run方法执行的就是Student对象的业务；假如p1指向Student对象 ，run方法执行的自然是Student对象的业务。 定义方法时，使用父类类型作为形参，可以接收一切子类对象，扩展行更强，更便利。 1234567891011121314151617public class Test2 &#123; public static void main(String[] args) &#123; // 目标：掌握使用多态的好处 Teacher t = new Teacher(); go(t); Student s = new Student(); go(s); &#125; //参数People p既可以接收Student对象，也能接收Teacher对象。 public static void go(People p)&#123; System.out.println(&quot;开始------------------------&quot;); p.run(); System.out.println(&quot;结束------------------------&quot;); &#125;&#125; 1.3 类型转换虽然多态形式下有一些好处，但是也有一些弊端。在多态形式下，不能调用子类特有的方法，比如在Teacher类中多了一个teach方法，在Student类中多了一个study方法，这两个方法在多态形式下是不能直接调用的。 多态形式下不能直接调用子类特有方法，但是转型后是可以调用的。这里所说的转型就是把父类变量转换为子类类型。格式如下： 12345//如果p接收的是子类对象if(父类变量 instance 子类)&#123; //则可以将p转换为子类类型 子类 变量名 = (子类)父类变量;&#125; 如果类型转换错了，就会出现类型转换异常ClassCastException，比如把Teacher类型转换成了Student类型. 关于多态转型问题，我们最终记住一句话：原本是什么类型，才能还原成什么类型 二、final关键字各位同学，接下来我们学习一个在面向对象编程中偶尔会用到的一个关键字叫final，也是为后面学习抽象类和接口做准备的。 2.1 final修饰符的特点我们先来认识一下final的特点，final关键字是最终的意思，可以修饰类、修饰方法、修饰变量。 123- final修饰类：该类称为最终类，特点是不能被继承- final修饰方法：该方法称之为最终方法，特点是不能被重写。- final修饰变量：该变量只能被赋值一次。 接下来我们分别演示一下，先看final修饰类的特点 再来演示一下final修饰方法的特点 再演示一下final修饰变量的特点 情况一 情况二 情况三 2.2 补充知识：常量刚刚我们学习了final修饰符的特点，在实际运用当中经常使用final来定义常量。先说一下什么是Java中的常量？ 被 static final 修饰的成员变量，称之为常量。 通常用于记录系统的配置信息 接下来我们用代码来演示一下 123456public class Constant &#123; //常量: 定义一个常量表示学校名称 //为了方便在其他类中被访问所以一般还会加上public修饰符 //常量命名规范：建议都采用大写字母命名，多个单词之前有_隔开 public static final String SCHOOL_NAME = &quot;传智教育&quot;;&#125; 123456789101112public class FinalDemo2 &#123; public static void main(String[] args) &#123; //由于常量是static的所以，在使用时直接用类名就可以调用 System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); &#125;&#125; 关于常量的原理，同学们也可以了解一下：在程序编译后，常量会“宏替换”，出现常量的地方，全都会被替换为其记住的字面量。把代码反编译后，其实代码是下面的样子 1234567891011public class FinalDemo2 &#123; public static void main(String[] args) &#123; System.out.println(&quot;传智教育&quot;); System.out.println(&quot;传智教育&quot;E); System.out.println(&quot;传智教育&quot;); System.out.println(&quot;传智教育&quot;); System.out.println(&quot;传智教育&quot;); System.out.println(&quot;传智教育&quot;); System.out.println(&quot;传智教育&quot;); &#125;&#125; 三、抽象同学们，接下来我们学习Java中一种特殊的类，叫抽象类。为了让同学们掌握抽象类，会先让同学们认识一下什么是抽象类以及抽象类的特点，再学习一个抽象类的常见应用场景。 3.1 认识抽象类我们先来认识一下什么是抽象类，以及抽象类有什么特点。 在Java中有一个关键字叫abstract，它就是抽象的意思，它可以修饰类也可以修饰方法。 12- 被abstract修饰的类，就是抽象类- 被abstract修饰的方法，就是抽象方法（不允许有方法体） 接下来用代码来演示一下抽象类和抽象方法 12345//abstract修饰类，这个类就是抽象类public abstract class A&#123; //abstract修饰方法，这个方法就是抽象方法 public abstract void test();&#125; 类的成员（成员变量、成员方法、构造器），类的成员都可以有。如下面代码 1234567891011121314151617181920212223// 抽象类public abstract class A &#123; //成员变量 private String name; static String schoolName; //构造方法 public A()&#123; &#125; //抽象方法 public abstract void test(); //实例方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 抽象类是不能创建对象的，如果抽象类的对象就会报错 抽象类虽然不能创建对象，但是它可以作为父类让子类继承。而且子类继承父类必须重写父类的所有抽象方法。 1234567//B类继承A类，必须复写test方法public class B extends A &#123; @Override public void test() &#123; &#125;&#125; 子类继承父类如果不复写父类的抽象方法，要想不出错，这个子类也必须是抽象类 1234//B类基础A类，此时B类也是抽象类，这个时候就可以不重写A类的抽象方法public abstract class B extends A &#123;&#125; 3.2 抽象类的好处接下来我们用一个案例来说一下抽象类的应用场景和好处。需求如下图所示 分析需求发现，该案例中猫和狗都有名字这个属性，也都有叫这个行为，所以我们可以将共性的内容抽取成一个父类，Animal类，但是由于猫和狗叫的声音不一样，于是我们在Animal类中将叫的行为写成抽象的。代码如下 1234567891011121314public abstract class Animal &#123; private String name; //动物叫的行为：不具体，是抽象的 public abstract void cry(); public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 接着写一个Animal的子类，Dog类。代码如下 12345public class Dog extends Animal&#123; public void cry()&#123; System.out.println(getName() + &quot;汪汪汪的叫~~&quot;); &#125;&#125; 然后，再写一个Animal的子类，Cat类。代码如下 12345public class Cat extends Animal&#123; public void cry()&#123; System.out.println(getName() + &quot;喵喵喵的叫~~&quot;); &#125;&#125; 最后，再写一个测试类，Test类。 1234567public class Test2 &#123; public static void main(String[] args) &#123; // 目标：掌握抽象类的使用场景和好处. Animal a = new Dog(); a.cry(); //这时执行的是Dog类的cry方法 &#125;&#125; 再学一招，假设现在系统有需要加一个Pig类，也有叫的行为，这时候也很容易原有功能扩展。只需要让Pig类继承Animal，复写cry方法就行。 123456public class Pig extends Animal&#123; @Override public void cry() &#123; System.out.println(getName() + &quot;嚯嚯嚯~~~&quot;); &#125;&#125; 此时，创建对象时，让Animal接收Pig，就可以执行Pig的cry方法 1234567public class Test2 &#123; public static void main(String[] args) &#123; // 目标：掌握抽象类的使用场景和好处. Animal a = new Pig(); a.cry(); //这时执行的是Pig类的cry方法 &#125;&#125; 综上所述，我们总结一下抽象类的使用场景和好处 1231.用抽象类可以把父类中相同的代码，包括方法声明都抽取到父类，这样能更好的支持多态，一提高代码的灵活性。2.反过来用，我们不知道系统未来具体的业务实现时，我们可以先定义抽象类，将来让子类去实现，以方便系统的扩展。 3.3 模板方法模式学习完抽象类的语法之后，接下来，我们学习一种利用抽象类实现的一种设计模式。先解释下一什么是设计模式？设计模式是解决某一类问题的最优方案。 设计模式在一些源码中经常会出现，还有以后面试的时候偶尔也会被问到，所以在合适的机会，就会给同学们介绍一下设计模式的知识。 那模板方法设计模式解决什么问题呢？模板方法模式主要解决方法中存在重复代码的问题 比如A类和B类都有sing()方法，sing()方法的开头和结尾都是一样的，只是中间一段内容不一样。此时A类和B类的sing()方法中就存在一些相同的代码。 怎么解决上面的重复代码问题呢？ 我们可以写一个抽象类C类，在C类中写一个doSing()的抽象方法。再写一个sing()方法，代码如下： 12345678910111213// 模板方法设计模式public abstract class C &#123; // 模板方法 public final void sing()&#123; System.out.println(&quot;唱一首你喜欢的歌：&quot;); doSing(); System.out.println(&quot;唱完了!&quot;); &#125; public abstract void doSing();&#125; 然后，写一个A类继承C类，复写doSing()方法，代码如下 123456public class A extends C&#123; @Override public void doSing() &#123; System.out.println(&quot;我是一只小小小小鸟，想要飞就能飞的高~~~&quot;); &#125;&#125; 接着，再写一个B类继承C类，也复写doSing()方法，代码如下 123456public class B extends C&#123; @Override public void doSing() &#123; System.out.println(&quot;我们一起学猫叫，喵喵喵喵喵喵喵~~&quot;); &#125;&#125; 最后，再写一个测试类Test 1234567public class Test &#123; public static void main(String[] args) &#123; // 目标：搞清楚模板方法设计模式能解决什么问题，以及怎么写。 B b = new B(); b.sing(); &#125;&#125; 综上所述：模板方法模式解决了多个子类中有相同代码的问题。具体实现步骤如下 123第1步：定义一个抽象类，把子类中相同的代码写成一个模板方法。第2步：把模板方法中不能确定的代码写成抽象方法，并在模板方法中调用。第3步：子类继承抽象类，只需要父类抽象方法就可以了。 四、接口同学们，接下来我们学习一个比抽象类抽象得更加彻底的一种特殊结构，叫做接口。在学习接口是什么之前，有一些事情需要给大家交代一下：Java已经发展了20多年了，在发展的过程中不同JDK版本的接口也有一些变化，所以我们在学习接口时，先以老版本为基础，学习完老版本接口的特性之后，再顺带着了解一些新版本接口的特性就可以了。 4.1 认识接口我们先来认识一下接口？Java提供了一个关键字interface，用这个关键字来定义接口这种特殊结构。格式如下 1234public interface 接口名&#123; //成员变量（常量） //成员方法（抽象方法）&#125; 按照接口的格式，我们定义一个接口看看 1234567public interface A&#123; //这里public static final可以加，可以不加。 public static final String SCHOOL_NAME = &quot;黑马程序员&quot;; //这里的public abstract可以加，可以不加。 public abstract void test();&#125; 写好A接口之后，在写一个测试类，用一下 123456789public class Test&#123; public static void main(String[] args)&#123; //打印A接口中的常量 System.out.println(A.SCHOOL_NAME); //接口是不能创建对象的 A a = new A(); &#125;&#125; 我们发现定义好接口之后，是不能创建对象的。那接口到底什么使用呢？需要我注意下面两点 接口是用来被类实现（implements）的，我们称之为实现类。 一个类是可以实现多个接口的（接口可以理解成干爹），类实现接口必须重写所有接口的全部抽象方法，否则这个类也必须是抽象类 比如，再定义一个B接口，里面有两个方法testb1()，testb2() 1234public interface B &#123; void testb1(); void testb2();&#125; 接着，再定义一个C接口，里面有两个方法testc1(), testc2() 1234public interface C &#123; void testc1(); void testc2();&#125; 然后，再写一个实现类D，同时实现B接口和C接口，此时就需要复写四个方法，如下代码 12345678910111213141516171819202122// 实现类public class D implements B, C&#123; @Override public void testb1() &#123; &#125; @Override public void testb2() &#123; &#125; @Override public void testc1() &#123; &#125; @Override public void testc2() &#123; &#125;&#125; 最后，定义一个测试类Test 123456789public class Test &#123; public static void main(String[] args) &#123; // 目标：认识接口。 System.out.println(A.SCHOOL_NAME); // A a = new A(); D d = new D(); &#125;&#125; 4.2 接口的好处同学们，刚刚上面我们学习了什么是接口，以及接口的基本特点。那使用接口到底有什么好处呢？主要有下面的两点 弥补了类单继承的不足，一个类同时可以实现多个接口。 让程序可以面向接口编程，这样程序员可以灵活方便的切换各种业务实现。 我们看一个案例演示，假设有一个Studnet学生类，还有一个Driver司机的接口，还有一个Singer歌手的接口。 现在要写一个A类，想让他既是学生，偶然也是司机能够开车，偶尔也是歌手能够唱歌。那我们代码就可以这样设计，如下： 123456789101112131415161718192021222324252627282930313233343536class Student&#123;&#125;interface Driver&#123; void drive();&#125;interface Singer&#123; void sing();&#125;//A类是Student的子类，同时也实现了Dirver接口和Singer接口class A extends Student implements Driver, Singer&#123; @Override public void drive() &#123; &#125; @Override public void sing() &#123; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; //想唱歌的时候，A类对象就表现为Singer类型 Singer s = new A(); s.sing(); //想开车的时候，A类对象就表现为Driver类型 Driver d = new A(); d.drive(); &#125;&#125; 综上所述：接口弥补了单继承的不足，同时可以轻松实现在多种业务场景之间的切换。 4.3 接口的案例各位同学，关于接口的特点以及接口的好处我们都已经学习完了。接下来我们做一个案例，先来看一下案例需求. 首先我们写一个学生类，用来描述学生的相关信息 1234567891011121314151617181920212223242526272829303132333435363738public class Student &#123; private String name; private char sex; private double score; public Student() &#123; &#125; public Student(String name, char sex, double score) &#123; this.name = name; this.sex = sex; this.score = score; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125;&#125; 接着，写一个StudentOperator接口，表示学生信息管理系统的两个功能。 1234public interface StudentOperator &#123; void printAllInfo(ArrayList&lt;Student&gt; students); void printAverageScore(ArrayList&lt;Student&gt; students);&#125; 然后，写一个StudentOperator接口的实现类StudentOperatorImpl1，采用第1套方案对业务进行实现。 123456789101112131415161718192021public class StudentOperatorImpl1 implements StudentOperator&#123; @Override public void printAllInfo(ArrayList&lt;Student&gt; students) &#123; System.out.println(&quot;----------全班全部学生信息如下--------------&quot;); for (int i = 0; i &lt; students.size(); i++) &#123; Student s = students.get(i); System.out.println(&quot;姓名：&quot; + s.getName() + &quot;, 性别：&quot; + s.getSex() + &quot;, 成绩：&quot; + s.getScore()); &#125; System.out.println(&quot;-----------------------------------------&quot;); &#125; @Override public void printAverageScore(ArrayList&lt;Student&gt; students) &#123; double allScore = 0.0; for (int i = 0; i &lt; students.size(); i++) &#123; Student s = students.get(i); allScore += s.getScore(); &#125; System.out.println(&quot;平均分：&quot; + (allScore) / students.size()); &#125;&#125; 接着，再写一个StudentOperator接口的实现类StudentOperatorImpl2，采用第2套方案对业务进行实现。 123456789101112131415161718192021222324252627282930313233343536public class StudentOperatorImpl2 implements StudentOperator&#123; @Override public void printAllInfo(ArrayList&lt;Student&gt; students) &#123; System.out.println(&quot;----------全班全部学生信息如下--------------&quot;); int count1 = 0; int count2 = 0; for (int i = 0; i &lt; students.size(); i++) &#123; Student s = students.get(i); System.out.println(&quot;姓名：&quot; + s.getName() + &quot;, 性别：&quot; + s.getSex() + &quot;, 成绩：&quot; + s.getScore()); if(s.getSex() == &#x27;男&#x27;)&#123; count1++; &#125;else &#123; count2 ++; &#125; &#125; System.out.println(&quot;男生人数是：&quot; + count1 + &quot;, 女士人数是：&quot; + count2); System.out.println(&quot;班级总人数是：&quot; + students.size()); System.out.println(&quot;-----------------------------------------&quot;); &#125; @Override public void printAverageScore(ArrayList&lt;Student&gt; students) &#123; double allScore = 0.0; double max = students.get(0).getScore(); double min = students.get(0).getScore(); for (int i = 0; i &lt; students.size(); i++) &#123; Student s = students.get(i); if(s.getScore() &gt; max) max = s.getScore(); if(s.getScore() &lt; min) min = s.getScore(); allScore += s.getScore(); &#125; System.out.println(&quot;学生的最高分是：&quot; + max); System.out.println(&quot;学生的最低分是：&quot; + min); System.out.println(&quot;平均分：&quot; + (allScore - max - min) / (students.size() - 2)); &#125;&#125; 再写一个班级管理类ClassManager，在班级管理类中使用StudentOperator的实现类StudentOperatorImpl1对学生进行操作 123456789101112131415161718192021public class ClassManager &#123; private ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); private StudentOperator studentOperator = new StudentOperatorImpl1(); public ClassManager()&#123; students.add(new Student(&quot;迪丽热巴&quot;, &#x27;女&#x27;, 99)); students.add(new Student(&quot;古力娜扎&quot;, &#x27;女&#x27;, 100)); students.add(new Student(&quot;马尔扎哈&quot;, &#x27;男&#x27;, 80)); students.add(new Student(&quot;卡尔扎巴&quot;, &#x27;男&#x27;, 60)); &#125; // 打印全班全部学生的信息 public void printInfo()&#123; studentOperator.printAllInfo(students); &#125; // 打印全班全部学生的平均分 public void printScore()&#123; studentOperator.printAverageScore(students); &#125;&#125; 最后，再写一个测试类Test，在测试类中使用ClassMananger完成班级学生信息的管理。 12345678public class Test &#123; public static void main(String[] args) &#123; // 目标：完成班级学生信息管理的案例。 ClassManager clazz = new ClassManager(); clazz.printInfo(); clazz.printScore(); &#125;&#125; 注意：如果想切换班级管理系统的业务功能，随时可以将StudentOperatorImpl1切换为StudentOperatorImpl2。自己试试 4.4 接口JDK8的新特性各位同学，对于接口最常见的特性我们都学习完了。随着JDK版本的升级，在JDK8版本以后接口中能够定义的成员也做了一些更新，从JDK8开始，接口中新增的三种方法形式。 我们看一下这三种方法分别有什么特点？ 12345678910111213141516171819202122232425262728293031public interface A &#123; /** * 1、默认方法：必须使用default修饰，默认会被public修饰 * 实例方法：对象的方法，必须使用实现类的对象来访问。 */ default void test1()&#123; System.out.println(&quot;===默认方法==&quot;); test2(); &#125; /** * 2、私有方法：必须使用private修饰。(JDK 9开始才支持的) * 实例方法：对象的方法。 */ private void test2()&#123; System.out.println(&quot;===私有方法==&quot;); &#125; /** * 3、静态方法：必须使用static修饰，默认会被public修饰 */ static void test3()&#123; System.out.println(&quot;==静态方法==&quot;); &#125; void test4(); void test5(); default void test6()&#123; &#125;&#125; 接下来我们写一个B类，实现A接口。B类作为A接口的实现类，只需要重写抽象方法就尅了，对于默认方法不需要子类重写。代码如下： 1234567891011public class B implements A&#123; @Override public void test4() &#123; &#125; @Override public void test5() &#123; &#125;&#125; 最后，写一个测试类，观察接口中的三种方法，是如何调用的 123456789public class Test &#123; public static void main(String[] args) &#123; // 目标：掌握接口新增的三种方法形式 B b = new B(); b.test1(); //默认方法使用对象调用 // b.test2(); //A接口中的私有方法，B类调用不了 A.test3(); //静态方法，使用接口名调用 &#125;&#125; 综上所述：JDK8对接口新增的特性，有利于对程序进行扩展。 4.5 接口的其他细节最后，给同学们介绍一下使用接口的其他细节，或者说注意事项： 一个接口可以继承多个接口 12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args) &#123; // 目标：理解接口的多继承。 &#125;&#125;interface A&#123; void test1();&#125;interface B&#123; void test2();&#125;interface C&#123;&#125;//比如：D接口继承C、B、Ainterface D extends C, B, A&#123;&#125;//E类在实现D接口时，必须重写D接口、以及其父类中的所有抽象方法。class E implements D&#123; @Override public void test1() &#123; &#125; @Override public void test2() &#123; &#125;&#125; 接口除了上面的多继承特点之外，在多实现、继承和实现并存时，有可能出现方法名冲突的问题，需要了解怎么解决（仅仅只是了解一下，实际上工作中几乎不会出现这种情况） 12341.一个接口继承多个接口，如果多个接口中存在相同的方法声明，则此时不支持多继承2.一个类实现多个接口，如果多个接口中存在相同的方法声明，则此时不支持多实现3.一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会有限使用父类的方法4.一个类实现类多个接口，多个接口中有同名的默认方法，则这个类必须重写该方法。 综上所述：一个接口可以继承多个接口，接口同时也可以被类实现。","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day13-常用API","slug":"day13-常用API","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day13-常用API/","link":"","permalink":"https://wxzhou.top/2020/05/05/day13-%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"一、 StringBuilder类 StringBuilder代表可变字符串对象，相当于是一个容器，它里面的字符串是可以改变的，就是用来操作字符串的。 好处：StringBuilder比String更合适做字符串的修改操作，效率更高，代码也更加简洁。 1.1 StringBuilder方法演示 接下来我们用代码演示一下StringBuilder的用法 12345678910111213141516171819202122232425public class Test&#123; public static void main(String[] args)&#123; StringBuilder sb = new StringBuilder(&quot;itehima&quot;); //1.拼接内容 sb.append(12); sb.append(&quot;黑马&quot;); sb.append(true); //2.append方法，支持临时编程 sb.append(666).append(&quot;黑马2&quot;).append(666); System.out.println(sb); //打印：12黑马666黑马2666 //3.反转操作 sb.reverse(); System.out.println(sb); //打印：6662马黑666马黑21 //4.返回字符串的长度 System.out.println(sb.length()); //5.StringBuilder还可以转换为字符串 String s = sb.toString(); System.out.println(s); //打印：6662马黑666马黑21 &#125;&#125; 为什么要用StringBuilder对字符串进行操作呢？因为它的效率比String更高，我们可以下面两段代码验证一下。 经过我的验证，直接使用Stirng拼接100万次，等了1分钟，还没结束，我等不下去了；但是使用StringBuilder做拼接，不到1秒钟出结果了。 1.2 StringBuilder应用案例 接下来，我们通过一个案例把StringBuilder运用下，案例需求如下图所示 代码如下 12345678910111213141516171819202122232425public class Test&#123; public static void main(String[] args)&#123; String str = getArrayData( new int[]&#123;11,22,33&#125;); System.out.println(str); &#125; //方法作用：将int数组转换为指定格式的字符串 public static String getArrayData(int[] arr)&#123; //1.判断数组是否为null if(arr==null)&#123; return null; &#125; //2.如果数组不为null，再遍历，并拼接数组中的元素 StringBuilder sb = new StringBuilder(&quot;[&quot;); for(int i=0; i&lt;arr.length; i++)&#123; if(i==arr.legnth-1)&#123; sb.append(arr[i]).append(&quot;]&quot;);; &#125;else&#123; sb.append(arr[i]).append(&quot;,&quot;); &#125; &#125; //3、把StirngBuilder转换为String，并返回。 return sb.toString(); &#125;&#125; 二、StringJoiner类接下来，我们学习一个类叫做StringJoiner，学习这个类干嘛用呢？是因为我们前面使用StringBuilder拼接字符串的时，代码写起来还是有一点麻烦，而StringJoiner号称是拼接神器，不仅效率高，而且代码简洁。 下面演示一下StringJoiner的基本使用 123456789101112131415161718public class Test&#123; public static void main(String[] args)&#123; StringJoiner s = new StringJoiner(&quot;,&quot;); s.add(&quot;java1&quot;); s.add(&quot;java2&quot;); s.add(&quot;java3&quot;); System.out.println(s); //结果为： java1,java2,java3 //参数1：间隔符 //参数2：开头 //参数3：结尾 StringJoiner s1 = new StringJoiner(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;); s1.add(&quot;java1&quot;); s1.add(&quot;java2&quot;); s1.add(&quot;java3&quot;); System.out.println(s1); //结果为： [java1,java2,java3] &#125;&#125; 使用StirngJoiner改写前面把数组转换为字符串的案例 12345678910111213141516171819202122public class Test&#123; public static void main(String[] args)&#123; String str = getArrayData( new int[]&#123;11,22,33&#125;); System.out.println(str); &#125; //方法作用：将int数组转换为指定格式的字符串 public static String getArrayData(int[] arr)&#123; //1.判断数组是否为null if(arr==null)&#123; return null; &#125; //2.如果数组不为null，再遍历，并拼接数组中的元素 StringJoiner s = new StringJoiner(&quot;, &quot;,&quot;[&quot;,&quot;]&quot;); for(int i=0; i&lt;arr.length; i++)&#123; //加&quot;&quot;是因为add方法的参数要的是String类型 s.add(String.valueOf(arr[i])); &#125; //3、把StringJoiner转换为String，并返回。 return s.toString(); &#125;&#125; 三、Math类Math是数学的意思，该类提供了很多个进行数学运算的方法，如求绝对值，求最大值，四舍五入等，话不多说，直接上代码。 12345678910111213141516171819202122232425262728293031323334public class MathTest &#123; public static void main(String[] args) &#123; // 目标：了解下Math类提供的常见方法。 // 1、public static int abs(int a)：取绝对值（拿到的结果一定是正数） // public static double abs(double a) System.out.println(Math.abs(-12)); // 12 System.out.println(Math.abs(123)); // 123 System.out.println(Math.abs(-3.14)); // 3.14 // 2、public static double ceil(double a): 向上取整 System.out.println(Math.ceil(4.0000001)); // 5.0 System.out.println(Math.ceil(4.0)); // 4.0 // 3、public static double floor(double a): 向下取整 System.out.println(Math.floor(4.999999)); // 4.0 System.out.println(Math.floor(4.0)); // 4.0 // 4、public static long round(double a)：四舍五入 System.out.println(Math.round(3.4999)); // 3 System.out.println(Math.round(3.50001)); // 4 // 5、public static int max(int a, int b)：取较大值 // public static int min(int a, int b)：取较小值 System.out.println(Math.max(10, 20)); // 20 System.out.println(Math.min(10, 20)); // 10 // 6、 public static double pow(double a, double b)：取次方 System.out.println(Math.pow(2, 3)); // 2的3次方 8.0 System.out.println(Math.pow(3, 2)); // 3的2次方 9.0 // 7、public static double random()： 取随机数 [0.0 , 1.0) (包前不包后) System.out.println(Math.random()); &#125;&#125; 四、 System类接下来，学习一个System类，这是系统类，提供了一些获取获取系统数据的方法。比如获取系统时间。 12345678910111213141516171819202122232425/** * 目标：了解下System类的常见方法。 */public class SystemTest &#123; public static void main(String[] args) &#123; // 1、public static void exit(int status): // 终止当前运行的Java虚拟机。 // 该参数用作状态代码; 按照惯例，非零状态代码表示异常终止。 System.exit(0); // 人为的终止虚拟机。(不要使用) // 2、public static long currentTimeMillis(): // 获取当前系统的时间 // 返回的是long类型的时间毫秒值：指的是从1970-1-1 0:0:0开始走到此刻的总的毫秒值，1s = 1000ms long time = System.currentTimeMillis(); System.out.println(time); for (int i = 0; i &lt; 1000000; i++) &#123; System.out.println(&quot;输出了：&quot; + i); &#125; long time2 = System.currentTimeMillis(); System.out.println((time2 - time) / 1000.0 + &quot;s&quot;); &#125;&#125; 五、Runtime类接下来，我们再学习一个Java的运行时类，叫Runtime类。这个类可以用来获取JVM的一些信息，也可以用这个类去执行其他的程序。话不多少，上代码。 12345678910111213141516171819202122232425262728/** * 目标：了解下Runtime的几个常见方法。 */public class RuntimeTest &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; // 1、public static Runtime getRuntime() 返回与当前Java应用程序关联的运行时对象。 Runtime r = Runtime.getRuntime(); // 2、public void exit(int status) 终止当前运行的虚拟机,该参数用作状态代码; 按照惯例，非零状态代码表示异常终止。 // r.exit(0); // 3、public int availableProcessors(): 获取虚拟机能够使用的处理器数。 System.out.println(r.availableProcessors()); // 4、public long totalMemory() 返回Java虚拟机中的内存总量。 System.out.println(r.totalMemory()/1024.0/1024.0 + &quot;MB&quot;); // 1024 = 1K 1024 * 1024 = 1M // 5、public long freeMemory() 返回Java虚拟机中的可用内存量 System.out.println(r.freeMemory()/1024.0/1024.0 + &quot;MB&quot;); // 6、public Process exec(String command) 启动某个程序，并返回代表该程序的对象。 // r.exec(&quot;D:\\\\soft\\\\XMind\\\\XMind.exe&quot;); Process p = r.exec(&quot;QQ&quot;); Thread.sleep(5000); // 让程序在这里暂停5s后继续往下走！！ p.destroy(); // 销毁！关闭程序！ &#125;&#125; 六、BigDecimal类各位同学，接下来我们学习的这个类叫BigDecimal，至于它是干什么用的，我们先不说。我们先看一段代码，看这个代码有什么问题？再说BigDeimal这个类是干什么用的，这样会更好理解一些。 12345678public class Test &#123; public static void main(String[] args) &#123; System.out.println(0.1 + 0.2); System.out.println(1.0 - 0.32); System.out.println(1.015 * 100); System.out.println(1.301 / 100); &#125;&#125; 运行以上代码，我们会发现，结果并和我们想看到的不太一样。如下图所示 为了解决计算精度损失的问题，Java给我们提供了BigDecimal类，它提供了一些方法可以对数据进行四则运算，而且不丢失精度，同时还可以保留指定的小数位。下面看代码，演示一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Test2 &#123; public static void main(String[] args) &#123; // 目标：掌握BigDecimal进行精确运算的方案。 double a = 0.1; double b = 0.2; // 1、把浮点型数据封装成BigDecimal对象，再来参与运算。 // a、public BigDecimal(double val) 得到的BigDecimal对象是无法精确计算浮点型数据的。 注意：不推荐使用这个， // b、public BigDecimal(String val) 得到的BigDecimal对象是可以精确计算浮点型数据的。 可以使用。 // c、public static BigDecimal valueOf(double val): 通过这个静态方法得到的BigDecimal对象是可以精确运算的。是最好的方案。 BigDecimal a1 = BigDecimal.valueOf(a); BigDecimal b1 = BigDecimal.valueOf(b); // 2、public BigDecimal add(BigDecimal augend): 加法 BigDecimal c1 = a1.add(b1); System.out.println(c1); // 3、public BigDecimal subtract(BigDecimal augend): 减法 BigDecimal c2 = a1.subtract(b1); System.out.println(c2); // 4、public BigDecimal multiply(BigDecimal augend): 乘法 BigDecimal c3 = a1.multiply(b1); System.out.println(c3); // 5、public BigDecimal divide(BigDecimal b): 除法 BigDecimal c4 = a1.divide(b1); System.out.println(c4);// BigDecimal d1 = BigDecimal.valueOf(0.1);// BigDecimal d2 = BigDecimal.valueOf(0.3);// BigDecimal d3 = d1.divide(d2);// System.out.println(d3); // 6、public BigDecimal divide(另一个BigDecimal对象，精确几位，舍入模式) : 除法，可以设置精确几位。 BigDecimal d1 = BigDecimal.valueOf(0.1); BigDecimal d2 = BigDecimal.valueOf(0.3); BigDecimal d3 = d1.divide(d2, 2, RoundingMode.HALF_UP); // 0.33 System.out.println(d3); // 7、public double doubleValue() : 把BigDecimal对象又转换成double类型的数据。 //print(d3); //print(c1); double db1 = d3.doubleValue(); double db2 = c1.doubleValue(); print(db1); print(db2); &#125; public static void print(double a)&#123; System.out.println(a); &#125;&#125; 五、Date类接下来，我们学习一下Date类，Java中是由这个类的对象用来表示日期或者时间。 Date对象记录的时间是用毫秒值来表示的。Java语言规定，1970年1月1日0时0分0秒认为是时间的起点，此时记作0，那么1000（1秒&#x3D;1000毫秒）就表示1970年1月1日0时0分1秒，依次内推。 下面是Date类的构造方法，和常见的成员方法，利用这些API写代码尝试一下 12345678910111213141516171819202122public class Test1Date &#123; public static void main(String[] args) &#123; // 目标：掌握Date日期类的使用。 // 1、创建一个Date的对象：代表系统当前时间信息的。 Date d = new Date(); System.out.println(d); // 2、拿到时间毫秒值。 long time = d.getTime(); System.out.println(time); // 3、把时间毫秒值转换成日期对象： 2s之后的时间是多少。 time += 2 * 1000; Date d2 = new Date(time); System.out.println(d2); // 4、直接把日期对象的时间通过setTime方法进行修改 Date d3 = new Date(); d3.setTime(time); System.out.println(d3); &#125;&#125; 六、SimpleDateFormat类各位同学，前面我们打印Date对象时，发现打印输出的日期格式我们并不喜欢，是不是？你们喜欢那种格式呢？是不是像下面页面中这种格式啊？接下来我们学习的SimpleDateFormat类就可以转换Date对象表示日期时间的显示格式。 我们把Date对象转换为指定格式的日期字符串这个操作，叫做日期格式化， 反过来把指定格式的日期符串转换为Date对象的操作，叫做日期解析。 接下来，我们先演示一下日期格式化，需要用到如下的几个方法 注意：创建SimpleDateFormat对象时，在构造方法的参数位置传递日期格式，而日期格式是由一些特定的字母拼接而来的。我们需要记住常用的几种日期&#x2F;时间格式 123456789101112字母 表示含义yyyy 年MM 月dd 日HH 时mm 分ss 秒SSS 毫秒&quot;2022年12月12日&quot; 的格式是 &quot;yyyy年MM月dd日&quot;&quot;2022-12-12 12:12:12&quot; 的格式是 &quot;yyyy-MM-dd HH:mm:ss&quot;按照上面的格式可以任意拼接，但是字母不能写错 最后，上代码演示一下 123456789101112131415161718192021222324252627public class Test2SimpleDateFormat &#123; public static void main(String[] args) throws ParseException &#123; // 目标：掌握SimpleDateFormat的使用。 // 1、准备一些时间 Date d = new Date(); System.out.println(d); long time = d.getTime(); System.out.println(time); // 2、格式化日期对象，和时间 毫秒值。 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;); String rs = sdf.format(d); String rs2 = sdf.format(time); System.out.println(rs); System.out.println(rs2); System.out.println(&quot;----------------------------------------------&quot;); // 目标：掌握SimpleDateFormat解析字符串时间 成为日期对象。 String dateStr = &quot;2022-12-12 12:12:11&quot;; // 1、创建简单日期格式化对象 , 指定的时间格式必须与被解析的时间格式一模一样，否则程序会出bug. SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d2 = sdf2.parse(dateStr); System.out.println(d2); &#125;&#125; 日期格式化&amp;解析案例 123456789101112131415161718192021222324252627282930313233343536public class Test3 &#123; public static void main(String[] args) throws ParseException &#123; // 目标：完成秒杀案例。 // 1、把开始时间、结束时间、小贾下单时间、小皮下单时间拿到程序中来。 String start = &quot;2023年11月11日 0:0:0&quot;; String end = &quot;2023年11月11日 0:10:0&quot;; String xj = &quot;2023年11月11日 0:01:18&quot;; String xp = &quot;2023年11月11日 0:10:57&quot;; // 2、把字符串的时间解析成日期对象。 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); Date startDt = sdf.parse(start); Date endDt = sdf.parse(end); Date xjDt = sdf.parse(xj); Date xpDt = sdf.parse(xp); // 3、开始判断小皮和小贾是否秒杀成功了。 // 把日期对象转换成时间毫秒值来判断 long startTime = startDt.getTime(); long endTime = endDt.getTime(); long xjTime = xjDt.getTime(); long xpTime = xpDt.getTime(); if(xjTime &gt;= startTime &amp;&amp; xjTime &lt;= endTime)&#123; System.out.println(&quot;小贾您秒杀成功了~~&quot;); &#125;else &#123; System.out.println(&quot;小贾您秒杀失败了~~&quot;); &#125; if(xpTime &gt;= startTime &amp;&amp; xpTime &lt;= endTime)&#123; System.out.println(&quot;小皮您秒杀成功了~~&quot;); &#125;else &#123; System.out.println(&quot;小皮您秒杀失败了~~&quot;); &#125; &#125;&#125; 七、Calendar类学完Date类和SimpleDateFormat类之后，我们再学习一个和日期相关的类，它是Calendar类。Calendar类表示日历，它提供了一些比Date类更好用的方法。 比如下面的案例，用Date类就不太好做，而用Calendar就特别方便。因为Calendar类提供了方法可以直接对日历中的年、月、日、时、分、秒等进行运算。 123456789101112131415161718192021222324252627282930313233343536public class Test4Calendar &#123; public static void main(String[] args) &#123; // 目标：掌握Calendar的使用和特点。 // 1、得到系统此刻时间对应的日历对象。 Calendar now = Calendar.getInstance(); System.out.println(now); // 2、获取日历中的某个信息 int year = now.get(Calendar.YEAR); System.out.println(year); int days = now.get(Calendar.DAY_OF_YEAR); System.out.println(days); // 3、拿到日历中记录的日期对象。 Date d = now.getTime(); System.out.println(d); // 4、拿到时间毫秒值 long time = now.getTimeInMillis(); System.out.println(time); // 5、修改日历中的某个信息 now.set(Calendar.MONTH, 9); // 修改月份成为10月份。 now.set(Calendar.DAY_OF_YEAR, 125); // 修改成一年中的第125天。 System.out.println(now); // 6、为某个信息增加或者减少多少 now.add(Calendar.DAY_OF_YEAR, 100); now.add(Calendar.DAY_OF_YEAR, -10); now.add(Calendar.DAY_OF_MONTH, 6); now.add(Calendar.HOUR, 12); now.set(2026, 11, 22); System.out.println(now); &#125;&#125; 八、为什么JDK8要新增日期类123456789101112131415161718192021222324/** * 目标：搞清楚为什么要用JDK 8开始新增的时间类。 */public class Test &#123; public static void main(String[] args) &#123; // 传统的时间类（Date、SimpleDateFormat、Calendar）存在如下问题： // 1、设计不合理，使用不方便，很多都被淘汰了。 Date d = new Date(); //System.out.println(d.getYear() + 1900); Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); System.out.println(year); // 2、都是可变对象，修改后会丢失最开始的时间信息。 // 3、线程不安全。 // 4、不能精确到纳秒，只能精确到毫秒。 // 1秒 = 1000毫秒 // 1毫秒 = 1000微妙 // 1微妙 = 1000纳秒 &#125;&#125; 九、JDK8日期、时间、日期时间接下来，我们学习一下JDK8新增的日期类。为什么以前的Date类就可以表示日期，为什么要有新增的日期类呢？原因如下 JDK8新增的日期类分得更细致一些，比如表示年月日用LocalDate类、表示时间秒用LocalTime类、而表示年月日时分秒用LocalDateTime类等；除了这些类还提供了对时区、时间间隔进行操作的类等。它们几乎把对日期&#x2F;时间的所有操作都通过了API方法，用起来特别方便。 先学习表示日期、时间、日期时间的类；有LocalDate、LocalTime、以及LocalDateTime类。仔细阅读代码，你会发现这三个类的用法套路都是一样的。 LocalDate类的基本使用 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test1_LocalDate &#123; public static void main(String[] args) &#123; // 0、获取本地日期对象(不可变对象) LocalDate ld = LocalDate.now(); // 年 月 日 System.out.println(ld); // 1、获取日期对象中的信息 int year = ld.getYear(); // 年 int month = ld.getMonthValue(); // 月(1-12) int day = ld.getDayOfMonth(); // 日 int dayOfYear = ld.getDayOfYear(); // 一年中的第几天 int dayOfWeek = ld.getDayOfWeek().getValue(); // 星期几 System.out.println(year); System.out.println(day); System.out.println(dayOfWeek); // 2、直接修改某个信息: withYear、withMonth、withDayOfMonth、withDayOfYear LocalDate ld2 = ld.withYear(2099); LocalDate ld3 = ld.withMonth(12); System.out.println(ld2); System.out.println(ld3); System.out.println(ld); // 3、把某个信息加多少: plusYears、plusMonths、plusDays、plusWeeks LocalDate ld4 = ld.plusYears(2); LocalDate ld5 = ld.plusMonths(2); // 4、把某个信息减多少：minusYears、minusMonths、minusDays、minusWeeks LocalDate ld6 = ld.minusYears(2); LocalDate ld7 = ld.minusMonths(2); // 5、获取指定日期的LocalDate对象： public static LocalDate of(int year, int month, int dayOfMonth) LocalDate ld8 = LocalDate.of(2099, 12, 12); LocalDate ld9 = LocalDate.of(2099, 12, 12); // 6、判断2个日期对象，是否相等，在前还是在后： equals isBefore isAfter System.out.println(ld8.equals(ld9));// true System.out.println(ld8.isAfter(ld)); // true System.out.println(ld8.isBefore(ld)); // false &#125;&#125; LocalTime类的基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142public class Test2_LocalTime &#123; public static void main(String[] args) &#123; // 0、获取本地时间对象 LocalTime lt = LocalTime.now(); // 时 分 秒 纳秒 不可变的 System.out.println(lt); // 1、获取时间中的信息 int hour = lt.getHour(); //时 int minute = lt.getMinute(); //分 int second = lt.getSecond(); //秒 int nano = lt.getNano(); //纳秒 // 2、修改时间：withHour、withMinute、withSecond、withNano LocalTime lt3 = lt.withHour(10); LocalTime lt4 = lt.withMinute(10); LocalTime lt5 = lt.withSecond(10); LocalTime lt6 = lt.withNano(10); // 3、加多少：plusHours、plusMinutes、plusSeconds、plusNanos LocalTime lt7 = lt.plusHours(10); LocalTime lt8 = lt.plusMinutes(10); LocalTime lt9 = lt.plusSeconds(10); LocalTime lt10 = lt.plusNanos(10); // 4、减多少：minusHours、minusMinutes、minusSeconds、minusNanos LocalTime lt11 = lt.minusHours(10); LocalTime lt12 = lt.minusMinutes(10); LocalTime lt13 = lt.minusSeconds(10); LocalTime lt14 = lt.minusNanos(10); // 5、获取指定时间的LocalTime对象： // public static LocalTime of(int hour, int minute, int second) LocalTime lt15 = LocalTime.of(12, 12, 12); LocalTime lt16 = LocalTime.of(12, 12, 12); // 6、判断2个时间对象，是否相等，在前还是在后： equals isBefore isAfter System.out.println(lt15.equals(lt16)); // true System.out.println(lt15.isAfter(lt)); // false System.out.println(lt15.isBefore(lt)); // true &#125;&#125; LocalDateTime类的基本使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Test3_LocalDateTime &#123; public static void main(String[] args) &#123; // 0、获取本地日期和时间对象。 LocalDateTime ldt = LocalDateTime.now(); // 年 月 日 时 分 秒 纳秒 System.out.println(ldt); // 1、可以获取日期和时间的全部信息 int year = ldt.getYear(); // 年 int month = ldt.getMonthValue(); // 月 int day = ldt.getDayOfMonth(); // 日 int dayOfYear = ldt.getDayOfYear(); // 一年中的第几天 int dayOfWeek = ldt.getDayOfWeek().getValue(); // 获取是周几 int hour = ldt.getHour(); //时 int minute = ldt.getMinute(); //分 int second = ldt.getSecond(); //秒 int nano = ldt.getNano(); //纳秒 // 2、修改时间信息： // withYear withMonth withDayOfMonth withDayOfYear withHour // withMinute withSecond withNano LocalDateTime ldt2 = ldt.withYear(2029); LocalDateTime ldt3 = ldt.withMinute(59); // 3、加多少: // plusYears plusMonths plusDays plusWeeks plusHours plusMinutes plusSeconds plusNanos LocalDateTime ldt4 = ldt.plusYears(2); LocalDateTime ldt5 = ldt.plusMinutes(3); // 4、减多少： // minusDays minusYears minusMonths minusWeeks minusHours minusMinutes minusSeconds minusNanos LocalDateTime ldt6 = ldt.minusYears(2); LocalDateTime ldt7 = ldt.minusMinutes(3); // 5、获取指定日期和时间的LocalDateTime对象： // public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, // int minute, int second, int nanoOfSecond) LocalDateTime ldt8 = LocalDateTime.of(2029, 12, 12, 12, 12, 12, 1222); LocalDateTime ldt9 = LocalDateTime.of(2029, 12, 12, 12, 12, 12, 1222); // 6、 判断2个日期、时间对象，是否相等，在前还是在后： equals、isBefore、isAfter System.out.println(ldt9.equals(ldt8)); System.out.println(ldt9.isAfter(ldt)); System.out.println(ldt9.isBefore(ldt)); // 7、可以把LocalDateTime转换成LocalDate和LocalTime // public LocalDate toLocalDate() // public LocalTime toLocalTime() // public static LocalDateTime of(LocalDate date, LocalTime time) LocalDate ld = ldt.toLocalDate(); LocalTime lt = ldt.toLocalTime(); LocalDateTime ldt10 = LocalDateTime.of(ld, lt); &#125;&#125; 十、JDK8日期（时区）接着，我们学习代表时区的两个类。由于世界各个国家与地区的经度不同，各地区的时间也有所不同，因此会划分为不同的时区。每一个时区的时间也不太一样。 12345678910111213141516171819202122232425262728293031public class Test4_ZoneId_ZonedDateTime &#123; public static void main(String[] args) &#123; // 目标：了解时区和带时区的时间。 // 1、ZoneId的常见方法： // public static ZoneId systemDefault(): 获取系统默认的时区 ZoneId zoneId = ZoneId.systemDefault(); System.out.println(zoneId.getId()); System.out.println(zoneId); // public static Set&lt;String&gt; getAvailableZoneIds(): 获取Java支持的全部时区Id System.out.println(ZoneId.getAvailableZoneIds()); // public static ZoneId of(String zoneId) : 把某个时区id封装成ZoneId对象。 ZoneId zoneId1 = ZoneId.of(&quot;America/New_York&quot;); // 2、ZonedDateTime：带时区的时间。 // public static ZonedDateTime now(ZoneId zone): 获取某个时区的ZonedDateTime对象。 ZonedDateTime now = ZonedDateTime.now(zoneId1); System.out.println(now); // 世界标准时间了 ZonedDateTime now1 = ZonedDateTime.now(Clock.systemUTC()); System.out.println(now1); // public static ZonedDateTime now()：获取系统默认时区的ZonedDateTime对象 ZonedDateTime now2 = ZonedDateTime.now(); System.out.println(now2); // Calendar instance = Calendar.getInstance(TimeZone.getTimeZone(zoneId1)); &#125;&#125; 十一、JDK8日期（Instant类）接下来，我们来学习Instant这个类。通过获取Instant的对象可以拿到此刻的时间，该时间由两部分组成：从1970-01-01 00:00:00 开始走到此刻的总秒数+不够1秒的纳秒数。 该类提供的方法如下图所示，可以用来获取当前时间，也可以对时间进行加、减、获取等操作。 作用：可以用来记录代码的执行时间，或用于记录用户操作某个事件的时间点。 12345678910111213141516171819202122232425262728/** * 目标：掌握Instant的使用。 */public class Test5_Instant &#123; public static void main(String[] args) &#123; // 1、创建Instant的对象，获取此刻时间信息 Instant now = Instant.now(); // 不可变对象 // 2、获取总秒数 long second = now.getEpochSecond(); System.out.println(second); // 3、不够1秒的纳秒数 int nano = now.getNano(); System.out.println(nano); System.out.println(now); Instant instant = now.plusNanos(111); // Instant对象的作用：做代码的性能分析，或者记录用户的操作时间点 Instant now1 = Instant.now(); // 代码执行。。。。 Instant now2 = Instant.now(); LocalDateTime l = LocalDateTime.now(); &#125;&#125; 十二、JDK8日期（格式化器）接下来，我们学习一个新增的日期格式化类，叫DateTimeFormater。它可以从来对日期进行格式化和解析。它代替了原来的SimpleDateFormat类。 需要用到的方法，如下图所示 接下来，将上面的方法用代码来演示一下 1234567891011121314151617181920212223242526/** * 目标：掌握JDK 8新增的DateTimeFormatter格式化器的用法。 */public class Test6_DateTimeFormatter &#123; public static void main(String[] args) &#123; // 1、创建一个日期时间格式化器对象出来。 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); // 2、对时间进行格式化 LocalDateTime now = LocalDateTime.now(); System.out.println(now); String rs = formatter.format(now); // 正向格式化 System.out.println(rs); // 3、格式化时间，其实还有一种方案。 String rs2 = now.format(formatter); // 反向格式化 System.out.println(rs2); // 4、解析时间：解析时间一般使用LocalDateTime提供的解析方法来解析。 String dateStr = &quot;2029年12月12日 12:12:11&quot;; LocalDateTime ldt = LocalDateTime.parse(dateStr, formatter); System.out.println(ldt); &#125;&#125; 十三、JDK8日期（Period类）除以了上新增的类，JDK8还补充了两个类，一个叫Period类、一个叫Duration类；这两个类可以用来对计算两个时间点的时间间隔。 其中Period用来计算日期间隔（年、月、日），Duration用来计算时间间隔（时、分、秒、纳秒） 先来演示Period类的用法，它的方法如下图所示。可以用来计算两个日期之间相隔的年、相隔的月、相隔的日。只能两个计算LocalDate对象之间的间隔 1234567891011121314151617/** * 目标：掌握Period的作用：计算机两个日期相差的年数，月数、天数。 */public class Test7_Period &#123; public static void main(String[] args) &#123; LocalDate start = LocalDate.of(2029, 8, 10); LocalDate end = LocalDate.of(2029, 12, 15); // 1、创建Period对象，封装两个日期对象。 Period period = Period.between(start, end); // 2、通过period对象获取两个日期对象相差的信息。 System.out.println(period.getYears()); System.out.println(period.getMonths()); System.out.println(period.getDays()); &#125;&#125; 十四、JDK8日期（Duration类）接下来，我们学习Duration类。它是用来表示两个时间对象的时间间隔。可以用于计算两个时间对象相差的天数、小时数、分数、秒数、纳秒数；支持LocalTime、LocalDateTime、Instant等时间 1234567891011121314151617public class Test8_Duration &#123; public static void main(String[] args) &#123; LocalDateTime start = LocalDateTime.of(2025, 11, 11, 11, 10, 10); LocalDateTime end = LocalDateTime.of(2025, 11, 11, 11, 11, 11); // 1、得到Duration对象 Duration duration = Duration.between(start, end); // 2、获取两个时间对象间隔的信息 System.out.println(duration.toDays());// 间隔多少天 System.out.println(duration.toHours());// 间隔多少小时 System.out.println(duration.toMinutes());// 间隔多少分 System.out.println(duration.toSeconds());// 间隔多少秒 System.out.println(duration.toMillis());// 间隔多少毫秒 System.out.println(duration.toNanos());// 间隔多少纳秒 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day14-Lambda、方法引用、算法、正则表达式","slug":"day14-Lambda、方法引用、算法、正则表达式","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day14-Lambda、方法引用、算法、正则表达式/","link":"","permalink":"https://wxzhou.top/2020/05/05/day14-Lambda%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"一、Arrays类接下来我们学习的类叫做Arrays，其实Arrays并不是重点，但是我们通过Arrays这个类的学习有助于我们理解下一个知识点Lambda的学习。所以我们这里先学习Arrays，再通过Arrays来学习Lamdba这样学习会更丝滑一些^_^. 1.1 Arrays基本使用我们先认识一下Arrays是干什么用的，Arrays是操作数组的工具类，它可以很方便的对数组中的元素进行遍历、拷贝、排序等操作。 下面我们用代码来演示一下：遍历、拷贝、排序等操作。需要用到的方法如下 1234567891011121314151617181920212223242526272829303132333435/** * 目标：掌握Arrays类的常用方法。 */public class ArraysTest1 &#123; public static void main(String[] args) &#123; // 1、public static String toString(类型[] arr): 返回数组的内容 int[] arr = &#123;10, 20, 30, 40, 50, 60&#125;; System.out.println(Arrays.toString(arr)); // 2、public static 类型[] copyOfRange(类型[] arr, 起始索引, 结束索引) ：拷贝数组（指定范围，包前不包后） int[] arr2 = Arrays.copyOfRange(arr, 1, 4); System.out.println(Arrays.toString(arr2)); // 3、public static copyOf(类型[] arr, int newLength)：拷贝数组，可以指定新数组的长度。 int[] arr3 = Arrays.copyOf(arr, 10); System.out.println(Arrays.toString(arr3)); // 4、public static setAll(double[] array, IntToDoubleFunction generator)：把数组中的原数据改为新数据又存进去。 double[] prices = &#123;99.8, 128, 100&#125;; // 0 1 2 // 把所有的价格都打八折，然后又存进去。 Arrays.setAll(prices, new IntToDoubleFunction() &#123; @Override public double applyAsDouble(int value) &#123; // value = 0 1 2 return prices[value] * 0.8; &#125; &#125;); System.out.println(Arrays.toString(prices)); // 5、public static void sort(类型[] arr)：对数组进行排序(默认是升序排序) Arrays.sort(prices); System.out.println(Arrays.toString(prices)); &#125;&#125; 1.2 Arrays操作对象数组刚才我们使用Arrays操作数组时，数组中存储存储的元素是int类型、double类型，是可以直接排序的，而且默认是升序排列。 如果数组中存储的元素类型是自定义的对象，如何排序呢？接下来，我们就学习一下Arrays如何对对象数组进行排序。 首先我们要准备一个Student类，代码如下： 123456789101112131415161718192021public class Student implements Comparable&lt;Student&gt;&#123; private String name; private double height; private int age; public Student(String name, double height, int age) &#123; this.name = name; this.height = height; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, height=&quot; + height + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 然后再写一个测试类，往数组中存储4个学生对象，代码如下。此时，运行代码你会发现是会报错的。 1234567891011121314public class ArraysTest2 &#123; public static void main(String[] args) &#123; // 目标：掌握如何对数组中的对象进行排序。 Student[] students = new Student[4]; students[0] = new Student(&quot;蜘蛛精&quot;, 169.5, 23); students[1] = new Student(&quot;紫霞&quot;, 163.8, 26); students[2] = new Student(&quot;紫霞&quot;, 163.8, 26); students[3] = new Student(&quot;至尊宝&quot;, 167.5, 24); // 1、public static void sort(类型[] arr)：对数组进行排序。 Arrays.sort(students); System.out.println(Arrays.toString(students)); &#125;&#125; 上面的代码为什么会报错呢？因为Arrays根本就不知道按照什么规则进行排序。为了让Arrays知道按照什么规则排序，我们有如下的两种办法。 排序方式1：让Student类实现Comparable接口，同时重写compareTo方法。Arrays的sort方法底层会根据compareTo方法的返回值是正数、负数、还是0来确定谁大、谁小、谁相等。代码如下： 1234567891011121314151617181920212223242526272829303132333435public class Student implements Comparable&lt;Student&gt;&#123; private String name; private double height; private int age; //...get、set、空参数构造方法、有参数构造方法...自己补全 // 指定比较规则 // this o @Override public int compareTo(Student o) &#123; // 约定1：认为左边对象 大于 右边对象 请您返回正整数 // 约定2：认为左边对象 小于 右边对象 请您返回负整数 // 约定3：认为左边对象 等于 右边对象 请您一定返回0 /* if(this.age &gt; o.age)&#123; return 1; &#125;else if(this.age &lt; o.age)&#123; return -1; &#125; return 0;*/ //上面的if语句，也可以简化为下面的一行代码 return this.age - o.age; // 按照年龄升序排列 // return o.age - this.age; // 按照年龄降序排列 &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, height=&quot; + height + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 排序方式2：在调用Arrays.sort(数组,Comparator比较器);时，除了传递数组之外，传递一个Comparator比较器对象。Arrays的sort方法底层会根据Comparator比较器对象的compare方法方法的返回值是正数、负数、还是0来确定谁大、谁小、谁相等。代码如下 1234567891011121314151617181920212223242526272829303132public class ArraysTest2 &#123; public static void main(String[] args) &#123; // 目标：掌握如何对数组中的对象进行排序。 Student[] students = new Student[4]; students[0] = new Student(&quot;蜘蛛精&quot;, 169.5, 23); students[1] = new Student(&quot;紫霞&quot;, 163.8, 26); students[2] = new Student(&quot;紫霞&quot;, 163.8, 26); students[3] = new Student(&quot;至尊宝&quot;, 167.5, 24); // 2、public static &lt;T&gt; void sort(T[] arr, Comparator&lt;? super T&gt; c) // 参数一：需要排序的数组 // 参数二：Comparator比较器对象（用来制定对象的比较规则） Arrays.sort(students, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; // 制定比较规则了：左边对象 o1 右边对象 o2 // 约定1：认为左边对象 大于 右边对象 请您返回正整数 // 约定2：认为左边对象 小于 右边对象 请您返回负整数 // 约定3：认为左边对象 等于 右边对象 请您一定返回0// if(o1.getHeight() &gt; o2.getHeight())&#123;// return 1;// &#125;else if(o1.getHeight() &lt; o2.getHeight())&#123;// return -1;// &#125;// return 0; // 升序 return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 // return Double.compare(o2.getHeight(), o1.getHeight()); // 降序 &#125; &#125;); System.out.println(Arrays.toString(students)); &#125;&#125; 二、Lambda表达式接下来，我们学习一个JDK8新增的一种语法形式，叫做Lambda表达式。作用：用于简化匿名内部类代码的书写。 2.1 Lambda表达式基本使用怎么去简化呢？Lamdba是有特有的格式的，按照下面的格式来编写Lamdba。 123(被重写方法的形参列表) -&gt; &#123; 被重写方法的方法体代码;&#125; 需要给说明一下的是，在使用Lambda表达式之前，必须先有一个接口，而且接口中只能有一个抽象方法。（注意：不能是抽象类，只能是接口） 像这样的接口，我们称之为函数式接口，只有基于函数式接口的匿名内部类才能被Lambda表达式简化。 123public interface Swimming&#123; void swim();&#125; 有了以上的Swimming接口之后，接下来才能再演示，使用Lambda表达式，简化匿名内部类书写。 12345678910111213141516171819public class LambdaTest1 &#123; public static void main(String[] args) &#123; // 目标：认识Lambda表达式. //1.创建一个Swimming接口的匿名内部类对象 Swimming s = new Swimming()&#123; @Override public void swim() &#123; System.out.println(&quot;学生快乐的游泳~~~~&quot;); &#125; &#125;; s.swim(); //2.使用Lambda表达式对Swimming接口的匿名内部类进行简化 Swimming s1 = () -&gt; &#123; System.out.println(&quot;学生快乐的游泳~~~~&quot;); &#125;; s1.swim(); &#125;&#125; 好的，我们现在已经知道Lamdba表达式可以简化基于函数式接口的匿名内部类的书写。接下来，我们可以把刚才使用Arrays方法时的代码，使用Lambda表达式简化一下了。 123456789101112131415161718192021222324252627282930313233343536373839public class LambdaTest2 &#123; public static void main(String[] args) &#123; // 目标：使用Lambda简化函数式接口。 double[] prices = &#123;99.8, 128, 100&#125;; //1.把所有元素*0.8: 先用匿名内部类写法 Arrays.setAll(prices, new IntToDoubleFunction() &#123; @Override public double applyAsDouble(int value) &#123; // value = 0 1 2 return prices[value] * 0.8; &#125; &#125;); //2.把所有元素*0.8: 改用Lamdba表达式写法 Arrays.setAll(prices, (int value) -&gt; &#123; return prices[value] * 0.8; &#125;); System.out.println(Arrays.toString(prices)); System.out.println(&quot;-----------------------------------------------&quot;); Student[] students = new Student[4]; students[0] = new Student(&quot;蜘蛛精&quot;, 169.5, 23); students[1] = new Student(&quot;紫霞&quot;, 163.8, 26); students[2] = new Student(&quot;紫霞&quot;, 163.8, 26); students[3] = new Student(&quot;至尊宝&quot;, 167.5, 24); //3.对数组中的元素按照年龄升序排列: 先用匿名内部类写法 Arrays.sort(students, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 &#125; &#125;); //4.对数组中的元素按照年龄升序排列: 改用Lambda写法 Arrays.sort(students, (Student o1, Student o2) -&gt; &#123; return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 &#125;); System.out.println(Arrays.toString(students)); &#125;&#125; 好的，各位同学，恭喜大家！到这里，你已经学会了Lambda表达式的基本使用了。 2.2 Lambda表达式省略规则刚才我们学习了Lambda表达式的基本使用。Java觉得代码还不够简单，于是还提供了Lamdba表达式的几种简化写法。具体的简化规则如下 12345678910111213141516171.Lambda的标准格式 (参数类型1 参数名1, 参数类型2 参数名2)-&gt;&#123; ...方法体的代码... return 返回值; &#125;2.在标准格式的基础上()中的参数类型可以直接省略 (参数名1, 参数名2)-&gt;&#123; ...方法体的代码... return 返回值; &#125; 3.如果&#123;&#125;总的语句只有一条语句，则&#123;&#125;可以省略、return关键字、以及最后的“;”都可以省略 (参数名1, 参数名2)-&gt; 结果 4.如果()里面只有一个参数，则()可以省略 (参数名)-&gt;结果 接下来从匿名内部类开始、到Lambda标准格式、再到Lambda简化格式，一步一步来简化一下。同学们体会一下简化的过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class LambdaTest2 &#123; public static void main(String[] args) &#123; // 目标：使用Lambda简化函数式接口。 double[] prices = &#123;99.8, 128, 100&#125;; //1.对数组中的每一个元素*0.8: 匿名内部类写法 Arrays.setAll(prices, new IntToDoubleFunction() &#123; @Override public double applyAsDouble(int value) &#123; // value = 0 1 2 return prices[value] * 0.8; &#125; &#125;); //2.需求：对数组中的每一个元素*0.8,使用Lambda表达式标准写法 Arrays.setAll(prices, (int value) -&gt; &#123; return prices[value] * 0.8; &#125;); //3.使用Lambda表达式简化格式1——省略参数类型 Arrays.setAll(prices, (value) -&gt; &#123; return prices[value] * 0.8; &#125;); //4.使用Lambda表达式简化格式2——省略() Arrays.setAll(prices, value -&gt; &#123; return prices[value] * 0.8; &#125;); //5.使用Lambda表达式简化格式3——省略&#123;&#125; Arrays.setAll(prices, value -&gt; prices[value] * 0.8 ); System.out.println(Arrays.toString(prices)); System.out.println(&quot;------------------------------------ Student[] students = new Student[4]; students[0] = new Student(&quot;蜘蛛精&quot;, 169.5, 23); students[1] = new Student(&quot;紫霞&quot;, 163.8, 26); students[2] = new Student(&quot;紫霞&quot;, 163.8, 26); students[3] = new Student(&quot;至尊宝&quot;, 167.5, 24); //1.使用匿名内部类 Arrays.sort(students, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 &#125; &#125;); //2.使用Lambda表达式表达式——标准格式 Arrays.sort(students, (Student o1, Student o2) -&gt; &#123; return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 &#125;); //3.使用Lambda表达式表达式——省略参数类型 Arrays.sort(students, ( o1, o2) -&gt; &#123; return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 &#125;); //4.使用Lambda表达式表达式——省略&#123;&#125; Arrays.sort(students, ( o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())); System.out.println(Arrays.toString(students)); &#125;&#125; 到这里，恭喜你，对Lamdba表达式的所有写法，就学习完毕了。 三、JDK8新特性（方法引用）各位小伙伴，接下来我们学习JDK8的另一个新特性，叫做方法引用。我们知道Lambda是用来简化匿名代码的书写格式的，而方法引用是用来进一步简化Lambda表达式的，它简化的更加过分。 到这里有小伙伴可能就想慰问Java爸爸了：“之前的代码挺好的呀！好不容易学会，你又来搞这些，把我都搞晕了。“ 说句大实话，确实有这样的问题，学习新的东西肯定会增加我们的学习成本，从心理上来说多少是有写抗拒的。但是从另一个角度想，一旦我们学会了，会大大简化我们的代码书写，提高我们编写代码的效率，而且这些新的语法都是有前提条件的，遇到的时候就简化得了。再退一步想，就算你没有学会，还是用以前的办法一点问题也没有。 给大家交代清楚了，学习方法引用可能存在的一些心理特点之后，接下来我们再正式学习方法引用的代码怎么编写。 3.1 静态方法引用我们先学习静态方法的引用，还是用之前Arrays代码来做演示。现在准备好下面的代码 1234567891011121314151617181920public class Test1 &#123; public static void main(String[] args) &#123; Student[] students = new Student[4]; students[0] = new Student(&quot;蜘蛛精&quot;, 169.5, 23); students[1] = new Student(&quot;紫霞&quot;, 163.8, 26); students[2] = new Student(&quot;紫霞&quot;, 163.8, 26); students[3] = new Student(&quot;至尊宝&quot;, 167.5, 24); // 原始写法：对数组中的学生对象，按照年龄升序排序 Arrays.sort(students, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getAge() - o2.getAge(); // 按照年龄升序排序 &#125; &#125;); // 使用Lambda简化后的形式 Arrays.sort(students, (o1, o2) -&gt; o1.getAge() - o2.getAge()); &#125;&#125; 现在，我想要把下图中Lambda表达式的方法体，用一个静态方法代替 准备另外一个类CompareByData类，用于封装Lambda表达式的方法体代码； 12345public class CompareByData &#123; public static int compareByAge(Student o1, Student o2)&#123; return o1.getAge() - o2.getAge(); // 升序排序的规则 &#125;&#125; 现在我们就可以把Lambda表达式的方法体代码，改为下面的样子 1Arrays.sort(students, (o1, o2) -&gt; CompareByData.compareByAge(o1, o2)); Java为了简化上面Lambda表达式的写法，利用方法引用可以改进为下面的样子。实际上就是用类名调用方法，但是把参数给省略了。这就是静态方法引用 12//静态方法引用：类名::方法名Arrays.sort(students, CompareByData::compareByAge); 3.2 实例方法引用还是基于上面的案例，我们现在来学习一下实例方法的引用。现在，我想要把下图中Lambda表达式的方法体，用一个实例方法代替。 在CompareByData类中，再添加一个实例方法，用于封装Lambda表达式的方法体 接下来，我们把Lambda表达式的方法体，改用对象调用方法 12CompareByData compare = new CompareByData();Arrays.sort(students, (o1, o2) -&gt; compare.compareByAgeDesc(o1, o2)); // 降序 最后，再将Lambda表达式的方法体，直接改成方法引用写法。实际上就是用类名调用方法，但是省略的参数。这就是实例方法引用 12CompareByData compare = new CompareByData();Arrays.sort(students, compare::compareByAgeDesc); // 降序 给小伙伴的寄语：一定要按照老师写的步骤，一步一步来做，你一定能学会的！！！ 3.2 特定类型的方法引用各位小伙伴，我们继续学习特定类型的方法引用。在学习之前还是需要给大家说明一下，这种特定类型的方法引用是没有什么道理的，只是语法的一种约定，遇到这种场景，就可以这样用。 1234Java约定： 如果某个Lambda表达式里只是调用一个实例方法，并且前面参数列表中的第一个参数作为方法的主调， 后面的所有参数都是作为该实例方法的入参时，则就可以使用特定类型的方法引用。格式： 类型::方法名 123456789101112131415161718192021public class Test2 &#123; public static void main(String[] args) &#123; String[] names = &#123;&quot;boby&quot;, &quot;angela&quot;, &quot;Andy&quot; ,&quot;dlei&quot;, &quot;caocao&quot;, &quot;Babo&quot;, &quot;jack&quot;, &quot;Cici&quot;&#125;; // 要求忽略首字符大小写进行排序。 Arrays.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // 制定比较规则。o1 = &quot;Andy&quot; o2 = &quot;angela&quot; return o1.compareToIgnoreCase(o2); &#125; &#125;); //lambda表达式写法 Arrays.sort(names, ( o1, o2) -&gt; o1.compareToIgnoreCase(o2) ); //特定类型的方法引用！ Arrays.sort(names, String::compareToIgnoreCase); System.out.println(Arrays.toString(names)); &#125;&#125; 3.3 构造器引用各位小伙伴，我们学习最后一种方法引用的形式，叫做构造器引用。还是先说明一下，构造器引用在实际开发中应用的并不多，目前还没有找到构造器的应用场景。所以大家在学习的时候，也只是关注语法就可以了。 现在，我们准备一个JavaBean类，Car类 12345678910111213141516171819202122232425262728293031323334353637public class Car &#123; private String name; private double price; public Car() &#123; &#125; public Car(String name, double price) &#123; this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; 因为方法引用是基于Lamdba表达式简化的，所以也要按照Lamdba表达式的使用前提来用，需要一个函数式接口，接口中代码的返回值类型是Car类型 123interface CreateCar&#123; Car create(String name, double price);&#125; 最后，再准备一个测试类，在测试类中创建CreateCar接口的实现类对象，先用匿名内部类创建、再用Lambda表达式创建，最后改用方法引用创建。同学们只关注格式就可以，不要去想为什么（语法就是这么设计的）。 12345678910111213141516171819202122public class Test3 &#123; public static void main(String[] args) &#123; // 1、创建这个接口的匿名内部类对象。 CreateCar cc1 = new CreateCar()&#123; @Override public Car create(String name, double price) &#123; return new Car(name, price); &#125; &#125;; //2、使用匿名内部类改进 CreateCar cc2 = (name, price) -&gt; new Car(name, price); //3、使用方法引用改进：构造器引用 CreateCar cc3 = Car::new; //注意：以上是创建CreateCar接口实现类对象的几种形式而已，语法一步一步简化。 //4、对象调用方法 Car car = cc3.create(&quot;奔驰&quot;, 49.9); System.out.println(car); &#125;&#125; 四、常见算法1.1 认识算法接下来，我们认识一下什么是算法。算法其实是解决某个实际问题的过程和方法。比如百度地图给你规划路径，计算最优路径的过程就需要用到算法。再比如你在抖音上刷视频时，它会根据你的喜好给你推荐你喜欢看的视频，这里也需要用到算法。 我们为什么要学习算法呢？主要目的是训练我们的编程思维，还有就是面试的时候，面试官也喜欢问一下算法的问题来考察你的技术水平。最后一点，学习算法是成为一个高级程序员的必经之路。 当然我们现在并不会学习非常复杂的算法，万丈高楼平地起，我们现在只需要学习几种常见的基础算法就可以了。而且Java语言本身就内置了一些基础算法给我们使用，实际上自己也不会去写这些算法。 1.2 冒泡排序接下来，我们学习一种算法叫排序算法，它可以价格无序的整数，排列成从小到大的形式（升序），或者从大到小的形式（降序） 排序算法有很多种，我们这里只学习比较简单的两种，一种是冒泡排序，一种是选择排序。学习算法我们先要搞清楚算法的流程，然后再去“推敲“如何写代码。（注意，我这里用的次是推敲，也就是说算法这样的代码并不是一次成型的，是需要反复修改才能写好的）。 先来学习冒泡排序，先来介绍一下，冒泡排序的流程 12345冒泡排序核心思路：每次将相邻的两个元素继续比较如下图所示： 第一轮比较 3次 第二轮比较 2次 第三轮比较 1次 12345678910111213141516171819202122232425public class Test1 &#123; public static void main(String[] args) &#123; // 1、准备一个数组 int[] arr = &#123;5, 2, 3, 1&#125;; // 2、定义一个循环控制排几轮 for (int i = 0; i &lt; arr.length - 1; i++) &#123; // i = 0 1 2 【5， 2， 3， 1】 次数 // i = 0 第一轮 0 1 2 3 // i = 1 第二轮 0 1 2 // i = 2 第三轮 0 1 // 3、定义一个循环控制每轮比较几次。 for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; // 判断当前位置的元素值，是否大于后一个位置处的元素值，如果大则交换。 if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125;&#125; 1.2 选择排序刚才我们学习了冒泡排序，接下来我们学习了另一种排序方法，叫做选择排序。按照我们刚才给大家介绍的算法的学习方式。先要搞清楚算法的流程，再去推敲代码怎么写。 所以我们先分析选择排序算法的流程：选择排序的核心思路是，每一轮选定一个固定的元素，和其他的每一个元素进行比较；经过几轮比较之后，每一个元素都能比较到了。 接下来，按照选择排序的流程编写代码 123456789101112131415161718192021222324ublic class Test2 &#123; public static void main(String[] args) &#123; // 1、准备好一个数组 int[] arr = &#123;5, 1, 3, 2&#125;; // 0 1 2 3 // 2、控制选择几轮 for (int i = 0; i &lt; arr.length - 1; i++) &#123; // i = 0 第一轮 j = 1 2 3 // i = 1 第二轮 j = 2 3 // i = 2 第三轮 j = 3 // 3、控制每轮选择几次。 for (int j = i + 1; j &lt; arr.length; j++) &#123; // 判断当前位置是否大于后面位置处的元素值，若大于则交换。 if(arr[i] &gt; arr[j])&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125;&#125; 1.3 查找算法接下来，我们学习一个查找算法叫做二分查找。在学习二分查找之前，我们先来说一下基本查找，从基本查找的弊端，我们再引入二分查找，这样我们的学习也会更加丝滑一下。 先聊一聊基本查找：假设我们要查找的元素是81，如果是基本查找的话，只能从0索引开始一个一个往后找，但是如果元素比较多，你要查找的元素比较靠后的话，这样查找的此处就比较多。性能比较差。 再讲二分查找：二分查找的主要特点是，每次查找能排除一般元素，这样效率明显提高。但是二分查找要求比较苛刻，它要求元素必须是有序的，否则不能进行二分查找。 二分查找的核心思路 12345678910第1步：先定义两个变量，分别记录开始索引(left)和结束索引(right)第2步：计算中间位置的索引，mid = (left+right)/2;第3步：每次查找中间mid位置的元素，和目标元素key进行比较 如果中间位置元素比目标元素小，那就说明mid前面的元素都比目标元素小 此时：left = mid+1 如果中间位置元素比目标元素大，那说明mid后面的元素都比目标元素大 此时：right = mid-1 如果中间位置元素和目标元素相等，那说明mid就是我们要找的位置 此时：把mid返回 注意：一搬查找一次肯定是不够的，所以需要把第1步和第2步循环来做，只到left&gt;end就结束，如果最后还没有找到目标元素，就返回-1. 12345678910111213141516171819202122232425262728293031323334353637/** * 目标：掌握二分查找算法。 */public class Test3 &#123; public static void main(String[] args) &#123; // 1、准备好一个数组。 int[] arr = &#123;7, 23, 79, 81, 103, 127, 131, 147&#125;; System.out.println(binarySearch(arr, 150)); System.out.println(Arrays.binarySearch(arr, 81)); &#125; public static int binarySearch(int[] arr, int data)&#123; // 1、定义两个变量，一个站在左边位置，一个站在右边位置 int left = 0; int right = arr.length - 1; // 2、定义一个循环控制折半。 while (left &lt;= right)&#123; // 3、每次折半，都算出中间位置处的索引 int middle = (left + right) / 2; // 4、判断当前要找的元素值，与中间位置处的元素值的大小情况。 if(data &lt; arr[middle])&#123; // 往左边找，截止位置（右边位置） = 中间位置 - 1 right = middle - 1; &#125;else if(data &gt; arr[middle])&#123; // 往右边找，起始位置（左边位置） = 中间位置 + 1 left = middle + 1; &#125;else &#123; // 中间位置处的元素值，正好等于我们要找的元素值 return middle; &#125; &#125; return -1; // -1特殊结果，就代表没有找到数据！数组中不存在该数据！ &#125;&#125; 五、正则表达式接下来，我们学习一个全新的知识，叫做正则表达式。正则表达式其实是由一些特殊的符号组成的，它代表的是某种规则。 正则表达式的作用1：用来校验字符串数据是否合法 正则表达式的作用2：可以从一段文本中查找满足要求的内容 5.1 正则表达式初体验现在，我们就以QQ号码为例，来体验一下正则表达式的用法。注意：现在仅仅只是体验而已，我们还没有讲正则表达式的具体写法。 不使用正则表达式，校验QQ号码代码是这样的 1234567891011121314151617181920public static boolean checkQQ(String qq)&#123; // 1、判断qq号码是否为null if(qq == null || qq.startsWith(&quot;0&quot;) || qq.length() &lt; 6 || qq.length() &gt; 20)&#123; return false; &#125; // 2、qq至少是不是null,不是以0开头的，满足6-20之间的长度。 // 判断qq号码中是否都是数字。 // qq = 2514ghd234 for (int i = 0; i &lt; qq.length(); i++) &#123; // 根据索引提取当前位置处的字符。 char ch = qq.charAt(i); // 判断ch记住的字符，如果不是数字，qq号码不合法。 if(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; return false; &#125; &#125; // 3、说明qq号码肯定是合法 return true; &#125; 用正则表达式代码是这样的 123public static boolean checkQQ1(String qq)&#123; return qq != null &amp;&amp; qq.matches(&quot;[1-9]\\\\d&#123;5,19&#125;&quot;);&#125; 我们发现，使用正则表达式，大大简化的了代码的写法。这个代码现在不用写，体验到正则表达式的优势就可以了。 5.2 正则表达式书写规则前面我们已经体验到了正则表达式，可以简化校验数据的代码书写。这里需要用到一个方法叫matches(String regex)。这个方法时属于String类的方法。 这个方法是用来匹配一个字符串是否匹配正则表达式的规则，参数需要调用者传递一个正则表达式。但是正则表达式不能乱写，是有特定的规则的。 下面我们就学习一下，正则表达式的规则。从哪里学呢？在API中有一个类叫做Pattern，我们可以到API文档中搜索，关于正则表达式的规则，这个类都告诉我们了。我这里把常用的已经给大家整理好了。 我们将这些规则，在代码中演示一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 目标：掌握正则表达式的书写规则 */public class RegexTest2 &#123; public static void main(String[] args) &#123; // 1、字符类(只能匹配单个字符) System.out.println(&quot;a&quot;.matches(&quot;[abc]&quot;)); // [abc]只能匹配a、b、c System.out.println(&quot;e&quot;.matches(&quot;[abcd]&quot;)); // false System.out.println(&quot;d&quot;.matches(&quot;[^abc]&quot;)); // [^abc] 不能是abc System.out.println(&quot;a&quot;.matches(&quot;[^abc]&quot;)); // false System.out.println(&quot;b&quot;.matches(&quot;[a-zA-Z]&quot;)); // [a-zA-Z] 只能是a-z A-Z的字符 System.out.println(&quot;2&quot;.matches(&quot;[a-zA-Z]&quot;)); // false System.out.println(&quot;k&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;)); // ： a到z，除了b和c System.out.println(&quot;b&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;)); // false System.out.println(&quot;ab&quot;.matches(&quot;[a-zA-Z0-9]&quot;)); // false 注意：以上带 [内容] 的规则都只能用于匹配单个字符 // 2、预定义字符(只能匹配单个字符) . \\d \\D \\s \\S \\w \\W System.out.println(&quot;徐&quot;.matches(&quot;.&quot;)); // .可以匹配任意字符 System.out.println(&quot;徐徐&quot;.matches(&quot;.&quot;)); // false // \\转义 System.out.println(&quot;\\&quot;&quot;); // \\n \\t System.out.println(&quot;3&quot;.matches(&quot;\\\\d&quot;)); // \\d: 0-9 System.out.println(&quot;a&quot;.matches(&quot;\\\\d&quot;)); //false System.out.println(&quot; &quot;.matches(&quot;\\\\s&quot;)); // \\s: 代表一个空白字符 System.out.println(&quot;a&quot;.matches(&quot;\\s&quot;)); // false System.out.println(&quot;a&quot;.matches(&quot;\\\\S&quot;)); // \\S: 代表一个非空白字符 System.out.println(&quot; &quot;.matches(&quot;\\\\S&quot;)); // false System.out.println(&quot;a&quot;.matches(&quot;\\\\w&quot;)); // \\w: [a-zA-Z_0-9] System.out.println(&quot;_&quot;.matches(&quot;\\\\w&quot;)); // true System.out.println(&quot;徐&quot;.matches(&quot;\\\\w&quot;)); // false System.out.println(&quot;徐&quot;.matches(&quot;\\\\W&quot;)); // [^\\w]不能是a-zA-Z_0-9 System.out.println(&quot;a&quot;.matches(&quot;\\\\W&quot;)); // false System.out.println(&quot;23232&quot;.matches(&quot;\\\\d&quot;)); // false 注意：以上预定义字符都只能匹配单个字符。 // 3、数量词： ? * + &#123;n&#125; &#123;n, &#125; &#123;n, m&#125; System.out.println(&quot;a&quot;.matches(&quot;\\\\w?&quot;)); // ? 代表0次或1次 System.out.println(&quot;&quot;.matches(&quot;\\\\w?&quot;)); // true System.out.println(&quot;abc&quot;.matches(&quot;\\\\w?&quot;)); // false System.out.println(&quot;abc12&quot;.matches(&quot;\\\\w*&quot;)); // * 代表0次或多次 System.out.println(&quot;&quot;.matches(&quot;\\\\w*&quot;)); // true System.out.println(&quot;abc12张&quot;.matches(&quot;\\\\w*&quot;)); // false System.out.println(&quot;abc12&quot;.matches(&quot;\\\\w+&quot;)); // + 代表1次或多次 System.out.println(&quot;&quot;.matches(&quot;\\\\w+&quot;)); // false System.out.println(&quot;abc12张&quot;.matches(&quot;\\\\w+&quot;)); // false System.out.println(&quot;a3c&quot;.matches(&quot;\\\\w&#123;3&#125;&quot;)); // &#123;3&#125; 代表要正好是n次 System.out.println(&quot;abcd&quot;.matches(&quot;\\\\w&#123;3&#125;&quot;)); // false System.out.println(&quot;abcd&quot;.matches(&quot;\\\\w&#123;3,&#125;&quot;)); // &#123;3,&#125; 代表是&gt;=3次 System.out.println(&quot;ab&quot;.matches(&quot;\\\\w&#123;3,&#125;&quot;)); // false System.out.println(&quot;abcde徐&quot;.matches(&quot;\\\\w&#123;3,&#125;&quot;)); // false System.out.println(&quot;abc232d&quot;.matches(&quot;\\\\w&#123;3,9&#125;&quot;)); // &#123;3, 9&#125; 代表是 大于等于3次，小于等于9次 // 4、其他几个常用的符号：(?i)忽略大小写 、 或：| 、 分组：() System.out.println(&quot;abc&quot;.matches(&quot;(?i)abc&quot;)); // true System.out.println(&quot;ABC&quot;.matches(&quot;(?i)abc&quot;)); // true System.out.println(&quot;aBc&quot;.matches(&quot;a((?i)b)c&quot;)); // true System.out.println(&quot;ABc&quot;.matches(&quot;a((?i)b)c&quot;)); // false // 需求1：要求要么是3个小写字母，要么是3个数字。 System.out.println(&quot;abc&quot;.matches(&quot;[a-z]&#123;3&#125;|\\\\d&#123;3&#125;&quot;)); // true System.out.println(&quot;ABC&quot;.matches(&quot;[a-z]&#123;3&#125;|\\\\d&#123;3&#125;&quot;)); // false System.out.println(&quot;123&quot;.matches(&quot;[a-z]&#123;3&#125;|\\\\d&#123;3&#125;&quot;)); // true System.out.println(&quot;A12&quot;.matches(&quot;[a-z]&#123;3&#125;|\\\\d&#123;3&#125;&quot;)); // false // 需求2：必须是”我爱“开头，中间可以是至少一个”编程“，最后至少是1个”666“ System.out.println(&quot;我爱编程编程666666&quot;.matches(&quot;我爱(编程)+(666)+&quot;)); System.out.println(&quot;我爱编程编程66666&quot;.matches(&quot;我爱(编程)+(666)+&quot;)); &#125;&#125; 5.3 正则表达式应用案例学习完正则表达式的规则之后，接下来我们再利用正则表达式，去校验几个实际案例。 正则表达式校验手机号码 1234567891011121314151617181920212223/** * 目标：校验用户输入的电话、邮箱、时间是否合法。 */public class RegexTest3 &#123; public static void main(String[] args) &#123; checkPhone(); &#125; public static void checkPhone()&#123; while (true) &#123; System.out.println(&quot;请您输入您的电话号码(手机|座机): &quot;); Scanner sc = new Scanner(System.in); String phone = sc.nextLine(); // 18676769999 010-3424242424 0104644535 if(phone.matches(&quot;(1[3-9]\\\\d&#123;9&#125;)|(0\\\\d&#123;2,7&#125;-?[1-9]\\\\d&#123;4,19&#125;)&quot;))&#123; System.out.println(&quot;您输入的号码格式正确~~~&quot;); break; &#125;else &#123; System.out.println(&quot;您输入的号码格式不正确~~~&quot;); &#125; &#125; &#125;&#125; 使用正则表达式校验邮箱是否正确 12345678910111213141516171819202122232425public class RegexTest3 &#123; public static void main(String[] args) &#123; checkEmail(); &#125; public static void checkEmail()&#123; while (true) &#123; System.out.println(&quot;请您输入您的邮箱： &quot;); Scanner sc = new Scanner(System.in); String email = sc.nextLine(); /** * dlei0009@163.com * 25143242@qq.com * itheima@itcast.com.cn */ if(email.matches(&quot;\\\\w&#123;2,&#125;@\\\\w&#123;2,20&#125;(\\\\.\\\\w&#123;2,10&#125;)&#123;1,2&#125;&quot;))&#123; System.out.println(&quot;您输入的邮箱格式正确~~~&quot;); break; &#125;else &#123; System.out.println(&quot;您输入的邮箱格式不正确~~~&quot;); &#125; &#125; &#125;&#125; 5.4 正则表达式信息爬取各位小伙伴，在前面的课程中，我们学习了正则表达式的作用之一，用来校验数据格式的正确性。接下来我们学习正则表达式的第二个作用：在一段文本中查找满足要求的内容 我们还是通过一个案例给大家做演示：案例需求如下 12345678910111213141516171819202122232425262728293031/** * 目标：掌握使用正则表达式查找内容。 */public class RegexTest4 &#123; public static void main(String[] args) &#123; method1(); &#125; // 需求1：从以下内容中爬取出，手机，邮箱，座机、400电话等信息。 public static void method1()&#123; String data = &quot; 来黑马程序员学习Java，\\n&quot; + &quot; 电话：1866668888，18699997777\\n&quot; + &quot; 或者联系邮箱：boniu@itcast.cn，\\n&quot; + &quot; 座机电话：01036517895，010-98951256\\n&quot; + &quot; 邮箱：bozai@itcast.cn，\\n&quot; + &quot; 邮箱：dlei0009@163.com，\\n&quot; + &quot; 热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090&quot;; // 1、定义爬取规则 String regex = &quot;(1[3-9]\\\\d&#123;9&#125;)|(0\\\\d&#123;2,7&#125;-?[1-9]\\\\d&#123;4,19&#125;)|(\\\\w&#123;2,&#125;@\\\\w&#123;2,20&#125;(\\\\.\\\\w&#123;2,10&#125;)&#123;1,2&#125;)&quot; + &quot;|(400-?\\\\d&#123;3,7&#125;-?\\\\d&#123;3,7&#125;)&quot;; // 2、把正则表达式封装成一个Pattern对象 Pattern pattern = Pattern.compile(regex); // 3、通过pattern对象去获取查找内容的匹配器对象。 Matcher matcher = pattern.matcher(data); // 4、定义一个循环开始爬取信息 while (matcher.find())&#123; String rs = matcher.group(); // 获取到了找到的内容了。 System.out.println(rs); &#125; &#125;&#125; 5.5 正则表达式搜索、替换接下来，我们学习一下正则表达式的另外两个功能，替换、分割的功能。需要注意的是这几个功能需要用到Stirng类中的方法。这两个方法其实我们之前学过，只是当时没有学正则表达式而已。 123456789101112131415161718192021/** * 目标：掌握使用正则表达式做搜索替换，内容分割。 */public class RegexTest5 &#123; public static void main(String[] args) &#123; // 1、public String replaceAll(String regex , String newStr)：按照正则表达式匹配的内容进行替换 // 需求1：请把下面字符串中的不是汉字的部分替换为 “-” String s1 = &quot;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴&quot;; System.out.println(s1.replaceAll(&quot;\\\\w+&quot;, &quot;-&quot;)); // 需求2(拓展)：某语音系统，收到一个口吃的人说的“我我我喜欢编编编编编编编编编编编编程程程！”，需要优化成“我喜欢编程！”。 String s2 = &quot;我我我喜欢编编编编编编编编编编编编程程程&quot;; System.out.println(s2.replaceAll(&quot;(.)\\\\1+&quot;, &quot;$1&quot;)); // 2、public String[] split(String regex)：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。 // 需求1：请把下面字符串中的人名取出来，使用切割来做 String s3 = &quot;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴&quot;; String[] names = s3.split(&quot;\\\\w+&quot;); System.out.println(Arrays.toString(names)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day15-异常、集合进阶（Collection、List集合）","slug":"day15-异常、集合进阶（Collection、List集合）","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day15-异常、集合进阶（Collection、List集合）/","link":"","permalink":"https://wxzhou.top/2020/05/05/day15-%E5%BC%82%E5%B8%B8%E3%80%81%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6%EF%BC%88Collection%E3%80%81List%E9%9B%86%E5%90%88%EF%BC%89/","excerpt":"","text":"一、异常1.1 认识异常接下来，我们学习一下异常，学习异常有利于我们处理程序中可能出现的问题。我先带着同学们认识一下，什么是异常？ 我们阅读下面的代码，通过这段代码来认识异常。 我们调用一个方法时，经常一部小心就出异常了，然后在控制台打印一些异常信息。其实打印的这些异常信息，就叫做异常。 那肯定有同学就纳闷了，我写代码天天出异常，我知道这是异常啊！我们这里学习异常，其实是为了告诉你异常是怎么产生的？只有你知道异常是如何产生的，才能避免出现异常。以及产生异常之后如何处理。 因为写代码时经常会出现问题，Java的设计者们早就为我们写好了很多个异常类，来描述不同场景下的问题。而有些类是有共性的所以就有了异常的继承体系 先来演示一个运行时异常产生 123int[] arr = &#123;11,22,33&#125;;//5是一个不存在的索引，所以此时产生ArrayIndexOutOfBoundsExcpetionSystem.out.println(arr[5]); 下图是API中对ArrayIndexOutOfBoundsExcpetion类的继承体系，以及告诉我们它在什么情况下产生。 再来演示一个编译时异常 我们在调用SimpleDateFormat对象的parse方法时，要求传递的参数必须和指定的日期格式一致，否则就会出现异常。 Java比较贴心，它为了更加强烈的提醒方法的调用者，设计了编译时异常，它把异常的提醒提前了，你调用方法是否真的有问题，只要可能有问题就给你报出异常提示（红色波浪线）。 编译时异常的目的：意思就是告诉你，你小子注意了！！，这里小心点容易出错，仔细检查一下 有人说，我检查过了，我确认我的代码没问题，为了让它不报错，继续将代码写下去。我们这里有两种解决方案。 第一种：使用throws在方法上声明，意思就是告诉下一个调用者，这里面可能有异常啊，你调用时注意一下。 12345678910/** * 目标：认识异常。 */public class ExceptionTest1 &#123; public static void main(String[] args) throws ParseException&#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d = sdf.parse(&quot;2028-11-11 10:24&quot;); System.out.println(d); &#125;&#125; 第二种：使用try…catch语句块异常进行处理。 1234567891011public class ExceptionTest1 &#123; public static void main(String[] args) throws ParseException&#123; try &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d = sdf.parse(&quot;2028-11-11 10:24&quot;); System.out.println(d); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 好了，关于什么是异常，我们就先认识到这里。 1.2 自定义异常同学们经过刚才的学习已经认识了什么是异常了，但是无法为这个世界上的全部问题都提供异常类，如果企业自己的某种问题，想通过异常来表示，那就需要自己来定义异常类了。 我们通过一个实际场景，来给大家演示自定义异常。 需求：写一个saveAge(int age)方法，在方法中对参数age进行判断，如果age&lt;0或者&gt;&#x3D;150就认为年龄不合法，如果年龄不合法，就给调用者抛出一个年龄非法异常。 分析：Java的API中是没有年龄非常这个异常的，所以我们可以自定义一个异常类，用来表示年龄非法异常，然后再方法中抛出自定义异常即可。 先写一个异常类AgeIllegalException（这是自己取的名字，名字取得很奈斯），继承 123456789// 1、必须让这个类继承自Exception，才能成为一个编译时异常类。public class AgeIllegalException extends Exception&#123; public AgeIllegalException() &#123; &#125; public AgeIllegalException(String message) &#123; super(message); &#125;&#125; 再写一个测试类，在测试类中定义一个saveAge(int age)方法，对age判断如果年龄不在0~150之间，就抛出一个AgeIllegalException异常对象给调用者。 1234567891011121314151617181920212223public class ExceptionTest2 &#123; public static void main(String[] args) &#123; // 需求：保存一个合法的年 try &#123; saveAge2(225); System.out.println(&quot;saveAge2底层执行是成功的！&quot;); &#125; catch (AgeIllegalException e) &#123; e.printStackTrace(); System.out.println(&quot;saveAge2底层执行是出现bug的！&quot;); &#125; &#125; //2、在方法中对age进行判断，不合法则抛出AgeIllegalException public static void saveAge(int age)&#123; if(age &gt; 0 &amp;&amp; age &lt; 150)&#123; System.out.println(&quot;年龄被成功保存： &quot; + age); &#125;else &#123; // 用一个异常对象封装这个问题 // throw 抛出去这个异常对象 throw new AgeIllegalRuntimeException(&quot;/age is illegal, your age is &quot; + age); &#125; &#125;&#125; 注意咯，自定义异常可能是编译时异常，也可以是运行时异常 123451.如果自定义异常类继承Excpetion，则是编译时异常。 特点：方法中抛出的是编译时异常，必须在方法上使用throws声明，强制调用者处理。 2.如果自定义异常类继承RuntimeException，则运行时异常。 特点：方法中抛出的是运行时异常，不需要在方法上用throws声明。 1.3 异常处理同学们，通过前面两小节的学习，我们已经认识了什么是异常，以及异常的产生过程。接下来就需要告诉同学们，出现异常该如何处理了。 比如有如下的场景：A调用用B，B调用C；C中有异常产生抛给B，B中有异常产生又抛给A；异常到了A这里就不建议再抛出了，因为最终抛出被JVM处理程序就会异常终止，并且给用户看异常信息，用户也看不懂，体验很不好。 此时比较好的做法就是：1.将异常捕获，将比较友好的信息显示给用户看；2.尝试重新执行，看是是否能修复这个问题。 我们看一个代码，main方法调用test1方法，test1方法调用test2方法，test1和test2方法中多有扔异常。 第一种处理方式是，在main方法中对异常进行try…catch捕获处理了，给出友好提示。 12345678910111213141516171819202122232425public class ExceptionTest3 &#123; public static void main(String[] args) &#123; try &#123; test1(); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;您要找的文件不存在！！&quot;); e.printStackTrace(); // 打印出这个异常对象的信息。记录下来。 &#125; catch (ParseException e) &#123; System.out.println(&quot;您要解析的时间有问题了！&quot;); e.printStackTrace(); // 打印出这个异常对象的信息。记录下来。 &#125; &#125; public static void test1() throws FileNotFoundException, ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d = sdf.parse(&quot;2028-11-11 10:24:11&quot;); System.out.println(d); test2(); &#125; public static void test2() throws FileNotFoundException &#123; // 读取文件的。 InputStream is = new FileInputStream(&quot;D:/meinv.png&quot;); &#125;&#125; 第二种处理方式是：在main方法中对异常进行捕获，并尝试修复 123456789101112131415161718192021222324252627282930/** * 目标：掌握异常的处理方式：捕获异常，尝试修复。 */public class ExceptionTest4 &#123; public static void main(String[] args) &#123; // 需求：调用一个方法，让用户输入一个合适的价格返回为止。 // 尝试修复 while (true) &#123; try &#123; System.out.println(getMoney()); break; &#125; catch (Exception e) &#123; System.out.println(&quot;请您输入合法的数字！！&quot;); &#125; &#125; &#125; public static double getMoney()&#123; Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(&quot;请您输入合适的价格：&quot;); double money = sc.nextDouble(); if(money &gt;= 0)&#123; return money; &#125;else &#123; System.out.println(&quot;您输入的价格是不合适的！&quot;); &#125; &#125; &#125;&#125; 好了，到此我们关于异常的知识就全部学习完了。 二、集合概述和分类2.1 集合的分类同学们，前面我们已经学习过了ArrayList集合，但是除了ArrayList集合，Java还提供了很多种其他的集合，如下图所示： 我想你的第一感觉是这些集合好多呀！但是，我们学习时会对这些集合进行分类学习，如下图所示：一类是单列集合元素是一个一个的，另一类是双列集合元素是一对一对的。 在今天的课程中，主要学习Collection单列集合。Collection是单列集合的根接口，Collection接口下面又有两个子接口List接口、Set接口，List和Set下面分别有不同的实现类，如下图所示： 上图中各种集合的特点如下图所示： 可以自己写代码验证一下，各种集合的特点 123456789101112131415//简单确认一下Collection集合的特点ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //存取顺序一致，可以重复，有索引list.add(&quot;java1&quot;);list.add(&quot;java2&quot;);list.add(&quot;java1&quot;);list.add(&quot;java2&quot;);System.out.println(list); //[java1, java2, java1, java2] HashSet&lt;String&gt; list = new HashSet&lt;&gt;(); //存取顺序不一致，不重复，无索引list.add(&quot;java1&quot;);list.add(&quot;java2&quot;);list.add(&quot;java1&quot;);list.add(&quot;java2&quot;);list.add(&quot;java3&quot;);System.out.println(list); //[java3, java2, java1] 2.2 Collection集合的常用方法接下来，我们学习一下Collection集合的一些常用方法，这些方法所有Collection实现类都可以使用。 这里我们以创建ArrayList为例，来演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344Collection&lt;String&gt; c = new ArrayList&lt;&gt;();//1.public boolean add(E e): 添加元素到集合c.add(&quot;java1&quot;);c.add(&quot;java1&quot;);c.add(&quot;java2&quot;);c.add(&quot;java2&quot;);c.add(&quot;java3&quot;);System.out.println(c); //打印: [java1, java1, java2, java2, java3]//2.public int size(): 获取集合的大小System.out.println(c.size()); //5//3.public boolean contains(Object obj): 判断集合中是否包含某个元素System.out.println(c.contains(&quot;java1&quot;)); //trueSystem.out.println(c.contains(&quot;Java1&quot;)); //false//4.pubilc boolean remove(E e): 删除某个元素，如果有多个重复元素只能删除第一个System.out.println(c.remove(&quot;java1&quot;)); //trueSystem.out.println(c); //打印: [java1,java2, java2, java3]//5.public void clear(): 清空集合的元素c.clear(); System.out.println(c); //打印：[]//6.public boolean isEmpty(): 判断集合是否为空 是空返回true 反之返回falseSystem.out.println(c.isEmpty()); //true//7.public Object[] toArray(): 把集合转换为数组Object[] array = c.toArray();System.out.println(Arrays.toString(array)); //[java1,java2, java2, java3]//8.如果想把集合转换为指定类型的数组，可以使用下面的代码String[] array1 = c.toArray(new String[c.size()]);System.out.println(Arrays.toString(array1)); //[java1,java2, java2, java3]//9.还可以把一个集合中的元素，添加到另一个集合中Collection&lt;String&gt; c1 = new ArrayList&lt;&gt;();c1.add(&quot;java1&quot;);c1.add(&quot;java2&quot;);Collection&lt;String&gt; c2 = new ArrayList&lt;&gt;();c2.add(&quot;java3&quot;);c2.add(&quot;java4&quot;);c1.addAll(c2); //把c2集合中的全部元素，添加到c1集合中去System.out.println(c1); //[java1, java2, java3, java4] 最后，我们总结一下Collection集合的常用功能有哪些，ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet集合都可以调用下面的方法。 三、Collection遍历方式各位同学，接下来我们学习一下Collection集合的遍历方式。有同学说：“集合的遍历之前不是学过吗？就用普通的for循环啊? “ 没错！之前是学过集合遍历，但是之前学习过的遍历方式，只能遍历List集合，不能遍历Set集合，因为以前的普通for循环遍历需要索引，只有List集合有索引，而Set集合没有索引。 所以我们需要有一种通用的遍历方式，能够遍历所有集合。 3.1 迭代器遍历集合 接下来学习的迭代器就是一种集合的通用遍历方式。 代码写法如下： 123456789101112131415161718Collection&lt;String&gt; c = new ArrayList&lt;&gt;();c.add(&quot;赵敏&quot;);c.add(&quot;小昭&quot;);c.add(&quot;素素&quot;);c.add(&quot;灭绝&quot;);System.out.println(c); //[赵敏, 小昭, 素素, 灭绝]//第一步：先获取迭代器对象//解释：Iterator就是迭代器对象，用于遍历集合的工具)Iterator&lt;String&gt; it = c.iterator();//第二步：用于判断当前位置是否有元素可以获取//解释：hasNext()方法返回true，说明有元素可以获取；反之没有while(it.hasNext())&#123; //第三步：获取当前位置的元素，然后自动指向下一个元素. String e = it.next(); System.out.println(s);&#125; 迭代器代码的原理如下： 当调用iterator()方法获取迭代器时，当前指向第一个元素 hasNext()方法则判断这个位置是否有元素，如果有则返回true，进入循环 调用next()方法获取元素，并将当月元素指向下一个位置， 等下次循环时，则获取下一个元素，依此内推 最后，我们再总结一下，使用迭代器遍历集合用到哪些方法 3.2 增强for遍历集合同学们刚才我们学习了迭代器遍历集合，但是这个代码其实还有一种更加简化的写法，叫做增强for循环。 格式如下： 需要注意的是，增强for不光可以遍历集合，还可以遍历数组。接下来我们用代码演示一em.o下： 12345678910111213141516Collection&lt;String&gt; c = new ArrayList&lt;&gt;();c.add(&quot;赵敏&quot;);c.add(&quot;小昭&quot;);c.add(&quot;素素&quot;);c.add(&quot;灭绝&quot;);//1.使用增强for遍历集合for(String s: c)&#123; System.out.println(s); &#125;//2.再尝试使用增强for遍历数组String[] arr = &#123;&quot;迪丽热巴&quot;, &quot;古力娜扎&quot;, &quot;稀奇哈哈&quot;&#125;;for(String name: arr)&#123; System.out.println(name);&#125; 3.3 forEach遍历集合在JDK8版本以后还提供了一个forEach方法也可以遍历集合，如果下图所示： 我们发现forEach方法的参数是一个Consumer接口，而Consumer是一个函数式接口，所以可以传递Lambda表达式 123456789101112131415161718Collection&lt;String&gt; c = new ArrayList&lt;&gt;();c.add(&quot;赵敏&quot;);c.add(&quot;小昭&quot;);c.add(&quot;素素&quot;);c.add(&quot;灭绝&quot;);//调用forEach方法//由于参数是一个Consumer接口，所以可以传递匿名内部类c.forEach(new Consumer&lt;String&gt;&#123; @Override public void accept(String s)&#123; System.out.println(s); &#125;&#125;);//也可以使用lambda表达式对匿名内部类进行简化c.forEach(s-&gt;System.out.println(s)); //[赵敏, 小昭, 素素, 灭绝] 3.4 遍历集合案例接下来，我们看一个案例，在集合中存储自定义的对象，并遍历。具体要求如下 首先，我们得写一个电影类，用来描述每一步电影应该有哪些信息。 1234567891011121314public class Movie&#123; private String name; //电影名称 private double score; //评分 private String actor; //演员 //无参数构造方法 public Movie()&#123;&#125; //全参数构造方法 public Movie(String name, double score, String actor)&#123; this.name=name; this.score=score; this.actor=actor; &#125; //...get、set、toString()方法自己补上..&#125; 接着，再创建一个测试类，完成上面的需求 1234567891011121314public class Test&#123; public static void main(String[] args)&#123; Collection&lt;Movie&gt; movies = new ArrayList&lt;&gt;(); movies.add(new MOvie(&quot;《肖申克的救赎》&quot;, 9.7, &quot;罗宾斯&quot;)); movies.add(new MOvie(&quot;《霸王别姬》&quot;, 9.6, &quot;张国荣、张丰毅&quot;)); movies.add(new MOvie(&quot;《阿甘正传》&quot;, 9.5, &quot;汤姆汉克斯&quot;)); for(Movie movie : movies)&#123; System.out.println(&quot;电影名：&quot; + movie.getName()); System.out.println(&quot;评分：&quot; + movie.getScore()); System.out.println(&quot;主演：&quot; + movie.getActor()); &#125; &#125;&#125; 以上代码的内存原理如下图所示：当往集合中存对象时，实际上存储的是对象的地址值 四、List系列集合前面我们已经把Collection通用的功能学习完了，接下来我们学习Collection下面的一个子体系List集合。如下图所示： 4.1 List集合的常用方法List集合是索引的，所以多了一些有索引操作的方法，如下图所示： 接下来，我们用代码演示一下这几个方法的效果 12345678910111213141516171819202122//1.创建一个ArrayList集合对象（有序、有索引、可以重复）List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;蜘蛛精&quot;);list.add(&quot;至尊宝&quot;);list.add(&quot;至尊宝&quot;);list.add(&quot;牛夫人&quot;); System.out.println(list); //[蜘蛛精, 至尊宝, 至尊宝, 牛夫人]//2.public void add(int index, E element): 在某个索引位置插入元素list.add(2, &quot;紫霞仙子&quot;);System.out.println(list); //[蜘蛛精, 至尊宝, 紫霞仙子, 至尊宝, 牛夫人]//3.public E remove(int index): 根据索引删除元素, 返回被删除的元素System.out.println(list.remove(2)); //紫霞仙子System.out.println(list);//[蜘蛛精, 至尊宝, 至尊宝, 牛夫人]//4.public E get(int index): 返回集合中指定位置的元素System.out.println(list.get(3));//5.public E set(int index, E e): 修改索引位置处的元素，修改后，会返回原数据System.out.println(list.set(3,&quot;牛魔王&quot;)); //牛夫人System.out.println(list); //[蜘蛛精, 至尊宝, 至尊宝, 牛魔王] 4.2 List集合的遍历方式List集合相比于前面的Collection多了一种可以通过索引遍历的方式，所以List集合遍历方式一共有四种： 普通for循环（只因为List有索引） 迭代器 增强for Lambda表达式 1234567891011121314151617181920212223242526List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;蜘蛛精&quot;);list.add(&quot;至尊宝&quot;);list.add(&quot;糖宝宝&quot;);//1.普通for循环for(int i = 0; i&lt; list.size(); i++)&#123; //i = 0, 1, 2 String e = list.get(i); System.out.println(e);&#125;//2.增强for遍历for(String s : list)&#123; System.out.println(s);&#125;//3.迭代器遍历Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String s = it.next(); System.out.println(s);&#125;//4.lambda表达式遍历list.forEach(s-&gt;System.out.println(s)); 4.3 ArrayList底层的原理为了让同学们更加透彻的理解ArrayList集合，接下来，学习一下ArrayList集合的底层原理。 ArrayList集合底层是基于数组结构实现的，也就是说当你往集合容器中存储元素时，底层本质上是往数组中存储元素。 特点如下： 我们知道数组的长度是固定的，但是集合的长度是可变的，这是怎么做到的呢？原理如下： 数组扩容，并不是在原数组上扩容（原数组是不可以扩容的），底层是创建一个新数组，然后把原数组中的元素全部复制到新数组中去。 4.4 LinkedList底层原理学习完ArrayList底层原理之后，接下来我们看一下LinkedList集合的底层原理。 LinkedList底层是链表结构，链表结构是由一个一个的节点组成，一个节点由数据值、下一个元素的地址组成。如下图所示 假如，现在要在B节点和D节点中间插入一个元素，只需要把B节点指向D节点的地址断掉，重新指向新的节点地址就可以了。如下图所示： 假如，现在想要把D节点删除，只需要让C节点指向E节点的地址，然后把D节点指向E节点的地址断掉。此时D节点就会变成垃圾，会把垃圾回收器清理掉。 上面的链表是单向链表，它的方向是从头节点指向尾节点的，只能从左往右查找元素，这样查询效率比较慢；还有一种链表叫做双向链表，不光可以从做往右找，还可以从右往左找。如下图所示： LinkedList集合是基于双向链表实现了，所以相对于ArrayList新增了一些可以针对头尾进行操作的方法，如下图示所示： 4.5 LinkedList集合的应用场景刚才我们学习了LinkedList集合，那么LInkedList集合有什么用呢？可以用它来设计栈结构、队列结构。 我们先来认识一下队列结构，队列结构你可以认为是一个上端开口，下端也开口的管子的形状。元素从上端入队列，从下端出队列。 入队列可以调用LinkedList集合的addLast方法，出队列可以调用removeFirst()方法. 1234567891011121314//1.创建一个队列：先进先出、后进后出LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();//入对列queue.addLast(&quot;第1号人&quot;);queue.addLast(&quot;第2号人&quot;);queue.addLast(&quot;第3号人&quot;);queue.addLast(&quot;第4号人&quot;);System.out.println(queue);//出队列System.out.println(queue.removeFirst()); //第4号人System.out.println(queue.removeFirst()); //第3号人System.out.println(queue.removeFirst()); //第2号人System.out.println(queue.removeFirst()); //第1号人 接下来，我们再用LinkedList集合来模拟一下栈结构的效果。还是先来认识一下栈结构长什么样。栈结构可以看做是一个上端开头，下端闭口的水杯的形状。 元素永远是上端进，也从上端出，先进入的元素会压在最底下，所以栈结构的特点是先进后出，后进先出 有没有感觉栈结构很像，手枪的子弹夹呀！！第一个压进入的子弹在最底下，最后一个才能打出来，最后一个压进入的子弹在最顶上，第一个打出来。 接着，我们就用LinkedList来模拟下栈结构，代码如下： 1234567891011121314151617//1.创建一个栈对象LinkedList&lt;String&gt; stack = new ArrayList&lt;&gt;();//压栈(push) 等价于 addFirst()stack.push(&quot;第1颗子弹&quot;);stack.push(&quot;第2颗子弹&quot;);stack.push(&quot;第3颗子弹&quot;);stack.push(&quot;第4颗子弹&quot;);System.out.println(stack); //[第4颗子弹, 第3颗子弹, 第2颗子弹,第1颗子弹]//弹栈(pop) 等价于 removeFirst()System.out.println(statck.pop()); //第4颗子弹System.out.println(statck.pop()); //第3颗子弹System.out.println(statck.pop()); //第2颗子弹System.out.println(statck.pop()); //第1颗子弹//弹栈完了，集合中就没有元素了System.out.println(list); //[]","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day16-集合进阶（Set、Map集合）","slug":"day16-集合进阶（Set、Map集合）","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day16-集合进阶（Set、Map集合）/","link":"","permalink":"https://wxzhou.top/2020/05/05/day16-%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6%EF%BC%88Set%E3%80%81Map%E9%9B%86%E5%90%88%EF%BC%89/","excerpt":"","text":"一、Set系列集合1.1 认识Set集合的特点Set集合是属于Collection体系下的另一个分支，它的特点如下图所示 下面我们用代码简单演示一下，每一种Set集合的特点。 1234567891011//Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); //无序、无索引、不重复//Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); //有序、无索引、不重复Set&lt;Integer&gt; set = new TreeSet&lt;&gt;(); //可排序(升序)、无索引、不重复set.add(666);set.add(555);set.add(555);set.add(888);set.add(888);set.add(777);set.add(777);System.out.println(set); //[555, 666, 777, 888] 1.2 HashSet集合底层原理接下来，为了让同学们更加透彻的理解HashSet为什么可以去重，我们来看一下它的底层原理。 HashSet集合底层是基于哈希表实现的，哈希表根据JDK版本的不同，也是有点区别的 JDK8以前：哈希表 &#x3D; 数组+链表 JDK8以后：哈希表 &#x3D; 数组+链表+红黑树 我们发现往HashSet集合中存储元素时，底层调用了元素的两个方法：一个是hashCode方法获取元素的hashCode值（哈希值）；另一个是调用了元素的equals方法，用来比较新添加的元素和集合中已有的元素是否相同。 只有新添加元素的hashCode值和集合中以后元素的hashCode值相同、新添加的元素调用equals方法和集合中已有元素比较结果为true, 才认为元素重复。 如果hashCode值相同，equals比较不同，则以链表的形式连接在数组的同一个索引为位置（如上图所示） 在JDK8开始后，为了提高性能，当链表的长度超过8时，就会把链表转换为红黑树，如下图所示： 1.3 HashSet去重原理前面我们学习了HashSet存储元素的原理，依赖于两个方法：一个是hashCode方法用来确定在底层数组中存储的位置，另一个是用equals方法判断新添加的元素是否和集合中已有的元素相同。 要想保证在HashSet集合中没有重复元素，我们需要重写元素类的hashCode和equals方法。比如以下面的Student类为例，假设把Student类的对象作为HashSet集合的元素，想要让学生的姓名和年龄相同，就认为元素重复。 12345678910111213141516171819202122232425262728293031323334353637383940public class Student&#123; private String name; //姓名 private int age; //年龄 private double height; //身高 //无参数构造方法 public Student()&#123;&#125; //全参数构造方法 public Student(String name, int age, double height)&#123; this.name=name; this.age=age; this.height=height; &#125; //...get、set、toString()方法自己补上.. //按快捷键生成hashCode和equals方法 //alt+insert 选择 hashCode and equals @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; if (Double.compare(student.height, height) != 0) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result; long temp; result = name != null ? name.hashCode() : 0; result = 31 * result + age; temp = Double.doubleToLongBits(height); result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32)); return result; &#125;&#125; 接着，写一个测试类，往HashSet集合中存储Student对象。 123456789101112131415161718public class Test&#123; public static void main(String[] args)&#123; Set&lt;Student&gt; students = new HashSet&lt;&gt;(); Student s1 = new Student(&quot;至尊宝&quot;,20, 169.6); Student s2 = new Student(&quot;蜘蛛精&quot;,23, 169.6); Student s3 = new Student(&quot;蜘蛛精&quot;,23, 169.6); Student s4 = new Student(&quot;牛魔王&quot;,48, 169.6); students.add(s1); students.add(s2); students.add(s3); students.add(s4); for(Student s : students)&#123; System.out.println(s); &#125; &#125;&#125; 打印结果如下，我们发现存了两个蜘蛛精，当时实际打印出来只有一个，而且是无序的。 123Student&#123;name=&#x27;牛魔王&#x27;, age=48, height=169.6&#125;Student&#123;name=&#x27;至尊宝&#x27;, age=20, height=169.6&#125;Student&#123;name=&#x27;蜘蛛精&#x27;, age=23, height=169.6&#125; 1.4 LinkedHashSet底层原理接下来，我们再学习一个HashSet的子类LinkedHashSet类。LinkedHashSet它底层采用的是也是哈希表结构，只不过额外新增了一个双向链表来维护元素的存取顺序。如下下图所示： 每次添加元素，就和上一个元素用双向链表连接一下。第一个添加的元素是双向链表的头节点，最后一个添加的元素是双向链表的尾节点。 把上个案例中的集合改成LinkedList集合，我们观察效果怎样 123456789101112131415161718public class Test&#123; public static void main(String[] args)&#123; Set&lt;Student&gt; students = new LinkedHashSet&lt;&gt;(); Student s1 = new Student(&quot;至尊宝&quot;,20, 169.6); Student s2 = new Student(&quot;蜘蛛精&quot;,23, 169.6); Student s3 = new Student(&quot;蜘蛛精&quot;,23, 169.6); Student s4 = new Student(&quot;牛魔王&quot;,48, 169.6); students.add(s1); students.add(s2); students.add(s3); students.add(s4); for(Student s : students)&#123; System.out.println(s); &#125; &#125;&#125; 打印结果如下 123Student&#123;name=&#x27;至尊宝&#x27;, age=20, height=169.6&#125;Student&#123;name=&#x27;蜘蛛精&#x27;, age=23, height=169.6&#125;Student&#123;name=&#x27;牛魔王&#x27;, age=48, height=169.6&#125; 1.5 TreeSet集合最后，我们学习一下TreeSet集合。TreeSet集合的特点是可以对元素进行排序，但是必须指定元素的排序规则。 如果往集合中存储String类型的元素，或者Integer类型的元素，它们本身就具备排序规则，所以直接就可以排序。 1234567891011121314151617181920Set&lt;Integer&gt; set1= new TreeSet&lt;&gt;();set1.add(8);set1.add(6);set1.add(4);set1.add(3);set1.add(7);set1.add(1);set1.add(5);set1.add(2);System.out.println(set1); //[1,2,3,4,5,6,7,8]Set&lt;Integer&gt; set2= new TreeSet&lt;&gt;();set2.add(&quot;a&quot;);set2.add(&quot;c&quot;);set2.add(&quot;e&quot;);set2.add(&quot;b&quot;);set2.add(&quot;d&quot;);set2.add(&quot;f&quot;);set2.add(&quot;g&quot;);System.out.println(set1); //[a,b,c,d,e,f,g] 如果往TreeSet集合中存储自定义类型的元素，比如说Student类型，则需要我们自己指定排序规则，否则会出现异常。 123456789101112131415//创建TreeSet集合，元素为Student类型Set&lt;Student&gt; students = new TreeSet&lt;&gt;();//创建4个Student对象Student s1 = new Student(&quot;至尊宝&quot;,20, 169.6);Student s2 = new Student(&quot;紫霞&quot;,23, 169.8);Student s3 = new Student(&quot;蜘蛛精&quot;,23, 169.6);Student s4 = new Student(&quot;牛魔王&quot;,48, 169.6);//添加Studnet对象到集合students.add(s1);students.add(s2);students.add(s3);students.add(s4);System.out.println(students); 此时运行代码，会直接报错。原因是TreeSet不知道按照什么条件对Student对象来排序。 我们想要告诉TreeSet集合按照指定的规则排序，有两种办法： 第一种：让元素的类实现Comparable接口，重写compareTo方法 第二种：在创建TreeSet集合时，通过构造方法传递Compartor比较器对象 排序方式1：我们先来演示第一种排序方式 123456789101112131415161718192021222324252627282930//第一步：先让Student类，实现Comparable接口//注意：Student类的对象是作为TreeSet集合的元素的public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; private double height; //无参数构造方法 public Student()&#123;&#125; //全参数构造方法 public Student(String name, int age, double height)&#123; this.name=name; this.age=age; this.height=height; &#125; //...get、set、toString()方法自己补上.. //第二步：重写compareTo方法 //按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。 /* 原理： 在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的 结果是正数、负数、还是零，决定元素放在后面、前面还是不存。 */ @Override public int compareTo(Student o) &#123; //this：表示将要添加进去的Student对象 //o: 表示集合中已有的Student对象 return this.age-o.age; &#125;&#125; 此时，再运行测试类，结果如下 1234Student&#123;name=&#x27;至尊宝&#x27;, age=20, height=169.6&#125;Student&#123;name=&#x27;紫霞&#x27;, age=20, height=169.8&#125;Student&#123;name=&#x27;蜘蛛精&#x27;, age=23, height=169.6&#125;Student&#123;name=&#x27;牛魔王&#x27;, age=48, height=169.6&#125; 排序方式2：接下来演示第二种排序方式 12345678910111213141516171819202122232425//创建TreeSet集合时，传递比较器对象排序/*原理：当调用add方法时，底层会先用比较器，根据Comparator的compare方是正数、负数、还是零，决定谁在后，谁在前，谁不存。*///下面代码中是按照学生的年龄升序排序Set&lt;Student&gt; students = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;&#123; @Override public int compare(Student o1, Student o2)&#123; //需求：按照学生的身高排序 return Double.compare(o1,o2); &#125;&#125;);//创建4个Student对象Student s1 = new Student(&quot;至尊宝&quot;,20, 169.6);Student s2 = new Student(&quot;紫霞&quot;,23, 169.8);Student s3 = new Student(&quot;蜘蛛精&quot;,23, 169.6);Student s4 = new Student(&quot;牛魔王&quot;,48, 169.6);//添加Studnet对象到集合students.add(s1);students.add(s2);students.add(s3);students.add(s4);System.out.println(students); 1.6 总结Collection集合最后，将所有的Collection集合总结一下，要求大家掌握每一种集合的特点，以及他们的体系结构。 好了，关于Collection集合，到这里就学习完了。 1.7 并发修改异常学完Collection集合后，还有一个小问题需要给同学们补充说明一下，那就是在使用迭代器遍历集合时，可能存在并发修改异常。 我们先把这个异常用代码演示出来，再解释一下为什么会有这个异常产生 123456789101112131415161718List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;王麻子&quot;);list.add(&quot;小李子&quot;);list.add(&quot;李爱花&quot;);list.add(&quot;张全蛋&quot;);list.add(&quot;晓李&quot;);list.add(&quot;李玉刚&quot;);System.out.println(list); // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String name = it.next(); if(name.contains(&quot;李&quot;))&#123; list.remove(name); &#125;&#125;System.out.println(list); 运行上面的代码，会出现下面的异常。这就是并发修改异常 为什么会出现这个异常呢？那是因为迭代器遍历机制，规定迭代器遍历集合的同时，不允许集合自己去增删元素，否则就会出现这个异常。 怎么解决这个问题呢？不使用集合的删除方法，而是使用迭代器的删除方法，代码如下： 12345678910111213141516171819List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;王麻子&quot;);list.add(&quot;小李子&quot;);list.add(&quot;李爱花&quot;);list.add(&quot;张全蛋&quot;);list.add(&quot;晓李&quot;);list.add(&quot;李玉刚&quot;);System.out.println(list); // [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String name = it.next(); if(name.contains(&quot;李&quot;))&#123; //list.remove(name); it.remove(); //当前迭代器指向谁，就删除谁 &#125;&#125;System.out.println(list); 二、Collection的其他操作各位同学，前面我们已经把Collection家族的集合都学习完了。为了更加方便的对Collection集合进行操作，今天我们还要学习一个操作Collection集合的工具类，叫做Collections。但是Collections工具类中需要用到一个没有学过的小知识点，叫做可变参数，所以必须先学习这个前置知识可变参数，再学习Collections工具类，最后再利用这个工具类做一个综合案例。 2.1 可变参数首先，我们来学习一下可变参数。关于可变参数我们首先要知道它是什么，然后要知道它的本质。搞清楚这两个问题，可变参数就算你学明白了。 可变参数是一种特殊的形式参数，定义在方法、构造器的形参列表处，它可以让方法接收多个同类型的实际参数。 可变参数在方法内部，本质上是一个数组 接下来，我们编写代码来演示一下 1234567891011121314151617181920public class ParamTest&#123; public static void main(String[] args)&#123; //不传递参数，下面的nums长度则为0, 打印元素是[] test(); //传递3个参数，下面的nums长度为3，打印元素是[10, 20, 30] test(10,20,30); //传递一个数组，下面数组长度为4，打印元素是[10,20,30,40] int[] arr = new int[]&#123;10,20,30,40&#125; test(arr); &#125; public static void test(int...nums)&#123; //可变参数在方法内部，本质上是一个数组 System.out.println(nums.length); System.out.println(Arrays.toString(nums)); System.out.println(&quot;----------------&quot;); &#125;&#125; 最后还有一些错误写法，需要让大家写代码时注意一下，不要这么写哦！！！ 一个形参列表中，只能有一个可变参数；否则会报错 一个形参列表中如果多个参数，可变参数需要写在最后；否则会报错 2.2 Collections工具类有了可变参数的基础，我们再学习Collections这个工具类就好理解了，因为这个工具类的方法中会用到可变参数。 注意Collections并不是集合，它比Collection多了一个s，一般后缀为s的类很多都是工具类。这里的Collections是用来操作Collection的工具类。它提供了一些好用的静态方法，如下 我们把这些方法用代码来演示一下： 1234567891011121314151617181920public class CollectionsTest&#123; public static void main(String[] args)&#123; //1.public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T...e) List&lt;String&gt; names = new ArrayList&lt;&gt;(); Collections.addAll(names, &quot;张三&quot;,&quot;王五&quot;,&quot;李四&quot;, &quot;张麻子&quot;); System.out.println(names); //2.public static void shuffle(List&lt;?&gt; list)：对集合打乱顺序 Collections.shuffle(names); System.out.println(names); //3.public static &lt;T&gt; void short(List&lt;T list): 对List集合排序 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(3); list.add(5); list.add(2); Collections.sort(list); System.out.println(list); &#125;&#125; 上面我们往集合中存储的元素要么是Stirng类型，要么是Integer类型，他们本来就有一种自然顺序所以可以直接排序。但是如果我们往List集合中存储Student对象，这个时候想要对List集合进行排序自定义比较规则的。指定排序规则有两种方式，如下： 排序方式1：让元素实现Comparable接口，重写compareTo方法 比如现在想要往集合中存储Studdent对象，首先需要准备一个Student类，实现Comparable接口。 1234567891011121314151617public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; private double height; //排序时：底层会自动调用此方法，this和o表示需要比较的两个对象 @Override public int compareTo(Student o)&#123; //需求：按照年龄升序排序 //如果返回正数：说明左边对象的年龄&gt;右边对象的年龄 //如果返回负数：说明左边对象的年龄&lt;右边对象的年龄， //如果返回0：说明左边对象的年龄和右边对象的年龄相同 return this.age - o.age; &#125; //...getter、setter、constructor..&#125; 然后再使用Collections.sort(list集合)对List集合排序，如下： 12345678910111213141516//3.public static &lt;T&gt; void short(List&lt;T list): 对List集合排序List&lt;Student&gt; students = new ArrayList&lt;&gt;();students.add(new Student(&quot;蜘蛛精&quot;,23,169.7));students.add(new Student(&quot;紫霞&quot;,22,169.8));students.add(new Student(&quot;紫霞&quot;,22,169.8));students.add(new Student(&quot;至尊宝&quot;,26,169.5));/*原理：sort方法底层会遍历students集合中的每一个元素，采用排序算法，将任意两个元素两两比较； 每次比较时，会用一个Student对象调用compareTo方法和另一个Student对象进行比较； 根据compareTo方法返回的结果是正数、负数，零来决定谁大，谁小，谁相等，重新排序元素的位置 注意：这些都是sort方法底层自动完成的，想要完全理解，必须要懂排序算法才行；*/Collections.sort(students); System.out.println(students); 排序方式2：使用调用sort方法是，传递比较器 1234567891011121314/*原理：sort方法底层会遍历students集合中的每一个元素，采用排序算法，将任意两个元素两两比较； 每次比较，会将比较的两个元素传递给Comparator比较器对象的compare方法的两个参数o1和o2, 根据compare方法的返回结果是正数，负数，或者0来决定谁大，谁小，谁相等，重新排序元素的位置 注意：这些都是sort方法底层自动完成的，不需要我们完全理解，想要理解它必须要懂排序算法才行.*/Collections.sort(students, new Comparator&lt;Student&gt;()&#123; @Override public int compare(Student o1, Student o2)&#123; return o1.getAge()-o2.getAge(); &#125;&#125;); System.out.println(students); 2.3 斗地主案例 我们先分析一下业务需求： 总共有54张牌，每一张牌有花色和点数两个属性、为了排序还可以再加一个序号 点数可以是：“3”,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot; 花色可以是：“♣”,&quot;♠&quot;,&quot;♥&quot;,&quot;♦&quot; 斗地主时：三个玩家没人手里17张牌，剩余3张牌作为底牌 123第一步：为了表示每一张牌有哪些属性，首先应该新建一个扑克牌的类第二步：启动游戏时，就应该提前准备好54张牌第三步：接着再完全洗牌、发牌、捋牌、看牌的业务逻辑 先来完成第一步，定义一个扑克类Card 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Card &#123; private String number; private String color; // 每张牌是存在大小的。 private int size; // 0 1 2 .... public Card() &#123; &#125; public Card(String number, String color, int size) &#123; this.number = number; this.color = color; this.size = size; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125; @Override public String toString() &#123; return color + number ; &#125;&#125; 再完成第二步，定义一个房间类，初始化房间时准备好54张牌 12345678910111213141516171819202122232425262728public class Room &#123; // 必须有一副牌。 private List&lt;Card&gt; allCards = new ArrayList&lt;&gt;(); public Room()&#123; // 1、做出54张牌，存入到集合allCards // a、点数：个数确定了，类型确定。 String[] numbers = &#123;&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;&#125;; // b、花色：个数确定了，类型确定。 String[] colors = &#123;&quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;&#125;; int size = 0; // 表示每张牌的大小 // c、遍历点数，再遍历花色，组织牌 for (String number : numbers) &#123; // number = &quot;3&quot; size++; // 1 2 .... for (String color : colors) &#123; // 得到一张牌 Card c = new Card(number, color, size); allCards.add(c); // 存入了牌 &#125; &#125; // 单独存入小大王的。 Card c1 = new Card(&quot;&quot;, &quot;🃏&quot; , ++size); Card c2 = new Card(&quot;&quot;, &quot;👲&quot; , ++size); Collections.addAll(allCards, c1, c2); System.out.println(&quot;新牌：&quot; + allCards); &#125;&#125; 最后完成第三步，定义一个启动游戏的方法，完成洗牌、发牌、捋牌、看牌的业务逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*** 游戏启动*/public void start() &#123; // 1、洗牌： allCards Collections.shuffle(allCards); System.out.println(&quot;洗牌后：&quot; + allCards); // 2、发牌，首先肯定要定义 三个玩家。 List(ArrayList) Set(TreeSet) List&lt;Card&gt; linHuChong = new ArrayList&lt;&gt;(); List&lt;Card&gt; jiuMoZhi = new ArrayList&lt;&gt;(); List&lt;Card&gt; renYingYing = new ArrayList&lt;&gt;(); // 正式发牌给这三个玩家，依次发出51张牌，剩余3张做为底牌。 // allCards = [♥3, ♣10, ♣4, ♥K, ♦Q, ♣2, 🃏, ♣8, .... // 0 1 2 3 4 5 6 ... % 3 for (int i = 0; i &lt; allCards.size() - 3; i++) &#123; Card c = allCards.get(i); // 判断牌发给谁 if(i % 3 == 0)&#123; // 请啊冲接牌 linHuChong.add(c); &#125;else if(i % 3 == 1)&#123; // 请啊鸠来接牌 jiuMoZhi.add(c); &#125;else if(i % 3 == 2)&#123; // 请盈盈接牌 renYingYing.add(c); &#125; &#125; // 3、对3个玩家的牌进行排序 sortCards(linHuChong); sortCards(jiuMoZhi); sortCards(renYingYing); // 4、看牌 System.out.println(&quot;啊冲：&quot; + linHuChong); System.out.println(&quot;啊鸠：&quot; + jiuMoZhi); System.out.println(&quot;盈盈：&quot; + renYingYing); List&lt;Card&gt; lastThreeCards = allCards.subList(allCards.size() - 3, allCards.size()); // 51 52 53 System.out.println(&quot;底牌：&quot; + lastThreeCards); jiuMoZhi.addAll(lastThreeCards); sortCards(jiuMoZhi); System.out.println(&quot;啊鸠抢到地主后：&quot; + jiuMoZhi);&#125;/** * 集中进行排序 * @param cards */private void sortCards(List&lt;Card&gt; cards) &#123; Collections.sort(cards, new Comparator&lt;Card&gt;() &#123; @Override public int compare(Card o1, Card o2) &#123; // return o1.getSize() - o2.getSize(); // 升序排序 return o2.getSize() - o1.getSize(); // 降序排序 &#125; &#125;);&#125; 不要忘记了写测试类了， 123456789public class GameDemo &#123; public static void main(String[] args) &#123; // 1、牌类。 // 2、房间 Room m = new Room(); // 3、启动游戏 m.start(); &#125;&#125; 三、Map集合3.1 Map概述体系各位同学，前面我们已经把单列集合学习完了，接下来我们要学习的是双列集合。首先我们还是先认识一下什么是双列集合。 所谓双列集合，就是说集合中的元素是一对一对的。Map集合中的每一个元素是以key=value的形式存在的，一个key=value就称之为一个键值对，而且在Java中有一个类叫Entry类，Entry的对象用来表示键值对对象。 所有的Map集合有如下的特点：键不能重复，值可以重复，每一个键只能找到自己对应的值。 下面我们先写一个Map集合，保存几个键值对，体验一下Map集合的特点 12345678910111213141516171819public class MapTest1 &#123; public static void main(String[] args) &#123; // Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 一行经典代码。 按照键 无序，不重复，无索引。 Map&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;(); // 有序，不重复，无索引。 map.put(&quot;手表&quot;, 100); map.put(&quot;手表&quot;, 220); // 后面重复的数据会覆盖前面的数据（键） map.put(&quot;手机&quot;, 2); map.put(&quot;Java&quot;, 2); map.put(null, null); System.out.println(map); Map&lt;Integer, String&gt; map1 = new TreeMap&lt;&gt;(); // 可排序，不重复，无索引 map1.put(23, &quot;Java&quot;); map1.put(23, &quot;MySQL&quot;); map1.put(19, &quot;李四&quot;); map1.put(20, &quot;王五&quot;); System.out.println(map1); &#125;&#125; Map集合也有很多种，在Java中使用不同的类来表示的，每一种Map集合其键的特点是有些差异的，值是键的一个附属值，所以我们只关注键的特点就可以了。 关于Map集合是什么，以及Map集合的体系我们先了解到这里，接下来就具体学习一下Map集合的通用方法。 3.2 Map集合的常用方法各位同学，上节课我们已经认识了Map集合，接下来我们学习一下Map集合提供了那些方法供我们使用。由于Map是所有双列集合的父接口，所以我们只需要学习Map接口中每一个方法是什么含义，那么所有的Map集合方法你就都会用了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MapTest2 &#123; public static void main(String[] args) &#123; // 1.添加元素: 无序，不重复，无索引。 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;手表&quot;, 100); map.put(&quot;手表&quot;, 220); map.put(&quot;手机&quot;, 2); map.put(&quot;Java&quot;, 2); map.put(null, null); System.out.println(map); // map = &#123;null=null, 手表=220, Java=2, 手机=2&#125; // 2.public int size():获取集合的大小 System.out.println(map.size()); // 3、public void clear():清空集合 //map.clear(); //System.out.println(map); // 4.public boolean isEmpty(): 判断集合是否为空，为空返回true ,反之！ System.out.println(map.isEmpty()); // 5.public V get(Object key)：根据键获取对应值 int v1 = map.get(&quot;手表&quot;); System.out.println(v1); System.out.println(map.get(&quot;手机&quot;)); // 2 System.out.println(map.get(&quot;张三&quot;)); // null // 6. public V remove(Object key)：根据键删除整个元素(删除键会返回键的值) System.out.println(map.remove(&quot;手表&quot;)); System.out.println(map); // 7.public boolean containsKey(Object key): 判断是否包含某个键 ，包含返回true ,反之 System.out.println(map.containsKey(&quot;手表&quot;)); // false System.out.println(map.containsKey(&quot;手机&quot;)); // true System.out.println(map.containsKey(&quot;java&quot;)); // false System.out.println(map.containsKey(&quot;Java&quot;)); // true // 8.public boolean containsValue(Object value): 判断是否包含某个值。 System.out.println(map.containsValue(2)); // true System.out.println(map.containsValue(&quot;2&quot;)); // false // 9.public Set&lt;K&gt; keySet(): 获取Map集合的全部键。 Set&lt;String&gt; keys = map.keySet(); System.out.println(keys); // 10.public Collection&lt;V&gt; values(); 获取Map集合的全部值。 Collection&lt;Integer&gt; values = map.values(); System.out.println(values); // 11.把其他Map集合的数据倒入到自己集合中来。(拓展) Map&lt;String, Integer&gt; map1 = new HashMap&lt;&gt;(); map1.put(&quot;java1&quot;, 10); map1.put(&quot;java2&quot;, 20); Map&lt;String, Integer&gt; map2 = new HashMap&lt;&gt;(); map2.put(&quot;java3&quot;, 10); map2.put(&quot;java2&quot;, 222); map1.putAll(map2); // putAll：把map2集合中的元素全部倒入一份到map1集合中去。 System.out.println(map1); System.out.println(map2); &#125;&#125; 3.3 Map集合遍历方式1Map集合一共有三种遍历方式，我们先来学习第一种，他需要用到下面的两个方法 12345678910111213141516171819202122232425262728/** * 目标：掌握Map集合的遍历方式1：键找值 */public class MapTest1 &#123; public static void main(String[] args) &#123; // 准备一个Map集合。 Map&lt;String, Double&gt; map = new HashMap&lt;&gt;(); map.put(&quot;蜘蛛精&quot;, 162.5); map.put(&quot;蜘蛛精&quot;, 169.8); map.put(&quot;紫霞&quot;, 165.8); map.put(&quot;至尊宝&quot;, 169.5); map.put(&quot;牛魔王&quot;, 183.6); System.out.println(map); // map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125; // 1、获取Map集合的全部键 Set&lt;String&gt; keys = map.keySet(); // System.out.println(keys); // [蜘蛛精, 牛魔王, 至尊宝, 紫霞] // key // 2、遍历全部的键，根据键获取其对应的值 for (String key : keys) &#123; // 根据键获取对应的值 double value = map.get(key); System.out.println(key + &quot;=====&gt;&quot; + value); &#125; &#125;&#125; 3.4 Map集合遍历方式2各位同学，接下来我们学习Map集合的第二种遍历方式，这种遍历方式更加符合面向对象的思维。 前面我们给大家介绍过，Map集合是用来存储键值对的，而每一个键值对实际上是一个Entry对象。 这里Map集合的第二种方式，是直接获取每一个Entry对象，把Entry存储扫Set集合中去，再通过Entry对象获取键和值。 1234567891011121314151617181920212223242526/** * 目标：掌握Map集合的第二种遍历方式：键值对。 */public class MapTest2 &#123; public static void main(String[] args) &#123; Map&lt;String, Double&gt; map = new HashMap&lt;&gt;(); map.put(&quot;蜘蛛精&quot;, 169.8); map.put(&quot;紫霞&quot;, 165.8); map.put(&quot;至尊宝&quot;, 169.5); map.put(&quot;牛魔王&quot;, 183.6); System.out.println(map); // map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125; // entries = [(蜘蛛精=169.8), (牛魔王=183.6), (至尊宝=169.5), (紫霞=165.8)] // entry = (蜘蛛精=169.8) // entry = (牛魔王=183.6) // ... // 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合 Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;String, Double&gt; entry : entries) &#123; String key = entry.getKey(); double value = entry.getValue(); System.out.println(key + &quot;----&gt;&quot; + value); &#125; &#125;&#125; 3.5 Map集合遍历方式3Map集合的第三种遍历方式，需要用到下面的一个方法forEach，而这个方法是JDK8版本以后才有的。调用起来非常简单，最好是结合的lambda表达式一起使用。 123456789101112131415161718192021222324252627/** * 目标：掌握Map集合的第二种遍历方式：键值对。 */public class MapTest3 &#123; public static void main(String[] args) &#123; Map&lt;String, Double&gt; map = new HashMap&lt;&gt;(); map.put(&quot;蜘蛛精&quot;, 169.8); map.put(&quot;紫霞&quot;, 165.8); map.put(&quot;至尊宝&quot;, 169.5); map.put(&quot;牛魔王&quot;, 183.6); System.out.println(map); // map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125; //遍历map集合，传递匿名内部类 map.forEach(new BiConsumer&lt;String, Double&gt;() &#123; @Override public void accept(String k, Double v) &#123; System.out.println(k + &quot;----&gt;&quot; + v); &#125; &#125;); //遍历map集合，传递Lambda表达式 map.forEach(( k, v) -&gt; &#123; System.out.println(k + &quot;----&gt;&quot; + v); &#125;); &#125;&#125; 3.6 Map集合案例学习完Map集合的基本用法之后，接下来我们做一个综合案例，将Map集合运用一下。 先分析需求，再考虑怎么用代码实现 123451.首先可以将80个学生选择的景点放到一个集合中去（也就是说，集合中的元素是80个任意的ABCD元素）2.准备一个Map集合用来存储景点，以及景点被选择的次数3.遍历80个学生选择景点的集合，得到每一个景点，判断Map集合中是否包含该景点 如果不包含，则存储&quot;景点=1&quot; 如果包含，则存获取该景点原先的值，再存储&quot;景点=原来的值+1&quot;; 此时新值会覆盖旧值 12345678910111213141516171819202122232425262728293031323334/** * 目标：完成Map集合的案例：统计投票人数。 */public class MapDemo4 &#123; public static void main(String[] args) &#123; // 1、把80个学生选择的景点数据拿到程序中来。 List&lt;String&gt; data = new ArrayList&lt;&gt;(); String[] selects = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;; Random r = new Random(); for (int i = 1; i &lt;= 80; i++) &#123; // 每次模拟一个学生选择一个景点，存入到集合中去。 int index = r.nextInt(4); // 0 1 2 3 data.add(selects[index]); &#125; System.out.println(data); // 2、开始统计每个景点的投票人数 // 准备一个Map集合用于统计最终的结果 Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); // 3、开始遍历80个景点数据 for (String s : data) &#123; // 问问Map集合中是否存在该景点 if(result.containsKey(s))&#123; // 说明这个景点之前统计过。其值+1. 存入到Map集合中去 result.put(s, result.get(s) + 1); &#125;else &#123; // 说明这个景点是第一次统计，存入&quot;景点=1&quot; result.put(s, 1); &#125; &#125; System.out.println(result); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day17-Map集合、Stream流、File类","slug":"day17-Map集合、Stream流、File类","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day17-Map集合、Stream流、File类/","link":"","permalink":"https://wxzhou.top/2020/05/05/day17-Map%E9%9B%86%E5%90%88%E3%80%81Stream%E6%B5%81%E3%80%81File%E7%B1%BB/","excerpt":"","text":"一、Map集合同学们，在前面几节课我们已经学习了Map集合的常用方法，以及遍历方式。 下面我们要学习的是Map接口下面的是三个实现类HashMap、LinkedHashMap、TreeMap。实际上这三个实现类并没有什么特有方法需要我们学习，它们的方法就是前面学习Map的方法。这里我们主要学习它们的底层原理。 1.1 HashMap首先，我们学习HashMap集合的底层原理。前面我们学习过HashSet的底层原理，实际上HashMap底层原理和HashSet是一样的。为什么这么说呢？因为我们往HashSet集合中添加元素时，实际上是把元素作为添加添加到了HashMap集合中。 下面是Map集合的体系结构，HashMap集合的特点是由键决定的： 它的键是无序、不能重复，而且没有索引的。再各种Map集合中也是用得最多的一种集合。 刚才我们说，HashSet底层就是HashMap，我们可以看源码验证这一点，如下图所示，我们可以看到，创建HashSet集合时，底层帮你创建了HashMap集合；往HashSet集合中添加添加元素时，底层却是调用了Map集合的put方法把元素作为了键来存储。所以实际上根本没有什么HashSet集合，把HashMap的集合的值忽略不看就是HashSet集合。 HashSet的原理我们之前已经学过了，所以HashMap是一样的，底层是哈希表结构。 1234567891011121314151617181920212223242526HashMap底层数据结构: 哈希表结构 JDK8之前的哈希表 = 数组+链表 JDK8之后的哈希表 = 数组+链表+红黑树 哈希表是一种增删改查数据，性能相对都较好的数据结构 往HashMap集合中键值对数据时，底层步骤如下 第1步：当你第一次往HashMap集合中存储键值对时，底层会创建一个长度为16的数组 第2步：把键然后将键和值封装成一个对象，叫做Entry对象 第3步：再根据Entry对象的键计算hashCode值（和值无关） 第4步：利用hashCode值和数组的长度做一个类似求余数的算法，会得到一个索引位置 第5步：判断这个索引的位置是否为null，如果为null,就直接将这个Entry对象存储到这个索引位置 如果不为null，则还需要进行第6步的判断 第6步：继续调用equals方法判断两个对象键是否相同 如果equals返回false，则以链表的形式往下挂 如果equals方法true,则认为键重复，此时新的键值对会替换就的键值对。 HashMap底层需要注意这几点： 1.底层数组默认长度为16，如果数组中有超过12个位置已经存储了元素，则会对数组进行扩容2倍 数组扩容的加载因子是0.75，意思是：16*0.75=12 2.数组的同一个索引位置有多个元素、并且在8个元素以内(包括8)，则以链表的形式存储 JDK7版本：链表采用头插法（新元素往链表的头部添加） JDK8版本：链表采用尾插法（新元素我那个链表的尾部添加） 3.数组的同一个索引位置有多个元素、并且超过了8个，则以红黑树形式存储 从HashMap底层存储键值对的过程中我们发现：决定键是否重复依赖与两个方法，一个是hashCode方法、一个是equals方法。有两个键计算得到的hashCode值相同，并且两个键使用equals比较为true，就认为键重复。 所以，往Map集合中存储自定义对象作为键，为了保证键的唯一性，我们应该重写hashCode方法和equals方法。 比如有如下案例：往HashMap集合中存储Student对象作为键，学生的家庭住址当做值。要求，当学生对象的姓名和年龄相同时就认为键重复。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student implements Comparable&lt;Student&gt; &#123; private String name; private int age; private double height; // this o @Override public int compareTo(Student o) &#123; return this.age - o.age; // 年龄升序排序 &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Double.compare(student.height, height) == 0 &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age, height); &#125; public Student() &#123; &#125; public Student(String name, int age, double height) &#123; this.name = name; this.age = age; this.height = height; &#125; //...get,set方法自己补全.... @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, height=&quot; + height + &#x27;&#125;&#x27;; &#125;&#125; 写一个测试类，在测试类中，创建HashMap集合，键是Student类型，值是Stirng类型 12345678910111213/** * 目标：掌握Map集合下的实现类：HashMap集合的底层原理。 */public class Test1HashMap &#123; public static void main(String[] args) &#123; Map&lt;Student, String&gt; map = new HashMap&lt;&gt;(); map.put(new Student(&quot;蜘蛛精&quot;, 25, 168.5), &quot;盘丝洞&quot;); map.put(new Student(&quot;蜘蛛精&quot;, 25, 168.5), &quot;水帘洞&quot;); map.put(new Student(&quot;至尊宝&quot;, 23, 163.5), &quot;水帘洞&quot;); map.put(new Student(&quot;牛魔王&quot;, 28, 183.5), &quot;牛头山&quot;); System.out.println(map); &#125;&#125; 上面存储的键，有两个蜘蛛精，但是打印出只会有最后一个。 1.2 LinkedHashMap学习完HashMap集合的特点，以及底层原理。接下来我们学习一下LinkedHashMap集合。 LinkedHashMap集合的特点也是由键决定的：有序的、不重复、无索引。 123456789101112131415/** * 目标：掌握LinkedHashMap的底层原理。 */public class Test2LinkedHashMap &#123; public static void main(String[] args) &#123; // Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 按照键 无序，不重复，无索引。 LinkedHashMap&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;(); // 按照键 有序，不重复，无索引。 map.put(&quot;手表&quot;, 100); map.put(&quot;手表&quot;, 220); map.put(&quot;手机&quot;, 2); map.put(&quot;Java&quot;, 2); map.put(null, null); System.out.println(map); &#125;&#125; 运行上面代码发现，如果是LinedHashMap集合键存储和取出的顺序是一样的 如果是HashMap，键存储和取出的顺序是不一致的 LinkedHashMap的底层原理，和LinkedHashSet底层原理是一样的。底层多个一个双向链表来维护键的存储顺序。 ​ 取元素时，先取头节点元素，然后再依次取下一个几点，一直到尾结点。所以是有序的。 1.3 TreeMap最后，我们再学习Map集合下面的另一个子类叫TreeMap。根据我们前面学习其他Map集合的经验，我们应该可以猜出TreeMap有什么特点。 TreeMap集合的特点也是由键决定的，默认按照键的升序排列，键不重复，也是无索引的。 TreeMap集合的底层原理和TreeSet也是一样的，底层都是红黑树实现的。所以可以对键进行排序。 比如往TreeMap集合中存储Student对象作为键，排序方法有两种。直接看代码吧 排序方式1：写一个Student类，让Student类实现Comparable接口 12345678910111213141516171819202122232425262728//第一步：先让Student类，实现Comparable接口public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; private double height; //无参数构造方法 public Student()&#123;&#125; //全参数构造方法 public Student(String name, int age, double height)&#123; this.name=name; this.age=age; this.height=height; &#125; //...get、set、toString()方法自己补上.. //按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。 /* 原理： 在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的 结果是正数、负数、还是零，决定元素放在后面、前面还是不存。 */ @Override public int compareTo(Student o) &#123; //this：表示将要添加进去的Student对象 //o: 表示集合中已有的Student对象 return this.age-o.age; &#125;&#125; 排序方式2：在创建TreeMap集合时，直接传递Comparator比较器对象。 12345678910111213141516171819/** * 目标：掌握TreeMap集合的使用。 */public class Test3TreeMap &#123; public static void main(String[] args) &#123; Map&lt;Student, String&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return Double.compare(o1.getHeight(), o2.getHeight()); &#125; &#125;);// Map&lt;Student, String&gt; map = new TreeMap&lt;&gt;(( o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight())); map.put(new Student(&quot;蜘蛛精&quot;, 25, 168.5), &quot;盘丝洞&quot;); map.put(new Student(&quot;蜘蛛精&quot;, 25, 168.5), &quot;水帘洞&quot;); map.put(new Student(&quot;至尊宝&quot;, 23, 163.5), &quot;水帘洞&quot;); map.put(new Student(&quot;牛魔王&quot;, 28, 183.5), &quot;牛头山&quot;); System.out.println(map); &#125;&#125; 这种方式都可以对TreeMap集合中的键排序。注意：只有TreeMap的键才能排序，HashMap键不能排序。 1.4 集合嵌套各位同学，到现在为止我们把Map集合和Collection集合的都已经学习完了。但是在实际开发中可能还会存在一种特殊的用法。就是把一个集合当做元素，存储到另一个集合中去，我们把这种用法称之为集合嵌套。 下面通过一个案例给大家演示一下 案例分析 123451.从需求中我们可以看到，有三个省份，每一个省份有多个城市 我们可以用一个Map集合的键表示省份名称，而值表示省份有哪些城市2.而又因为一个身份有多个城市，同一个省份的多个城市可以再用一个List集合来存储。 所以Map集合的键是String类型，而指是List集合类型 HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 代码如下 12345678910111213141516171819202122232425262728293031323334/** * 目标：理解集合的嵌套。 * 江苏省 = &quot;南京市&quot;,&quot;扬州市&quot;,&quot;苏州市“,&quot;无锡市&quot;,&quot;常州市&quot; * 湖北省 = &quot;武汉市&quot;,&quot;孝感市&quot;,&quot;十堰市&quot;,&quot;宜昌市&quot;,&quot;鄂州市&quot; * 河北省 = &quot;石家庄市&quot;,&quot;唐山市&quot;, &quot;邢台市&quot;, &quot;保定市&quot;, &quot;张家口市&quot; */public class Test &#123; public static void main(String[] args) &#123; // 1、定义一个Map集合存储全部的省份信息，和其对应的城市信息。 Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); List&lt;String&gt; cities1 = new ArrayList&lt;&gt;(); Collections.addAll(cities1, &quot;南京市&quot;,&quot;扬州市&quot;,&quot;苏州市&quot; ,&quot;无锡市&quot;,&quot;常州市&quot;); map.put(&quot;江苏省&quot;, cities1); List&lt;String&gt; cities2 = new ArrayList&lt;&gt;(); Collections.addAll(cities2, &quot;武汉市&quot;,&quot;孝感市&quot;,&quot;十堰市&quot;,&quot;宜昌市&quot;,&quot;鄂州市&quot;); map.put(&quot;湖北省&quot;, cities2); List&lt;String&gt; cities3 = new ArrayList&lt;&gt;(); Collections.addAll(cities3, &quot;石家庄市&quot;,&quot;唐山市&quot;, &quot;邢台市&quot;, &quot;保定市&quot;, &quot;张家口市&quot;); map.put(&quot;河北省&quot;, cities3); System.out.println(map); List&lt;String&gt; cities = map.get(&quot;湖北省&quot;); for (String city : cities) &#123; System.out.println(city); &#125; map.forEach((p, c) -&gt; &#123; System.out.println(p + &quot;-----&gt;&quot; + c); &#125;); &#125;&#125; 二、JDK8新特性（Stream流）各位同学，接下来我们学习一个全新的知识，叫做Stream流（也叫Stream API）。它是从JDK8以后才有的一个新特性，是专业用于对集合或者数组进行便捷操作的。有多方便呢？我们用一个案例体验一下，然后再详细学习。 2.1 Stream流体验案例需求：有一个List集合，元素有&quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;，找出姓张，且是3个字的名字，存入到一个新集合中去。 123List&lt;String&gt; names = new ArrayList&lt;&gt;();Collections.addAll(names, &quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;);System.out.println(names); 用传统方式来做，代码是这样的 12345678// 找出姓张，且是3个字的名字，存入到一个新集合中去。List&lt;String&gt; list = new ArrayList&lt;&gt;();for (String name : names) &#123; if(name.startsWith(&quot;张&quot;) &amp;&amp; name.length() == 3)&#123; list.add(name); &#125;&#125;System.out.println(list); 用Stream流来做，代码是这样的（ps: 是不是想流水线一样，一句话就写完了） 12List&lt;String&gt; list2 = names.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(a -&gt; a.length()==3).collect(Collectors.toList());System.out.println(list2); 先不用知道这里面每一句话是什么意思，具体每一句话的含义，待会再一步步学习。现在只是体验一下。 学习Stream流我们接下来，会按照下面的步骤来学习。 2.2 Stream流的创建好，接下来我们正式来学习Stream流。先来学习如何创建Stream流、或者叫获取Stream流。 12345主要掌握下面四点： 1、如何获取List集合的Stream流？ 2、如何获取Set集合的Stream流？ 3、如何获取Map集合的Stream流？ 4、如何获取数组的Stream流？ 直接上代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 目标：掌握Stream流的创建。 */public class StreamTest2 &#123; public static void main(String[] args) &#123; // 1、如何获取List集合的Stream流？ List&lt;String&gt; names = new ArrayList&lt;&gt;(); Collections.addAll(names, &quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;); Stream&lt;String&gt; stream = names.stream(); // 2、如何获取Set集合的Stream流？ Set&lt;String&gt; set = new HashSet&lt;&gt;(); Collections.addAll(set, &quot;刘德华&quot;,&quot;张曼玉&quot;,&quot;蜘蛛精&quot;,&quot;马德&quot;,&quot;德玛西亚&quot;); Stream&lt;String&gt; stream1 = set.stream(); stream1.filter(s -&gt; s.contains(&quot;德&quot;)).forEach(s -&gt; System.out.println(s)); // 3、如何获取Map集合的Stream流？ Map&lt;String, Double&gt; map = new HashMap&lt;&gt;(); map.put(&quot;古力娜扎&quot;, 172.3); map.put(&quot;迪丽热巴&quot;, 168.3); map.put(&quot;马尔扎哈&quot;, 166.3); map.put(&quot;卡尔扎巴&quot;, 168.3); Set&lt;String&gt; keys = map.keySet(); Stream&lt;String&gt; ks = keys.stream(); Collection&lt;Double&gt; values = map.values(); Stream&lt;Double&gt; vs = values.stream(); Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet(); Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream(); kvs.filter(e -&gt; e.getKey().contains(&quot;巴&quot;)) .forEach(e -&gt; System.out.println(e.getKey()+ &quot;--&gt;&quot; + e.getValue())); // 4、如何获取数组的Stream流？ String[] names2 = &#123;&quot;张翠山&quot;, &quot;东方不败&quot;, &quot;唐大山&quot;, &quot;独孤求败&quot;&#125;; Stream&lt;String&gt; s1 = Arrays.stream(names2); Stream&lt;String&gt; s2 = Stream.of(names2); &#125;&#125; 2.3 Stream流中间方法在上一节，我们学习了创建Stream流的方法。接下来我们再来学习，Stream流中间操作的方法。 中间方法指的是：调用完方法之后其结果是一个新的Stream流，于是可以继续调用方法，这样一来就可以支持链式编程（或者叫流式编程）。 话不多说，直接上代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 目标：掌握Stream流提供的常见中间方法。 */public class StreamTest3 &#123; public static void main(String[] args) &#123; List&lt;Double&gt; scores = new ArrayList&lt;&gt;(); Collections.addAll(scores, 88.5, 100.0, 60.0, 99.0, 9.5, 99.6, 25.0); // 需求1：找出成绩大于等于60分的数据，并升序后，再输出。 scores.stream().filter(s -&gt; s &gt;= 60).sorted().forEach(s -&gt; System.out.println(s)); List&lt;Student&gt; students = new ArrayList&lt;&gt;(); Student s1 = new Student(&quot;蜘蛛精&quot;, 26, 172.5); Student s2 = new Student(&quot;蜘蛛精&quot;, 26, 172.5); Student s3 = new Student(&quot;紫霞&quot;, 23, 167.6); Student s4 = new Student(&quot;白晶晶&quot;, 25, 169.0); Student s5 = new Student(&quot;牛魔王&quot;, 35, 183.3); Student s6 = new Student(&quot;牛夫人&quot;, 34, 168.5); Collections.addAll(students, s1, s2, s3, s4, s5, s6); // 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出. students.stream().filter(s -&gt; s.getAge() &gt;= 23 &amp;&amp; s.getAge() &lt;= 30) .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge()) .forEach(s -&gt; System.out.println(s)); // 需求3：取出身高最高的前3名学生，并输出。 students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight())) .limit(3).forEach(System.out::println); System.out.println(&quot;-----------------------------------------------&quot;); // 需求4：取出身高倒数的2名学生，并输出。 s1 s2 s3 s4 s5 s6 students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight())) .skip(students.size() - 2).forEach(System.out::println); // 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。 students.stream().filter(s -&gt; s.getHeight() &gt; 168).map(Student::getName) .distinct().forEach(System.out::println); // distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals） students.stream().filter(s -&gt; s.getHeight() &gt; 168) .distinct().forEach(System.out::println); Stream&lt;String&gt; st1 = Stream.of(&quot;张三&quot;, &quot;李四&quot;); Stream&lt;String&gt; st2 = Stream.of(&quot;张三2&quot;, &quot;李四2&quot;, &quot;王五&quot;); Stream&lt;String&gt; allSt = Stream.concat(st1, st2); allSt.forEach(System.out::println); &#125;&#125; 2.5 Stream流终结方法最后，我们再学习Stream流的终结方法。这些方法的特点是，调用完方法之后，其结果就不再是Stream流了，所以不支持链式编程。 我列举了下面的几个终结方法，接下来用几个案例来一个一个给同学们演示。 话不多说，直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 目标：Stream流的终结方法 */public class StreamTest4 &#123; public static void main(String[] args) &#123; List&lt;Student&gt; students = new ArrayList&lt;&gt;(); Student s1 = new Student(&quot;蜘蛛精&quot;, 26, 172.5); Student s2 = new Student(&quot;蜘蛛精&quot;, 26, 172.5); Student s3 = new Student(&quot;紫霞&quot;, 23, 167.6); Student s4 = new Student(&quot;白晶晶&quot;, 25, 169.0); Student s5 = new Student(&quot;牛魔王&quot;, 35, 183.3); Student s6 = new Student(&quot;牛夫人&quot;, 34, 168.5); Collections.addAll(students, s1, s2, s3, s4, s5, s6); // 需求1：请计算出身高超过168的学生有几人。 long size = students.stream().filter(s -&gt; s.getHeight() &gt; 168).count(); System.out.println(size); // 需求2：请找出身高最高的学生对象，并输出。 Student s = students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get(); System.out.println(s); // 需求3：请找出身高最矮的学生对象，并输出。 Student ss = students.stream().min((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get(); System.out.println(ss); // 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。 // 流只能收集一次。 List&lt;Student&gt; students1 = students.stream().filter(a -&gt; a.getHeight() &gt; 170).collect(Collectors.toList()); System.out.println(students1); Set&lt;Student&gt; students2 = students.stream().filter(a -&gt; a.getHeight() &gt; 170).collect(Collectors.toSet()); System.out.println(students2); // 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。 Map&lt;String, Double&gt; map = students.stream().filter(a -&gt; a.getHeight() &gt; 170) .distinct().collect(Collectors.toMap(a -&gt; a.getName(), a -&gt; a.getHeight())); System.out.println(map); // Object[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray(); Student[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray(len -&gt; new Student[len]); System.out.println(Arrays.toString(arr)); &#125;&#125; 到这里，关于Stream流的操常见操作我们就已经学习完了。当然Stream流还有一些其他的方法，同学们遇到了也可以自己再研究一下。 三、File类接下来，我们要学习的知识是一个File类。但是在讲这个知识点之前，我想先和同学们聊点别的，聊完之后再回过来学习File你会更容易理解一些。 先问大家一个问题，目前你写代码时存储数据，可以用哪些方案? 答案如下图所示：可以是变量、可以是数组、可以是对象、可以是集合，但是这些数据都是存储在内存中的，只要程序执行结束，或者断点了，数据就消失了。不能永久存储。 有些数据要长久保存，该怎么办呢？ 答案如下图所示：可以将数据以文件的形式存在硬盘里，即使程序结束了，断点了只要硬盘没坏，数据就永久存在。 而现在要学习的File类，它的就用来表示当前系统下的文件（也可以是文件夹），通过File类提供的方法可以获取文件大小、判断文件是否存在、创建文件、创建文件夹等。 但是需要我们注意：File对象只能对文件进行操作，不能操作文件中的内容。 3.1 File对象的创建学习File类和其他类一样，第一步是创建File类的对象。 想要创建对象，我们得看File类有哪些构造方法。 下面我们演示一下，File类创建对象的代码 1需求我们注意的是：路径中&quot;\\&quot;要写成&quot;\\\\&quot;， 路径中&quot;/&quot;可以直接用 12345678910111213141516171819202122232425262728/** * 目标：掌握File创建对象，代表具体文件的方案。 */public class FileTest1 &#123; public static void main(String[] args) &#123; // 1、创建一个File对象，指代某个具体的文件。 // 路径分隔符 // File f1 = new File(&quot;D:/resource/ab.txt&quot;); // File f1 = new File(&quot;D:\\\\resource\\\\ab.txt&quot;); File f1 = new File(&quot;D:&quot; + File.separator +&quot;resource&quot; + File.separator + &quot;ab.txt&quot;); System.out.println(f1.length()); // 文件大小 File f2 = new File(&quot;D:/resource&quot;); System.out.println(f2.length()); // 注意：File对象可以指代一个不存在的文件路径 File f3 = new File(&quot;D:/resource/aaaa.txt&quot;); System.out.println(f3.length()); System.out.println(f3.exists()); // false // 我现在要定位的文件是在模块中，应该怎么定位呢？ // 绝对路径：带盘符的 // File f4 = new File(&quot;D:\\\\code\\\\javasepromax\\\\file-io-app\\\\src\\\\itheima.txt&quot;); // 相对路径（重点）：不带盘符，默认是直接去工程下寻找文件的。 File f4 = new File(&quot;file-io-app\\\\src\\\\itheima.txt&quot;); System.out.println(f4.length()); &#125;&#125; 3.2 File判断和获取方法各位同学，刚才我们创建File对象的时候，会传递一个文件路径过来。但是File对象封装的路径是存在还是不存在，是文件还是文件夹其实是不清楚的。好在File类提供了方法可以帮我们做判断。 话不多少，直接上代码 12345678910111213141516171819/** 目标：掌握File提供的判断文件类型、获取文件信息功能 */public class FileTest2 &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; // 1.创建文件对象，指代某个文件 File f1 = new File(&quot;D:/resource/ab.txt&quot;); //File f1 = new File(&quot;D:/resource/&quot;); // 2、public boolean exists()：判断当前文件对象，对应的文件路径是否存在，存在返回true. System.out.println(f1.exists()); // 3、public boolean isFile() : 判断当前文件对象指代的是否是文件，是文件返回true，反之。 System.out.println(f1.isFile()); // 4、public boolean isDirectory() : 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。 System.out.println(f1.isDirectory()); &#125;&#125; 除了判断功能还有一些获取功能，看代码 12345678910111213141516171819202122File f1 = new File(&quot;D:/resource/ab.txt&quot;);// 5.public String getName()：获取文件的名称（包含后缀）System.out.println(f1.getName());// 6.public long length()：获取文件的大小，返回字节个数System.out.println(f1.length());// 7.public long lastModified()：获取文件的最后修改时间。long time = f1.lastModified();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);System.out.println(sdf.format(time));// 8.public String getPath()：获取创建文件对象时，使用的路径File f2 = new File(&quot;D:\\\\resource\\\\ab.txt&quot;);File f3 = new File(&quot;file-io-app\\\\src\\\\itheima.txt&quot;);System.out.println(f2.getPath());System.out.println(f3.getPath());// 9.public String getAbsolutePath()：获取绝对路径System.out.println(f2.getAbsolutePath());System.out.println(f3.getAbsolutePath()); 3.3 创建和删除方法刚才有同学问老师，我们不能不用Java代码创建一个文件或者文件夹呀？答案是有的，不光可以创建还可以删除。 File类提供了创建和删除文件的方法，话不多少，看代码。 123456789101112131415161718192021222324/** * 目标：掌握File创建和删除文件相关的方法。 */public class FileTest3 &#123; public static void main(String[] args) throws Exception &#123; // 1、public boolean createNewFile()：创建一个新文件（文件内容为空），创建成功返回true,反之。 File f1 = new File(&quot;D:/resource/itheima2.txt&quot;); System.out.println(f1.createNewFile()); // 2、public boolean mkdir()：用于创建文件夹，注意：只能创建一级文件夹 File f2 = new File(&quot;D:/resource/aaa&quot;); System.out.println(f2.mkdir()); // 3、public boolean mkdirs()：用于创建文件夹，注意：可以创建多级文件夹 File f3 = new File(&quot;D:/resource/bbb/ccc/ddd/eee/fff/ggg&quot;); System.out.println(f3.mkdirs()); // 3、public boolean delete()：删除文件，或者空文件，注意：不能删除非空文件夹。 System.out.println(f1.delete()); System.out.println(f2.delete()); File f4 = new File(&quot;D:/resource&quot;); System.out.println(f4.delete()); &#125;&#125; 需要注意的是： 1231.mkdir(): 只能创建单级文件夹、2.mkdirs(): 才能创建多级文件夹3.delete(): 文件可以直接删除，但是文件夹只能删除空的文件夹，文件夹有内容删除不了。 3.4 遍历文件夹方法有人说，想获取到一个文件夹中的内容，有没有方法呀？也是有的，下面我们就学习两个这样的方法。 话不多少上代码，演示一下 1234567891011121314151617181920212223/** * 目标：掌握File提供的遍历文件夹的方法。 */public class FileTest4 &#123; public static void main(String[] args) &#123; // 1、public String[] list()：获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。 File f1 = new File(&quot;D:\\\\course\\\\待研发内容&quot;); String[] names = f1.list(); for (String name : names) &#123; System.out.println(name); &#125; // 2、public File[] listFiles():（重点）获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点） File[] files = f1.listFiles(); for (File file : files) &#123; System.out.println(file.getAbsolutePath()); &#125; File f = new File(&quot;D:/resource/aaa&quot;); File[] files1 = f.listFiles(); System.out.println(Arrays.toString(files1)); &#125;&#125; 这里需要注意几个问题 123451.当主调是文件时，或者路径不存在时，返回null2.当主调是空文件夹时，返回一个长度为0的数组3.当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹路径放在File数组中，并把数组返回4.当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在FIle数组中，包含隐藏文件5.当主调是一个文件夹，但是没有权限访问时，返回null 关于遍历文件夹的基本操作就学习完了。 但是有同学如果想要获取文件夹中子文件夹的内容，那目前还做不到。但是学习下面了下面的递归知识就，很容易做到了。 四、递归各位同学，为了获取文件夹中子文件夹的内容，我们就需要学习递归这个知识点。但是递归是什么意思，我们需要单独讲一下。学习完递归是什么，以及递归的执行流程之后，我们再回过头来用递归来找文件夹中子文件夹的内容。 4.1 递归算法引入 什么是递归？ 递归是一种算法，从形式上来说，方法调用自己的形式称之为递归。 递归的形式：有直接递归、间接递归，如下面的代码。 12345678910111213141516171819202122232425/** * 目标：认识一下递归的形式。 */public class RecursionTest1 &#123; public static void main(String[] args) &#123; test1(); &#125; // 直接方法递归 public static void test1()&#123; System.out.println(&quot;----test1---&quot;); test1(); // 直接方法递归 &#125; // 间接方法递归 public static void test2()&#123; System.out.println(&quot;---test2---&quot;); test3(); &#125; public static void test3()&#123; test2(); // 间接递归 &#125;&#125; 如果直接执行上面的代码，会进入死循环，最终导致栈内存溢出 以上只是用代码演示了一下，递归的形式。在下一节，在通过一个案例来给同学们讲一讲递归的执行流程。 4.2 递归算法的执行流程为了弄清楚递归的执行流程，接下来我们通过一个案例来学习一下。 案例需求：计算n的阶乘，比如5的阶乘 &#x3D; 1 * 2 * 3 * 4 * 5 ； 6 的阶乘 &#x3D; 1 * 2 * 3 * 4 * 5 * 6 分析需求用递归该怎么做 12345678910假设f(n)表示n的阶乘，那么我们可以推导出下面的式子 f(5) = 1+2+3+4+5 f(5) = f(4)+5 f(4) = f(3)+4 f(3) = f(2)+3 f(2) = f(1)+2 f(1) = 1总结规律： 除了f(1) = 1; 出口 其他的f(n) = f(n-1)+n 我们可以把f(n)当做一个方法，那么方法的写法如下 123456789101112131415161718/** * 目标：掌握递归的应用，执行流程和算法思想。 */public class RecursionTest2 &#123; public static void main(String[] args) &#123; System.out.println(&quot;5的阶乘是：&quot; + f(5)); &#125; //求n个数的阶乘 public static int f(int n)&#123; // 终结点 if(n == 1)&#123; return 1; &#125;else &#123; return f(n - 1) * n; &#125; &#125;&#125; 这个代码的执行流程，我们用内存图的形式来分析一下，该案例中递归调用的特点是：一层一层调用，再一层一层往回返。 4.3 递归文件搜索学习完递归算法执行流程后，最后我们回过头来。再来看一下，如果使用递归来遍历文件夹。 案例需求：在D:\\\\判断下搜索QQ.exe这个文件，然后直接输出。 1234561.先调用文件夹的listFiles方法，获取文件夹的一级内容，得到一个数组2.然后再遍历数组，获取数组中的File对象3.因为File对象可能是文件也可能是文件夹，所以接下来就需要判断 判断File对象如果是文件，就获取文件名，如果文件名是`QQ.exe`则打印，否则不打印 判断File对象如果是文件夹，就递归执行1,2,3步骤所以：把1，2,3步骤写成方法，递归调用即可。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 目标：掌握文件搜索的实现。 */public class RecursionTest3 &#123; public static void main(String[] args) throws Exception &#123; searchFile(new File(&quot;D:/&quot;) , &quot;QQ.exe&quot;); &#125; /** * 去目录下搜索某个文件 * @param dir 目录 * @param fileName 要搜索的文件名称 */ public static void searchFile(File dir, String fileName) throws Exception &#123; // 1、把非法的情况都拦截住 if(dir == null || !dir.exists() || dir.isFile())&#123; return; // 代表无法搜索 &#125; // 2、dir不是null,存在，一定是目录对象。 // 获取当前目录下的全部一级文件对象。 File[] files = dir.listFiles(); // 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。 if(files != null &amp;&amp; files.length &gt; 0)&#123; // 4、遍历全部一级文件对象。 for (File f : files) &#123; // 5、判断文件是否是文件,还是文件夹 if(f.isFile())&#123; // 是文件，判断这个文件名是否是我们要找的 if(f.getName().contains(fileName))&#123; System.out.println(&quot;找到了：&quot; + f.getAbsolutePath()); Runtime runtime = Runtime.getRuntime(); runtime.exec(f.getAbsolutePath()); &#125; &#125;else &#123; // 是文件夹，继续重复这个过程（递归） searchFile(f, fileName); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day18-字符集、IO流（一）","slug":"day18-字符集、IO流（一）","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day18-字符集、IO流（一）/","link":"","permalink":"https://wxzhou.top/2020/05/05/day18-%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81IO%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"各位同学，前面我们已经学习了File类，通过File类的对象可以对文件进行操作，但是不能操作文件中的内容。要想操作文件中的内容，我们还得学习IO流。但是在正式学习IO流之前，我们还需要学习一个前置知识叫做字符集，只有我们把字符集搞明白了，再学习IO流才会更加丝滑。 一、字符集1.1 字符集的来历所以，接下来我们正式学习一下字符集。先来带着同学们，了解一下字符集的来历。 我们知道计算机是美国人发明的，由于计算机能够处理的数据只能是0和1组成的二进制数据，为了让计算机能够处理字符，于是美国人就把他们会用到的每一个字符进行了编码（所谓编码，就是为一个字符编一个二进制数据），如下图所示： 美国人常用的字符有英文字母、标点符号、数字以及一些特殊字符，这些字符一共也不到128个，所以他们用1个字节来存储1字符就够了。 美国人把他们用到的字符和字符对应的编码总结成了一张码表，这张码表叫做ASCII码表（也叫ASCII字符集）。 其实计算机只在美国用是没有问题的，但是计算机慢慢的普及到全世界，当普及到中国的时候，在计算机中想要存储中文，那ASCII字符集就不够用了，因为中文太多了，随便数一数也有几万个字符。 于是中国人为了在计算机中存储中文，也编了一个中国人用的字符集叫做GBK字符集，这里面包含2万多个汉字字符，GBK中一个汉字采用两个字节来存储，为了能够显示英文字母，GBK字符集也兼容了ASCII字符集，在GBK字符集中一个字母还是采用一个字节来存储。 1.2 汉字和字母的编码特点讲到这里，可能有同学有这么一个疑问： 如果一个文件中既有中文，也有英文，那计算机怎么知道哪几个字节表示一个汉字，哪几个字节表示一个字母呢？ 其实这个问题问当想当有水平，接下来，就带着同学们了解一下，计算机是怎么识别中文和英文的。 比如：在文件中存储一个我a你，底层其实存储的是这样的二进制数据。 需要我们注意汉字和字母的编码特点： 如果是存储字母，采用1个字节来存储，一共8位，其中第1位是0 如果是存储汉字，采用2个字节来存储，一共16位，其中第1位是1 当读取文件中的字符时，通过识别读取到的第1位是0还是1来判断是字母还是汉字 如果读取到第1位是0，就认为是一个字母，此时往后读1个字节。 如果读取到第1位是1，就认为是一个汉字，此时往后读2个字节。 1.3 Unicode字符集同学们注意了，咱们国家可以用GBK字符集来表示中国人使用的文字，那世界上还有很多其他的国家，他们也有自己的文字，他们也想要自己国家的文字在计算机中处理，于是其他国家也在搞自己的字符集，就这样全世界搞了上百个字符集，而且各个国家的字符集互不兼容。 这样其实很不利于国际化的交流，可能一个文件在我们国家的电脑上打开好好的，但是在其他国家打开就是乱码了。 为了解决各个国家字符集互不兼容的问题，由国际化标准组织牵头，设计了一套全世界通用的字符集，叫做Unicode字符集。在Unicode字符集中包含了世界上所有国家的文字，一个字符采用4个自己才存储。 在Unicode字符集中，采用一个字符4个字节的编码方案，又造成另一个问题：如果是说英语的国家，他们只需要用到26大小写字母，加上一些标点符号就够了，本身一个字节就可以表示完，用4个字节就有点浪费。 于是又对Unicode字符集中的字符进行了重新编码，一共设计了三种编码方案。分别是UTF-32、UTF-16、UTF-8; 其中比较常用的编码方案是UTF-8 下面我们详细介绍一下UTF-8这种编码方案的特点。 12341.UTF-8是一种可变长的编码方案，工分为4个长度区2.英文字母、数字占1个字节兼容(ASCII编码)3.汉字字符占3个字节4.极少数字符占4个字节 1.4 字符集小结最后，我们将前面介绍过的字符集小结一下 12345678ASCII字符集：《美国信息交换标准代码》，包含英文字母、数字、标点符号、控制字符 特点：1个字符占1个字节GBK字符集：中国人自己的字符集，兼容ASCII字符集，还包含2万多个汉字 特点：1个字母占用1个字节；1个汉字占用2个字节Unicode字符集：包含世界上所有国家的文字，有三种编码方案，最常用的是UTF-8 UTF-8编码方案：英文字母、数字占1个字节兼容(ASCII编码)、汉字字符占3个字节 1.5 编码和解码搞清楚字符集的知识之后，我们接下来再带着同学们使用Java代码完成编码和解码的操作。 其实String类类中就提供了相应的方法，可以完成编码和解码的操作。 编码：把字符串按照指定的字符集转换为字节数组 解码：把字节数组按照指定的字符集转换为字符串 12345678910111213141516171819202122/** * 目标：掌握如何使用Java代码完成对字符的编码和解码。 */public class Test &#123; public static void main(String[] args) throws Exception &#123; // 1、编码 String data = &quot;a我b&quot;; byte[] bytes = data.getBytes(); // 默认是按照平台字符集（UTF-8）进行编码的。 System.out.println(Arrays.toString(bytes)); // 按照指定字符集进行编码。 byte[] bytes1 = data.getBytes(&quot;GBK&quot;); System.out.println(Arrays.toString(bytes1)); // 2、解码 String s1 = new String(bytes); // 按照平台默认编码（UTF-8）解码 System.out.println(s1); String s2 = new String(bytes1, &quot;GBK&quot;); System.out.println(s2); &#125;&#125; 二、IO流（字节流）2.1 IO流概述各位小伙伴，在前面我们已经学习过File类。但是我们知道File只能操作文件，但是不能操作文件中的内容。我们也学习了字符集，不同的字符集存字符数据的原理是不一样的。有了前面两个知识的基础，接下来我们再学习IO流，就可以对文件中的数据进行操作了。 IO流的作用：就是可以对文件或者网络中的数据进行读、写的操作。如下图所示 把数据从磁盘、网络中读取到程序中来，用到的是输入流。 把程序中的数据写入磁盘、网络中，用到的是输出流。 简单记：输入流（读数据）、输出流（写数据） IO流在Java中有很多种，不同的流来干不同的事情。Java把各种流用不同的类来表示，这些流的继承体系如下图所示： 123IO流分为两大派系： 1.字节流：字节流又分为字节输入流、字节输出流 2.字符流：字符流由分为字符输入流、字符输出流 2.2 FileInputStream读取一个字节同学们，在上节课认识了什么是IO流，接下来我们学习字节流中的字节输入流，用InputStream来表示。但是InputStream是抽象类，我们用的是它的子类，叫FileInputStream。 需要用到的方法如下图所示：有构造方法、成员方法 使用FileInputStream读取文件中的字节数据，步骤如下 123第一步：创建FileInputStream文件字节输入流管道，与源文件接通。第二步：调用read()方法开始读取文件的字节数据。第三步：调用close()方法释放资源 代码如下： 12345678910111213141516171819/** * 目标：掌握文件字节输入流，每次读取一个字节。 */public class FileInputStreamTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建文件字节输入流管道，与源文件接通。 InputStream is = new FileInputStream((&quot;file-io-app\\\\src\\\\itheima01.txt&quot;)); // 2、开始读取文件的字节数据。 // public int read():每次读取一个字节返回，如果没有数据了，返回-1. int b; // 用于记住读取的字节。 while ((b = is.read()) != -1)&#123; System.out.print((char) b); &#125; //3、流使用完毕之后，必须关闭！释放系统资源！ is.close(); &#125;&#125; 这里需要注意一个问题：由于一个中文在UTF-8编码方案中是占3个字节，采用一次读取一个字节的方式，读一个字节就相当于读了1&#x2F;3个汉字，此时将这个字节转换为字符，是会有乱码的。 2.3 FileInputStream读取多个字节各位同学，在上一节我们学习了FileInputStream调用read()方法，可以一次读取一个字节。但是这种读取方式效率太太太太慢了。 为了提高效率，我们可以使用另一个read(byte[] bytes)的重载方法，可以一次读取多个字节，至于一次读多少个字节，就在于你传递的数组有多大。 使用FileInputStream一次读取多个字节的步骤如下 123第一步：创建FileInputStream文件字节输入流管道，与源文件接通。第二步：调用read(byte[] bytes)方法开始读取文件的字节数据。第三步：调用close()方法释放资源 代码如下： 1234567891011121314151617181920212223242526/** * 目标：掌握使用FileInputStream每次读取多个字节。 */public class FileInputStreamTest2 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个字节输入流对象代表字节输入流管道与源文件接通。 InputStream is = new FileInputStream(&quot;file-io-app\\\\src\\\\itheima02.txt&quot;); // 2、开始读取文件中的字节数据：每次读取多个字节。 // public int read(byte b[]) throws IOException // 每次读取多个字节到字节数组中去，返回读取的字节数量，读取完毕会返回-1. // 3、使用循环改造。 byte[] buffer = new byte[3]; int len; // 记住每次读取了多少个字节。 abc 66 while ((len = is.read(buffer)) != -1)&#123; // 注意：读取多少，倒出多少。 String rs = new String(buffer, 0 , len); System.out.print(rs); &#125; // 性能得到了明显的提升！！ // 这种方案也不能避免读取汉字输出乱码的问题！！ is.close(); // 关闭流 &#125;&#125; 需要我们注意的是：read(byte[] bytes)它的返回值，表示当前这一次读取的字节个数。 假设有一个a.txt文件如下： 1abcde 每次读取过程如下 1234也就是说，并不是每次读取的时候都把数组装满，比如数组是 byte[] bytes = new byte[3];第一次调用read(bytes)读取了3个字节(分别是97,98,99)，并且往数组中存，此时返回值就是3第二次调用read(bytes)读取了2个字节(分别是99,100),并且往数组中存，此时返回值是2第三次调用read(bytes)文件中后面已经没有数据了，此时返回值为-1 还需要注意一个问题：采用一次读取多个字节的方式，也是可能有乱码的。因为也有可能读取到半个汉字的情况。 2.4 FileInputStream读取全部字节同学们，前面我们到的读取方式，不管是一次读取一个字节，还是一次读取多个字节，都有可能有乱码。那么接下来我们介绍一种，不出现乱码的读取方式。 我们可以一次性读取文件中的全部字节，然后把全部字节转换为一个字符串，就不会有乱码了。 1234567891011121314// 1、一次性读取完文件的全部字节到一个字节数组中去。// 创建一个字节输入流管道与源文件接通InputStream is = new FileInputStream(&quot;file-io-app\\\\src\\\\itheima03.txt&quot;);// 2、准备一个字节数组，大小与文件的大小正好一样大。File f = new File(&quot;file-io-app\\\\src\\\\itheima03.txt&quot;);long size = f.length();byte[] buffer = new byte[(int) size];int len = is.read(buffer);System.out.println(new String(buffer));//3、关闭流is.close(); 12345678910// 1、一次性读取完文件的全部字节到一个字节数组中去。// 创建一个字节输入流管道与源文件接通InputStream is = new FileInputStream(&quot;file-io-app\\\\src\\\\itheima03.txt&quot;);//2、调用方法读取所有字节，返回一个存储所有字节的字节数组。byte[] buffer = is.readAllBytes();System.out.println(new String(buffer));//3、关闭流is.close(); 最后，还是要注意一个问题：一次读取所有字节虽然可以解决乱码问题，但是文件不能过大，如果文件过大，可能导致内存溢出。 2.5 FileOutputStream写字节各位同学，前面我们学习了使用FIleInputStream读取文件中的字节数据。然后有同学就迫不及待的想学习往文件中写入数据了。 往文件中写数据需要用到OutputStream下面的一个子类FileOutputStream。写输入的流程如下图所示 使用FileOutputStream往文件中写数据的步骤如下： 123第一步：创建FileOutputStream文件字节输出流管道，与目标文件接通。第二步：调用wirte()方法往文件中写数据第三步：调用close()方法释放资源 代码如下： 123456789101112131415161718192021222324252627282930/** * 目标：掌握文件字节输出流FileOutputStream的使用。 */public class FileOutputStreamTest4 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个字节输出流管道与目标文件接通。 // 覆盖管道：覆盖之前的数据// OutputStream os =// new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;); // 追加数据的管道 OutputStream os = new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;, true); // 2、开始写字节数据出去了 os.write(97); // 97就是一个字节，代表a os.write(&#x27;b&#x27;); // &#x27;b&#x27;也是一个字节 // os.write(&#x27;磊&#x27;); // [ooo] 默认只能写出去一个字节 byte[] bytes = &quot;我爱你中国abc&quot;.getBytes(); os.write(bytes); os.write(bytes, 0, 15); // 换行符 os.write(&quot;\\r\\n&quot;.getBytes()); os.close(); // 关闭流 &#125;&#125; 2.6 字节流复制文件同学们，我们在前面已经把字节输入流和字节输出流都学习完了。现在我们就可以用这两种流配合起来使用，做一个文件复制的综合案例。 比如：我们要复制一张图片，从磁盘D:/resource/meinv.png的一个位置，复制到C:/data/meinv.png位置。 复制文件的思路如下图所示： 1231.需要创建一个FileInputStream流与源文件接通，创建FileOutputStream与目标文件接通2.然后创建一个数组，使用FileInputStream每次读取一个字节数组的数据，存如数组中3.然后再使用FileOutputStream把字节数组中的有效元素，写入到目标文件中 代码如下： 12345678910111213141516171819202122232425/** * 目标：使用字节流完成对文件的复制操作。 */public class CopyTest5 &#123; public static void main(String[] args) throws Exception &#123; // 需求：复制照片。 // 1、创建一个字节输入流管道与源文件接通 InputStream is = new FileInputStream(&quot;D:/resource/meinv.png&quot;); // 2、创建一个字节输出流管道与目标文件接通。 OutputStream os = new FileOutputStream(&quot;C:/data/meinv.png&quot;); System.out.println(10 / 0); // 3、创建一个字节数组，负责转移字节数据。 byte[] buffer = new byte[1024]; // 1KB. // 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。 int len; // 记住每次读取了多少个字节。 while ((len = is.read(buffer)) != -1)&#123; os.write(buffer, 0, len); &#125; os.close(); is.close(); System.out.println(&quot;复制完成！！&quot;); &#125;&#125; 三、IO流资源释放各位同学，前面我们已经学习了字节流，也给同学们强调过，流使用完之后一定要释放资源。但是我们之前的代码并不是很专业。 我们现在知道这个问题了，那这个问题怎么解决呢？ 在JDK7以前，和JDK7以后分别给出了不同的处理方案。 3.1 JDK7以前的资源释放在JDK7版本以前，我们可以使用try…catch…finally语句来处理。格式如下 12345678try&#123; //有可能产生异常的代码&#125;catch(异常类 e)&#123; //处理异常的代码&#125;finally&#123; //释放资源的代码 //finally里面的代码有一个特点，不管异常是否发生，finally里面的代码都会执行。&#125; 改造上面的低吗： 1234567891011121314151617181920212223242526272829303132333435363738public class Test2 &#123; public static void main(String[] args) &#123; InputStream is = null; OutputStream os = null; try &#123; System.out.println(10 / 0); // 1、创建一个字节输入流管道与源文件接通 is = new FileInputStream(&quot;file-io-app\\\\src\\\\itheima03.txt&quot;); // 2、创建一个字节输出流管道与目标文件接通。 os = new FileOutputStream(&quot;file-io-app\\\\src\\\\itheima03copy.txt&quot;); System.out.println(10 / 0); // 3、创建一个字节数组，负责转移字节数据。 byte[] buffer = new byte[1024]; // 1KB. // 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。 int len; // 记住每次读取了多少个字节。 while ((len = is.read(buffer)) != -1)&#123; os.write(buffer, 0, len); &#125; System.out.println(&quot;复制完成！！&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放资源的操作 try &#123; if(os != null) os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(is != null) is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 代码写到这里，有很多同学就已经看不下去了。是的，我也看不下去，本来几行代码就写完了的，加上try…catch…finally之后代码多了十几行，而且阅读性并不高。难受…. 3.2 JDK7以后的资源释放刚才很多同学已经发现了try…catch…finally处理异常，并释放资源代码比较繁琐。Java在JDK7版本为我们提供了一种简化的是否资源的操作，它会自动是否资源。代码写起来也想当简单。 格式如下： 1234567try(资源对象1; 资源对象2;)&#123; 使用资源的代码&#125;catch(异常类 e)&#123; 处理异常的代码&#125;//注意：注意到没有，这里没有释放资源的代码。它会自动是否资源 代码如下： 1234567891011121314151617181920212223242526/** * 目标：掌握释放资源的方式：try-with-resource */public class Test3 &#123; public static void main(String[] args) &#123; try ( // 1、创建一个字节输入流管道与源文件接通 InputStream is = new FileInputStream(&quot;D:/resource/meinv.png&quot;); // 2、创建一个字节输出流管道与目标文件接通。 OutputStream os = new FileOutputStream(&quot;C:/data/meinv.png&quot;); )&#123; // 3、创建一个字节数组，负责转移字节数据。 byte[] buffer = new byte[1024]; // 1KB. // 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。 int len; // 记住每次读取了多少个字节。 while ((len = is.read(buffer)) != -1)&#123; os.write(buffer, 0, len); &#125; System.out.println(conn); System.out.println(&quot;复制完成！！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day19-IO流（二）","slug":"day19-IO流（二）","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day19-IO流（二）/","link":"","permalink":"https://wxzhou.top/2020/05/05/day19-IO%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"一、字符流同学们，前面我们学习了字节流，使用字节流可以读取文件中的字节数据。但是如果文件中有中文，使用字节流来读取，就有可能读到半个汉字的情况，这样会导致乱码。虽然使用读取全部字节的方法不会出现乱码，但是如果文件过大又不太合适。 所以Java专门为我们提供了另外一种流，叫字符流，可以字符流是专门为读取文本数据而生的。 1.1 FileReader类先类学习字符流中的FileReader类，这是字符输入流，用来将文件中的字符数据读取到程序中来。 FileReader读取文件的步骤如下： 123第一步：创建FileReader对象与要读取的源文件接通第二步：调用read()方法读取文件中的字符第三步：调用close()方法关闭流 需要用到的方法：先通过构造器创建对象，再通过read方法读取数据（注意：两个read方法的返回值，含义不一样） 12345678910111213141516171819202122232425262728/** * 目标：掌握文件字符输入流。 */public class FileReaderTest1 &#123; public static void main(String[] args) &#123; try ( // 1、创建一个文件字符输入流管道与源文件接通 Reader fr = new FileReader(&quot;io-app2\\\\src\\\\itheima01.txt&quot;); )&#123; // 2、一个字符一个字符的读（性能较差）// int c; // 记住每次读取的字符编号。// while ((c = fr.read()) != -1)&#123;// System.out.print((char) c);// &#125; // 每次读取一个字符的形式，性能肯定是比较差的。 // 3、每次读取多个字符。（性能是比较不错的！） char[] buffer = new char[3]; int len; // 记住每次读取了多少个字符。 while ((len = fr.read(buffer)) != -1)&#123; // 读取多少倒出多少 System.out.print(new String(buffer, 0, len)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.2 FileWriter类在上节课，我们学习了FileReader，它可以将文件中的字符数据读取到程序中来。接下来，我们就要学习FileWriter了，它可以将程序中的字符数据写入文件。 FileWriter往文件中写字符数据的步骤如下： 123第一步：创建FileWirter对象与要读取的目标文件接通第二步：调用write(字符数据/字符数组/字符串)方法读取文件中的字符第三步：调用close()方法关闭流 需要用到的方法如下：构造器是用来创建FileWriter对象的，有了对象才能调用write方法写数据到文件。 接下来，用代码演示一下： 123456789101112131415161718192021222324252627282930313233343536373839/** * 目标：掌握文件字符输出流：写字符数据出去 */public class FileWriterTest2 &#123; public static void main(String[] args) &#123; try ( // 0、创建一个文件字符输出流管道与目标文件接通。 // 覆盖管道 // Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;); // 追加数据的管道 Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;, true); )&#123; // 1、public void write(int c):写一个字符出去 fw.write(&#x27;a&#x27;); fw.write(97); //fw.write(&#x27;磊&#x27;); // 写一个字符出去 fw.write(&quot;\\r\\n&quot;); // 换行 // 2、public void write(String c)写一个字符串出去 fw.write(&quot;我爱你中国abc&quot;); fw.write(&quot;\\r\\n&quot;); // 3、public void write(String c ,int pos ,int len):写字符串的一部分出去 fw.write(&quot;我爱你中国abc&quot;, 0, 5); fw.write(&quot;\\r\\n&quot;); // 4、public void write(char[] buffer):写一个字符数组出去 char[] buffer = &#123;&#x27;黑&#x27;, &#x27;马&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; fw.write(buffer); fw.write(&quot;\\r\\n&quot;); // 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去 fw.write(buffer, 0, 2); fw.write(&quot;\\r\\n&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.3 FileWriter写的注意事项各位同学，刚才我们已经学习了FileWriter字符输出流的基本使用。但是，这里有一个小问题需要和同学们说下一：FileWriter写完数据之后，必须刷新或者关闭，写出去的数据才能生效。 比如：下面的代码只调用了写数据的方法，没有关流的方法。当你打开目标文件时，是看不到任何数据的。 1234567//1.创建FileWriter对象Writer fw = new FileWriter(&quot;io-app2/src/itheima03out.txt&quot;);//2.写字符数据出去fw.write(&#x27;a&#x27;);fw.write(&#x27;b&#x27;);fw.write(&#x27;c&#x27;); 而下面的代码，加上了flush()方法之后，数据就会立即到目标文件中去。 12345678910//1.创建FileWriter对象Writer fw = new FileWriter(&quot;io-app2/src/itheima03out.txt&quot;);//2.写字符数据出去fw.write(&#x27;a&#x27;);fw.write(&#x27;b&#x27;);fw.write(&#x27;c&#x27;);//3.刷新fw.flush(); 下面的代码，调用了close()方法，数据也会立即到文件中去。因为close()方法在关闭流之前，会将内存中缓存的数据先刷新到文件，再关流。 12345678910//1.创建FileWriter对象Writer fw = new FileWriter(&quot;io-app2/src/itheima03out.txt&quot;);//2.写字符数据出去fw.write(&#x27;a&#x27;);fw.write(&#x27;b&#x27;);fw.write(&#x27;c&#x27;);//3.关闭流fw.close(); //会先刷新，再关流 但是需要注意的是，关闭流之后，就不能在对流进行操作了。否则会出异常 二、缓冲流学习完字符流之后，接下来我们学习一下缓冲流。我们还是先来认识一下缓存流，再来说一下它的作用。缓冲流有四种，如下图所示 缓冲流的作用：可以对原始流进行包装，提高原始流读写数据的性能。 2.1 缓冲字节流我们先来学习字节缓冲流是如何提高读写数据的性能的，原理如下图所示。是因为在缓冲流的底层自己封装了一个长度为8KB（8129byte）的字节数组，但是缓冲流不能单独使用，它需要依赖于原始流。 读数据时：它先用原始字节输入流一次性读取8KB的数据存入缓冲流内部的数组中（ps: 先一次多囤点货），再从8KB的字节数组中读取一个字节或者多个字节（把消耗屯的货）。 写数据时： 它是先把数据写到缓冲流内部的8BK的数组中（ps: 先攒一车货），等数组存满了，再通过原始的字节输出流，一次性写到目标文件中去（把囤好的货，一次性运走）。 在创建缓冲字节流对象时，需要封装一个原始流对象进来。构造方法如下 如果我们用缓冲流复制文件，代码写法如下: 123456789101112131415161718192021222324public class BufferedInputStreamTest1 &#123; public static void main(String[] args) &#123; try ( InputStream is = new FileInputStream(&quot;io-app2/src/itheima01.txt&quot;); // 1、定义一个字节缓冲输入流包装原始的字节输入流 InputStream bis = new BufferedInputStream(is); OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima01_bak.txt&quot;); // 2、定义一个字节缓冲输出流包装原始的字节输出流 OutputStream bos = new BufferedOutputStream(os); )&#123; byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1)&#123; bos.write(buffer, 0, len); &#125; System.out.println(&quot;复制完成！！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.2 字符缓冲流接下来，我们学习另外两个缓冲流——字符缓冲流。它的原理和字节缓冲流是类似的，它底层也会有一个8KB的数组，但是这里是字符数组。字符缓冲流也不能单独使用，它需要依赖于原始字符流一起使用。 BufferedReader读数据时：它先原始字符输入流一次性读取8KB的数据存入缓冲流内部的数组中（ps: 先一次多囤点货），再从8KB的字符数组中读取一个字符或者多个字符（把消耗屯的货）。 创建BufferedReader对象需要用到BufferedReader的构造方法，内部需要封装一个原始的字符输入流，我们可以传入FileReader. 而且BufferedReader还要特有的方法，一次可以读取文本文件中的一行 使用BufferedReader读取数据的代码如下 1234567891011121314151617181920212223242526public class BufferedReaderTest2 &#123; public static void main(String[] args) &#123; try ( Reader fr = new FileReader(&quot;io-app2\\\\src\\\\itheima04.txt&quot;); // 创建一个字符缓冲输入流包装原始的字符输入流 BufferedReader br = new BufferedReader(fr); )&#123;// char[] buffer = new char[3];// int len;// while ((len = br.read(buffer)) != -1)&#123;// System.out.print(new String(buffer, 0, len));// &#125;// System.out.println(br.readLine());// System.out.println(br.readLine());// System.out.println(br.readLine());// System.out.println(br.readLine()); String line; // 记住每次读取的一行数据 while ((line = br.readLine()) != null)&#123; System.out.println(line); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; BufferedWriter写数据时： 它是先把数据写到字符缓冲流内部的8BK的数组中（ps: 先攒一车货），等数组存满了，再通过原始的字符输出流，一次性写到目标文件中去（把囤好的货，一次性运走）。如下图所示 创建BufferedWriter对象时需要用到BufferedWriter的构造方法，而且内部需要封装一个原始的字符输出流，我们这里可以传递FileWriter。 而且BufferedWriter新增了一个功能，可以用来写一个换行符 接下来，用代码演示一下，使用BufferedWriter往文件中写入字符数据。 123456789101112131415161718192021public class BufferedWriterTest3 &#123; public static void main(String[] args) &#123; try ( Writer fw = new FileWriter(&quot;io-app2/src/itheima05out.txt&quot;, true); // 创建一个字符缓冲输出流管道包装原始的字符输出流 BufferedWriter bw = new BufferedWriter(fw); )&#123; bw.write(&#x27;a&#x27;); bw.write(97); bw.write(&#x27;磊&#x27;); bw.newLine(); bw.write(&quot;我爱你中国abc&quot;); bw.newLine(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.3 缓冲流性能分析我们说缓冲流内部多了一个数组，可以提高原始流的读写性能。讲到这一定有同学有这么一个疑问，它和我们使用原始流，自己加一个8BK数组不是一样的吗？ 缓冲流就一定能提高性能吗？先告诉同学们答案，缓冲流不一定能提高性能。 下面我们用一个比较大文件（889MB）复制，做性能测试，分别使用下面四种方式来完成文件复制，并记录文件复制的时间。 ① 使用低级流一个字节一个字节的复制 ② 使用低级流按照字节数组的形式复制 ③ 使用缓冲流一个字节一个字节的复制 ④ 使用缓冲流按照字节数组的形式复制 12345低级流一个字节复制: 慢得简直让人无法忍受低级流按照字节数组复制(数组长度1024): 12.117s缓冲流一个字节复制: 11.058s缓冲流按照字节数组复制(数组长度1024): 2.163s【注意：这里的测试只能做一个参考，和电脑性能也有直接关系】 经过上面的测试，我们可以得出一个结论：默认情况下，采用一次复制1024个字节，缓冲流完胜。 但是，缓冲流就一定性能高吗？我们采用一次复制8192个字节试试 12低级流按照字节数组复制(数组长度8192): 2.535s缓冲流按照字节数组复制(数组长度8192): 2.088s 经过上面的测试，我们可以得出一个结论：一次读取8192个字节时，低级流和缓冲流性能相当。相差的那几毫秒可以忽略不计。 继续把数组变大，看一看缓冲流就一定性能高吗？现在采用一次读取1024*32个字节数据试试 12低级流按照字节数组复制(数组长度8192): 1.128s缓冲流按照字节数组复制(数组长度8192): 1.133s 经过上面的测试，我们可以得出一个结论：数组越大性能越高，低级流和缓冲流性能相当。相差的那几秒可以忽略不计。 继续把数组变大，看一看缓冲流就一定性能高吗？现在采用一次读取1024*6个字节数据试试 12低级流按照字节数组复制(数组长度8192): 1.039s缓冲流按照字节数组复制(数组长度8192): 1.151s 此时你会发现，当数组大到一定程度，性能已经提高了多少了，甚至缓冲流的性能还没有低级流高。 最终总结一下：缓冲流的性能不一定比低级流高，其实低级流自己加一个数组，性能其实是不差。只不过缓冲流帮你加了一个相对而言大小比较合理的数组 。 三、转换流前面我们学习过FileReader读取文件中的字符，但是同学们注意了，FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码，因为FileReader它遇到汉字默认是按照3个字节来读取的，而GBK格式的文件一个汉字是占2个字节，这样就会导致乱码。 Java给我们提供了另外两种流InputStreamReader，OutputStreamWriter，这两个流我们把它叫做转换流。它们可以将字节流转换为字符流，并且可以指定编码方案。 3.1 InputStreamReader类接下来，我们先学习InputStreamReader类，你看这个类名就比较有意思，前面是InputStream表示字节输入流，后面是Reader表示字符输入流，合在一起意思就是表示可以把InputStream转换为Reader，最终InputStreamReader其实也是Reader的子类，所以也算是字符输入流。 InputStreamReader也是不能单独使用的，它内部需要封装一个InputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。 需求：我们可以先准备一个GBK格式的文件，然后使用下面的代码进行读取，看是是否有乱码。 123456789101112131415161718192021public class InputStreamReaderTest2 &#123; public static void main(String[] args) &#123; try ( // 1、得到文件的原始字节流（GBK的字节流形式） InputStream is = new FileInputStream(&quot;io-app2/src/itheima06.txt&quot;); // 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流 Reader isr = new InputStreamReader(is, &quot;GBK&quot;); // 3、把字符输入流包装成缓冲字符输入流 BufferedReader br = new BufferedReader(isr); )&#123; String line; while ((line = br.readLine()) != null)&#123; System.out.println(line); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行完之后，你会发现没有乱码。 3.2 OutputStreamWriter类接下来，我们先学习OutputStreamWriter类，你看这个类名也比较有意思，前面是OutputStream表示字节输出流，后面是Writer表示字符输出流，合在一起意思就是表示可以把OutputStream转换为Writer，最终OutputStreamWriter其实也是Writer的子类，所以也算是字符输出流。 OutputStreamReader也是不能单独使用的，它内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。 需求：我们可以先准备一个GBK格式的文件，使用下面代码往文件中写字符数据。 12345678910111213141516171819public class OutputStreamWriterTest3 &#123; public static void main(String[] args) &#123; // 指定写出去的字符编码。 try ( // 1、创建一个文件字节输出流 OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima07out.txt&quot;); // 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。 Writer osw = new OutputStreamWriter(os, &quot;GBK&quot;); // 3、把字符输出流包装成缓冲字符输出流 BufferedWriter bw = new BufferedWriter(osw); )&#123; bw.write(&quot;我是中国人abc&quot;); bw.write(&quot;我爱你中国123&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 四、打印流接下来，我们学习打印流，其实打印流我们从开学第一天就一直再使用，只是没有学到你感受不到而已。打印流可以实现更加方便，更加高效的写数据的方式。 4.1 打印流基本使用打印流，这里所说的打印其实就是写数据的意思，它和普通的write方法写数据还不太一样，一般会使用打印流特有的方法叫print(数据)或者println(数据)，它打印啥就输出啥。 打印流有两个，一个是字节打印流PrintStream，一个是字符打印流PrintWriter，如下图所示 PrintStream和PrintWriter的用法是一样的，所以这里就一块演示了。 123456789101112131415161718192021222324public class PrintTest1 &#123; public static void main(String[] args) &#123; try ( // 1、创建一个打印流管道// PrintStream ps =// new PrintStream(&quot;io-app2/src/itheima08.txt&quot;, Charset.forName(&quot;GBK&quot;));// PrintStream ps =// new PrintStream(&quot;io-app2/src/itheima08.txt&quot;); PrintWriter ps = new PrintWriter(new FileOutputStream(&quot;io-app2/src/itheima08.txt&quot;, true)); )&#123; ps.print(97); //文件中显示的就是:97 ps.print(&#x27;a&#x27;); //文件中显示的就是:a ps.println(&quot;我爱你中国abc&quot;); //文件中显示的就是:我爱你中国abc ps.println(true);//文件中显示的就是:true ps.println(99.5);//文件中显示的就是99.5 ps.write(97); //文件中显示a，发现和前面println方法的区别了吗？ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.2 重定向输出语句其实我们开学第一课，就给同学们讲过System.out.println()这句话表示打印输出，但是至于为什么能够输出，其实我们一直不清楚。 以前是因为知识储备还不够，无法解释，到现在就可以给同学们揭晓谜底了，因为System里面有一个静态变量叫out，out的数据类型就是PrintStream，它就是一个打印流，而且这个打印流的默认输出目的地是控制台，所以我们调用System.out.pirnln()就可以往控制台打印输出任意类型的数据，而且打印啥就输出啥。 而且System还提供了一个方法，可以修改底层的打印流，这样我们就可以重定向打印语句的输出目的地了。我们玩一下, 直接上代码。 12345678910111213141516public class PrintTest2 &#123; public static void main(String[] args) &#123; System.out.println(&quot;老骥伏枥&quot;); System.out.println(&quot;志在千里&quot;); try ( PrintStream ps = new PrintStream(&quot;io-app2/src/itheima09.txt&quot;); )&#123; // 把系统默认的打印流对象改成自己设置的打印流 System.setOut(ps); System.out.println(&quot;烈士暮年&quot;); System.out.println(&quot;壮心不已&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 此时打印语句，将往文件中打印数据，而不在控制台。 五、数据流同学们，接下我们再学习一种流，这种流在开发中偶尔也会用到。比如，我们想把数据和数据的类型一并写到文件中去，读取的时候也将数据和数据类型一并读出来。这就可以用到数据流，有两个DataInputStream和DataOutputStream. 5.1 DataOutputStream类我们先学习DataOutputStream类，它也是一种包装流，创建DataOutputStream对象时，底层需要依赖于一个原始的OutputStream流对象。然后调用它的wirteXxx方法，写的是特定类型的数据。 代码如下：往文件中写整数、小数、布尔类型数据、字符串数据 1234567891011121314151617public class DataOutputStreamTest1 &#123; public static void main(String[] args) &#123; try ( // 1、创建一个数据输出流包装低级的字节输出流 DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;io-app2/src/itheima10out.txt&quot;)); )&#123; dos.writeInt(97); dos.writeDouble(99.5); dos.writeBoolean(true); dos.writeUTF(&quot;黑马程序员666！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.2 DataInputStream类学习完DataOutputStream后，再学习DataIntputStream类，它也是一种包装流，创建DataInputStream对象时，底层需要依赖于一个原始的InputStream流对象。然后调用它的readXxx()方法就可以读取特定类型的数据。 代码如下：读取文件中特定类型的数据（整数、小数、字符串等） 12345678910111213141516171819202122public class DataInputStreamTest2 &#123; public static void main(String[] args) &#123; try ( DataInputStream dis = new DataInputStream(new FileInputStream(&quot;io-app2/src/itheima10out.txt&quot;)); )&#123; int i = dis.readInt(); System.out.println(i); double d = dis.readDouble(); System.out.println(d); boolean b = dis.readBoolean(); System.out.println(b); String rs = dis.readUTF(); System.out.println(rs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 六、序列化流各位同学同学，还有最后一个流要学习，叫做序列化流。序列化流是干什么用的呢？ 我们知道字节流是以字节为单位来读写数据、字符流是按照字符为单位来读写数据、而对象流是以对象为单位来读写数据。也就是把对象当做一个整体，可以写一个对象到文件，也可以从文件中把对象读取出来。 这里有一个新词 序列化，第一次听同学们可能还比较陌生，我来给同学们解释一下 12序列化：意思就是把对象写到文件或者网络中去。（简单记：写对象）反序列化：意思就是把对象从文件或者网络中读取出来。（简单记：读对象） 6.1 ObjectOutputStraem类接下来，先学习ObjectOutputStream流，它也是一个包装流，不能单独使用，需要结合原始的字节输出流使用。 代码如下：将一个User对象写到文件中去 第一步：先准备一个User类，必须让其实现Serializable接口。 12345678910111213141516171819202122232425262728// 注意：对象如果需要序列化，必须实现序列化接口。public class User implements Serializable &#123; private String loginName; private String userName; private int age; // transient 这个成员变量将不参与序列化。 private transient String passWord; public User() &#123; &#125; public User(String loginName, String userName, int age, String passWord) &#123; this.loginName = loginName; this.userName = userName; this.age = age; this.passWord = passWord; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;loginName=&#x27;&quot; + loginName + &#x27;\\&#x27;&#x27; + &quot;, userName=&#x27;&quot; + userName + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, passWord=&#x27;&quot; + passWord + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 第二步：再创建ObjectOutputStream流对象，调用writeObject方法对象到文件。 12345678910111213141516171819public class Test1ObjectOutputStream &#123; public static void main(String[] args) &#123; try ( // 2、创建一个对象字节输出流包装原始的字节 输出流。 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;io-app2/src/itheima11out.txt&quot;)); )&#123; // 1、创建一个Java对象。 User u = new User(&quot;admin&quot;, &quot;张三&quot;, 32, &quot;666888xyz&quot;); // 3、序列化对象到文件中去 oos.writeObject(u); System.out.println(&quot;序列化对象成功！！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：写到文件中的对象，是不能用记事本打开看的。因为对象本身就不是文本数据，打开是乱码 怎样才能读懂文件中的对象是什么呢？这里必须用反序列化，自己写代码读。 6.2 ObjectInputStream类接下来，学习ObjectInputStream流，它也是一个包装流，不能单独使用，需要结合原始的字节输入流使用。 接着前面的案例，文件中已经有一个Student对象，现在要使用ObjectInputStream读取出来。称之为反序列化。 12345678910111213public class Test2ObjectInputStream &#123; public static void main(String[] args) &#123; try ( // 1、创建一个对象字节输入流管道，包装 低级的字节输入流与源文件接通 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;io-app2/src/itheima11out.txt&quot;)); )&#123; User u = (User) ois.readObject(); System.out.println(u); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 七、补充知识：IO框架最后，再给同学们补充讲解一个知识，叫做IO框架。它有什么用呢？有同学经常问老师，我们只学习了IO流对文件复制，能不能复制文件夹呀？ 当然是可以咯，但是如果让我们自己写复制文件夹的代码需要用到递归，还是比较麻烦的。为了简化对IO操作，由apache开源基金组织提供了一组有关IO流小框架，可以提高IO流的开发效率。 这个框架的名字叫commons-io：其本质是别人写好的一些字节码文件（class文件），打包成了一个jar包。我们只需要把jar包引入到我们的项目中，就可以直接用了。 这里给同学们介绍一个jar包中提供的工具类叫FileUtils，它的部分功能如下，很方便，你一看名字就知道怎么用了。 在写代码之前，先需要引入jar包，具体步骤如下 1231.在模块的目录下，新建一个lib文件夹2.把jar包复制粘贴到lib文件夹下3.选择lib下的jar包，右键点击Add As Library，然后就可以用了。 代码如下： 12345678910111213141516public class CommonsIOTest1 &#123; public static void main(String[] args) throws Exception &#123; //1.复制文件 FileUtils.copyFile(new File(&quot;io-app2\\\\src\\\\itheima01.txt&quot;), new File(&quot;io-app2/src/a.txt&quot;)); //2.复制文件夹 FileUtils.copyDirectory(new File(&quot;D:\\\\resource\\\\私人珍藏&quot;), new File(&quot;D:\\\\resource\\\\私人珍藏3&quot;)); //3.删除文件夹 FileUtils.deleteDirectory(new File(&quot;D:\\\\resource\\\\私人珍藏3&quot;)); // Java提供的原生的一行代码搞定很多事情 Files.copy(Path.of(&quot;io-app2\\\\src\\\\itheima01.txt&quot;), Path.of(&quot;io-app2\\\\src\\\\b.txt&quot;)); System.out.println(Files.readString(Path.of(&quot;io-app2\\\\src\\\\itheima01.txt&quot;))); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day20-特殊文件、日志技术、多线程","slug":"day20-特殊文件、日志技术、多线程","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day20-特殊文件、日志技术、多线程/","link":"","permalink":"https://wxzhou.top/2020/05/05/day20-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"一、属性文件1.1 特殊文件概述同学们，前面我们学习了IO流，我们知道IO流是用来读、写文件中的数据。但是我们接触到的文件都是普通的文本文件，普通的文本文件里面的数据是没有任何格式规范的，用户可以随意编写，如下图所示。 像这种普通的文本文件，没有任何规律可言，不方便程序对文件中的数据信息处理。 在以后的Java开发过程中还会遇到一些特殊的文本文件，这些文件是有一些格式要求的，方便程序对文件中的数据进行处理。 比如，后面我们会用到两种特殊的文本文件，一种是properties文件，还有一种是xml文件。如下图所示。 后缀为.properties的文件，称之为属性文件，它可以很方便的存储一些类似于键值对的数据。经常当做软件的配置文件使用。 而xml文件能够表示更加复杂的数据关系，比如要表示多个用户的用户名、密码、家乡、性别等。在后面，也经常当做软件的配置文件使用。 现在，学习特殊的文件主要学习什么呢？ 主要学习以下的三点 1.2 Properties属性文件接下来，我们先学习Properties这种属性文件。首先我们要掌握属性文件的格式： 属性文件后缀以.properties结尾 属性文件里面的每一行都是一个键值对，键和值中间用&#x3D;隔开。比如: admin=123456 #表示这样是注释信息，是用来解释这一行配置是什么意思。 每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。 键不能重复，值可以重复 如下图所示 接下来，我们学习如何读取属性文件中的数据。这里需要给同学们，介绍一个来叫Properties. 123451.Properties是什么？ Properties是Map接口下面的一个实现类，所以Properties也是一种双列集合，用来存储键值对。 但是一般不会把它当做集合来使用。 2.Properties核心作用？ Properties类的对象，用来表示属性文件，可以用来读取属性文件中的键值对。 使用Properties读取属性文件中的键值对，需要用到的方法如下。 实用Properties读取属性文件的步骤如下 1231、创建一个Properties的对象出来（键值对集合，空容器）2、调用load(字符输入流/字节输入流)方法，开始加载属性文件中的键值对数据到properties对象中去3、调用getProperty(键)方法，根据键取值 代码如下： 12345678910111213141516171819202122232425262728293031/** * 目标：掌握使用Properties类读取属性文件中的键值对信息。 */public class PropertiesTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个Properties的对象出来（键值对集合，空容器） Properties properties = new Properties(); System.out.println(properties); // 2、开始加载属性文件中的键值对数据到properties对象中去 properties.load(new FileReader(&quot;properties-xml-log-app\\\\src\\\\users.properties&quot;)); System.out.println(properties); // 3、根据键取值 System.out.println(properties.getProperty(&quot;赵敏&quot;)); System.out.println(properties.getProperty(&quot;张无忌&quot;)); // 4、遍历全部的键和值。 //获取键的集合 Set&lt;String&gt; keys = properties.stringPropertyNames(); for (String key : keys) &#123; //再根据键获取值 String value = properties.getProperty(key); System.out.println(key + &quot;----&gt;&quot; + value); &#125; properties.forEach((k, v) -&gt; &#123; System.out.println(k + &quot;----&gt;&quot; + v); &#125;); &#125;&#125; 使用Properties往属性文件中写键值对，需要用到的方法如下 往Properties属性文件中写键值对的步骤如下 123451、先准备一个.properties属性文件，按照格式写几个键值对1、创建Properties对象出来，2、调用setProperty存储一些键值对数据3、调用store(字符输出流/字节输出流, 注释)，将Properties集合中的键和值写到文件中 注意：第二个参数是注释，必须得加； 先准备一个users.properties属性文件，如下图所示 接下来，编写代码读取上面的属性文件。代码如下： 1234567891011121314public class PropertiesTest2 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建Properties对象出来，先用它存储一些键值对数据 Properties properties = new Properties(); properties.setProperty(&quot;张无忌&quot;, &quot;minmin&quot;); properties.setProperty(&quot;殷素素&quot;, &quot;cuishan&quot;); properties.setProperty(&quot;张翠山&quot;, &quot;susu&quot;); // 2、把properties对象中的键值对数据存入到属性文件中去 properties.store(new FileWriter(&quot;properties-xml-log-app/src/users2.properties&quot;) , &quot;i saved many users!&quot;); &#125;&#125; 运行上面的代码，user2.properties 配置文件打开效果如下图所示。 二、XML文件同学们，在上一节我们学习了properties属性文件。接下来我们再学习一种在开发中经常使用的文件，叫做xml文件。我们先来给同学们介绍一下，什么是xml文件，然后再来学习如何读取xml文件中的数据。 2.1 XML文件概述首先，我们来认识一下，什么是XML？ XML是可扩展的标记语言，意思是它是由一些标签组成 的，而这些标签是自己定义的。本质上一种数据格式，可以用来表示复杂的数据关系。 XML文件有如下的特点： XML中的&lt;标签名&gt; 称为一个标签或者一个元素，一般是成对出现的。 XML中的标签名可以自己定义（可扩展），但是必须要正确的嵌套 XML中只能有一个根标签。 XML标准中可以有属性 XML必须第一行有一个文档声明，格式是固定的&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; XML文件必须是以.xml为后缀结尾 如下图所示 接下，同学们可以跟着步骤新建一个XML文件，试试！ 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!-- 注释：以上抬头声明必须放在第一行，必须有 --&gt;&lt;!-- 根标签只能有一个 --&gt;&lt;users&gt; &lt;user id=&quot;1&quot; desc=&quot;第一个用户&quot;&gt; &lt;name&gt;张无忌&lt;/name&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;地址&gt;光明顶&lt;/地址&gt; &lt;password&gt;minmin&lt;/password&gt; &lt;/user&gt; &lt;people&gt;很多人&lt;/people&gt; &lt;user id=&quot;2&quot;&gt; &lt;name&gt;敏敏&lt;/name&gt; &lt;sex&gt;女&lt;/sex&gt; &lt;地址&gt;光明顶&lt;/地址&gt; &lt;password&gt;wuji&lt;/password&gt; &lt;/user&gt;&lt;/users&gt; 上面XML文件中的数据格式是最为常见的，标签有属性、文本、还有合理的嵌套。XML文件中除了写以上的数据格式之外，还有一些特殊的字符不能直接写。 像 &lt;,&gt;,&amp; 等这些符号不能出现在标签的文本中，因为标签格式本身就有&lt;&gt;，会和标签格式冲突。 如果标签文本中有这些特殊字符，需要用一些占位符代替。 12345&amp;lt; 表示 &lt;&amp;gt; 表示 &gt;&amp;amp; 表示 &amp;&amp;apos; 表示 &#x27;&amp;quot; 表示 &quot; 1&lt;data&gt; 3 &amp;lt; 2 &amp;amp;&amp;amp; 5 &amp;gt; 4 &lt;/data&gt; 如果在标签文本中，出现大量的特殊字符，不想使用特殊字符，此时可以用CDATA区，格式如下 12345&lt;data1&gt; &lt;![CDATA[ 3 &lt; 2 &amp;&amp; 5 &gt; 4 ]]&gt;&lt;/data1&gt; 最后，给同学们聊聊，XML在实际开发中有什么作用？ 关于XML是什么，以及XML的格式，还有XML有什么作用，就先认识到这里。 2.2 XML解析1使用程序读取XML文件中的数据，称之为XML解析。这里并不需要我们自己写IO流代码去读取xml文件中的数据。其实有很多开源的，好用的XML解析框架，最知名的是DOM4J（第三方开发的） 由于DOM4J是第三方提供的，所以需要把第三方提供的Jar包导入到自己的项目中来，才可以使用。具体步骤如下： DOM4J解析XML文件的思想是：文档对象模型（意思是把整个XML文档、每一个标签、每一个属性都等都当做对象来看待）。Dowument对象表示真个XML文档、Element对象表示标签（元素）、Attribute对象表示属性、标签中的内容就是文本 DOM4J解析XML需要用到的方法如下图所示 XML解析的过程，是从根元素开始，从外层往里层解析。 我们先把Document对象，和根元素获取出来 1234567891011121314public class Dom4JTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个Dom4J框架提供的解析器对象 SAXReader saxReader = new SAXReader(); // 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。 Document document = saxReader.read(&quot;properties-xml-log-app\\\\src\\\\helloworld.xml&quot;); // 3、从文档对象中解析XML文件的全部数据了 Element root = document.getRootElement(); System.out.println(root.getName()); &#125;&#125; 2.3 XML解析2获取到XML文件的根元素之后，接下来，就可以用根元素在获取到它里面的子元素（包括子标签、表属性等）。需要用到的方法如下图所示 接下来，把上面的方法先一个一个的演示一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Dom4JTest1 &#123; public static void main(String[] args) throws Exception &#123; // 1、创建一个Dom4J框架提供的解析器对象 SAXReader saxReader = new SAXReader(); // 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。 Document document = saxReader.read(&quot;properties-xml-log-app\\\\src\\\\helloworld.xml&quot;); // 3、从文档对象中解析XML文件的全部数据了 Element root = document.getRootElement(); System.out.println(root.getName()); // 4、获取根元素下的全部一级子元素。 // List&lt;Element&gt; elements = root.elements(); List&lt;Element&gt; elements = root.elements(&quot;user&quot;); for (Element element : elements) &#123; System.out.println(element.getName()); &#125; // 5、获取当前元素下的某个子元素。 Element people = root.element(&quot;people&quot;); System.out.println(people.getText()); // 如果下面有很多子元素user，默认获取第一个。 Element user = root.element(&quot;user&quot;); System.out.println(user.elementText(&quot;name&quot;)); // 6、获取元素的属性信息呢？ System.out.println(user.attributeValue(&quot;id&quot;)); Attribute id = user.attribute(&quot;id&quot;); System.out.println(id.getName()); System.out.println(id.getValue()); List&lt;Attribute&gt; attributes = user.attributes(); for (Attribute attribute : attributes) &#123; System.out.println(attribute.getName() + &quot;=&quot; + attribute.getValue()); &#125; // 7、如何获取全部的文本内容:获取当前元素下的子元素文本值 System.out.println(user.elementText(&quot;name&quot;)); System.out.println(user.elementText(&quot;地址&quot;)); System.out.println(user.elementTextTrim(&quot;地址&quot;)); // 取出文本去除前后空格 System.out.println(user.elementText(&quot;password&quot;)); Element data = user.element(&quot;data&quot;); System.out.println(data.getText()); System.out.println(data.getTextTrim()); // 取出文本去除前后空格 &#125;&#125; 2.4 XML文件写入在前面我们已经学习了XML解析，意思就是使用程序把XML文件中的数据读取出来。反过来能不能往XML文件中写入数据呢？ 答案是可以的。 DOM4J也提供了往XML文件中写标签的方法，但是用起来比较麻烦。这里不建议使用 我们自己使用StringBuilder按照标签的格式拼接，然后再使用BufferedWriter写到XML文件中去就可以了。 123456789101112131415161718192021public class Dom4JTest2 &#123; public static void main(String[] args) &#123; // 1、使用一个StringBuilder对象来拼接XML格式的数据。 StringBuilder sb = new StringBuilder(); sb.append(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot; ?&gt;\\r\\n&quot;); sb.append(&quot;&lt;book&gt;\\r\\n&quot;); sb.append(&quot;\\t&lt;name&gt;&quot;).append(&quot;从入门到跑路&quot;).append(&quot;&lt;/name&gt;\\r\\n&quot;); sb.append(&quot;\\t&lt;author&gt;&quot;).append(&quot;dlei&quot;).append(&quot;&lt;/author&gt;\\r\\n&quot;); sb.append(&quot;\\t&lt;price&gt;&quot;).append(999.99).append(&quot;&lt;/price&gt;\\r\\n&quot;); sb.append(&quot;&lt;/book&gt;&quot;); try ( BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;properties-xml-log-app/src/book.xml&quot;)); )&#123; bw.write(sb.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.5 XML约束（了解）各位小伙伴，关于XML还有最后一个知识需要大家了解一下。这个知识叫做约束XML文件的编写，我讲这个知识的目的是因为同学们以后在开发过程中会遇到这个知识，但是这个代码不需要大家写，了解一下就可以了。 首先，说一些什么是XML约束？ XML约束指的是限制XML文件中的标签或者属性，只能按照规定的格式写。 比如我在项目中，想约束一个XML文件中的标签只能写&lt;书&gt;、&lt;书名&gt;、&lt;作者&gt;、&lt;售价&gt;这几个标签，如果写其他标签就报错。 怎么才能达到上面的效果呢？有两种约束技术，一种是DTD约束、一种是Schame约束。 DTD约束案例 如下图所示book.xml中引入了DTD约束文件，book.xml文件中的标签就受到DTD文件的约束 DTD文件解释 12345&lt;!ELEMENT 书架(书+)&gt; 表示根标签是&lt;书架&gt;，并且书架中有子标签&lt;书&gt;&lt;!ELEMENT 书(书名、作者、售价)&gt; 表示书是一个标签，且书中有子标签&lt;书名&gt;、&lt;作者&gt;、&lt;售价&gt;&lt;!ELEMENT 书名(#PCDATA)&gt; 表示&lt;书名&gt;是一个标签，且&lt;书名&gt;里面是普通文本&lt;!ELEMENT 作者(#PCDATA)&gt; 表示&lt;作者&gt;是一个标签，且&lt;作者&gt;里面是普通文本&lt;!ELEMENT 售价(#PCDATA)&gt; 表示&lt;售价&gt;是一个标签，且&lt;售价&gt;里面是普通文本 Schame约束案例 如下图所示，左边的book2.xml文件就受到右边schame文件（.xsd结尾的文件）的约束。 三、日志技术3.1 日志概述好的同学们，接下来我们学习一个将来我们会用到的一个技术，叫做日志技术。首先同学们肯定想知道什么是日志？ 想搞清楚什么是日志，其实可以通过下面几个问题来了解的。 系统系统能记住某些数据被谁操作，比如被谁删除了？ 想分析用户浏览系统的具体情况，比如挖掘用户的具体喜好？ 当系统在开发中或者上线后出现了Bug，崩溃了，该通过什么去分析，定位Bug? 而日志就可以帮我们解决以上的问题。所以日志就好比生活中的日记，日记可以记录生活中的点点滴滴；而程序中的日志，通常就是一个文件，里面记录了程序运行过程中产生的各种数据。 日志技术有如下好处 日志可以将系统执行的信息，方便的记录到指定位置，可以是控制台、可以是文件、可以是数据库中。 日志可以随时以开关的形式控制启停，无需侵入到源代码中去修改。 3.2 日志的体系在上一节给同学们介绍了，什么是日志，日志能干什么。接下来需要给同学们介绍一下有哪些日志技术，以及日志的体系。 大家注意了在行内，其实有很多日志框架给开发者使用。所谓日志框架就是由一些牛人或者第三方公司已经做好的实现代码，后来者就可以直接拿过去使用。 日志框架有很多种，比如有JUL（java.util.logging）、Log4j、logback等。但是这些日志框架如果使用的API方法都不一样的话，使用者的学习成本就很高。为了降低程序员的学习压力，行内提供了一套日志接口，然后所有的日志框架都按照日志接口的API来实现就可以了。 这样程序员只要会一套日志框架，那么其他的也就可以通过用，甚至可以在多套日志框架之间来回切换。比较常用的日志框架，和日志接口的关系如下图所示 这里推荐同学们使用Logback日志框架，也在行业中最为广泛使用的。 Logback日志分为哪几个模块 3.3 Logback快速入门接下来，就带领同学们快速使用一下Logback日志框架，使用Logback记录几条日志信息到文件中去和将日志信息打印在控制台上。 由于Logback是第三方提供的技术，所以首先需要啊将Jar包引入到项目中，具体步骤如下 在资料中找到slftj-api.jar、logback-core.jar、logback-classes.jar 这三个jar包，复制一下 在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处 从资料中找到logback.xml配置文件，将此文件复制粘贴到src目录下（必须是src目录） 然后就可以开始写代码了，在代码中创建一个日志记录日对象 1public static final Logger LOGGER = LoggerFactory.getLogger(&quot;当前类名&quot;); 开始记录日志，代码如下 1234567891011121314151617181920212223public class LogBackTest &#123; // 创建一个Logger日志对象 public static final Logger LOGGER = LoggerFactory.getLogger(&quot;LogBackTest&quot;); public static void main(String[] args) &#123; //while (true) &#123; try &#123; LOGGER.info(&quot;chu法方法开始执行~~~&quot;); chu(10, 0); LOGGER.info(&quot;chu法方法执行成功~~~&quot;); &#125; catch (Exception e) &#123; LOGGER.error(&quot;chu法方法执行失败了，出现了bug~~~&quot;); &#125; //&#125; &#125; public static void chu(int a, int b)&#123; LOGGER.debug(&quot;参数a:&quot; + a); LOGGER.debug(&quot;参数b:&quot; + b); int c = a / b; LOGGER.info(&quot;结果是：&quot; + c); &#125;&#125; 当我们运行程序时，就可以看到控制台记录的日志 同时在文件中，也有一份这样的日志信息。文件在哪里内，从配置文件中去找 打开D:/log/itheima-data.log看一下文件中是否有记录日志吧！！ 关于Logback的快速入门我们就做完了。至于日志的配置文件中，其他的配置是什么含义我们下一节再继续学习。 3.4 日志配置文件Logback提供了一个核心配置文件logback.xml，日志框架在记录日志时会读取配置文件中的配置信息，从而记录日志的形式。具体可以做哪些配置呢？ 1231. 可以配置日志输出的位置是文件、还是控制台2. 可以配置日志输出的格式3. 还可以配置日志关闭和开启、以及哪些日志输出哪些日志不输出。 如下图所示，控制日志往文件中输出，还是往控制台输出 如下图所示，控制打开和关闭日志 如下图所示，控制日志的输出的格式 日志格式是由一些特殊的符号组成，可以根据需要删减不想看到的部分。比如不想看到线程名那就不要[%thread]。但是不建议同学们更改这些格式，因为这些都是日志很基本的信息。 3.5 配置日志级别 在哪里配置日志级别呢？如下图所示 Logback只输出大于或者等于核心配置文件配置的日志级别信息。小于配置级别的日志信息，不被记录。 1234配置的是trace，则trace、debug、info、warn、error级别的日志都被输出配置的是debug, 则debug、info、warn、error级别的日志被输出配置的是info,则info、warn、error级别的日志被输出... 三、多线程同学们，接下来我们来学习一个全新而且非常重要的知识，叫做多线程。首先和同学们聊聊什么是线程？线程其实是程序中的一条执行路径。 我们之前写过的程序，其实都是单线程程序，如下图代码，如果前面的for循环没有执行完，for循环下面的代码是不会执行的。 怎样的程序才是多线程程序呢？ 如下图所示，12306网站就是支持多线程的，因为同时可以有很多人一起进入网站购票，而且每一个人互不影响。再比如百度网盘，可以同时下载或者上传多个文件。这些程序中其实就有多条执行路径，每一条执行执行路径就是一条线程，所以这样的程序就是多线程程序。 认识了什么是多线程程序，那如何使用Java创建线程呢？ Java提供了几种创建线程的方式，下一节再一种一种的学习。 4.1 线程创建方式1Java为开发者提供了一个类叫做Thread，此类的对象用来表示线程。创建线程并执行线程的步骤如下 1231.定义一个子类继承Thread类，并重写run方法2.创建Thread的子类对象3.调用start方法启动线程（启动线程后，会自动执行run方法中的代码） 代码如下 12345678910public class MyThread extends Thread&#123; // 2、必须重写Thread类的run方法 @Override public void run() &#123; // 描述线程的执行任务。 for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程MyThread输出：&quot; + i); &#125; &#125;&#125; 再定义一个测试类，在测试类中创建MyThread线程对象，并启动线程 12345678910111213public class ThreadTest1 &#123; // main方法是由一条默认的主线程负责执行。 public static void main(String[] args) &#123; // 3、创建MyThread线程类的对象代表一个线程 Thread t = new MyThread(); // 4、启动线程（自动执行run方法的） t.start(); for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;主线程main输出：&quot; + i); &#125; &#125;&#125; 打印结果如下图所示，我们会发现MyThread和main线程在相互抢夺CPU的执行权（注意：哪一个线程先执行，哪一个线程后执行，目前我们是无法控制的，每次输出结果都会不一样） 最后我们还需要注意一点：不能直接去调用run方法，如果直接调用run方法就不认为是一条线程启动了，而是把Thread当做一个普通对象，此时run方法中的执行的代码会成为主线程的一部分。此时执行结果是这样的。 4.2 线程创建方式2接下来我们学习线程的第二种创建方式。Java为开发者提供了一个Runnable接口，该接口中只有一个run方法，意思就是通过Runnable接口的实现类对象专门来表示线程要执行的任务。具体步骤如下 12341.先写一个Runnable接口的实现类，重写run方法(这里面就是线程要执行的代码)2.再创建一个Runnable实现类的对象3.创建一个Thread对象，把Runnable实现类的对象传递给Thread4.调用Thread对象的start()方法启动线程（启动后会自动执行Runnable里面的run方法） 代码如下：先准备一个Runnable接口的实现类 12345678910111213/** * 1、定义一个任务类，实现Runnable接口 */public class MyRunnable implements Runnable&#123; // 2、重写runnable的run方法 @Override public void run() &#123; // 线程要执行的任务。 for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程输出 ===》&quot; + i); &#125; &#125;&#125; 再写一个测试类，在测试类中创建线程对象，并执行线程 12345678910111213public class ThreadTest2 &#123; public static void main(String[] args) &#123; // 3、创建任务对象。 Runnable target = new MyRunnable(); // 4、把任务对象交给一个线程对象处理。 // public Thread(Runnable target) new Thread(target).start(); for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;主线程main输出 ===》&quot; + i); &#125; &#125;&#125; 运行上面代码，结果如下图所示（注意：没有出现下面交替执行的效果，也是正常的） 12345678910主线程main输出 ===》1主线程main输出 ===》2主线程main输出 ===》3子线程输出 ===》1子线程输出 ===》2子线程输出 ===》3子线程输出 ===》4子线程输出 ===》5主线程main输出 ===》4主线程main输出 ===》5 4.3 线程创建方式2—匿名内部类同学们注意了，现在这种写法不是新知识。只是将前面第二种方式用匿名内部类改写一下。因为同学们在看别人写的代码时，有可能会看到这种写法。你知道是怎么回事就可以了。 刚刚我们学习的第二种线程的创建方式，需要写一个Runnable接口的实现类，然后再把Runnable实现类的对象传递给Thread对象。 现在我不想写Runnable实现类，于是可以直接创建Runnable接口的匿名内部类对象，传递给Thread对象。 代码如下 1234567891011121314151617181920212223242526272829303132333435public class ThreadTest2_2 &#123; public static void main(String[] args) &#123; // 1、直接创建Runnable接口的匿名内部类形式（任务对象） Runnable target = new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程1输出：&quot; + i); &#125; &#125; &#125;; new Thread(target).start(); // 简化形式1： new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程2输出：&quot; + i); &#125; &#125; &#125;).start(); // 简化形式2： new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程3输出：&quot; + i); &#125; &#125;).start(); for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;主线程main输出：&quot; + i); &#125; &#125;&#125; 4.4 线程的创建方式3接下来，我们学习线程的第三种创建方式。已经有两种了为什么还有要第三种呢？ 这样，我们先分析一下前面两种都存在的一个问题。然后再引出第三种可以解决这个问题。 假设线程执行完毕之后有一些数据需要返回，前面两种方式重写的run方法均没有返回结果。 123public void run()&#123; ...线程执行的代码...&#125; JDK5提供了Callable接口和FutureTask类来创建线程，它最大的优点就是有返回值。 在Callable接口中有一个call方法，重写call方法就是线程要执行的代码，它是有返回值的 1234public T call()&#123; ...线程执行的代码... return 结果;&#125; 第三种创建线程的方式，步骤如下 123456781.先定义一个Callable接口的实现类，重写call方法2.创建Callable实现类的对象3.创建FutureTask类的对象，将Callable对象传递给FutureTask4.创建Thread对象，将Future对象传递给Thread5.调用Thread的start()方法启动线程(启动后会自动执行call方法) 等call()方法执行完之后，会自动将返回值结果封装到FutrueTask对象中 6.调用FutrueTask对的get()方法获取返回结果 代码如下：先准备一个Callable接口的实现类 12345678910111213/** * 1、让子类继承Thread线程类。 */public class MyThread extends Thread&#123; // 2、必须重写Thread类的run方法 @Override public void run() &#123; // 描述线程的执行任务。 for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(&quot;子线程MyThread输出：&quot; + i); &#125; &#125;&#125; 再定义一个测试类，在测试类中创建线程并启动线程，还要获取返回结果 12345678910111213141516171819202122232425262728public class ThreadTest3 &#123; public static void main(String[] args) throws Exception &#123; // 3、创建一个Callable的对象 Callable&lt;String&gt; call = new MyCallable(100); // 4、把Callable的对象封装成一个FutureTask对象（任务对象） // 未来任务对象的作用？ // 1、是一个任务对象，实现了Runnable对象. // 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。 FutureTask&lt;String&gt; f1 = new FutureTask&lt;&gt;(call); // 5、把任务对象交给一个Thread对象 new Thread(f1).start(); Callable&lt;String&gt; call2 = new MyCallable(200); FutureTask&lt;String&gt; f2 = new FutureTask&lt;&gt;(call2); new Thread(f2).start(); // 6、获取线程执行完毕后返回的结果。 // 注意：如果执行到这儿，假如上面的线程还没有执行完毕 // 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。 String rs = f1.get(); System.out.println(rs); String rs2 = f2.get(); System.out.println(rs2); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day21-多线程","slug":"day21-多线程","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day21-多线程/","link":"","permalink":"https://wxzhou.top/2020/05/05/day21-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"一、多线程常用方法 下面我们演示一下getName()、setName(String name)、currentThread()、sleep(long time)这些方法的使用效果。 1234567891011121314public class MyThread extends Thread&#123; public MyThread(String name)&#123; super(name); //1.执行父类Thread(String name)构造器，为当前线程设置名字了 &#125; @Override public void run() &#123; //2.currentThread() 哪个线程执行它，它就会得到哪个线程对象。 Thread t = Thread.currentThread(); for (int i = 1; i &lt;= 3; i++) &#123; //3.getName() 获取线程名称 System.out.println(t.getName() + &quot;输出：&quot; + i); &#125; &#125;&#125; 再测试类中，创建线程对象，并启动线程 1234567891011121314151617181920212223public class ThreadTest1 &#123; public static void main(String[] args) &#123; Thread t1 = new MyThread(); t1.setName(String name) //设置线程名称; t1.start(); System.out.println(t1.getName()); //Thread-0 Thread t2 = new MyThread(&quot;2号线程&quot;); // t2.setName(&quot;2号线程&quot;); t2.start(); System.out.println(t2.getName()); // Thread-1 // 主线程对象的名字 // 哪个线程执行它，它就会得到哪个线程对象。 Thread m = Thread.currentThread(); m.setName(&quot;最牛的线程&quot;); System.out.println(m.getName()); // main for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(m.getName() + &quot;线程输出：&quot; + i); &#125; &#125;&#125; 执行上面代码，效果如下图所示，我们发现每一条线程都有自己了名字了。 最后再演示一下join这个方法是什么效果。 12345678910111213141516public class ThreadTest2 &#123; public static void main(String[] args) throws Exception &#123; // join方法作用：让当前调用这个方法的线程先执行完。 Thread t1 = new MyThread(&quot;1号线程&quot;); t1.start(); t1.join(); Thread t2 = new MyThread(&quot;2号线程&quot;); t2.start(); t2.join(); Thread t3 = new MyThread(&quot;3号线程&quot;); t3.start(); t3.join(); &#125;&#125; 执行效果是1号线程先执行完，再执行2号线程；2号线程执行完，再执行3号线程；3号线程执行完就结束了。 我们再尝试，把join()方法去掉，再看执行效果。此时你会发现2号线程没有执行完1号线程就执行了（效果是多次运行才出现的，根据个人电脑而异，可能有同学半天也出现不了也是正常的） 二、线程安全问题各位小伙伴，前面我们已经学习了如何创建线程，以及线程的常用方法。接下来，我们要学习一个在实际开发过程中，使用线程时最重要的一个问题，叫线程安全问题。 2.1 线程安全问题概述 首先，什么是线程安全问题呢？ 线程安全问题指的是，多个线程同时操作同一个共享资源的时候，可能会出现业务安全问题。 下面通过一个取钱的案例给同学们演示一下。案例需求如下 1场景：小明和小红是一对夫妻，他们有一个共享账户，余额是10万元，小红和小明同时来取钱，并且2人各自都在取钱10万元，可能出现什么问题呢？ 如下图所示，小明和小红假设都是一个线程，本类每个线程都应该执行完三步操作，才算是完成的取钱的操作。但是真实执行过程可能是下面这样子的 ​ ① 小红线程只执行了判断余额是否足够（条件为true），然后CPU的执行权就被小红线程抢走了。 ​ ② 小红线程也执行了判断了余额是否足够（条件也是true）, 然后CPU执行权又被小明线程抢走了。 ​ ③ 小明线程由于刚才已经判断余额是否足够了，直接执行第2步，吐出了10万元钱，此时共享账户月为0。然后CPU执行权又被小红线程抢走。 ​ ④ 小红线程由于刚刚也已经判断余额是否足够了，直接执行第2步，吐出了10万元钱，此时共享账户月为-10万。 你会发现，在这个取钱案例中，两个人把共享账户的钱都取了10万，但问题是只有10万块钱啊！！！ 以上取钱案例中的问题，就是线程安全问题的一种体现。 2.2 线程安全问题的代码演示先定义一个共享的账户类 123456789101112131415161718192021222324252627282930313233343536373839404142public class Account &#123; private String cardId; // 卡号 private double money; // 余额。 public Account() &#123; &#125; public Account(String cardId, double money) &#123; this.cardId = cardId; this.money = money; &#125; // 小明 小红同时过来的 public void drawMoney(double money) &#123; // 先搞清楚是谁来取钱？ String name = Thread.currentThread().getName(); // 1、判断余额是否足够 if(this.money &gt;= money)&#123; System.out.println(name + &quot;来取钱&quot; + money + &quot;成功！&quot;); this.money -= money; System.out.println(name + &quot;来取钱后，余额剩余：&quot; + this.money); &#125;else &#123; System.out.println(name + &quot;来取钱：余额不足~&quot;); &#125; &#125; public String getCardId() &#123; return cardId; &#125; public void setCardId(String cardId) &#123; this.cardId = cardId; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125;&#125; 在定义一个是取钱的线程类 123456789101112public class DrawThread extends Thread&#123; private Account acc; public DrawThread(Account acc, String name)&#123; super(name); this.acc = acc; &#125; @Override public void run() &#123; // 取钱(小明，小红) acc.drawMoney(100000); &#125;&#125; 最后，再写一个测试类，在测试类中创建两个线程对象 123456789public class ThreadTest &#123; public static void main(String[] args) &#123; // 1、创建一个账户对象，代表两个人的共享账户。 Account acc = new Account(&quot;ICBC-110&quot;, 100000); // 2、创建两个线程，分别代表小明 小红，再去同一个账户对象中取钱10万。 new DrawThread(acc, &quot;小明&quot;).start(); // 小明 new DrawThread(acc, &quot;小红&quot;).start(); // 小红 &#125;&#125; 运行程序，执行效果如下。你会发现两个人都取了10万块钱，余额为-10完了。 2.3 线程同步方案为了解决前面的线程安全问题，我们可以使用线程同步思想。同步最常见的方案就是加锁，意思是每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动释放锁，然后其他线程才能再加锁进来。 等小红线程执行完了，把余额改为0，出去了就会释放锁。这时小明线程就可以加锁进来执行，如下图所示。 采用加锁的方案，就可以解决前面两个线程都取10万块钱的问题。怎么加锁呢？Java提供了三种方案 1231.同步代码块2.同步方法3.Lock锁 2.4 同步代码块我们先来学习同步代码块。它的作用就是把访问共享数据的代码锁起来，以此保证线程安全。 1234//锁对象：必须是一个唯一的对象（同一个地址）synchronized(锁对象)&#123; //...访问共享数据的代码...&#125; 使用同步代码块，来解决前面代码里面的线程安全问题。我们只需要修改DrawThread类中的代码即可。 12345678910111213141516// 小明 小红线程同时过来的public void drawMoney(double money) &#123; // 先搞清楚是谁来取钱？ String name = Thread.currentThread().getName(); // 1、判断余额是否足够 // this正好代表共享资源！ synchronized (this) &#123; if(this.money &gt;= money)&#123; System.out.println(name + &quot;来取钱&quot; + money + &quot;成功！&quot;); this.money -= money; System.out.println(name + &quot;来取钱后，余额剩余：&quot; + this.money); &#125;else &#123; System.out.println(name + &quot;来取钱：余额不足~&quot;); &#125; &#125;&#125; 此时再运行测试类，观察是否会出现不合理的情况。 最后，再给同学们说一下锁对象如何选择的问题 1231.建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象2.对于实例方法，建议使用this作为锁对象3.对于静态方法，建议把类的字节码(类名.class)当做锁对象 2.5 同步方法接下来，学习同步方法解决线程安全问题。其实同步方法，就是把整个方法给锁住，一个线程调用这个方法，另一个线程调用的时候就执行不了，只有等上一个线程调用结束，下一个线程调用才能继续执行。 12345678910111213// 同步方法public synchronized void drawMoney(double money) &#123; // 先搞清楚是谁来取钱？ String name = Thread.currentThread().getName(); // 1、判断余额是否足够 if(this.money &gt;= money)&#123; System.out.println(name + &quot;来取钱&quot; + money + &quot;成功！&quot;); this.money -= money; System.out.println(name + &quot;来取钱后，余额剩余：&quot; + this.money); &#125;else &#123; System.out.println(name + &quot;来取钱：余额不足~&quot;); &#125;&#125; 改完之后，再次运行测试类，观察是否会出现不合理的情况。 接着，再问同学们一个问题，同步方法有没有锁对象？锁对象是谁？ 123同步方法也是有锁对象，只不过这个锁对象没有显示的写出来而已。 1.对于实例方法，锁对象其实是this（也就是方法的调用者） 2.对于静态方法，锁对象时类的字节码对象（类名.class） 最终，总结一下同步代码块和同步方法有什么区别？ 1231.不存在哪个好与不好，只是一个锁住的范围大，一个范围小2.同步方法是将方法中所有的代码锁住3.同步代码块是将方法中的部分代码锁住 2.6 Lock锁接下来，我们再来学习一种，线程安全问题的解决办法，叫做Lock锁。 Lock锁是JDK5版本专门提供的一种锁对象，通过这个锁对象的方法来达到加锁，和释放锁的目的，使用起来更加灵活。格式如下 1234561.首先在成员变量位子，需要创建一个Lock接口的实现类对象（这个对象就是锁对象） private final Lock lk = new ReentrantLock();2.在需要上锁的地方加入下面的代码 lk.lock(); // 加锁 //...中间是被锁住的代码... lk.unlock(); // 解锁 使用Lock锁改写前面DrawThread中取钱的方法，代码如下 1234567891011121314151617181920212223// 创建了一个锁对象private final Lock lk = new ReentrantLock();public void drawMoney(double money) &#123; // 先搞清楚是谁来取钱？ String name = Thread.currentThread().getName(); try &#123; lk.lock(); // 加锁 // 1、判断余额是否足够 if(this.money &gt;= money)&#123; System.out.println(name + &quot;来取钱&quot; + money + &quot;成功！&quot;); this.money -= money; System.out.println(name + &quot;来取钱后，余额剩余：&quot; + this.money); &#125;else &#123; System.out.println(name + &quot;来取钱：余额不足~&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lk.unlock(); // 解锁 &#125; &#125;&#125; 运行程序结果，观察是否有线程安全问题。到此三种解决线程安全问题的办法我们就学习完了。 三、线程通信（了解）接下来，我们学习一下线程通信。 首先，什么是线程通信呢？ 当多个线程共同操作共享资源时，线程间通过某种方式互相告知自己的状态，以相互协调，避免无效的资源挣抢。 线程通信的常见模式：是生产者与消费者模型 生产者线程负责生成数据 消费者线程负责消费生产者生成的数据 注意：生产者生产完数据后应该让自己等待，通知其他消费者消费；消费者消费完数据之后应该让自己等待，同时通知生产者生成。 比如下面案例中，有3个厨师（生产者线程），两个顾客（消费者线程）。 接下来，我们先分析一下完成这个案例的思路 12345678910111213141516171.先确定在这个案例中，什么是共享数据？ 答：这里案例中桌子是共享数据，因为厨师和顾客都需要对桌子上的包子进行操作。2.再确定有那几条线程？哪个是生产者，哪个是消费者？ 答：厨师是生产者线程，3条生产者线程； 顾客是消费者线程，2条消费者线程 3.什么时候将哪一个线程设置为什么状态 生产者线程(厨师)放包子： 1)先判断是否有包子 2)没有包子时，厨师开始做包子, 做完之后把别人唤醒，然后让自己等待 3)有包子时，不做包子了，直接唤醒别人、然后让自己等待 消费者线程(顾客)吃包子： 1)先判断是否有包子 2)有包子时，顾客开始吃包子, 吃完之后把别人唤醒，然后让自己等待 3)没有包子时，不吃包子了，直接唤醒别人、然后让自己等待 按照上面分析的思路写代码。先写桌子类，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Desk &#123; private List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 放1个包子的方法 // 厨师1 厨师2 厨师3 public synchronized void put() &#123; try &#123; String name = Thread.currentThread().getName(); // 判断是否有包子。 if(list.size() == 0)&#123; list.add(name + &quot;做的肉包子&quot;); System.out.println(name + &quot;做了一个肉包子~~&quot;); Thread.sleep(2000); // 唤醒别人, 等待自己 this.notifyAll(); this.wait(); &#125;else &#123; // 有包子了，不做了。 // 唤醒别人, 等待自己 this.notifyAll(); this.wait(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 吃货1 吃货2 public synchronized void get() &#123; try &#123; String name = Thread.currentThread().getName(); if(list.size() == 1)&#123; // 有包子，吃了 System.out.println(name + &quot;吃了：&quot; + list.get(0)); list.clear(); Thread.sleep(1000); this.notifyAll(); this.wait(); &#125;else &#123; // 没有包子 this.notifyAll(); this.wait(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再写测试类，在测试类中，创建3个厨师线程对象，再创建2个顾客对象，并启动所有线程 123456789101112131415161718192021222324252627282930313233343536373839public class ThreadTest &#123; public static void main(String[] args) &#123; // 需求：3个生产者线程，负责生产包子，每个线程每次只能生产1个包子放在桌子上 // 2个消费者线程负责吃包子，每人每次只能从桌子上拿1个包子吃。 Desk desk = new Desk(); // 创建3个生产者线程（3个厨师） new Thread(() -&gt; &#123; while (true) &#123; desk.put(); &#125; &#125;, &quot;厨师1&quot;).start(); new Thread(() -&gt; &#123; while (true) &#123; desk.put(); &#125; &#125;, &quot;厨师2&quot;).start(); new Thread(() -&gt; &#123; while (true) &#123; desk.put(); &#125; &#125;, &quot;厨师3&quot;).start(); // 创建2个消费者线程（2个吃货） new Thread(() -&gt; &#123; while (true) &#123; desk.get(); &#125; &#125;, &quot;吃货1&quot;).start(); new Thread(() -&gt; &#123; while (true) &#123; desk.get(); &#125; &#125;, &quot;吃货2&quot;).start(); &#125;&#125; 执行上面代码，运行结果如下：你会发现多个线程相互协调执行，避免无效的资源挣抢。 12345678910厨师1做了一个肉包子~~吃货2吃了：厨师1做的肉包子厨师3做了一个肉包子~~吃货2吃了：厨师3做的肉包子厨师1做了一个肉包子~~吃货1吃了：厨师1做的肉包子厨师2做了一个肉包子~~吃货2吃了：厨师2做的肉包子厨师3做了一个肉包子~~吃货1吃了：厨师3做的肉包子 四、线程池4.1 线程池概述各位小伙伴，接下来我们学习一下线程池技术。先认识一下什么是线程池技术？ 其实，线程池就是一个可以复用线程的技术。 要理解什么是线程复用技术，我们先得看一下不使用线程池会有什么问题，理解了这些问题之后，我们在解释线程复用同学们就好理解了。 1假设：用户每次发起一个请求给后台，后台就创建一个新的线程来处理，下次新的任务过来肯定也会创建新的线程，如果用户量非常大，创建的线程也讲越来越多。然而，创建线程是开销很大的，并且请求过多时，会严重影响系统性能。 而使用线程池，就可以解决上面的问题。如下图所示，线程池内部会有一个容器，存储几个核心线程，假设有3个核心线程，这3个核心线程可以处理3个任务。 但是任务总有被执行完的时候，假设第1个线程的任务执行完了，那么第1个线程就空闲下来了，有新的任务时，空闲下来的第1个线程可以去执行其他任务。依此内推，这3个线程可以不断的复用，也可以执行很多个任务。 所以，线程池就是一个线程复用技术，它可以提高线程的利用率。 4.2 创建线程池在JDK5版本中提供了代表线程池的接口ExecutorService，而这个接口下有一个实现类叫ThreadPoolExecutor类，使用ThreadPoolExecutor类就可以用来创建线程池对象。 下面是它的构造器，参数比较多，不要怕，干就完了^_^。 接下来，用这7个参数的构造器来创建线程池的对象。代码如下 123456789ExecutorService pool = new ThreadPoolExecutor( 3, //核心线程数有3个 5, //最大线程数有5个。 临时线程数=最大线程数-核心线程数=5-3=2 8, //临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。 TimeUnit.SECONDS,//时间单位（秒） new ArrayBlockingQueue&lt;&gt;(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待 Executors.defaultThreadFactory(), //用于创建线程的工厂对象 new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略); 关于线程池，我们需要注意下面的两个问题 临时线程什么时候创建？ 1新任务提交时，发现核心线程都在忙、任务队列满了、并且还可以创建临时线程，此时会创建临时线程。 什么时候开始拒绝新的任务？ 1核心线程和临时线程都在忙、任务队列也满了、新任务过来时才会开始拒绝任务。 4.3 线程池执行Runnable任务创建好线程池之后，接下来我们就可以使用线程池执行任务了。线程池执行的任务可以有两种，一种是Runnable任务；一种是callable任务。下面的execute方法可以用来执行Runnable任务。 先准备一个线程任务类 12345678910111213public class MyRunnable implements Runnable&#123; @Override public void run() &#123; // 任务是干啥的？ System.out.println(Thread.currentThread().getName() + &quot; ==&gt; 输出666~~&quot;); //为了模拟线程一直在执行，这里睡久一点 try &#123; Thread.sleep(Integer.MAX_VALUE); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面是执行Runnable任务的代码，注意阅读注释，对照着前面的7个参数理解。 12345678910111213141516171819202122232425ExecutorService pool = new ThreadPoolExecutor( 3, //核心线程数有3个 5, //最大线程数有5个。 临时线程数=最大线程数-核心线程数=5-3=2 8, //临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。 TimeUnit.SECONDS,//时间单位（秒） new ArrayBlockingQueue&lt;&gt;(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待 Executors.defaultThreadFactory(), //用于创建线程的工厂对象 new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略);Runnable target = new MyRunnable();pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！//下面4个任务在任务队列里排队pool.execute(target);pool.execute(target);pool.execute(target);pool.execute(target);//下面2个任务，会被临时线程的创建时机了pool.execute(target);pool.execute(target);// 到了新任务的拒绝时机了！pool.execute(target); 执行上面的代码，结果输出如下 4.4 线程池执行Callable任务接下来，我们学习使用线程池执行Callable任务。callable任务相对于Runnable任务来说，就是多了一个返回值。 执行Callable任务需要用到下面的submit方法 先准备一个Callable线程任务 123456789101112131415161718public class MyCallable implements Callable&lt;String&gt; &#123; private int n; public MyCallable(int n) &#123; this.n = n; &#125; // 2、重写call方法 @Override public String call() throws Exception &#123; // 描述线程的任务，返回线程执行返回后的结果。 // 需求：求1-n的和返回。 int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; sum += i; &#125; return Thread.currentThread().getName() + &quot;求出了1-&quot; + n + &quot;的和是：&quot; + sum; &#125;&#125; 再准备一个测试类，在测试类中创建线程池，并执行callable任务。 12345678910111213141516171819202122232425public class ThreadPoolTest2 &#123; public static void main(String[] args) throws Exception &#123; // 1、通过ThreadPoolExecutor创建一个线程池对象。 ExecutorService pool = new ThreadPoolExecutor( 3, 5, 8, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy()); // 2、使用线程处理Callable任务。 Future&lt;String&gt; f1 = pool.submit(new MyCallable(100)); Future&lt;String&gt; f2 = pool.submit(new MyCallable(200)); Future&lt;String&gt; f3 = pool.submit(new MyCallable(300)); Future&lt;String&gt; f4 = pool.submit(new MyCallable(400)); // 3、执行完Callable任务后，需要获取返回结果。 System.out.println(f1.get()); System.out.println(f2.get()); System.out.println(f3.get()); System.out.println(f4.get()); &#125;&#125; 执行后，结果如下图所示 4.5 线程池工具类（Executors）有同学可能会觉得前面创建线程池的代码参数太多、记不住，有没有快捷的创建线程池的方法呢？有的。Java为开发者提供了一个创建线程池的工具类，叫做Executors，它提供了方法可以创建各种不能特点的线程池。如下图所示 接下来，我们演示一下创建固定线程数量的线程池。这几个方法用得不多，所以这里不做过多演示，同学们了解一下就行了。 1234567891011121314151617181920public class ThreadPoolTest3 &#123; public static void main(String[] args) throws Exception &#123; // 1、通过Executors创建一个线程池对象。 ExecutorService pool = Executors.newFixedThreadPool(17); // 老师：核心线程数量到底配置多少呢？？？ // 计算密集型的任务：核心线程数量 = CPU的核数 + 1 // IO密集型的任务：核心线程数量 = CPU核数 * 2 // 2、使用线程处理Callable任务。 Future&lt;String&gt; f1 = pool.submit(new MyCallable(100)); Future&lt;String&gt; f2 = pool.submit(new MyCallable(200)); Future&lt;String&gt; f3 = pool.submit(new MyCallable(300)); Future&lt;String&gt; f4 = pool.submit(new MyCallable(400)); System.out.println(f1.get()); System.out.println(f2.get()); System.out.println(f3.get()); System.out.println(f4.get()); &#125;&#125; Executors创建线程池这么好用，为什么不推荐同学们使用呢？原因在这里：看下图，这是《阿里巴巴Java开发手册》提供的强制规范要求。 五、补充知识最后，我们再补充几个概念性的知识点，同学们知道这些概念什么意思就可以了。 5.1 并发和并行先学习第一个补充知识点，并发和并行。在讲解并发和并行的含义之前，我们先来了解一下什么是进程、线程？ 正常运行的程序（软件）就是一个独立的进程 线程是属于进程，一个进程中包含多个线程 进程中的线程其实并发和并行同时存在（继续往下看） 我们可以打开系统的任务管理器看看（快捷键：Ctrl+Shfit+Esc），自己的电脑上目前有哪些进程。 知道了什么是进程和线程之后，接着我们再来学习并发和并行的含义。 首先，来学习一下什么是并发？ 进程中的线程由CPU负责调度执行，但是CPU同时处理线程的数量是优先的，为了保证全部线程都能执行到，CPU采用轮询机制为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。（简单记：并发就是多条线程交替执行） 接下，再来学习一下什么是并行？ 并行指的是，多个线程同时被CPU调度执行。如下图所示，多个CPU核心在执行多条线程 最后一个问题，多线程到底是并发还是并行呢？ 其实多个线程在我们的电脑上执行，并发和并行是同时存在的。 5.2 线程的生命周期接下来，我们学习最后一个有关线程的知识点，叫做线程的生命周期。所谓生命周期就是线程从生到死的过程中间有哪些状态，以及这些状态之间是怎么切换的。 为了让大家同好的理解线程的生命周期，先用人的生命周期举个例子，人从生到死有下面的几个过程。在人的生命周期过程中，各种状态之间可能会有切换，线程也是一样的。 接下来就来学习线程的生命周期。在Thread类中有一个嵌套的枚举类叫Thread.Status，这里面定义了线程的6中状态。如下图所示 123456NEW: 新建状态，线程还没有启动RUNNABLE: 可以运行状态，线程调用了start()方法后处于这个状态BLOCKED: 锁阻塞状态，没有获取到锁处于这个状态WAITING: 无限等待状态，线程执行时被调用了wait方法处于这个状态TIMED_WAITING: 计时等待状态，线程执行时被调用了sleep(毫秒)或者wait(毫秒)方法处于这个状态TERMINATED: 终止状态, 线程执行完毕或者遇到异常时，处于这个状态。 这几种状态之间切换关系如下图所示","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day22-网络编程","slug":"day22-网络编程","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day22-网络编程/","link":"","permalink":"https://wxzhou.top/2020/05/05/day22-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一、网络编程概述同学们，今天我们学习的课程内容叫网络编程。意思就是编写的应用程序可以与网络上其他设备中的应用程序进行数据交互。 网络编程有什么用呢？这个就不言而喻了，比如我们经常用的微信收发消息就需要用到网络通信的技术、在比如我们打开浏览器可以浏览各种网络、视频等也需要用到网络编程的技术。 我们知道什么是网络编程、也知道网络编程能干什么后了，那Java给我们提供了哪些网络编程的解决方案呢？ Java提供的网络编程的解决方案都是在java.net包下。在正式学习Java网络编程技术之前，我们还需要学习一些网络通信的前置知识理论知识，只有这些前置知识做基础，我们学习网络编程代码编写才起来才能继续下去。 首先和同学们聊聊网络通信的基本架构。通信的基本架构主要有两种形式：一种是CS架构（Client 客户端&#x2F;Server服务端）、一种是BS架构（Brower 浏览器&#x2F;Server服务端）。 CS架构的特点：CS架构需要用户在自己的电脑或者手机上安装客户端软件，然后由客户端软件通过网络连接服务器程序，由服务器把数据发给客户端，客户端就可以在页面上看到各种数据了。 BS架构的特点：BS架构不需要开发客户端软件，用户只需要通过浏览器输入网址就可以直接从服务器获取数据，并由服务器将数据返回给浏览器，用户在页面上就可以看到各种数据了。 这两种结构不管是CS、还是BS都是需要用到网络编程的相关技术。我们学习Java的程序员，以后从事的工作方向主要还是BS架构的。 二、网络编程三要素各位小伙伴，我们前面已经知道什么是网络编程了。接下来我们还需要学习一些网络编程的基本概念，才能去编写网络编程的应用程序。 有哪三要素呢？分别是IP地址、端口号、通信协议 IP地址：表示设备在网络中的地址，是网络中设备的唯一标识 端口号：应用程序在设备中唯一的标识 协议：连接和数据在网络中传输的规则。 如下图所示：假设现在要从一台电脑中的微信上，发一句“你愁啥？”到其他电脑的微信上，流程如下 1231.先通过ip地址找到对方的电脑2.再通过端口号找到对方的电脑上的应用程序3.按照双方约定好的规则发送、接收数据 2.1 IP地址接下来，我们详细介绍一下IP地址。IP（Ineternet Protocol）全称互联网协议地址，是分配给网络设备的唯一表示。IP地址分为：IPV4地址、IPV6地址 IPV4地址由32个比特位（4个字节）组成，如果下图所示，但是由于采用二进制太不容易阅读了，于是就将每8位看成一组，把每一组用十进制表示（叫做点分十进制表示法）。所以就有了我们经常看到的IP地址形式，如：192.168.1.66 如果想查看本机的IP地址，可以在命令行窗口，输入ipconfig命令查看，如下图所示 经过不断的发展，现在越来越多的设备需要联网，IPV4地址已经不够用了，所以扩展出来了IPV6地址。 IPV6采用128位二进制数据来表示（16个字节），号称可以为地球上的每一粒沙子编一个IP地址， IPV6比较长，为了方便阅读，每16位编成一组，每组采用十六进制数据表示，然后用冒号隔开（称为冒分十六进制表示法），如下图所示 我们在命令行窗口输入ipconfig命令，同样可以看到ipv6地址，如下图所示 现在的网络设备，一般IPV4和IPV6地址都是支持的。 聊完什么是IP地址和IP地址分类之后，接下来再给大家介绍一下和IP地址相关的一个东西，叫做域名。 我们在浏览器上访问某一个网站是，就需要在浏览器的地址栏输入网址，这个网址的专业说法叫做域名。比如：传智播客的域名是http://www.itcast.cn。 域名和IP其实是一一对应的，由运营商来管理域名和IP的对应关系。我们在浏览器上敲一个域名时，首先由运营商的域名解析服务，把域名转换为ip地址，再通过IP地址去访问对应的服务器设备。 关于IP地址，还有一个特殊的地址需要我们记住一下。就是我们在学习阶段进行测试时，经常会自己给自己消息，需要用到一个本地回送地址：127.0.0.1 最后给同学们介绍，两个和IP地址相关的命令 12ipconfig: 查看本机的ip地址pring 域名/ip 检测当前电脑与指定的ip是否连通 ping命令出现以下的提示，说明网络是通过的 2.2 InetAddress类各位小伙伴，在上一节课我们学习了网络编程的三要素之一，IP地址。按照面向对象的设计思想，Java中也有一个类用来表IP地址，这个类是InetAddress类。我们在开发网络通信程序的时候，可能有时候会获取本机的IP地址，以及测试与其他地址是否连通，这个时候就可以使用InetAddress类来完成。下面学习几个InetAddress的方法。 演示上面几个方法的效果 12345678910111213141516public class InetAddressTest &#123; public static void main(String[] args) throws Exception &#123; // 1、获取本机IP地址对象的 InetAddress ip1 = InetAddress.getLocalHost(); System.out.println(ip1.getHostName()); System.out.println(ip1.getHostAddress()); // 2、获取指定IP或者域名的IP地址对象。 InetAddress ip2 = InetAddress.getByName(&quot;www.baidu.com&quot;); System.out.println(ip2.getHostName()); System.out.println(ip2.getHostAddress()); // ping www.baidu.com System.out.println(ip2.isReachable(6000)); &#125;&#125; 2.3 端口号端口号：指的是计算机设备上运行的应用程序的标识，被规定为一个16位的二进制数据，范围（0~65535） 端口号分为一下几类（了解一下） 周知端口：0~1023，被预先定义的知名应用程序占用（如：HTTP占用80，FTP占用21） 注册端口：1024~49151，分配给用户经常或者某些应用程序 动态端口：49152~65536，之所以称为动态端口，是因为它一般不固定分配给某进程，而是动态分配的。 需要我们注意的是，同一个计算机设备中，不能出现两个应用程序，用同一个端口号 2.4 协议各位同学，前面我们已经学习了IP地址和端口号，但是想要完成数据通信还需要有通信协议。 网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议。 为了让世界上各种上网设备能够互联互通，肯定需要有一个组织出来，指定一个规则，大家都遵守这个规则，才能进行数据通信。 只要按照OSI网络参考模型制造的设备，就可以在国际互联网上互联互通。其中传输层有两个协议，是我们今天会接触到的（UDP协议、TCP协议） UDP协议特点 TPC协议特点 三次握手如下图所示：目的是确认通信双方，手法消息都是正常没问题的 四次挥手如下图所示：目的是确保双方数据的收发已经完成，没有数据丢失 三、UDP通信代码（入门案例）有了网络编程的三要素基础知识之后，我们就可以开始学习编写网络通信的程序了。首先学习基于UDP协议通信的代码编写。 UDP是面向无连接的、不需要确认双方是否存在，所以它是不可靠的协议。Java提供了一个类叫DatagramSocket来完成基于UDP协议的收发数据。使用DatagramSocket收发数据时，数据要以数据包的形式体现，一个数据包限制在64KB以内 具体流程如下图所示：假设我们把DatagramSocket看做是街道两天的人，现在左边的人要扔一盘韭菜到右边，这里的韭菜就是数据，但是数据需要用一个盘子装起来，这里的盘子就是DatagramPacket数据包的意思。通信双方都需要有DatagramSocket(扔、接韭菜人)，还需要有DatagramPacket(装韭菜的盘子) 下面我们看一个案例，需要有两个程序，一个表示客户端程序，一个表示服务端程序。 需求：客户端程序发一个字符串数据给服务端，服务端程序接收数据并打印。 3.1 客户端程序123456789101112131415161718192021222324252627/** * 目标：完成UDP通信快速入门：实现1发1收。 */public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、创建客户端对象（发韭菜出去的人） DatagramSocket socket = new DatagramSocket(7777); // 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子） /* public DatagramPacket(byte buf[], int length, InetAddress address, int port) 参数一：封装要发出去的数据。 参数二：发送出去的数据大小（字节个数） 参数三：服务端的IP地址（找到服务端主机） 参数四：服务端程序的端口。 */ byte[] bytes = &quot;我是快乐的客户端，我爱你abc&quot;.getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length , InetAddress.getLocalHost(), 6666); // 3、开始正式发送这个数据包的数据出去了 socket.send(packet); System.out.println(&quot;客户端数据发送完毕~~~&quot;); socket.close(); // 释放资源！ &#125;&#125; 3.2 服务端程序123456789101112131415161718192021222324252627public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;----服务端启动----&quot;); // 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口 DatagramSocket socket = new DatagramSocket(6666); // 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子） byte[] buffer = new byte[1024 * 64]; // 64KB. DatagramPacket packet = new DatagramPacket(buffer, buffer.length); // 3、开始正式使用数据包来接收客户端发来的数据 socket.receive(packet); // 4、从字节数组中，把接收到的数据直接打印出来 // 接收多少就倒出多少 // 获取本次数据包接收了多少数据。 int len = packet.getLength(); String rs = new String(buffer, 0 , len); System.out.println(rs); System.out.println(packet.getAddress().getHostAddress()); System.out.println(packet.getPort()); socket.close(); // 释放资源 &#125;&#125; 四、UDP通信代码（多发多收）刚才的案例，我们只能客户端发一次，服务端接收一次就结束了。下面我们想把这个代码改进一下， 需求：实现客户端不断的发数据，而服务端能不断的接收数据，客户端发送exit时客户端程序退出。 4.1 客户端程序12345678910111213141516171819202122232425262728293031323334353637/** * 目标：完成UDP通信快速入门：实现客户端反复的发。 */public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、创建客户端对象（发韭菜出去的人） DatagramSocket socket = new DatagramSocket(); // 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子） /* public DatagramPacket(byte buf[], int length, InetAddress address, int port) 参数一：封装要发出去的数据。 参数二：发送出去的数据大小（字节个数） 参数三：服务端的IP地址（找到服务端主机） 参数四：服务端程序的端口。 */ Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(&quot;请说：&quot;); String msg = sc.nextLine(); // 一旦发现用户输入的exit命令，就退出客户端 if(&quot;exit&quot;.equals(msg))&#123; System.out.println(&quot;欢迎下次光临！退出成功！&quot;); socket.close(); // 释放资源 break; // 跳出死循环 &#125; byte[] bytes = msg.getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length , InetAddress.getLocalHost(), 6666); // 3、开始正式发送这个数据包的数据出去了 socket.send(packet); &#125; &#125;&#125; 4.2 服务端程序12345678910111213141516171819202122232425262728293031/** * 目标：完成UDP通信快速入门-服务端反复的收 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;----服务端启动----&quot;); // 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口 DatagramSocket socket = new DatagramSocket(6666); // 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子） byte[] buffer = new byte[1024 * 64]; // 64KB. DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while (true) &#123; // 3、开始正式使用数据包来接收客户端发来的数据 socket.receive(packet); // 4、从字节数组中，把接收到的数据直接打印出来 // 接收多少就倒出多少 // 获取本次数据包接收了多少数据。 int len = packet.getLength(); String rs = new String(buffer, 0 , len); System.out.println(rs); System.out.println(packet.getAddress().getHostAddress()); System.out.println(packet.getPort()); System.out.println(&quot;--------------------------------------&quot;); &#125; &#125;&#125; 五、TCP通信（一发一收）学习完UDP通信的代码编写之后，接下来我们学习TCP通信的代码如何编写。Java提供了一个java.net.Socket类来完成TCP通信。 我们先讲一下Socket完成TCP通信的流程，再讲代码怎么编写就很好理解了。如下图所示 当创建Socket对象时，就会在客户端和服务端创建一个数据通信的管道，在客户端和服务端两边都会有一个Socket对象来访问这个通信管道。 现在假设客户端要发送一个“在一起”给服务端，客户端这边先需要通过Socket对象获取到一个字节输出流，通过字节输出流写数据到服务端 然后服务端这边通过Socket对象可以获取字节输入流，通过字节输入流就可以读取客户端写过来的数据，并对数据进行处理。 服务端处理完数据之后，假设需要把“没感觉”发给客户端端，那么服务端这边再通过Socket获取到一个字节输出流，将数据写给客户端 客户端这边再获取输入流，通过字节输入流来读取服务端写过来的数据。 5.1 TCP客户端下面我们写一个客户端，用来往服务端发数据。由于原始的字节流不是很好用，这里根据我的经验，我原始的OutputStream包装为DataOutputStream是比较好用的。 123456789101112131415161718192021/** * 目标：完成TCP通信快速入门-客户端开发：实现1发1收。 */public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、创建Socket对象，并同时请求与服务端程序的连接。 Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); // 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。 OutputStream os = socket.getOutputStream(); // 3、把低级的字节输出流包装成数据输出流 DataOutputStream dos = new DataOutputStream(os); // 4、开始写数据出去了 dos.writeUTF(&quot;在一起，好吗？&quot;); dos.close(); socket.close(); // 释放连接资源 &#125;&#125; 5.2 TCP服务端上面我们只是写了TCP客户端，还没有服务端，接下来我们把服务端写一下。这里的服务端用来接收客户端发过来的数据。 12345678910111213141516171819202122232425262728/** * 目标：完成TCP通信快速入门-服务端开发：实现1发1收。 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、从socket通信管道中得到一个字节输入流。 InputStream is = socket.getInputStream(); // 4、把原始的字节输入流包装成数据输入流 DataInputStream dis = new DataInputStream(is); // 5、使用数据输入流读取客户端发送过来的消息 String rs = dis.readUTF(); System.out.println(rs); // 其实我们也可以获取客户端的IP地址 System.out.println(socket.getRemoteSocketAddress()); dis.close(); socket.close(); &#125;&#125; 六、TCP通信（多发多收）到目前为止，我们已经完成了客户端发送消息、服务端接收消息，但是客户端只能发一次，服务端只能接收一次。现在我想要客户端能过一直发消息，服务端能够一直接收消息。 下面我们把客户端代码改写一下，采用键盘录入的方式发消息，为了让客户端能够一直发，我们只需要将发送消息的代码套一层循环就可以了，当用户输入exit时，客户端退出循环并结束客户端。 6.1 TCP客户端123456789101112131415161718192021222324252627282930313233/** * 目标：完成TCP通信快速入门-客户端开发：实现客户端可以反复的发消息出去 */public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、创建Socket对象，并同时请求与服务端程序的连接。 Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); // 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。 OutputStream os = socket.getOutputStream(); // 3、把低级的字节输出流包装成数据输出流 DataOutputStream dos = new DataOutputStream(os); Scanner sc = new Scanner(System.in); while (true) &#123; System.out.println(&quot;请说：&quot;); String msg = sc.nextLine(); // 一旦用户输入了exit，就退出客户端程序 if(&quot;exit&quot;.equals(msg))&#123; System.out.println(&quot;欢迎您下次光临！退出成功！&quot;); dos.close(); socket.close(); break; &#125; // 4、开始写数据出去了 dos.writeUTF(msg); dos.flush(); &#125; &#125;&#125; 6.2 TCP服务端为了让服务端能够一直接收客户端发过来的消息，服务端代码也得改写一下。我们只需要将读取数据的代码加一个循环就可以了。 但是需要我们注意的时，如果客户端Socket退出之后，就表示连接客户端与服务端的数据通道被关闭了，这时服务端就会出现异常。服务端可以通过出异常来判断客户端下线了，所以可以用try…catch把读取客户端数据的代码套一起来，catch捕获到异常后，打印客户端下线。 1234567891011121314151617181920212223242526272829303132/** * 目标：完成TCP通信快速入门-服务端开发：实现服务端反复发消息 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、从socket通信管道中得到一个字节输入流。 InputStream is = socket.getInputStream(); // 4、把原始的字节输入流包装成数据输入流 DataInputStream dis = new DataInputStream(is); while (true) &#123; try &#123; // 5、使用数据输入流读取客户端发送过来的消息 String rs = dis.readUTF(); System.out.println(rs); &#125; catch (Exception e) &#123; System.out.println(socket.getRemoteSocketAddress() + &quot;离线了！&quot;); dis.close(); socket.close(); break; &#125; &#125; &#125;&#125; 七、TCP通信（多线程改进）上一个案例中我们写的服务端程序只能和一个客户端通信，如果有多个客户端连接服务端，此时服务端是不支持的。 为了让服务端能够支持多个客户端通信，就需要用到多线程技术。具体的实现思路如下图所示：每当有一个客户端连接服务端，在服务端这边就为Socket开启一条线程取执行读取数据的操作，来多少个客户端，就有多少条线程。按照这样的设计，服务端就可以支持多个客户端连接了。 按照上面的思路，改写服务端代码。 7.1 多线程改进首先，我们需要写一个服务端的读取数据的线程类，代码如下 123456789101112131415161718192021222324252627public class ServerReaderThread extends Thread&#123; private Socket socket; public ServerReaderThread(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true)&#123; try &#123; String msg = dis.readUTF(); System.out.println(msg); &#125; catch (Exception e) &#123; System.out.println(&quot;有人下线了：&quot; + socket.getRemoteSocketAddress()); dis.close(); socket.close(); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 接下来，再改写服务端的主程序代码，如下： 1234567891011121314151617181920/** * 目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); while (true) &#123; // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); System.out.println(&quot;有人上线了：&quot; + socket.getRemoteSocketAddress()); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 new ServerReaderThread(socket).start(); &#125; &#125;&#125; 7.2 案例拓展（群聊）接着前面的案例，下面我们案例再次拓展一下，这个并不需要同学们必须掌握，主要是为了锻炼同学们的编程能力、和编程思维。 我们想把刚才的案例，改进成全能够实现群聊的效果，就是一个客户端发的消息，其他的每一个客户端都可以收到。 刚才我们写的多个客户端可以往服务端发现消息，但是客户端和客户端是不能直接通信的。想要试下全群聊的效果，我们还是必须要有服务端在中间做中转。 具体实现方案如下图所示： 我们可以在服务端创建一个存储Socket的集合，每当一个客户端连接服务端，就可以把客户端Socket存储起来；当一个客户端给服务端发消息时，再遍历集合通过每个Socket将消息再转发给其他客户端。 下面我们改造服务端代码，由于服务端读取数据是在线程类中完成的，所以我们改SerReaderThread类就可以了。服务端的主程序不用改。 123456789101112131415161718192021222324252627282930313233343536373839public class ServerReaderThread extends Thread&#123; private Socket socket; public ServerReaderThread(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true)&#123; try &#123; String msg = dis.readUTF(); System.out.println(msg); // 把这个消息分发给全部客户端进行接收。 sendMsgToAll(msg); &#125; catch (Exception e) &#123; System.out.println(&quot;有人下线了：&quot; + socket.getRemoteSocketAddress()); Server.onLineSockets.remove(socket); dis.close(); socket.close(); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void sendMsgToAll(String msg) throws IOException &#123; // 发送给全部在线的socket管道接收。 for (Socket onLineSocket : Server.onLineSockets) &#123; OutputStream os = onLineSocket.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); dos.writeUTF(msg); dos.flush(); &#125; &#125;&#125; 八、BS架构程序（简易版）前面我们所写的代码都是基于CS架构的。我们说网络编程还可以编写BS架构的程序，为了让同学们体验一下BS架构通信，这里我们写一个简易版的程序。仅仅只是体验下一，后期我们会详细学习BS架构的程序如何编写。 BS架构程序的实现原理，如下图所示：不需要开发客户端程序，此时浏览器就相当于是客户端，此时我们只需要写服务端程序就可以了。 在BS结构的程序中，浏览器和服务器通信是基于HTTP协议来完成的，浏览器给客户端发送数据需要按照HTTP协议规定好的数据格式发给服务端，服务端返回数据时也需要按照HTTP协议规定好的数据给是发给浏览器，只有这两双方才能完成一次数据交互。 客户端程序不需要我们编写（浏览器就是），所以我们只需要写服务端就可以了。 服务端给客户端响应数据的数据格式（HTTP协议规定数据格式）如下图所示：左图是数据格式，右图是示例。 接下来，我们写一个服务端程序按照右图示例的样子，给浏览器返回数据。注意：数据是由多行组成的，必须按照规定的格式来写。 8.1 服务端程序先写一个线程类，用于按照HTTP协议的格式返回数据 12345678910111213141516171819202122public class ServerReaderThread extends Thread&#123; private Socket socket; public ServerReaderThread(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; // 立即响应一个网页内容：“黑马程序员”给浏览器展示。 try &#123; OutputStream os = socket.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(&quot;HTTP/1.1 200 OK&quot;); ps.println(&quot;Content-Type:text/html;charset=UTF-8&quot;); ps.println(); // 必须换行 ps.println(&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;); ps.close(); socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再写服务端的主程序 1234567891011121314151617181920/** * 目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。 */public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8080); while (true) &#123; // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); System.out.println(&quot;有人上线了：&quot; + socket.getRemoteSocketAddress()); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 new ServerReaderThread(socket).start(); &#125; &#125;&#125; 8.2 服务端主程序用线程池改进为了避免服务端创建太多的线程，可以把服务端用线程池改进，提高服务端的性能。 先写一个给浏览器响应数据的线程任务 12345678910111213141516171819202122public class ServerReaderRunnable implements Runnable&#123; private Socket socket; public ServerReaderRunnable(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; // 立即响应一个网页内容：“黑马程序员”给浏览器展示。 try &#123; OutputStream os = socket.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(&quot;HTTP/1.1 200 OK&quot;); ps.println(&quot;Content-Type:text/html;charset=UTF-8&quot;); ps.println(); // 必须换行 ps.println(&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;); ps.close(); socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再改写服务端的主程序，使用ThreadPoolExecutor创建一个线程池，每次接收到一个Socket就往线程池中提交任务就行。 1234567891011121314151617181920public class Server &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;-----服务端启动成功-------&quot;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8080); // 创建出一个线程池，负责处理通信管道的任务。 ThreadPoolExecutor pool = new ThreadPoolExecutor(16 * 2, 16 * 2, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(8) , Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); while (true) &#123; // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 pool.execute(new ServerReaderRunnable(socket)); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]},{"title":"Java-day23-单元测试、反射、注解、动态代理","slug":"day23-单元测试、反射、注解、动态代理","date":"2020-05-05T07:43:32.000Z","updated":"2024-02-12T11:56:31.000Z","comments":true,"path":"2020/05/05/day23-单元测试、反射、注解、动态代理/","link":"","permalink":"https://wxzhou.top/2020/05/05/day23-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"恭喜同学们，Java主要的知识我们其实已经学习得差不多了。今天同学们再把单元测试、反射、注解、动态代理学习完。Java的基础知识就算全齐活了。 首先，我们进入单元测试的学习。 一、单元测试1.1 单元测试快速入门所谓单元测试，就是针对最小的功能单元，编写测试代码对其进行正确性测试。 我们想想，咱们之前是怎么进行测试的呢？ 比如说我们写了一个学生管理系统，有添加学生、修改学生、删除学生、查询学生等这些功能。要对这些功能这几个功能进行测试，我们是在main方法中编写代码来测试的。 但是在main方法中写测试代码有如下的几个问题，如下图所示： 为了测试更加方便，有一些第三方的公司或者组织提供了很好用的测试框架，给开发者使用。这里给同学们介绍一种Junit测试框架。 Junit是第三方公司开源出来的，用于对代码进行单元测试的工具（IDEA已经集成了junit框架）。相比于在main方法中测试有如下几个优点。 我们知道单元测试是什么之后，接下来带领同学们使用一下。由于Junit是第三方提供的，所以我们需要把jar包导入到我们的项目中，才能使用，具体步骤如下图所示： 接下来，我们就按照上面的步骤，来使用一下. 先准备一个类，假设写了一个StringUtil工具类，代码如下 12345public class StringUtil&#123; public static void printNumber(String name)&#123; System.out.println(&quot;名字长度：&quot;+name.length()); &#125;&#125; 接下来，写一个测试类，测试StringUtil工具类中的方法能否正常使用。 1234567public class StringUtilTest&#123; @Test public void testPrintNumber()&#123; StringUtil.printNumber(&quot;admin&quot;); StringUtil.printNumber(null); &#125;&#125; 写完代码之后，我们会发现测试方法左边，会有一个绿色的三角形按钮。点击这个按钮，就可以运行测试方法。 1.2 单元测试断言接下来，我们学习一个单元测试的断言机制。所谓断言：意思是程序员可以预测程序的运行结果，检查程序的运行结果是否与预期一致。 我们在StringUtil类中新增一个测试方法 123456public static int getMaxIndex(String data)&#123; if(data == null)&#123; return -1; &#125; return data.length();&#125; 接下来，我们在StringUtilTest类中写一个测试方法 12345678910111213public class StringUtilTest&#123; @Test public void testGetMaxIndex()&#123; int index1 = StringUtil.getMaxIndex(null); System.out.println(index1); int index2 = StringUtil.getMaxIndex(&quot;admin&quot;); System.out.println(index2); //断言机制：预测index2的结果 Assert.assertEquals(&quot;方法内部有Bug&quot;,4,index2); &#125;&#125; 运行测试方法，结果如下图所示，表示我们预期值与实际值不一致 1.3 Junit框架的常用注解同学们，刚才我们以及学习了@Test注解，可以用来标记一个方法为测试方法，测试才能启动执行。 除了@Test注解，还有一些其他的注解，我们要知道其他注解标记的方法什么时候执行，以及其他注解在什么场景下可以使用。 接下来，我们演示一下其他注解的使用。我们在StringUtilTest测试类中，再新增几个测试方法。代码如下 123456789101112131415161718public class StringUtilTest&#123; @Before public void test1()&#123; System.out.println(&quot;--&gt; test1 Before 执行了&quot;); &#125; @BeforeClass public static void test11()&#123; System.out.println(&quot;--&gt; test11 BeforeClass 执行了&quot;); &#125; @After public void test2()&#123; System.out.println(&quot;--&gt; test2 After 执行了&quot;); &#125; @AfterCalss public static void test22()&#123; System.out.println(&quot;--&gt; test22 AfterCalss 执行了&quot;); &#125;&#125; 执行上面的测试类，结果如下图所示，观察执行结果特点如下 12341.被@BeforeClass标记的方法,执行在所有方法之前2.被@AfterCalss标记的方法，执行在所有方法之后3.被@Before标记的方法，执行在每一个@Test方法之前4.被@After标记的方法，执行在每一个@Test方法之后 我们现在已经知道每一个注解的作用了，那他们有什么用呢？应用场景在哪里? 我们来看一个例子，假设我想在每个测试方法中使用Socket对象，并且用完之后，需要把Socket关闭。代码就可以按照下面的结构来设计 1234567891011121314151617181920212223public class StringUtilTest&#123; private static Socket socket; @Before public void test1()&#123; System.out.println(&quot;--&gt; test1 Before 执行了&quot;); &#125; @BeforeClass public static void test11()&#123; System.out.println(&quot;--&gt; test11 BeforeClass 执行了&quot;); //初始化Socket对象 socket = new Socket(); &#125; @After public void test2()&#123; System.out.println(&quot;--&gt; test2 After 执行了&quot;); &#125; @AfterCalss public static void test22()&#123; System.out.println(&quot;--&gt; test22 AfterCalss 执行了&quot;); //关闭Socket socket.close(); &#125;&#125; 最后，我们再补充一点。前面的注解是基于Junit4版本的，再Junit5版本中对注解作了更新，但是作用是一样的。所以这里就不做演示了 二、反射各位小伙伴，接下来我们要学习反射技术。在学习反射之前，有几个点需要给同学们提前交代一下，接下来我们学习的反射、动态代理、注解等知识点，在以后开发中极少用到，这些技术都是以后学习框架、或者做框架的底层源码。给同学们讲这些技术的目的，是为了以后我们理解框架、或者自己开发框架给别人用作铺垫的。同时由于这些技术非常抽象，所以按照国际惯例，我们都会采用先带着大家充分的认识它们，然后再了解其作用和应用场景。 接下来，我们就需要带着同学们认识一下什么是反射。其实API文档中对反射有详细的说明，我们去了解一下。在java.lang.reflect包中对反射的解释如下图所示 翻译成人话就是：反射技术，指的是加载类的字节码到内存，并以编程的方法解刨出类中的各个成分（成员变量、方法、构造器等）。 反射有啥用呢？其实反射是用来写框架用的，但是现阶段同学们对框架还没有太多感觉。为了方便理解，我给同学们看一个我们见过的例子：平时我们用IDEA开发程序时，用对象调用方法，IDEA会有代码提示，idea会将这个对象能调用的方法都给你列举出来，供你选择，如果下图所示 问题是IDEA怎么知道这个对象有这些方法可以调用呢? 原因是对象能调用的方法全都来自于类，IDEA通过反射技术就可以获取到类中有哪些方法，并且把方法的名称以提示框的形式显示出来，所以你能看到这些提示了。 那记事本写代码为什么没有提示呢? 因为技术本软件没有利用反射技术开发这种代码提示的功能，哈哈！！ 好了，认识了反射是什么之后，接下来我还想给同学们介绍一下反射具体学什么？ 因为反射获取的是类的信息，那么反射的第一步首先获取到类才行。由于Java的设计原则是万物皆对象，获取到的类其实也是以对象的形式体现的，叫字节码对象，用Class类来表示。获取到字节码对象之后，再通过字节码对象就可以获取到类的组成成分了，这些组成成分其实也是对象，其中每一个成员变量用Field类的对象来表示、每一个成员方法用Method类的对象来表示，每一个构造器用Constructor类的对象来表示。 如下图所示： 1.1 获取类的字节码反射的第一步：是将字节码加载到内存，我们需要获取到的字节码对象。 比如有一个Student类，获取Student类的字节码代码有三种写法。不管用哪一种方式，获取到的字节码对象其实是同一个。 1234567891011121314public class Test1Class&#123; public static void main(String[] args)&#123; Class c1 = Student.class; System.out.println(c1.getName()); //获取全类名 System.out.println(c1.getSimpleName()); //获取简单类名 Class c2 = Class.forName(&quot;com.itheima.d2_reflect.Student&quot;); System.out.println(c1 == c2); //true Student s = new Student(); Class c3 = s.getClass(); System.out.println(c2 == c3); //true &#125;&#125; 1.2 获取类的构造器同学们，上一节我们已经可以获取到类的字节码对象了。接下来，我们学习一下通过字节码对象获取构造器，并使用构造器创建对象。 获取构造器，需要用到Class类提供的几个方法，如下图所示： 想要快速记住这个方法的区别，给同学们说一下这些方法的命名规律，按照规律来记就很方便了。 1234get:获取Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个public修饰的Constructor: 构造方法的意思后缀s: 表示可以获取多个，没有后缀s只能获取一个 话不多少，上代码。假设现在有一个Cat类，里面有几个构造方法，代码如下 123456789101112public class Cat&#123; private String name; private int age; public Cat()&#123; &#125; private Cat(String name, int age)&#123; &#125;&#125; 接下来，我们写一个测试方法，来测试获取类中所有的构造器 1234567891011121314public class Test2Constructor()&#123; @Test public void testGetConstructors()&#123; //1、反射第一步：必须先得到这个类的Class对象 Class c = Cat.class; //2、获取类的全部构造器 Constructor[] constructors = c.getDeclaredConstructors(); //3、遍历数组中的每一个构造器对象。 for(Constructor constructor: constructors)&#123; System.out.println(constructor.getName()+&quot;---&gt; 参数个数：&quot;+constructor.getParameterCount()); &#125; &#125;&#125; 运行测试方法打印结果如下 刚才演示的是获取Cat类中所有的构造器，接下来，我们演示单个构造器试一试 123456789101112131415161718public class Test2Constructor()&#123; @Test public void testGetConstructor()&#123; //1、反射第一步：必须先得到这个类的Class对象 Class c = Cat.class; //2、获取类public修饰的空参数构造器 Constructor constructor1 = c.getConstructor(); System.out.println(constructor1.getName()+&quot;---&gt; 参数个数：&quot;+constructor1.getParameterCount()); //3、获取private修饰的有两个参数的构造器，第一个参数String类型，第二个参数int类型 Constructor constructor2 = c.getDeclaredConstructor(String.class,int.class); System.out.println(constructor2.getName()+&quot;---&gt; 参数个数：&quot;+constructor1.getParameterCount()); &#125;&#125; 打印结果如下 1.3 反射获取构造器的作用同学们，刚才上一节我们已经获取到了Cat类中的构造器。获取到构造器后，有什么作用呢？ 其实构造器的作用：初始化对象并返回。 这里我们需要用到如下的两个方法，注意：这两个方法时属于Constructor的，需要用Constructor对象来调用。 如下图所示，constructor1和constructor2分别表示Cat类中的两个构造器。现在我要把这两个构造器执行起来 由于构造器是private修饰的，先需要调用setAccessible(true) 表示禁止检查访问控制，然后再调用newInstance(实参列表) 就可以执行构造器，完成对象的初始化了。 代码如下：为了看到构造器真的执行， 故意在两个构造器中分别加了两个打印语句 代码的执行结果如下图所示： 1.4 反射获取成员变量&amp;使用同学们，上一节我们已经学习了获取类的构造方法并使用。接下来，我们再学习获取类的成员变量，并使用。 其实套路是一样的，在Class类中提供了获取成员变量的方法，如下图所示。 这些方法的记忆规则，如下 1234get:获取Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个public修饰的Field: 成员变量的意思后缀s: 表示可以获取多个，没有后缀s只能获取一个 假设有一个Cat类它有若干个成员变量，用Class类提供 的方法将成员变量的对象获取出来。 执行完上面的代码之后，我们可以看到控制台上打印输出了，每一个成员变量的名称和它的类型。 获取到成员变量的对象之后该如何使用呢？ 在Filed类中提供给给成员变量赋值和获取值的方法，如下图所示。 再次强调一下设置值、获取值的方法时Filed类的需要用Filed类的对象来调用，而且不管是设置值、还是获取值，都需要依赖于该变量所属的对象。代码如下 执行代码，控制台会有如下的打印 1.5 反射获取成员方法各位同学，上面几节我们已经学习了反射获取构造方法、反射获取成员变量，还剩下最后一个就是反射获取成员方法并使用了。 在Java中反射包中，每一个成员方法用Method对象来表示，通过Class类提供的方法可以获取类中的成员方法对象。如下下图所示 接下来我们还是用代码演示一下：假设有一个Cat类，在Cat类中红有若干个成员方法 123456789101112131415161718192021222324252627282930313233343536373839public class Cat&#123; private String name; private int age; public Cat()&#123; System.out.println(&quot;空参数构造方法执行了&quot;); &#125; private Cat(String name, int age)&#123; System.out.println(&quot;有参数构造方法执行了&quot;); this.name=name; this.age=age; &#125; private void run()&#123; System.out.println(&quot;(&gt;^ω^&lt;)喵跑得贼快~~&quot;); &#125; public void eat()&#123; System.out.println(&quot;(&gt;^ω^&lt;)喵爱吃猫粮~&quot;); &#125; private String eat(String name)&#123; return &quot;(&gt;^ω^&lt;)喵爱吃:&quot;+name; &#125; public void setName(String name)&#123; this.name=name; &#125; public String getName()&#123; return name; &#125; public void setAge(int age)&#123; this.age=age; &#125; public int getAge()&#123; return age; &#125;&#125; 接下来，通过反射获取Cat类中所有的成员方法，每一个成员方法都是一个Method对象 1234567891011121314public class Test3Method&#123; public static void main(String[] args)&#123; //1、反射第一步：先获取到Class对象 Class c = Cat.class; //2、获取类中的全部成员方法 Method[] methods = c.getDecalaredMethods(); //3、遍历这个数组中的每一个方法对象 for(Method method : methods)&#123; System.out.println(method.getName()+&quot;--&gt;&quot;+method.getParameterCount()+&quot;--&gt;&quot;+method.getReturnType()); &#125; &#125;&#125; 执行上面的代码，运行结果如下图所示：打印输出每一个成员方法的名称、参数格式、返回值类型 也能获取单个指定的成员方法，如下图所示 获取到成员方法之后，有什么作用呢？ 在Method类中提供了方法，可以将方法自己执行起来。 下面我们演示一下，把run()方法和eat(String name)方法执行起来。看分割线之下的代码 1234567891011121314151617181920212223242526272829public class Test3Method&#123; public static void main(String[] args)&#123; //1、反射第一步：先获取到Class对象 Class c = Cat.class; //2、获取类中的全部成员方法 Method[] methods = c.getDecalaredMethods(); //3、遍历这个数组中的每一个方法对象 for(Method method : methods)&#123; System.out.println(method.getName()+&quot;--&gt;&quot;+method.getParameterCount()+&quot;--&gt;&quot;+method.getReturnType()); &#125; System.out.println(&quot;-----------------------&quot;); //4、获取private修饰的run方法，得到Method对象 Method run = c.getDecalaredMethod(&quot;run&quot;); //执行run方法,在执行前需要取消权限检查 Cat cat = new Cat(); run.setAccessible(true); Object rs1 = run.invoke(cat); System.out.println(rs1) //5、获取private 修饰的eat(String name)方法，得到Method对象 Method eat = c.getDeclaredMethod(&quot;eat&quot;,String.class); eat.setAccessible(true); Object rs2 = eat.invoke(cat,&quot;鱼儿&quot;); System.out.println(rs2) &#125;&#125; 打印结果如下图所示：run()方法执行后打印猫跑得贼快~~，返回null； eat()方法执行完，直接返回猫最爱吃:鱼儿 1.6 反射的应用各位小伙伴，按照前面我们学习反射的套路，我们已经充分认识了什么是反射，以及反射的核心作用是用来获取类的各个组成部分并执行他们。但是由于同学们的经验有限，对于反射的具体应用场景还是很难感受到的（这个目前没有太好的办法，只能慢慢积累，等经验积累到一定程度，就会豁然开朗了）。 我们一直说反射使用来写框架的，接下来，我们就写一个简易的框架，简单窥探一下反射的应用。反射其实是非常强大的，这个案例也仅仅值小试牛刀。 需求是让我们写一个框架，能够将任意一个对象的属性名和属性值写到文件中去。不管这个对象有多少个属性，也不管这个对象的属性名是否相同。 分析一下该怎么做 1234567891.先写好两个类，一个Student类和Teacher类2.写一个ObjectFrame类代表框本架 在ObjectFrame类中定义一个saveObject(Object obj)方法，用于将任意对象存到文件中去 参数：Object obj: 就表示要存入文件中的对象 3.编写方法内部的代码，往文件中存储对象的属性名和属性值 1)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。 2)接着就通过反射获取类的成员变量信息了（变量名、变量值） 3)把变量名和变量值写到文件中去 写一个ObjectFrame表示自己设计的框架，代码如下图所示 12345678910111213141516171819public class ObjectFrame&#123; public static void saveObject(Object obj) throws Exception&#123; PrintStream ps = new PrintStream(new FileOutputStream(&quot;模块名\\\\src\\\\data.txt&quot;,true)); //1)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。 //2)接着就通过反射获取类的成员变量信息了（变量名、变量值） Class c = obj.getClass(); //获取字节码 ps.println(&quot;---------&quot;+class.getSimpleName()+&quot;---------&quot;); Field[] fields = c.getDeclaredFields(); //获取所有成员变量 //3)把变量名和变量值写到文件中去 for(Field field : fields)&#123; String name = field.getName(); Object value = field.get(obj)+&quot;&quot;; ps.println(name); &#125; ps.close(); &#125;&#125; 使用自己设计的框架，往文件中写入Student对象的信息和Teacher对象的信息。 先准备好Student类和Teacher类 1234567public class Student&#123; private String name; private int age; private char sex; private double height; private String hobby;&#125; 1234public class Teacher&#123; private String name; private double salary;&#125; 创建一个测试类，在测试中类创建一个Student对象，创建一个Teacher对象，用ObjectFrame的方法把这两个对象所有的属性名和属性值写到文件中去。 12345678910public class Test5Frame&#123; @Test public void save() throws Exception&#123; Student s1 = new Student(&quot;黑马吴彦祖&quot;,45, &#x27;男&#x27;, 185.3, &quot;篮球，冰球，阅读&quot;); Teacher s2 = new Teacher(&quot;播妞&quot;,999.9); ObjectFrame.save(s1); ObjectFrame.save(s2); &#125;&#125; 打开data.txt文件，内容如下图所示，就说明我们这个框架的功能已经实现了 好了，同学们，恭喜大家！学习到这里，反射技术已经学习完毕了。 三、注解3.1 认识注解&amp;定义注解各位小伙伴，接下来我们学习注解。注解和反射一样，都是用来做框架的，我们这里学习注解的目的其实是为了以后学习框架或者做框架做铺垫的。 那注解该怎么学呢？和反射的学习套路一样，我们先充分的认识注解，掌握注解的定义和使用格式，然后再学习它的应用场景。 先来认识一下什么是注解？ Java注解是代码中的特殊标记，比如@Override、@Test等，作用是：让其他程序根据注解信息决定怎么执行该程序。 比如：Junit框架的@Test注解可以用在方法上，用来标记这个方法是测试方法，被@Test标记的方法能够被Junit框架执行。 再比如：@Override注解可以用在方法上，用来标记这个方法是重写方法，被@Override注解标记的方法能够被IDEA识别进行语法检查。 注解不光可以用在方法上，还可以用在类上、变量上、构造器上等位置。 上面我们说的@Test注解、@Overide注解是别人定义好给我们用的，将来如果需要自己去开发框架，就需要我们自己定义注解。 接着我们学习自定义注解 自定义注解的格式如下图所示 比如：现在我们自定义一个MyTest注解 12345public @interface MyTest&#123; String aaa(); boolean bbb() default true; //default true 表示默认值为true,使用时可以不赋值。 String[] ccc();&#125; 定义好MyTest注解之后，我们可以使用MyTest注解在类上、方法上等位置做标记。注意使用注解时需要加@符号，如下 1234567@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)public class AnnotationTest1&#123; @MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;) public void test1()&#123; &#125;&#125; 注意：注解的属性名如何是value的话，并且只有value没有默认值，使用注解时value名称可以省略。比如现在重新定义一个MyTest2注解 1234public @interface MyTest2&#123; String value(); //特殊属性 int age() default 10;&#125; 定义好MyTest2注解后，再将@MyTest2标记在类上，此时value属性名可以省略，代码如下 12345678@MyTest2(&quot;孙悟空&quot;) //等价于 @MyTest2(value=&quot;孙悟空&quot;)@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)public class AnnotationTest1&#123; @MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;) public void test1()&#123; &#125;&#125; 到这里关于定义注解的格式、以及使用注解的格式就学习完了。 注解本质是什么呢？ 想要搞清楚注解本质是什么东西，我们可以把注解的字节码进行反编译，使用XJad工具进行反编译。经过对MyTest1注解字节码反编译我们会发现： 12341.MyTest1注解本质上是接口，每一个注解接口都继承子Annotation接口2.MyTest1注解中的属性本质上是抽象方法3.@MyTest1实际上是作为MyTest接口的实现类对象4.@MyTest1(aaa=&quot;孙悟空&quot;,bbb=false,ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)里面的属性值，可以通过调用aaa()、bbb()、ccc()方法获取到。 【别着急，继续往下看，再解析注解时会用到】 3.2 元注解各位小伙伴，刚才我们已经认识了注解以及注解的基本使用。接下来我们还需要学习几种特殊的注解，叫做元注解。 什么是元注解？ 元注解是修饰注解的注解。这句话虽然有一点饶，但是非常准确。我们看一个例子 接下来分别看一下@Target注解和@Retention注解有什么作用，如下图所示 12@Target是用来声明注解只能用在那些位置，比如：类上、方法上、成员变量上等@Retetion是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期 @Target元注解的使用：比如定义一个MyTest3注解，并添加@Target注解用来声明MyTest3的使用位置 1234@Target(ElementType.TYPE) //声明@MyTest3注解只能用在类上public @interface MyTest3&#123; &#125; 接下来，我们把@MyTest3用来类上观察是否有错，再把@MyTest3用在方法上、变量上再观察是否有错 如果我们定义MyTest3注解时，使用@Target注解属性值写成下面样子 12345//声明@MyTest3注解只能用在类上和方法上@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;) public @interface MyTest3&#123; &#125; 此时再观察，@MyTest用在类上、方法上、变量上是否有错 到这里@Target元注解的使用就演示完毕了。 @Retetion元注解的使用：定义MyTest3注解时，给MyTest3注解添加@Retetion注解来声明MyTest3注解保留的时期 12345@Retetion是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期 @Retetion(RetetionPloicy.SOURCE): 注解保留到源代码时期、字节码中就没有了 @Retetion(RetetionPloicy.CLASS): 注解保留到字节码中、运行时注解就没有了 @Retetion(RetetionPloicy.RUNTIME)：注解保留到运行时期 【自己写代码时，比较常用的是保留到运行时期】 1234567//声明@MyTest3注解只能用在类上和方法上@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;) //控制使用了@MyTest3注解的代码中，@MyTest3保留到运行时期@Retetion(RetetionPloicy.RUNTIME)public @interface MyTest3&#123; &#125; 3.3 解析注解各位小伙伴，通过前面的学习我们能够自己定义注解，也能够把自己定义的注解标记在类上或者方法上等位置，但是总感觉有点别扭，给类、方法、变量等加上注解后，我们也没有干什么呀！！！ 接下来，我们就要做点什么。我们可以通过反射技术把类上、方法上、变量上的注解对象获取出来，然后通过调用方法就可以获取注解上的属性值了。我们把获取类上、方法上、变量上等位置注解及注解属性值的过程称为解析注解。 解析注解套路如下 12341.如果注解在类上，先获取类的字节码对象，再获取类上的注解2.如果注解在方法上，先获取方法对象，再获取方法上的注解3.如果注解在成员变量上，先获取成员变量对象，再获取变量上的注解总之：注解在谁身上，就先获取谁，再用谁获取谁身上的注解 解析来看一个案例，来演示解析注解的代码编写 按照需求要求一步一步完成 ① 先定义一个MyTest4注解 123456789//声明@MyTest4注解只能用在类上和方法上@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;) //控制使用了@MyTest4注解的代码中，@MyTest4保留到运行时期@Retetion(RetetionPloicy.RUNTIME)public @interface MyTest4&#123; String value(); double aaa() default 100; String[] bbb();&#125; ② 定义有一个类Demo 1234567@MyTest4(value=&quot;蜘蛛侠&quot;,aaa=99.9, bbb=&#123;&quot;至尊宝&quot;,&quot;黑马&quot;&#125;)public class Demo&#123; @MyTest4(value=&quot;孙悟空&quot;,aaa=199.9, bbb=&#123;&quot;紫霞&quot;,&quot;牛夫人&quot;&#125;) public void test1()&#123; &#125;&#125; ③ 写一个测试类AnnotationTest3解析Demo类上的MyTest4注解 12345678910111213141516171819202122232425262728293031323334public class AnnotationTest3&#123; @Test public void parseClass()&#123; //1.先获取Class对象 Class c = Demo.class; //2.解析Demo类上的注解 if(c.isAnnotationPresent(MyTest4.class))&#123; //获取类上的MyTest4注解 MyTest4 myTest4 = (MyTest4)c.getDeclaredAnnotation(MyTest4.class); //获取MyTests4注解的属性值 System.out.println(myTest4.value()); System.out.println(myTest4.aaa()); System.out.println(myTest4.bbb()); &#125; &#125; @Test public void parseMethods()&#123; //1.先获取Class对象 Class c = Demo.class; //2.解析Demo类中test1方法上的注解MyTest4注解 Method m = c.getDeclaredMethod(&quot;test1&quot;); if(m.isAnnotationPresent(MyTest4.class))&#123; //获取方法上的MyTest4注解 MyTest4 myTest4 = (MyTest4)m.getDeclaredAnnotation(MyTest4.class); //获取MyTests4注解的属性值 System.out.println(myTest4.value()); System.out.println(myTest4.aaa()); System.out.println(myTest4.bbb()); &#125; &#125;&#125; 3.4 注解的应用场景各位同学，关于注解的定义、使用、解析注解就已经学习完了。接下来，我们再学习一下注解的应用场景，注解是用来写框架的，比如现在我们要模拟Junit写一个测试框架，要求有@MyTest注解的方法可以被框架执行，没有@MyTest注解的方法不能被框架执行。 第一步：先定义一个MyTest注解 12345@Target(ElementType.METHOD) @Retetion(RetetionPloicy.RUNTIME)public @interface MyTest&#123; &#125; 第二步：写一个测试类AnnotationTest4，在类中定义几个被@MyTest注解标记的方法 1234567891011121314151617181920212223242526272829303132public class AnnotationTest4&#123; @MyTest public void test1()&#123; System.out.println(&quot;=====test1====&quot;); &#125; @MyTest public void test2()&#123; System.out.println(&quot;=====test2====&quot;); &#125; public void test3()&#123; System.out.println(&quot;=====test2====&quot;); &#125; public static void main(String[] args)&#123; AnnotationTest4 a = new AnnotationTest4(); //1.先获取Class对象 Class c = AnnotationTest4.class; //2.解析AnnotationTest4类中所有的方法对象 Method[] methods = c.getDeclaredMethods(); for(Method m: methods)&#123; //3.判断方法上是否有MyTest注解，有就执行该方法 if(m.isAnnotationPresent(MyTest.class))&#123; m.invoke(a); &#125; &#125; &#125;&#125; 恭喜小伙伴们，学习到这里，关于注解的使用就学会了(^▽^) 四、动态代理4.1 动态代理介绍、准备功能各位同学，这节课我们学习一个Java的高级技术叫做动态代理。首先我们认识一下代理长什么样？我们以大明星“杨超越”例。 假设现在有一个大明星叫杨超越，它有唱歌和跳舞的本领，作为大明星是要用唱歌和跳舞来赚钱的，但是每次做节目，唱歌的时候要准备话筒、收钱，再唱歌；跳舞的时候也要准备场地、收钱、再唱歌。杨超越越觉得我擅长的做的事情是唱歌，和跳舞，但是每次唱歌和跳舞之前或者之后都要做一些繁琐的事情，有点烦。于是杨超越就找个一个经济公司，请了一个代理人，代理杨超越处理这些事情，如果有人想请杨超越演出，直接找代理人就可以了。如下图所示 我们说杨超越的代理是中介公司派的，那中介公司怎么知道，要派一个有唱歌和跳舞功能的代理呢？ 解决这个问题，Java使用的是接口，杨超越想找代理，在Java中需要杨超越实现了一个接口，接口中规定要唱歌和跳舞的方法。Java就可以通过这个接口为杨超越生成一个代理对象，只要接口中有的方法代理对象也会有。 接下来我们就先把有唱歌和跳舞功能的接口，和实现接口的大明星类定义出来。 4.2 生成动态代理对象下面我们写一个为BigStar生成动态代理对象的工具类。这里需要用Java为开发者提供的一个生成代理对象的类叫Proxy类。 通过Proxy类的newInstance(…)方法可以为实现了同一接口的类生成代理对象。 调用方法时需要传递三个参数，该方法的参数解释可以查阅API文档，如下。 123456789101112131415161718192021222324252627public class ProxyUtil &#123; public static Star createProxy(BigStar bigStar)&#123; /* newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 参数1：用于指定一个类加载器 参数2：指定生成的代理长什么样子，也就是有哪些方法 参数3：用来指定生成的代理对象要干什么事情 */ // Star starProxy = ProxyUtil.createProxy(s); // starProxy.sing(&quot;好日子&quot;) starProxy.dance() Star starProxy = (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(), new Class[]&#123;Star.class&#125;, new InvocationHandler() &#123; @Override // 回调方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理对象要做的事情，会在这里写代码 if(method.getName().equals(&quot;sing&quot;))&#123; System.out.println(&quot;准备话筒，收钱20万&quot;); &#125;else if(method.getName().equals(&quot;dance&quot;))&#123; System.out.println(&quot;准备场地，收钱1000万&quot;); &#125; return method.invoke(bigStar, args); &#125; &#125;); return starProxy; &#125;&#125; 调用我们写好的ProxyUtil工具类，为BigStar对象生成代理对象 1234567891011public class Test &#123; public static void main(String[] args) &#123; BigStar s = new BigStar(&quot;杨超越&quot;); Star starProxy = ProxyUtil.createProxy(s); String rs = starProxy.sing(&quot;好日子&quot;); System.out.println(rs); starProxy.dance(); &#125;&#125; 运行测试类，结果如下图所示 恭喜同学们，当你把上面的案例写出来，并且理解，那么动态代理的基本使用就学会了。 4.3 动态代理应用学习完动态代理的基本使用之后，接下来我们再做一个应用案例。 现有如下代码 1234567891011/** * 用户业务接口 */public interface UserService &#123; // 登录功能 void login(String loginName,String passWord) throws Exception; // 删除用户 void deleteUsers() throws Exception; // 查询用户，返回数组的形式。 String[] selectUsers() throws Exception;&#125; 下面有一个UserService接口的实现类，下面每一个方法中都有计算方法运行时间的代码。 12345678910111213141516171819202122232425262728293031323334353637/** * 用户业务实现类（面向接口编程） */public class UserServiceImpl implements UserService&#123; @Override public void login(String loginName, String passWord) throws Exception &#123; long time1 = System.currentTimeMillis(); if(&quot;admin&quot;.equals(loginName) &amp;&amp; &quot;123456&quot;.equals(passWord))&#123; System.out.println(&quot;您登录成功，欢迎光临本系统~&quot;); &#125;else &#123; System.out.println(&quot;您登录失败，用户名或密码错误~&quot;); &#125; Thread.sleep(1000); long time2 = System.currentTimeMillis(); System.out.println(&quot;login方法耗时：&quot;+(time2-time1)); &#125; @Override public void deleteUsers() throws Exception&#123; long time1 = System.currentTimeMillis(); System.out.println(&quot;成功删除了1万个用户~&quot;); Thread.sleep(1500); long time2 = System.currentTimeMillis(); System.out.println(&quot;deleteUsers方法耗时：&quot;+(time2-time1)); &#125; @Override public String[] selectUsers() throws Exception&#123; long time1 = System.currentTimeMillis(); System.out.println(&quot;查询出了3个用户&quot;); String[] names = &#123;&quot;张全蛋&quot;, &quot;李二狗&quot;, &quot;牛爱花&quot;&#125;; Thread.sleep(500); long time2 = System.currentTimeMillis(); System.out.println(&quot;selectUsers方法耗时：&quot;+(time2-time1)); return names; &#125;&#125; 观察上面代码发现有什么问题吗？ 我们会发现每一个方法中计算耗时的代码都是重复的，我们可是学习了动态代理的高级程序员，怎么能忍受在每个方法中写重复代码呢！况且这些重复的代码并不属于UserSerivce的主要业务代码。 所以接下来我们打算，把计算每一个方法的耗时操作，交给代理对象来做。 先在UserService类中把计算耗时的代码删除，代码如下 123456789101112131415161718192021222324252627282930/** * 用户业务实现类（面向接口编程） */public class UserServiceImpl implements UserService&#123; @Override public void login(String loginName, String passWord) throws Exception &#123; if(&quot;admin&quot;.equals(loginName) &amp;&amp; &quot;123456&quot;.equals(passWord))&#123; System.out.println(&quot;您登录成功，欢迎光临本系统~&quot;); &#125;else &#123; System.out.println(&quot;您登录失败，用户名或密码错误~&quot;); &#125; Thread.sleep(1000); &#125; @Override public void deleteUsers() throws Exception&#123; System.out.println(&quot;成功删除了1万个用户~&quot;); Thread.sleep(1500); &#125; @Override public String[] selectUsers() throws Exception&#123; System.out.println(&quot;查询出了3个用户&quot;); String[] names = &#123;&quot;张全蛋&quot;, &quot;李二狗&quot;, &quot;牛爱花&quot;&#125;; Thread.sleep(500); return names; &#125;&#125; 然后为UserService生成一个动态代理对象，在动态代理中调用目标方法，在调用目标方法之前和之后记录毫秒值，并计算方法运行的时间。代码如下 123456789101112131415161718192021222324252627282930public class ProxyUtil &#123; public static UserService createProxy(UserService userService)&#123; UserService userServiceProxy = (UserService) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(), new Class[]&#123;UserService.class&#125;, new InvocationHandler() &#123; @Override public Object invoke( Object proxy, Method method, Object[] args) throws Throwable &#123; if( method.getName().equals(&quot;login&quot;) || method.getName().equals(&quot;deleteUsers&quot;)|| method.getName().equals(&quot;selectUsers&quot;))&#123; //方法运行前记录毫秒值 long startTime = System.currentTimeMillis(); //执行方法 Object rs = method.invoke(userService, args); //执行方法后记录毫秒值 long endTime = System.currentTimeMillis(); System.out.println(method.getName() + &quot;方法执行耗时：&quot; + (endTime - startTime)/ 1000.0 + &quot;s&quot;); return rs; &#125;else &#123; Object rs = method.invoke(userService, args); return rs; &#125; &#125; &#125;); //返回代理对象 return userServiceProxy; &#125;&#125; 在测试类中为UserService创建代理对象 123456789101112131415161718192021/** * 目标：使用动态代理解决实际问题，并掌握使用代理的好处。 */public class Test &#123; public static void main(String[] args) throws Exception&#123; // 1、创建用户业务对象。 UserService userService = ProxyUtil.createProxy(new UserServiceImpl()); // 2、调用用户业务的功能。 userService.login(&quot;admin&quot;, &quot;123456&quot;); System.out.println(&quot;----------------------------------&quot;); userService.deleteUsers(); System.out.println(&quot;----------------------------------&quot;); String[] names = userService.selectUsers(); System.out.println(&quot;查询到的用户是：&quot; + Arrays.toString(names)); System.out.println(&quot;----------------------------------&quot;); &#125;&#125; 执行结果如下图所示 动态代理对象的执行流程如下图所示，每次用代理对象调用方法时，都会执行InvocationHandler中的invoke方法。 恭喜同学们，动态代理我们已经学习完了。到此整个JavaSE的课程也学习完了。","categories":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://wxzhou.top/categories/Linux/"},{"name":"GIT","slug":"GIT","permalink":"https://wxzhou.top/categories/GIT/"},{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/categories/Python/"},{"name":"kafka","slug":"kafka","permalink":"https://wxzhou.top/categories/kafka/"},{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Blog","slug":"Blog","permalink":"https://wxzhou.top/categories/Blog/"},{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/categories/Java/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wxzhou.top/tags/Linux/"},{"name":"IDEA","slug":"IDEA","permalink":"https://wxzhou.top/tags/IDEA/"},{"name":"GIT","slug":"GIT","permalink":"https://wxzhou.top/tags/GIT/"},{"name":"Python","slug":"Python","permalink":"https://wxzhou.top/tags/Python/"},{"name":"Server","slug":"Server","permalink":"https://wxzhou.top/tags/Server/"},{"name":"Pytorch","slug":"Pytorch","permalink":"https://wxzhou.top/tags/Pytorch/"},{"name":"Pycharm","slug":"Pycharm","permalink":"https://wxzhou.top/tags/Pycharm/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://wxzhou.top/tags/Anaconda/"},{"name":"kafka","slug":"kafka","permalink":"https://wxzhou.top/tags/kafka/"},{"name":"面试","slug":"面试","permalink":"https://wxzhou.top/tags/%E9%9D%A2%E8%AF%95/"},{"name":"GitHub","slug":"GitHub","permalink":"https://wxzhou.top/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://wxzhou.top/tags/Hexo/"},{"name":"Java","slug":"Java","permalink":"https://wxzhou.top/tags/Java/"}]}