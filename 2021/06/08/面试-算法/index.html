<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="baidu-site-verification" content="codeva-G3l7rnjbue"><link rel="icon" href="favicon.png"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>面试-算法 | wxzhou&#39;s blog</title><meta name="description" content="1主要总结算法的模板题 1. 输入输出123常用的数据输入方法有两种，Scanner和BufferedReader。BufferedReader可以读一行，速度比Scanner快，所以数据较多的时候使用。注意BufferedReader用完记得关。 1.1 输入123456789101112131415161718192021222324252627282930313233343536373839"><meta property="og:type" content="article"><meta property="og:title" content="面试-算法"><meta property="og:url" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/index.html"><meta property="og:site_name" content="wxzhou&#39;s blog"><meta property="og:description" content="1主要总结算法的模板题 1. 输入输出123常用的数据输入方法有两种，Scanner和BufferedReader。BufferedReader可以读一行，速度比Scanner快，所以数据较多的时候使用。注意BufferedReader用完记得关。 1.1 输入123456789101112131415161718192021222324252627282930313233343536373839"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/1.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/2.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/3.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/4.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8_1.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8_2.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_1.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_3.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_4.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_5.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_6.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_7.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_8.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_9.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_10.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E5%A0%86_1.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E5%A0%86_2.png"><meta property="article:published_time" content="2021-06-08T11:50:53.000Z"><meta property="article:modified_time" content="2024-02-12T11:56:31.000Z"><meta property="article:author" content="wxzhou"><meta property="article:tag" content="面试"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/1.png"><link rel="canonical" href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/index.html"><link rel="alternate" href="/atom.xml" title="wxzhou&#39;s blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/wx-zhou" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">wxzhou</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Development</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="Search"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">Home</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">Archives</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">Categories</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">Tags</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">Repository</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">Links</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">About</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/wx-zhou" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/wxzhou" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">Board</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">Categories</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIT/">GIT</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="category-list-count">5</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tags</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anaconda/" rel="tag">Anaconda</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GIT/" rel="tag">GIT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pycharm/" rel="tag">Pycharm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pytorch/" rel="tag">Pytorch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Server/" rel="tag">Server</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">5</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tag Cloud</h3><div class="widget-body tagcloud"><a href="/tags/Anaconda/" style="font-size:13px">Anaconda</a> <a href="/tags/GIT/" style="font-size:13px">GIT</a> <a href="/tags/GitHub/" style="font-size:13px">GitHub</a> <a href="/tags/Hexo/" style="font-size:13px">Hexo</a> <a href="/tags/IDEA/" style="font-size:13px">IDEA</a> <a href="/tags/Java/" style="font-size:14px">Java</a> <a href="/tags/Linux/" style="font-size:13.25px">Linux</a> <a href="/tags/Pycharm/" style="font-size:13px">Pycharm</a> <a href="/tags/Python/" style="font-size:13.5px">Python</a> <a href="/tags/Pytorch/" style="font-size:13px">Pytorch</a> <a href="/tags/Server/" style="font-size:13.25px">Server</a> <a href="/tags/kafka/" style="font-size:13px">kafka</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size:13.75px">面试</a></div></div><div class="widget"><h3 class="widget-title">Archive</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">24</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Recent Posts</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Linux/">Linux</a></p><p class="item-title"><a href="/2023/08/20/Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5(%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96)/" class="title">Linux云服务器故障排查（内存优化）</a></p><p class="item-date"><time datetime="2023-08-20T07:51:44.000Z" itemprop="datePublished">2023-08-20</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/GIT/">GIT</a></p><p class="item-title"><a href="/2023/07/20/%E8%A7%A3%E5%86%B3IDEA%E9%85%8D%E7%BD%AE-gitignore%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/" class="title">解决IDEA配置.gitignore不生效的问题</a></p><p class="item-date"><time datetime="2023-07-20T11:05:29.000Z" itemprop="datePublished">2023-07-20</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Python/">Python</a></p><p class="item-title"><a href="/2023/02/18/%E6%9F%A5%E7%9C%8B%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%89%80%E6%9C%89%E6%98%BE%E5%8D%A1%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%85%E5%92%8CGPU%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/" class="title">查看一台服务器上所有显卡上的使用者和GPU占用情况</a></p><p class="item-date"><time datetime="2023-02-18T04:34:49.000Z" itemprop="datePublished">2023-02-18</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Linux/">Linux</a></p><p class="item-title"><a href="/2023/02/15/Linux%E4%B8%8B%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/" class="title">Linux下在文件夹所有文件中查找相关内容</a></p><p class="item-date"><time datetime="2023-02-15T07:51:44.000Z" itemprop="datePublished">2023-02-15</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Linux/">Linux</a></p><p class="item-title"><a href="/2023/02/15/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" class="title">Linux服务器环境安装</a></p><p class="item-date"><time datetime="2023-02-15T07:51:44.000Z" itemprop="datePublished">2023-02-15</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-面试-算法" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">面试-算法</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/" class="article-date"><time datetime="2021-06-08T11:50:53.000Z" itemprop="datePublished">2021-06-08</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/#comments" class="article-comment-link">Comments</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 11.7k(words)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 56(minutes)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要总结算法的模板题</span><br></pre></td></tr></table></figure><h2 id="1-输入输出"><a href="#1-输入输出" class="headerlink" title="1. 输入输出"></a>1. 输入输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常用的数据输入方法有两种，Scanner和BufferedReader。</span><br><span class="line">BufferedReader可以读一行，速度比Scanner快，所以数据较多的时候使用。</span><br><span class="line">注意BufferedReader用完记得关。</span><br></pre></td></tr></table></figure><h3 id="1-1-输入"><a href="#1-1-输入" class="headerlink" title="1.1 输入"></a>1.1 输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入包</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="comment">//2. 抛出IOException异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 3. 定义BufferedReader类</span></span><br><span class="line">        <span class="comment">// 最后不要忘了关闭reader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 只读取一行字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="comment">// 连续读取多行字符串</span></span><br><span class="line">        String string2;</span><br><span class="line">        <span class="keyword">while</span>((str = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果不为空，才进行下述操作</span></span><br><span class="line">            System.out.println(string2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * char</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 一行一个char</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ca</span> <span class="operator">=</span> reader.readLine().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 一行一个char数组</span></span><br><span class="line">        <span class="type">char</span>[] charArray = reader.readLine().toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 整型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 一行一个整数</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">short1</span> <span class="operator">=</span> Short.parseShort(reader.readLine());</span><br><span class="line">        <span class="type">int</span> <span class="variable">int1</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="type">long</span> <span class="variable">long1</span> <span class="operator">=</span> Long.parseLong(reader.readLine());</span><br><span class="line">        <span class="comment">// 一行多个整数</span></span><br><span class="line">        String[] sList = reader.readLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">//用空格分割，也可以用逗号分割</span></span><br><span class="line">        <span class="keyword">for</span> (String s : sList)&#123;</span><br><span class="line">            <span class="comment">// String转为整数</span></span><br><span class="line">            System.out.println(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转化为int数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[s.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            arr[i] = Integer.parseInt(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 浮点型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// float</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(reader.readLine());</span><br><span class="line">        <span class="comment">// double</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(reader.readLine());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(reader.readLine());</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(reader.readLine());</span><br><span class="line">        <span class="comment">// 加</span></span><br><span class="line">        System.out.println(bigInteger1.add(bigInteger2));</span><br><span class="line">        <span class="comment">// 减 </span></span><br><span class="line">        System.out.println(bigInteger1.subtract(bigInteger2));</span><br><span class="line">        <span class="comment">// 乘</span></span><br><span class="line">        System.out.println(bigInteger1.multiply(bigInteger2));</span><br><span class="line">        <span class="comment">// 除</span></span><br><span class="line">        System.out.println(bigInteger1.divide(bigInteger2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 高精度浮点数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(reader.readLine());</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(reader.readLine());</span><br><span class="line">        <span class="comment">// 加</span></span><br><span class="line">        System.out.println(bigDecimal1.add(bigDecimal2));</span><br><span class="line">        <span class="comment">// 减</span></span><br><span class="line">        System.out.println(bigDecimal1.subtract(bigDecimal2));</span><br><span class="line">        <span class="comment">// 乘</span></span><br><span class="line">        System.out.println(bigDecimal1.multiply(bigDecimal2));</span><br><span class="line">        <span class="comment">// 除</span></span><br><span class="line">        System.out.println(bigDecimal1.divide(bigDecimal2, <span class="number">3</span>, RoundingMode.HALF_UP)); <span class="comment">// 第二个参数：保留小数位数；第三位参数：四舍五入模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进制</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 字符串转2进制int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">int2</span> <span class="operator">=</span> Integer.parseInt(reader.readLine(), <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 字符串转2进制大数</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(reader.readLine(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * double格式化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 导入包：import java.text.*;</span></span><br><span class="line">        NumberFormat formatter;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">1234.567</span>;</span><br><span class="line">        <span class="comment">// 强制在整数部分加0：0，多几位就多几个0</span></span><br><span class="line">        formatter = <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000000&quot;</span>);</span><br><span class="line">        s = formatter.format(d);</span><br><span class="line">        System.out.println(s);                  <span class="comment">// -001235</span></span><br><span class="line">        formatter = <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00&quot;</span>);</span><br><span class="line">        s = formatter.format(d);</span><br><span class="line">        System.out.println(s);                  <span class="comment">// -1235</span></span><br><span class="line">        <span class="comment">// 强制保留小数部分：0，有几个0就保留几位小数</span></span><br><span class="line">        formatter = <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000000.00&quot;</span>);</span><br><span class="line">        s = formatter.format(d);</span><br><span class="line">        System.out.println(s);                  <span class="comment">// -001235.57</span></span><br><span class="line">        formatter = <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;.00&quot;</span>);</span><br><span class="line">        s = formatter.format(d);</span><br><span class="line">        System.out.println(s);                  <span class="comment">// -1235.57</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;array默认升序_________________________________________________&quot;</span>);</span><br><span class="line">        <span class="comment">//默认升序，从小到大</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;array降序_______________________________________________&quot;</span>);</span><br><span class="line">        Integer[] arr2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">// 只支持包装类元素逆序</span></span><br><span class="line">        Arrays.sort(arr2,Collections.reverseOrder());</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;List默认升序_______________________________________________&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; arrList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrList.add(<span class="number">1</span>);arrList.add(<span class="number">4</span>);arrList.add(<span class="number">2</span>);arrList.add(<span class="number">78</span>);arrList.add(<span class="number">23</span>);</span><br><span class="line">        <span class="comment">//集合工具类Collections，对集合进行升序排序</span></span><br><span class="line">        Collections.sort(arrList);</span><br><span class="line">        System.out.println(Arrays.toString(arrList.toArray()));</span><br><span class="line">        System.out.println(<span class="string">&quot;List降序__________________________________________________&quot;</span>);</span><br><span class="line">        Collections.sort(arrList,Collections.reverseOrder());</span><br><span class="line">        System.out.println(Arrays.toString(arrList.toArray()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭reader</span></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-输出"><a href="#1-2-输出" class="headerlink" title="1.2 输出"></a>1.2 输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1. 单行输出</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">// 2. 多行输出</span><br><span class="line">System.out.println(result1);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">System.out.println(result3);</span><br><span class="line"></span><br><span class="line">// 3. 格式化输出</span><br><span class="line">System.out.printf(&quot;Formatted result: %.2f&quot;, floatValue);</span><br><span class="line"></span><br><span class="line">// 4. 输出数组或集合</span><br><span class="line">int[] array = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int num : array) &#123;</span><br><span class="line">    System.out.print(num + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5. 特殊字符输出</span><br><span class="line">System.out.println(&quot;Line 1\nLine 2\tTabbed&quot;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2. 排序算法"></a>2. 排序算法</h2><h3 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A(排序) --&gt; B(内部排序)</span><br><span class="line">A(排序) --&gt; C(外部排序)</span><br><span class="line"></span><br><span class="line">B --&gt; D(选择排序)</span><br><span class="line">B --&gt; E(插入排序)</span><br><span class="line">B --&gt; F(交换排序)</span><br><span class="line">B --&gt; G(归并排序)</span><br><span class="line">B --&gt; H(桶排序)</span><br><span class="line"></span><br><span class="line">C --&gt; I(多路归并)</span><br><span class="line">C --&gt; J(败者树)</span><br><span class="line"></span><br><span class="line">D --&gt; K(直接选择排序)</span><br><span class="line">D --&gt; L(堆排序)</span><br><span class="line"></span><br><span class="line">E --&gt; M(直接插入排序)</span><br><span class="line">E --&gt; N(希尔排序)</span><br><span class="line"></span><br><span class="line">F --&gt; O(冒泡排序)</span><br><span class="line">F --&gt; P(快速排序)</span><br><span class="line"></span><br><span class="line">H --&gt; Q(计数排序)</span><br><span class="line">H --&gt; R(基数排序)</span><br></pre></td></tr></table></figure><h3 id="2-2-时间复杂度和空间复杂度"><a href="#2-2-时间复杂度和空间复杂度" class="headerlink" title="2.2 时间复杂度和空间复杂度"></a>2.2 时间复杂度和空间复杂度</h3><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>最好时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>直接选择排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n<sup>2</sup>)</td><td>O(nlogn)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(ns)</td><td>O(n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(N*M)</td><td>O(N*M)</td><td>O(N*M)</td><td>O(M)</td><td>稳定</td></tr></tbody></table><p><strong>注</strong>：基数排序: 基数排序时间复杂度为O(N*M)，其中N为数据个数，M为数据位数。</p><p><strong>记忆</strong>：</p><ul><li>时间复杂度：<ul><li>冒泡、选择、插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)）（一遍找元素O(n)，一遍找位置O(n)）</li><li>快速、堆、希尔、归并基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）</li></ul></li><li>稳定性：<ul><li>“快希选堆”（快牺牲稳定性）</li><li>排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。</li></ul></li></ul><h3 id="2-3-原理"><a href="#2-3-原理" class="headerlink" title="2.3 原理"></a>2.3 原理</h3><ul><li><p>冒泡排序</p><ul><li>原理：从数组最左端开始向右遍历，依次比较相邻元素大小，如果”左元素 &gt; 右元素”就交换它俩。遍历完成后，最大的元素会被移动到数组的最右端。</li><li>算法流程：<ul><li>首先，对n个元素执行”冒泡”，将数组的最大元素交换至正确位置，</li><li>接下来，对剩余n-1个元素执行”冒泡”，将第二大元素交换至正确位置。</li><li>以此类推，经过n-1轮”冒泡”后，前n-1大的元素都被交换至正确位置。</li><li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li></ul></li><li>图示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/1.png"></li><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 冒泡排序 */</span><br><span class="line">void bubbleSort(int[] nums) &#123;</span><br><span class="line">    // 外循环：未排序区间为 [0, i]</span><br><span class="line">    for (int i = nums.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 </span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[j] &gt; nums[j + 1]) &#123;</span><br><span class="line">                // 交换 nums[j] 与 nums[j + 1]</span><br><span class="line">                int tmp = nums[j];</span><br><span class="line">                nums[j] = nums[j + 1];</span><br><span class="line">                nums[j + 1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>选择排序：</p><ul><li>原理：轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</li><li>算法流程：<ul><li>初始状态下，所有元素未排序，即未排序（索引）区间为[0,n-1]。</li><li>选取区间[0,n-1]中的最小元素，将其与索引0处元素交换。完成后，数组前1个元素已排序。</li><li>选取区间[1,n-1]中的最小元素，将其与索引1处元素交换。完成后，数组前2个元素已排序。</li><li>以此类推。经过n-1轮选择与交换后，数组前n-1个元素已排序。</li><li>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。</li></ul></li><li>图示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/2.png"></li><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 选择排序 */</span><br><span class="line">void selectionSort(int[] nums) &#123;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    // 外循环：未排序区间为 [i, n-1]</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        // 内循环：找到未排序区间内的最小元素</span><br><span class="line">        int k = i;</span><br><span class="line">        for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[k])</span><br><span class="line">                k = j; // 记录最小元素的索引</span><br><span class="line">        &#125;</span><br><span class="line">        // 将该最小元素与未排序区间的首个元素交换</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        nums[i] = nums[k];</span><br><span class="line">        nums[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>插入排序</p><ul><li>原理：在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</li><li>算法流程：<ul><li>初始状态下，数组的第1个元素已完成排序。</li><li>选取数组的第2个元素作为base，将其插入到正确位置后，数组的前2个元素已排序。</li><li>选取第3个元素作为base，将其插入到正确位置后，数组的前3个元素已排序。</li><li>以此类推，在最后一轮中，选取最后一个元素作为base，将其插入到正确位置后，所有元素均已排序。</li></ul></li><li>图示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/3.png"></li><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 插入排序 */</span><br><span class="line">void insertionSort(int[] nums) &#123;</span><br><span class="line">    // 外循环：已排序元素数量为 1, 2, ..., n</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int base = nums[i], j = i - 1;</span><br><span class="line">        // 内循环：将 base 插入到已排序部分的正确位置</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + 1] = base;        // 将 base 赋值到正确位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>快速排序：</p><ul><li>原理：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</li><li>算法流程：<ul><li>选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端。</li><li>设置一个循环，在每轮中使用i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li><li>循环执行步骤2，直到i和j相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ul></li><li>图示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/4.png"></li><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* 元素交换 */</span><br><span class="line">void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 哨兵划分 */</span><br><span class="line">int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 以 nums[left] 作为基准数</span><br><span class="line">    int i = left, j = right;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])</span><br><span class="line">            j--;          // 从右向左找首个小于基准数的元素</span><br><span class="line">        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])</span><br><span class="line">            i++;          // 从左向右找首个大于基准数的元素</span><br><span class="line">        swap(nums, i, j); // 交换这两个元素</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, left);  // 将基准数交换至两子数组的分界线</span><br><span class="line">    return i;             // 返回基准数的索引</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 快速排序 */</span><br><span class="line">void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">    // 子数组长度为 1 时终止递归</span><br><span class="line">    if (left &gt;= right)</span><br><span class="line">        return;</span><br><span class="line">    // 哨兵划分</span><br><span class="line">    int pivot = partition(nums, left, right);</span><br><span class="line">    // 递归左子数组、右子数组</span><br><span class="line">    quickSort(nums, left, pivot - 1);</span><br><span class="line">    quickSort(nums, pivot + 1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h2><h3 id="3-1-读取链表"><a href="#3-1-读取链表" class="headerlink" title="3.1 读取链表"></a>3.1 读取链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">// 如果第一行表示节点个数，那就读取n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        String[] s = reader.readLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">//用空格分割，也可以用逗号分割</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 创建当前指针</span></span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 当前值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Integer.parseInt(s[i]);</span><br><span class="line">            <span class="comment">// 创建当前指针的后继</span></span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line">            <span class="comment">// 指针向后移一位</span></span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// current指针最后指向null</span></span><br><span class="line">        current.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// head指针为虚拟头节点的直接后继</span></span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">head</span> <span class="operator">=</span> dummy.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出链表，仅为演示，实际问题中可能要根据题目要求进行输出</span></span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助类：构建一个节点类，用于链表构建</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-插入节点"><a href="#3-2-插入节点" class="headerlink" title="3.2 插入节点"></a>3.2 插入节点</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8_1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 在链表的节点 n0 之后插入节点 P */</span><br><span class="line">void insert(ListNode n0, ListNode P) &#123;</span><br><span class="line">    ListNode n1 = n0.next;</span><br><span class="line">    P.next = n1;</span><br><span class="line">    n0.next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-删除节点"><a href="#3-3-删除节点" class="headerlink" title="3.3 删除节点"></a>3.3 删除节点</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8_2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 删除链表的节点 n0 之后的首个节点 */</span><br><span class="line">void remove(ListNode n0) &#123;</span><br><span class="line">    if (n0.next == null)</span><br><span class="line">        return;</span><br><span class="line">    // n0 -&gt; P -&gt; n1</span><br><span class="line">    // n0.next = n0.next.next;</span><br><span class="line">    ListNode P = n0.next;</span><br><span class="line">    ListNode n1 = P.next;</span><br><span class="line">    n0.next = n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-访问节点"><a href="#3-4-访问节点" class="headerlink" title="3.4 访问节点"></a>3.4 访问节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 访问链表中索引为 index 的节点 */</span><br><span class="line">ListNode access(ListNode head, int index) &#123;</span><br><span class="line">    for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">        if (head == null)</span><br><span class="line">            return null;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-查找节点"><a href="#3-5-查找节点" class="headerlink" title="3.5 查找节点"></a>3.5 查找节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 在链表中查找值为 target 的首个节点 */</span><br><span class="line">int find(ListNode head, int target) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    while (head != null) &#123;</span><br><span class="line">        if (head.val == target)</span><br><span class="line">            return index;</span><br><span class="line">        head = head.next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-模板题"><a href="#3-6-模板题" class="headerlink" title="3.6 模板题"></a>3.6 模板题</h3><ul><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">移除链表元素</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        if (head == null) return head;</span><br><span class="line">        // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span><br><span class="line">        ListNode dummy = new ListNode(-1, head);</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            if (cur.val == val) &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">设计链表:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList&#123;</span><br><span class="line">    // 定义节点</span><br><span class="line">    class Node&#123;</span><br><span class="line">        // 节点值</span><br><span class="line">        int val;</span><br><span class="line">        // 下一节点的地址</span><br><span class="line">        Node next;</span><br><span class="line">        // 构造器</span><br><span class="line">        public Node(int val)&#123;</span><br><span class="line">            this.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 链表的长度</span><br><span class="line">    int size;</span><br><span class="line">    // 虚拟头节点</span><br><span class="line">    Node head;</span><br><span class="line">    </span><br><span class="line">    // 1、初始化链表</span><br><span class="line">    public MyLinkedList()&#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        // 定义这个虚拟头节点的值为0</span><br><span class="line">        head =  new Node(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. addAtIndex方法</span><br><span class="line">    public void addAtIndex(int index, int val)&#123;</span><br><span class="line">        // 当index大于size</span><br><span class="line">        if (index&gt;size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 当index小于0</span><br><span class="line">        if (index&lt;0)&#123;</span><br><span class="line">            index=0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // current指针移动到index的前一个</span><br><span class="line">        Node current = head;</span><br><span class="line">        for (int i=0; i&lt;index; i++)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入的节点</span><br><span class="line">        Node addNode = new Node(val);</span><br><span class="line">        addNode.next = current.next;</span><br><span class="line">        current.next = addNode;</span><br><span class="line">        </span><br><span class="line">        // 链表总数+1</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3. addAtHead方法</span><br><span class="line">    public void addAtHead(int val)&#123;</span><br><span class="line">        addAtIndex(0, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. addAtTail方法</span><br><span class="line">    public void addAtTail(int val)&#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 5. get方法</span><br><span class="line">    public int get(int index)&#123;</span><br><span class="line">        // 逻辑判断</span><br><span class="line">        if (index&lt;0 || index&gt;size-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历每个节点</span><br><span class="line">        Node current = head;</span><br><span class="line">        for (int i=0; i&lt;=index; i++)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return current.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 6. deleteAtIndex方法</span><br><span class="line">    public void deleteAtIndex(int index)&#123;</span><br><span class="line">        // 逻辑判断</span><br><span class="line">        if (index&lt;0 || index&gt;size-1)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">        Node current = head;</span><br><span class="line">        for (int i=0; i&lt;index; i++)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = current.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">反转链表:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode tem = null;</span><br><span class="line">        while (cur!=null)&#123;</span><br><span class="line">            // 保存下一个节点</span><br><span class="line">            tem = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            // 两个指针都往后移一位</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        // 0/1个节点的情况</span><br><span class="line">        if (head==null || head.next==null) return head;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode cur = head.next;</span><br><span class="line">        while (cur!=null)&#123;</span><br><span class="line">            int tem = pre.val;</span><br><span class="line">            pre.val = cur.val;</span><br><span class="line">            cur.val = tem;</span><br><span class="line">            if (cur.next==null || cur.next.next==null) return head;</span><br><span class="line">            pre = pre.next.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第N个节点:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        // 虚拟指针</span><br><span class="line">        ListNode dummy = new ListNode(0, head);</span><br><span class="line">        // 双指针</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        // current指针往前先移动n个</span><br><span class="line">        for (int i=1; i&lt;=n; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // pre和cur同时往后移动</span><br><span class="line">        while (cur.next!=null)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 删除节点</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">链表相交:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        // 虚拟头节点</span><br><span class="line">        ListNode dummyA = new ListNode(0);</span><br><span class="line">        dummyA.next = headA;</span><br><span class="line">        ListNode dummyB = new ListNode(0);</span><br><span class="line">        dummyB.next = headB;</span><br><span class="line">        // 长度</span><br><span class="line">        int lenA = 0;</span><br><span class="line">        int lenB = 0;</span><br><span class="line"></span><br><span class="line">        // 计算两个链表的长度</span><br><span class="line">        ListNode tmpA = dummyA;</span><br><span class="line">        ListNode tmpB = dummyB;</span><br><span class="line">        while (tmpA.next!=null)&#123;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (tmpB.next!=null)&#123;</span><br><span class="line">            tmpB = tmpB.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将最长的链表的指针往前移动|lenA-lenB|</span><br><span class="line">        ListNode tmpA1 = dummyA;</span><br><span class="line">        ListNode tmpB1 = dummyB;</span><br><span class="line">        if (lenA&gt;lenB)&#123;</span><br><span class="line">            int step = lenA - lenB;</span><br><span class="line">            for (int i=0; i&lt;step; i++)&#123;</span><br><span class="line">                tmpA1 = tmpA1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int step = lenB - lenA;</span><br><span class="line">            for (int i=0; i&lt;step; i++)&#123;</span><br><span class="line">                tmpB1 = tmpB1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // tmpA1和tmpB1依次往后移动</span><br><span class="line">        while (tmpA1!=null &amp;&amp; tmpB1!=null)&#123;</span><br><span class="line">            if (tmpA1==tmpB1)&#123;</span><br><span class="line">                return tmpA1;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpA1 = tmpA1.next;</span><br><span class="line">            tmpB1 = tmpB1.next;</span><br><span class="line">        &#125; </span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表II:</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        // 定义一个hashmap</span><br><span class="line">        HashMap&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        // 定义一个虚拟头节点</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        // 定义索引</span><br><span class="line">        int index = 0;</span><br><span class="line"></span><br><span class="line">        // 循环</span><br><span class="line">        while (dummy.next!=null)&#123;</span><br><span class="line">            if (map.containsValue(dummy))&#123;</span><br><span class="line">                return dummy;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(index, dummy);</span><br><span class="line">                index++;</span><br><span class="line">                dummy = dummy.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h2><h3 id="4-1-读取数组"><a href="#4-1-读取数组" class="headerlink" title="4.1 读取数组"></a>4.1 读取数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">// 如果第一行表示节点个数，那就读取n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        String[] s = reader.readLine().split(<span class="string">&quot; &quot;</span>); <span class="comment">//用空格分割，也可以用逗号分割</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[s.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            nums[i] = Integer.parseInt(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-访问元素"><a href="#4-2-访问元素" class="headerlink" title="4.2 访问元素"></a>4.2 访问元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 访问元素 */</span><br><span class="line">int access(int[] nums, int index) &#123;</span><br><span class="line">    // 获取并返回随机元素</span><br><span class="line">    return nums[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-插入元素"><a href="#4-3-插入元素" class="headerlink" title="4.3 插入元素"></a>4.3 插入元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 在数组的索引 index 处插入元素 num */</span><br><span class="line">void insert(int[] nums, int num, int index) &#123;</span><br><span class="line">    // 把索引 index 以及之后的所有元素向后移动一位</span><br><span class="line">    for (int i = nums.length - 1; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    // 将 num 赋给 index 处元素</span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-删除元素"><a href="#4-4-删除元素" class="headerlink" title="4.4 删除元素"></a>4.4 删除元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 删除索引 index 处元素 */</span><br><span class="line">void remove(int[] nums, int index) &#123;</span><br><span class="line">    // 把索引 index 之后的所有元素向前移动一位</span><br><span class="line">    for (int i = index; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-遍历数组"><a href="#4-5-遍历数组" class="headerlink" title="4.5 遍历数组"></a>4.5 遍历数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 遍历数组 */</span><br><span class="line">void traverse(int[] nums) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    // 通过索引遍历数组</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 直接遍历数组</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure><h3 id="4-6-查找元素"><a href="#4-6-查找元素" class="headerlink" title="4.6 查找元素"></a>4.6 查找元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 在数组中查找指定元素 */</span><br><span class="line">int find(int[] nums, int target) &#123;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] == target)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-扩容数组"><a href="#4-7-扩容数组" class="headerlink" title="4.7 扩容数组"></a>4.7 扩容数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 扩展数组长度 */</span><br><span class="line">int[] extend(int[] nums, int enlarge) &#123;</span><br><span class="line">    // 初始化一个扩展长度后的数组</span><br><span class="line">    int[] res = new int[nums.length + enlarge];</span><br><span class="line">    // 将原数组中的所有元素复制到新数组</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回扩展后的新数组</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-模板题"><a href="#4-8-模板题" class="headerlink" title="4.8 模板题"></a>4.8 模板题</h3><ul><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">二分查找:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        // 左</span><br><span class="line">        int left = 0;</span><br><span class="line">        // 右</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        while (left&lt;=right)&#123;</span><br><span class="line">            // 中间</span><br><span class="line">            int middle = left + (right - left) / 2;</span><br><span class="line">            if (nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">移除元素:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        // 1. 定义两个指针fast, slow</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast=0; fast&lt;=nums.length-1; fast++)&#123;</span><br><span class="line">            if (nums[fast] != val)&#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">有序数组的平方:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        // 双向双指针</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        int index = nums.length - 1;</span><br><span class="line">        int[] result = new int[nums.length];</span><br><span class="line">        while (left &lt;= right)&#123;</span><br><span class="line">            if (nums[right]*nums[right] &gt; nums[left]*nums[left])&#123;</span><br><span class="line">                result[index--] = nums[right]*nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result[index--] = nums[left]*nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minSubArrayLen(int target, int[] nums) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int len = Integer.MAX_VALUE;</span><br><span class="line">        for (int right=0; right&lt;nums.length; right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            while (sum&gt;=target)&#123;</span><br><span class="line">                len = Math.min(len, right-left+1);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len == Integer.MAX_VALUE ? 0 : len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        // 定义左右上下</span><br><span class="line">        int left = 0, right = n-1, top = 0, bottom = n-1;</span><br><span class="line">        // 定义填充的总数和正填充的计数</span><br><span class="line">        int count = 1, target = n*n;</span><br><span class="line">        // 定义返回的数组</span><br><span class="line">        int[][] returnList = new int[n][n];</span><br><span class="line"></span><br><span class="line">        // i表示遍历行，j表示遍历列</span><br><span class="line">        while (count&lt;=target)&#123;</span><br><span class="line">            // 从左到右</span><br><span class="line">            for (int j=left; j&lt;=right; j++)&#123;</span><br><span class="line">                returnList[top][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            // 从上往下</span><br><span class="line">            for (int i=top; i&lt;=bottom; i++)&#123;</span><br><span class="line">                returnList[i][right] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            // 从右往左</span><br><span class="line">            for (int j=right; j&gt;=left; j--)&#123;</span><br><span class="line">                returnList[bottom][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            // 从下往上</span><br><span class="line">            for (int i=bottom; i&gt;=top; i--)&#123;</span><br><span class="line">                returnList[i][left] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return returnList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-栈"><a href="#5-栈" class="headerlink" title="5. 栈"></a>5. 栈</h2><h3 id="5-1-基本操作"><a href="#5-1-基本操作" class="headerlink" title="5.1 基本操作"></a>5.1 基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化栈 */</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 元素入栈 */</span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);</span><br><span class="line"></span><br><span class="line">/* 访问栈顶元素 */</span><br><span class="line">int peek = stack.peek();</span><br><span class="line"></span><br><span class="line">/* 元素出栈 */</span><br><span class="line">int pop = stack.pop();</span><br><span class="line"></span><br><span class="line">/* 获取栈的长度 */</span><br><span class="line">int size = stack.size();</span><br><span class="line"></span><br><span class="line">/* 判断是否为空 */</span><br><span class="line">boolean isEmpty = stack.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="5-2-基于链表实现栈"><a href="#5-2-基于链表实现栈" class="headerlink" title="5.2 基于链表实现栈"></a>5.2 基于链表实现栈</h3><ul><li>push：链表头插法</li><li>pop：删除头节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的栈 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode stackPeek; <span class="comment">// 将头节点作为栈顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stkSize</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 栈的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stackPeek = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取栈的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stkSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        node.next = stackPeek;</span><br><span class="line">        stackPeek = node;</span><br><span class="line">        stkSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> peek();</span><br><span class="line">        stackPeek = stackPeek.next;</span><br><span class="line">        stkSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> stackPeek.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 List 转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> stackPeek;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-基于数组实现栈"><a href="#5-3-基于数组实现栈" class="headerlink" title="5.3 基于数组实现栈"></a>5.3 基于数组实现栈</h3><ul><li>push：插入到数组尾部</li><li>pop：删除数组尾元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于数组实现的栈 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化列表（动态数组）</span></span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取栈的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        stack.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> stack.remove(size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> stack.get(size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 List 转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-模板题"><a href="#5-4-模板题" class="headerlink" title="5.4 模板题"></a>5.4 模板题</h3><ul><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">    // 定义两个栈</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    // 构造函数</span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        stackIn = new Stack&lt;&gt;();</span><br><span class="line">        stackOut = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 入队列</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 出队列</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回队列开头元素</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断队列是否为空</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return stackIn.isEmpty() &amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中</span><br><span class="line">    public void dumpstackIn()&#123;</span><br><span class="line">        // 出队列：判断stackOut是否为空，不为空就返回</span><br><span class="line">        if (!stackOut.isEmpty())return;</span><br><span class="line">        while (!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">用队列实现栈:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">    // 定义两个队列</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    // 构造器</span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        queue1 = new LinkedList&lt;&gt;();</span><br><span class="line">        queue2 = new LinkedList&lt;&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 入栈流程是：</span><br><span class="line">    // 入栈元素放入queue2中</span><br><span class="line">    // 然后将queue1元素全部放入queue2中</span><br><span class="line">    // 最后queue1和queue2互换</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        queue2.offer(x); // 先放在辅助队列中</span><br><span class="line">        while (!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queueTemp;</span><br><span class="line">        queueTemp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 出栈</span><br><span class="line">    // queue2</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回栈顶元素</span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断是否为空</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">有效的括号:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        // if (s.length()%2!=0) return false;</span><br><span class="line"></span><br><span class="line">        // 定义一个栈</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 循环</span><br><span class="line">        for (int i=0; i&lt;=s.length()-1; i++)&#123;</span><br><span class="line">            if (s.charAt(i) == &#x27;(&#x27;)&#123;</span><br><span class="line">                stack.push(&#x27;)&#x27;);</span><br><span class="line">            &#125;else if (s.charAt(i) == &#x27;&#123;&#x27;)&#123;</span><br><span class="line">                stack.push(&#x27;&#125;&#x27;);</span><br><span class="line">            &#125;else if (s.charAt(i) == &#x27;[&#x27;)&#123;</span><br><span class="line">                stack.push(&#x27;]&#x27;);</span><br><span class="line">            &#125;else if (stack.isEmpty() || stack.peek()!=s.charAt(i))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Character&gt; stack1 = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;=s.length()-1; i++)&#123;</span><br><span class="line">            if (stack.isEmpty() || stack.peek()!=s.charAt(i))&#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        while (!stack1.isEmpty())&#123;</span><br><span class="line">            sb.append(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        // 1. 定义一个栈</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        // 2. 定义运算的两个变量</span><br><span class="line">        int a;</span><br><span class="line">        int b;</span><br><span class="line"></span><br><span class="line">        // 3. 对tokens进行遍历</span><br><span class="line">        for (String s : tokens)&#123;</span><br><span class="line">            if (s.equals(&quot;+&quot;))&#123;</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                stack.push(a+b);</span><br><span class="line">            &#125;else if (s.equals(&quot;-&quot;))&#123;</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                stack.push(a-b);</span><br><span class="line">            &#125;else if (s.equals(&quot;*&quot;))&#123;</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                stack.push(a*b);</span><br><span class="line">            &#125;else if (s.equals(&quot;/&quot;))&#123;</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                stack.push(a/b);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        if(nums.length == 0 || k == 0) return new int[0];</span><br><span class="line">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">        int[] res = new int[nums.length - k + 1];</span><br><span class="line">        for(int j = 0, i = 1 - k; j &lt; nums.length; i++, j++) &#123;</span><br><span class="line">            // 删除 deque 中对应的 nums[i-1]</span><br><span class="line">            if(i &gt; 0 &amp;&amp; deque.peekFirst() == nums[i - 1])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            // 保持 deque 递减</span><br><span class="line">            while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line">            // 记录窗口最大值</span><br><span class="line">            if(i &gt;= 0)</span><br><span class="line">                res[i] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">前 K 个高频元素:</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        // 优先级队列，为了避免复杂 api 操作，pq 存储数组</span><br><span class="line">        // lambda 表达式设置优先级队列从大到小存储 o1 - o2 为从大到小，o2 - o1 反之</span><br><span class="line">        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[1] - o2[1]);</span><br><span class="line">        int[] res = new int[k]; // 答案数组为 k 个元素</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 记录元素出现次数</span><br><span class="line">        for(int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);</span><br><span class="line">        for(var x : map.entrySet()) &#123; // entrySet 获取 k-v Set 集合</span><br><span class="line">            // 将 kv 转化成数组</span><br><span class="line">            int[] tmp = new int[2];</span><br><span class="line">            tmp[0] = x.getKey();</span><br><span class="line">            tmp[1] = x.getValue();</span><br><span class="line">            pq.offer(tmp);</span><br><span class="line">            if(pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; k; i ++) &#123;</span><br><span class="line">            res[i] = pq.poll()[0]; // 获取优先队列里的元素</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-队列"><a href="#6-队列" class="headerlink" title="6. 队列"></a>6. 队列</h2><h3 id="6-1-队列常用操作"><a href="#6-1-队列常用操作" class="headerlink" title="6.1 队列常用操作"></a>6.1 队列常用操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化队列 */</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 元素入队 */</span><br><span class="line">queue.offer(1);</span><br><span class="line">queue.offer(2);</span><br><span class="line"></span><br><span class="line">/* 访问队首元素 */</span><br><span class="line">int peek = queue.peek();</span><br><span class="line"></span><br><span class="line">/* 元素出队 */</span><br><span class="line">int pop = queue.poll();</span><br><span class="line"></span><br><span class="line">/* 获取队列的长度 */</span><br><span class="line">int size = queue.size();</span><br><span class="line"></span><br><span class="line">/* 判断队列是否为空 */</span><br><span class="line">boolean isEmpty = queue.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="6-2-基于链表实现队列"><a href="#6-2-基于链表实现队列" class="headerlink" title="6.2 基于链表实现队列"></a>6.2 基于链表实现队列</h3><ul><li>push：添加到链表尾部</li><li>pop：删除链表头节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode front, rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 尾节点后添加 num</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        <span class="comment">// 如果队列为空，则令头、尾节点都指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) &#123;</span><br><span class="line">            front = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        <span class="comment">// 如果队列不为空，则将该节点添加到尾节点后</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rear.next = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        &#125;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> peek();</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        front = front.next;</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> front.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将链表转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3-双向队列常用操作"><a href="#6-3-双向队列常用操作" class="headerlink" title="6.3 双向队列常用操作"></a>6.3 双向队列常用操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化双向队列 */</span><br><span class="line">Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 元素入队 */</span><br><span class="line">deque.offerLast(1);   // 添加至队尾</span><br><span class="line">deque.offerFirst(3);  // 添加至队首</span><br><span class="line"></span><br><span class="line">/* 访问元素 */</span><br><span class="line">int peekFirst = deque.peekFirst();  // 队首元素</span><br><span class="line">int peekLast = deque.peekLast();    // 队尾元素</span><br><span class="line"></span><br><span class="line">/* 元素出队 */</span><br><span class="line">int popFirst = deque.pollFirst();  // 队首元素出队</span><br><span class="line">int popLast = deque.pollLast();    // 队尾元素出队</span><br><span class="line"></span><br><span class="line">/* 获取双向队列的长度 */</span><br><span class="line">int size = deque.size();</span><br><span class="line"></span><br><span class="line">/* 判断双向队列是否为空 */</span><br><span class="line">boolean isEmpty = deque.isEmpty();</span><br></pre></td></tr></table></figure><h3 id="6-4-基于双向链表实现双向队列"><a href="#6-4-基于双向链表实现双向队列" class="headerlink" title="6.4 基于双向链表实现双向队列"></a>6.4 基于双向链表实现双向队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 节点值</span></span><br><span class="line">    ListNode next; <span class="comment">// 后继节点引用</span></span><br><span class="line">    ListNode prev; <span class="comment">// 前驱节点引用</span></span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        prev = next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于双向链表实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListDeque</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode front, rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queSize</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 双向队列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        front = rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队操作 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num, <span class="type">boolean</span> isFront)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        <span class="comment">// 若链表为空，则令 front, rear 都指向 node</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            front = rear = node;</span><br><span class="line">        <span class="comment">// 队首入队操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表头部</span></span><br><span class="line">            front.prev = node;</span><br><span class="line">            node.next = front;</span><br><span class="line">            front = node; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾入队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表尾部</span></span><br><span class="line">            rear.next = node;</span><br><span class="line">            node.prev = rear;</span><br><span class="line">            rear = node; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize++; <span class="comment">// 更新队列长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        push(num, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushLast</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        push(num, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队操作 */</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">pop</span><span class="params">(<span class="type">boolean</span> isFront)</span> &#123;</span><br><span class="line">        <span class="comment">// 若队列为空，直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="comment">// 队首出队操作</span></span><br><span class="line">        <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            val = front.val; <span class="comment">// 暂存头节点值</span></span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">fNext</span> <span class="operator">=</span> front.next;</span><br><span class="line">            <span class="keyword">if</span> (fNext != <span class="literal">null</span>) &#123;</span><br><span class="line">                fNext.prev = <span class="literal">null</span>;</span><br><span class="line">                front.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front = fNext; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾出队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = rear.val; <span class="comment">// 暂存尾节点值</span></span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">rPrev</span> <span class="operator">=</span> rear.prev;</span><br><span class="line">            <span class="keyword">if</span> (rPrev != <span class="literal">null</span>) &#123;</span><br><span class="line">                rPrev.next = <span class="literal">null</span>;</span><br><span class="line">                rear.prev = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear = rPrev; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize--; <span class="comment">// 更新队列长度</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">popFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pop(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">popLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pop(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="literal">null</span> : front.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="literal">null</span> : rear.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-哈希表"><a href="#7-哈希表" class="headerlink" title="7. 哈希表"></a>7. 哈希表</h2><h3 id="7-1-哈希表常用操作"><a href="#7-1-哈希表常用操作" class="headerlink" title="7.1 哈希表常用操作"></a>7.1 哈希表常用操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化哈希表 */</span><br><span class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 添加操作 */</span><br><span class="line">// 在哈希表中添加键值对 (key, value)</span><br><span class="line">map.put(12836, &quot;小哈&quot;);   </span><br><span class="line">map.put(15937, &quot;小啰&quot;);   </span><br><span class="line">map.put(16750, &quot;小算&quot;);   </span><br><span class="line">map.put(13276, &quot;小法&quot;);</span><br><span class="line">map.put(10583, &quot;小鸭&quot;);</span><br><span class="line"></span><br><span class="line">/* 查询操作 */</span><br><span class="line">// 向哈希表输入键 key ，得到值 value</span><br><span class="line">String name = map.get(15937);</span><br><span class="line"></span><br><span class="line">/* 删除操作 */</span><br><span class="line">// 在哈希表中删除键值对 (key, value)</span><br><span class="line">map.remove(10583);</span><br><span class="line"></span><br><span class="line">/* 遍历哈希表 */</span><br><span class="line">// 遍历键值对 key-&gt;value</span><br><span class="line">for (Map.Entry &lt;Integer, String&gt; kv: map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + &quot; -&gt; &quot; + kv.getValue());</span><br><span class="line">&#125;</span><br><span class="line">// 单独遍历键 key</span><br><span class="line">for (int key: map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">// 单独遍历值 value</span><br><span class="line">for (String val: map.values()) &#123;</span><br><span class="line">    System.out.println(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-树"><a href="#8-树" class="headerlink" title="8. 树"></a>8. 树</h2><h3 id="8-1-二叉树"><a href="#8-1-二叉树" class="headerlink" title="8.1 二叉树"></a>8.1 二叉树</h3><ul><li><p>二叉树常见术语：</p><ul><li>根节点 root node：位于二叉树顶层的节点，没有父节点。</li><li>叶节点 leaf node：没有子节点的节点，其两个指针均指向。</li><li>边 edge：连接两个节点的线段，即节点引用（指针）。</li><li>节点所在的层 level：从顶至底递增，根节点所在层为 1 。</li><li>节点的度 degree：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</li><li>二叉树的高度 height：从根节点到最远叶节点所经过的边的数量。</li><li>节点的深度 depth：从根节点到该节点所经过的边的数量。</li><li>节点的高度 height：从最远叶节点到该节点所经过的边的数量。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_1.png"></li></ul></li><li><p>二叉树分类：</p><ul><li>完美二叉树（满二叉树）<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_3.png"></li><li>完全二叉树<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_4.png"></li><li>完满二叉树<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_5.png"></li><li>平衡二叉树<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_6.png"></li></ul></li><li><p>二叉树基本操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  /* 二叉树节点类 */</span><br><span class="line">  class TreeNode &#123;</span><br><span class="line">      int val;         // 节点值</span><br><span class="line">      TreeNode left;   // 左子节点引用</span><br><span class="line">      TreeNode right;  // 右子节点引用</span><br><span class="line">      TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* 初始化二叉树 */</span><br><span class="line">  // 初始化节点</span><br><span class="line">  TreeNode n1 = new TreeNode(1);</span><br><span class="line">  TreeNode n2 = new TreeNode(2);</span><br><span class="line">  TreeNode n3 = new TreeNode(3);</span><br><span class="line">  TreeNode n4 = new TreeNode(4);</span><br><span class="line">  TreeNode n5 = new TreeNode(5);</span><br><span class="line">  // 构建引用指向（即指针）</span><br><span class="line">  n1.left = n2;</span><br><span class="line">  n1.right = n3;</span><br><span class="line">  n2.left = n4;</span><br><span class="line">  n2.right = n5;</span><br><span class="line">  </span><br><span class="line">  /* 插入与删除节点 */</span><br><span class="line">  TreeNode P = new TreeNode(0);</span><br><span class="line">  // 在 n1 -&gt; n2 中间插入节点 P</span><br><span class="line">  n1.left = P;</span><br><span class="line">  P.left = n2;</span><br><span class="line">  // 删除节点 P</span><br><span class="line">  n1.left = n2;</span><br><span class="line">  ```  </span><br><span class="line">  ![](面试-算法/树_2.png)</span><br><span class="line"></span><br><span class="line">- 读取二叉树：</span><br><span class="line">  ```java</span><br><span class="line">  import java.io.BufferedReader;</span><br><span class="line">  import java.io.IOException;</span><br><span class="line">  import java.io.InputStreamReader;</span><br><span class="line">   </span><br><span class="line">  public class Main&#123;</span><br><span class="line">      //4.输入二叉树</span><br><span class="line">      public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          //获取键盘一行的输入，以enter键为结束标志</span><br><span class="line">          BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">          String[] s = reader.readLine().split(&quot; &quot;); //用空格分割，也可以用逗号分割</span><br><span class="line">   </span><br><span class="line">          //用数组按层级遍历顺序存储二叉树的节点</span><br><span class="line">          TreeNode[] tree = new TreeNode[s.length];</span><br><span class="line">          for(int i = 0; i &lt; tree.length; i++)&#123;</span><br><span class="line">              int val_i = Integer.parseInt(s[i]);</span><br><span class="line">              if(val_i == -1)&#123;</span><br><span class="line">                  tree[i] = null; //-1代表null</span><br><span class="line">              &#125;else&#123;</span><br><span class="line">                  tree[i] = new TreeNode(val_i); </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">   </span><br><span class="line">          //再遍历一边，给左右子树赋值</span><br><span class="line">          for(int i = 0; i * 2 + 2 &lt; tree.length; i++)&#123;</span><br><span class="line">              if(tree[i] != null)&#123;</span><br><span class="line">                  tree[i].left = tree[i * 2 + 1];</span><br><span class="line">                  tree[i].right = tree[i * 2 + 2];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          TreeNode root = tree[0];</span><br><span class="line">          //root是最终得到的二叉树根节点</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      //辅助类：构造树需要的结点类</span><br><span class="line">      static class TreeNode &#123;</span><br><span class="line">          int val;</span><br><span class="line">          TreeNode left, right;</span><br><span class="line">          public TreeNode(int val) &#123;</span><br><span class="line">              this.val = val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-2-二叉树遍历"><a href="#8-2-二叉树遍历" class="headerlink" title="8.2 二叉树遍历"></a>8.2 二叉树遍历</h3><ul><li>层序遍历：本质上属于广度优先遍历 breadth-first traversal，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_7.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 层序遍历 */</span><br><span class="line">List&lt;Integer&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    // 初始化队列，加入根节点</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    // 初始化一个列表，用于保存遍历序列</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); // 队列出队</span><br><span class="line">        list.add(node.val);           // 保存节点值</span><br><span class="line">        if (node.left != null)&#123;</span><br><span class="line">            queue.offer(node.left);   // 左子节点入队</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right != null)&#123;</span><br><span class="line">            queue.offer(node.right);  // 右子节点入队</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>前序、中序、后序遍历：都属于「深度优先遍历 depth-first traversal」，它体现了一种“先走到尽头，再回溯继续”的遍历方式。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_8.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* 前序遍历 */</span><br><span class="line">void preOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 中序遍历 */</span><br><span class="line">void inOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 后序遍历 */</span><br><span class="line">void postOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-二叉树数组表示"><a href="#8-3-二叉树数组表示" class="headerlink" title="8.3 二叉树数组表示"></a>8.3 二叉树数组表示</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_9.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数组表示下的二叉树类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(List&lt;Integer&gt; arr)</span> &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 节点数量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tree.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的值 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">val</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 若索引越界，则返回 null ，代表空位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> tree.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的左子节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的右子节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的父节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 层序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 直接遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val(i) != <span class="literal">null</span>)</span><br><span class="line">                res.add(val(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 深度优先遍历 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Integer i, String order, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 若为空位，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (val(i) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;pre&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(left(i), order, res);</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(right(i), order, res);</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;post&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;pre&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;in&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;post&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-二叉搜索树"><a href="#8-4-二叉搜索树" class="headerlink" title="8.4 二叉搜索树"></a>8.4 二叉搜索树</h3><ul><li><p>二叉搜索树(binary search tree)满足以下条件：</p><ul><li>对于根节点，左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值。</li><li>任意节点的左、右子树也是二叉搜索树，即同样满足条件 1. 。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E6%A0%91_10.png"></li></ul></li><li><p>查找节点</p><ul><li>若 cur.val &lt; num ，说明目标节点在 cur 的右子树中，因此执行 cur &#x3D; cur.right 。</li><li>若 cur.val &gt; num ，说明目标节点在 cur 的左子树中，因此执行 cur &#x3D; cur.left 。</li><li>若 cur.val &#x3D; num ，说明找到目标节点，跳出循环并返回该节点。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 查找节点 */</span><br><span class="line">TreeNode search(int num) &#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    // 循环查找，越过叶节点后跳出</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // 目标节点在 cur 的右子树中</span><br><span class="line">        if (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        // 目标节点在 cur 的左子树中</span><br><span class="line">        else if (cur.val &gt; num)</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        // 找到目标节点，跳出循环</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回目标节点</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>插入节点</p><ul><li>查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（遍历至None）时跳出循环。</li><li>在该位置插入节点：初始化节点 num ，将该节点插入当前的位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* 插入节点 */</span><br><span class="line">void insert(int num) &#123;</span><br><span class="line">    // 若树为空，则初始化根节点</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        root = new TreeNode(num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode cur = root, pre = null;</span><br><span class="line">    // 循环查找，越过叶节点后跳出</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // 找到重复节点，直接返回</span><br><span class="line">        if (cur.val == num)</span><br><span class="line">            return;</span><br><span class="line">        pre = cur;</span><br><span class="line">        // 插入位置在 cur 的右子树中</span><br><span class="line">        if (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        // 插入位置在 cur 的左子树中</span><br><span class="line">        else</span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    // 插入节点</span><br><span class="line">    TreeNode node = new TreeNode(num);</span><br><span class="line">    if (pre.val &lt; num)</span><br><span class="line">        pre.right = node;</span><br><span class="line">    else</span><br><span class="line">        pre.left = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/* 删除节点 */</span><br><span class="line">void remove(int num) &#123;</span><br><span class="line">    // 若树为空，直接提前返回</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    TreeNode cur = root, pre = null;</span><br><span class="line">    // 循环查找，越过叶节点后跳出</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // 找到待删除节点，跳出循环</span><br><span class="line">        if (cur.val == num)</span><br><span class="line">            break;</span><br><span class="line">        pre = cur;</span><br><span class="line">        // 待删除节点在 cur 的右子树中</span><br><span class="line">        if (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        // 待删除节点在 cur 的左子树中</span><br><span class="line">        else</span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若无待删除节点，则直接返回</span><br><span class="line">    if (cur == null)</span><br><span class="line">        return;</span><br><span class="line">    // 子节点数量 = 0 or 1</span><br><span class="line">    if (cur.left == null || cur.right == null) &#123;</span><br><span class="line">        // 当子节点数量 = 0 / 1 时， child = null / 该子节点</span><br><span class="line">        TreeNode child = cur.left != null ? cur.left : cur.right;</span><br><span class="line">        // 删除节点 cur</span><br><span class="line">        if (cur != root) &#123;</span><br><span class="line">            if (pre.left == cur)</span><br><span class="line">                pre.left = child;</span><br><span class="line">            else</span><br><span class="line">                pre.right = child;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 若删除节点为根节点，则重新指定根节点</span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 子节点数量 = 2</span><br><span class="line">    else &#123;</span><br><span class="line">        // 获取中序遍历中 cur 的下一个节点</span><br><span class="line">        TreeNode tmp = cur.right;</span><br><span class="line">        while (tmp.left != null) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        // 递归删除节点 tmp</span><br><span class="line">        remove(tmp.val);</span><br><span class="line">        // 用 tmp 覆盖 cur</span><br><span class="line">        cur.val = tmp.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-5-AVL树"><a href="#8-5-AVL树" class="headerlink" title="8.5 AVL树"></a>8.5 AVL树</h3><h2 id="9-堆"><a href="#9-堆" class="headerlink" title="9. 堆"></a>9. 堆</h2><h3 id="9-1-基础问题"><a href="#9-1-基础问题" class="headerlink" title="9.1 基础问题"></a>9.1 基础问题</h3><ul><li><p>概念：</p><ul><li>大顶堆 max heap：任意节点的值大于等于其子节点的值。</li><li>小顶堆 min heap：任意节点的值小于等于其子节点的值。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E5%A0%86_1.png"></li></ul></li><li><p>堆常用操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 初始化堆 */</span><br><span class="line">// 初始化小顶堆</span><br><span class="line">Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</span><br><span class="line">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span><br><span class="line">Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line">/* 元素入堆 */</span><br><span class="line">maxHeap.offer(1);</span><br><span class="line">maxHeap.offer(3);</span><br><span class="line">maxHeap.offer(2);</span><br><span class="line">maxHeap.offer(5);</span><br><span class="line">maxHeap.offer(4);</span><br><span class="line"></span><br><span class="line">/* 获取堆顶元素 */</span><br><span class="line">int peek = maxHeap.peek(); // 5</span><br><span class="line"></span><br><span class="line">/* 堆顶元素出堆 */</span><br><span class="line">// 出堆元素会形成一个从大到小的序列</span><br><span class="line">peek = maxHeap.poll(); // 5</span><br><span class="line">peek = maxHeap.poll(); // 4</span><br><span class="line">peek = maxHeap.poll(); // 3</span><br><span class="line">peek = maxHeap.poll(); // 2</span><br><span class="line">peek = maxHeap.poll(); // 1</span><br><span class="line"></span><br><span class="line">/* 获取堆大小 */</span><br><span class="line">int size = maxHeap.size();</span><br><span class="line"></span><br><span class="line">/* 判断堆是否为空 */</span><br><span class="line">boolean isEmpty = maxHeap.isEmpty();</span><br><span class="line"></span><br><span class="line">/* 输入列表并建堆 */</span><br><span class="line">minHeap = new PriorityQueue&lt;&gt;(Arrays.asList(1, 3, 2, 5, 4));</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-2-建堆操作"><a href="#9-2-建堆操作" class="headerlink" title="9.2 建堆操作"></a>9.2 建堆操作</h3><ul><li>堆的存储与表示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/%E5%A0%86_2.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/* 获取左子节点索引 */</span><br><span class="line">int left(int i) &#123;</span><br><span class="line">    return 2 * i + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 获取右子节点索引 */</span><br><span class="line">int right(int i) &#123;</span><br><span class="line">    return 2 * i + 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 获取父节点索引 */</span><br><span class="line">int parent(int i) &#123;</span><br><span class="line">    return (i - 1) / 2; // 向下整除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 访问堆顶元素 */</span><br><span class="line">int peek() &#123;</span><br><span class="line">    return maxHeap.get(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 元素入堆 */</span><br><span class="line">void push(int val) &#123;</span><br><span class="line">    // 添加节点</span><br><span class="line">    maxHeap.add(val);</span><br><span class="line">    // 从底至顶堆化</span><br><span class="line">    siftUp(size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从节点 i 开始，从底至顶堆化 */</span><br><span class="line">void siftUp(int i) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 获取节点 i 的父节点</span><br><span class="line">        int p = parent(i);</span><br><span class="line">        // 当“越过根节点”或“节点无须修复”时，结束堆化</span><br><span class="line">        if (p &lt; 0 || maxHeap.get(i) &lt;= maxHeap.get(p))</span><br><span class="line">            break;</span><br><span class="line">        // 交换两节点</span><br><span class="line">        swap(i, p);</span><br><span class="line">        // 循环向上堆化</span><br><span class="line">        i = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 元素出堆 */</span><br><span class="line">int pop() &#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if (isEmpty())</span><br><span class="line">        throw new IndexOutOfBoundsException();</span><br><span class="line">    // 交换根节点与最右叶节点（即交换首元素与尾元素）</span><br><span class="line">    swap(0, size() - 1);</span><br><span class="line">    // 删除节点</span><br><span class="line">    int val = maxHeap.remove(size() - 1);</span><br><span class="line">    // 从顶至底堆化</span><br><span class="line">    siftDown(0);</span><br><span class="line">    // 返回堆顶元素</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从节点 i 开始，从顶至底堆化 */</span><br><span class="line">void siftDown(int i) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // 判断节点 i, l, r 中值最大的节点，记为 ma</span><br><span class="line">        int l = left(i), r = right(i), ma = i;</span><br><span class="line">        if (l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(ma))</span><br><span class="line">            ma = l;</span><br><span class="line">        if (r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(ma))</span><br><span class="line">            ma = r;</span><br><span class="line">        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span><br><span class="line">        if (ma == i)</span><br><span class="line">            break;</span><br><span class="line">        // 交换两节点</span><br><span class="line">        swap(i, ma);</span><br><span class="line">        // 循环向下堆化</span><br><span class="line">        i = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-3-Top-K-问题"><a href="#9-3-Top-K-问题" class="headerlink" title="9.3 Top-K 问题"></a>9.3 Top-K 问题</h3><ul><li>给定一个长度为无序数组nums，请返回数组中前 k 大的元素。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 基于堆查找数组中最大的 k 个元素 */</span><br><span class="line">Queue&lt;Integer&gt; topKHeap(int[] nums, int k) &#123;</span><br><span class="line">    Queue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    // 将数组的前 k 个元素入堆</span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        heap.offer(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 从第 k+1 个元素开始，保持堆的长度为 k</span><br><span class="line">    for (int i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆</span><br><span class="line">        if (nums[i] &gt; heap.peek()) &#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">            heap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="10-图"><a href="#10-图" class="headerlink" title="10. 图"></a>10. 图</h2><h3 id="10-1-基于邻接矩阵的实现"><a href="#10-1-基于邻接矩阵的实现" class="headerlink" title="10.1 基于邻接矩阵的实现"></a>10.1 基于邻接矩阵的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/* 基于邻接矩阵实现的无向图类 */</span><br><span class="line">class GraphAdjMat &#123;</span><br><span class="line">    List&lt;Integer&gt; vertices; // 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjMat; // 邻接矩阵，行列索引对应“顶点索引”</span><br><span class="line"></span><br><span class="line">    /* 构造方法 */</span><br><span class="line">    public GraphAdjMat(int[] vertices, int[][] edges) &#123;</span><br><span class="line">        this.vertices = new ArrayList&lt;&gt;();</span><br><span class="line">        this.adjMat = new ArrayList&lt;&gt;();</span><br><span class="line">        // 添加顶点</span><br><span class="line">        for (int val : vertices) &#123;</span><br><span class="line">            addVertex(val);</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加边</span><br><span class="line">        // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span><br><span class="line">        for (int[] e : edges) &#123;</span><br><span class="line">            addEdge(e[0], e[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取顶点数量 */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return vertices.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加顶点 */</span><br><span class="line">    public void addVertex(int val) &#123;</span><br><span class="line">        int n = size();</span><br><span class="line">        // 向顶点列表中添加新顶点的值</span><br><span class="line">        vertices.add(val);</span><br><span class="line">        // 在邻接矩阵中添加一行</span><br><span class="line">        List&lt;Integer&gt; newRow = new ArrayList&lt;&gt;(n);</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            newRow.add(0);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.add(newRow);</span><br><span class="line">        // 在邻接矩阵中添加一列</span><br><span class="line">        for (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.add(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 删除顶点 */</span><br><span class="line">    public void removeVertex(int index) &#123;</span><br><span class="line">        if (index &gt;= size())</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        // 在顶点列表中移除索引 index 的顶点</span><br><span class="line">        vertices.remove(index);</span><br><span class="line">        // 在邻接矩阵中删除索引 index 的行</span><br><span class="line">        adjMat.remove(index);</span><br><span class="line">        // 在邻接矩阵中删除索引 index 的列</span><br><span class="line">        for (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加边 */</span><br><span class="line">    // 参数 i, j 对应 vertices 元素索引</span><br><span class="line">    public void addEdge(int i, int j) &#123;</span><br><span class="line">        // 索引越界与相等处理</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        // 在无向图中，邻接矩阵沿主对角线对称，即满足 (i, j) == (j, i)</span><br><span class="line">        adjMat.get(i).set(j, 1);</span><br><span class="line">        adjMat.get(j).set(i, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 删除边 */</span><br><span class="line">    // 参数 i, j 对应 vertices 元素索引</span><br><span class="line">    public void removeEdge(int i, int j) &#123;</span><br><span class="line">        // 索引越界与相等处理</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        adjMat.get(i).set(j, 0);</span><br><span class="line">        adjMat.get(j).set(i, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 打印邻接矩阵 */</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.print(&quot;顶点列表 = &quot;);</span><br><span class="line">        System.out.println(vertices);</span><br><span class="line">        System.out.println(&quot;邻接矩阵 =&quot;);</span><br><span class="line">        PrintUtil.printMatrix(adjMat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-基于邻接表的实现"><a href="#10-2-基于邻接表的实现" class="headerlink" title="10.2 基于邻接表的实现"></a>10.2 基于邻接表的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/* 基于邻接表实现的无向图类 */</span><br><span class="line">class GraphAdjList &#123;</span><br><span class="line">    // 邻接表，key: 顶点，value：该顶点的所有邻接顶点</span><br><span class="line">    Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    /* 构造方法 */</span><br><span class="line">    public GraphAdjList(Vertex[][] edges) &#123;</span><br><span class="line">        this.adjList = new HashMap&lt;&gt;();</span><br><span class="line">        // 添加所有顶点和边</span><br><span class="line">        for (Vertex[] edge : edges) &#123;</span><br><span class="line">            addVertex(edge[0]);</span><br><span class="line">            addVertex(edge[1]);</span><br><span class="line">            addEdge(edge[0], edge[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取顶点数量 */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return adjList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加边 */</span><br><span class="line">    public void addEdge(Vertex vet1, Vertex vet2) &#123;</span><br><span class="line">        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 添加边 vet1 - vet2</span><br><span class="line">        adjList.get(vet1).add(vet2);</span><br><span class="line">        adjList.get(vet2).add(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 删除边 */</span><br><span class="line">    public void removeEdge(Vertex vet1, Vertex vet2) &#123;</span><br><span class="line">        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 删除边 vet1 - vet2</span><br><span class="line">        adjList.get(vet1).remove(vet2);</span><br><span class="line">        adjList.get(vet2).remove(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加顶点 */</span><br><span class="line">    public void addVertex(Vertex vet) &#123;</span><br><span class="line">        if (adjList.containsKey(vet))</span><br><span class="line">            return;</span><br><span class="line">        // 在邻接表中添加一个新链表</span><br><span class="line">        adjList.put(vet, new ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 删除顶点 */</span><br><span class="line">    public void removeVertex(Vertex vet) &#123;</span><br><span class="line">        if (!adjList.containsKey(vet))</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        // 在邻接表中删除顶点 vet 对应的链表</span><br><span class="line">        adjList.remove(vet);</span><br><span class="line">        // 遍历其他顶点的链表，删除所有包含 vet 的边</span><br><span class="line">        for (List&lt;Vertex&gt; list : adjList.values()) &#123;</span><br><span class="line">            list.remove(vet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 打印邻接表 */</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;邻接表 =&quot;);</span><br><span class="line">        for (Map.Entry&lt;Vertex, List&lt;Vertex&gt;&gt; pair : adjList.entrySet()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span><br><span class="line">            for (Vertex vertex : pair.getValue())</span><br><span class="line">                tmp.add(vertex.val);</span><br><span class="line">            System.out.println(pair.getKey().val + &quot;: &quot; + tmp + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-图的遍历"><a href="#10-3-图的遍历" class="headerlink" title="10.3 图的遍历"></a>10.3 图的遍历</h3><ul><li><p>广度优先遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 广度优先遍历 BFS */</span><br><span class="line">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span><br><span class="line">List&lt;Vertex&gt; graphBFS(GraphAdjList graph, Vertex startVet) &#123;</span><br><span class="line">    // 顶点遍历序列</span><br><span class="line">    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    // 哈希表，用于记录已被访问过的顶点</span><br><span class="line">    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">    visited.add(startVet);</span><br><span class="line">    // 队列用于实现 BFS</span><br><span class="line">    Queue&lt;Vertex&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">    que.offer(startVet);</span><br><span class="line">    // 以顶点 vet 为起点，循环直至访问完所有顶点</span><br><span class="line">    while (!que.isEmpty()) &#123;</span><br><span class="line">        Vertex vet = que.poll(); // 队首顶点出队</span><br><span class="line">        res.add(vet);            // 记录访问顶点</span><br><span class="line">        // 遍历该顶点的所有邻接顶点</span><br><span class="line">        for (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">            if (visited.contains(adjVet))</span><br><span class="line">                continue;        // 跳过已被访问过的顶点</span><br><span class="line">            que.offer(adjVet);   // 只入队未访问的顶点</span><br><span class="line">            visited.add(adjVet); // 标记该顶点已被访问</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回顶点遍历序列</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>深度优先遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 深度优先遍历 DFS 辅助函数 */</span><br><span class="line">void dfs(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) &#123;</span><br><span class="line">    res.add(vet);     // 记录访问顶点</span><br><span class="line">    visited.add(vet); // 标记该顶点已被访问</span><br><span class="line">    // 遍历该顶点的所有邻接顶点</span><br><span class="line">    for (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">        if (visited.contains(adjVet))</span><br><span class="line">            continue; // 跳过已被访问过的顶点</span><br><span class="line">        // 递归访问邻接顶点</span><br><span class="line">        dfs(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 深度优先遍历 DFS */</span><br><span class="line">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span><br><span class="line">List&lt;Vertex&gt; graphDFS(GraphAdjList graph, Vertex startVet) &#123;</span><br><span class="line">    // 顶点遍历序列</span><br><span class="line">    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    // 哈希表，用于记录已被访问过的顶点</span><br><span class="line">    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">    dfs(graph, visited, res, startVet);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-4-拓扑排序"><a href="#10-4-拓扑排序" class="headerlink" title="10.4 拓扑排序"></a>10.4 拓扑排序</h3><h2 id="11-搜索"><a href="#11-搜索" class="headerlink" title="11. 搜索"></a>11. 搜索</h2><h2 id="12-分治"><a href="#12-分治" class="headerlink" title="12. 分治"></a>12. 分治</h2><h2 id="13-回溯算法"><a href="#13-回溯算法" class="headerlink" title="13. 回溯算法"></a>13. 回溯算法</h2><h2 id="14-动态规划"><a href="#14-动态规划" class="headerlink" title="14. 动态规划"></a>14. 动态规划</h2><h2 id="15-贪心算法"><a href="#15-贪心算法" class="headerlink" title="15. 贪心算法"></a>15. 贪心算法</h2></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/" title="面试-算法" target="_blank" rel="external">https://wxzhou.top/2021/06/08/面试-算法/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/wx-zhou" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/wx-zhou" target="_blank"><span class="text-dark">wxzhou</span><small class="ml-1x">Java Development</small></a></h3><div>个人简介。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2021/06/08/%E9%9D%A2%E8%AF%95-java/" title="面试-Java"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a></li><li class="next"><a href="/2021/06/08/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93/" title="面试-数据库"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>Maybe you could buy me a cup of coffee.</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan"></div><p class="text-muted mv">Scan this qrcode</p><p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan"></div><p class="text-muted mv">Scan this qrcode</p><p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/wx-zhou" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/wxzhou" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2020-2024 <a href="https://wxzhou.top/" target="_blank">wxzhou</a><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"fPfDFgAyNvmw7q4OorZQyteK-gzGzoHsz",appKey:"4DRPTMYndqchd1TRUdHRcz6Q",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html>