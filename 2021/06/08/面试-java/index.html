<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="baidu-site-verification" content="codeva-G3l7rnjbue"><link rel="icon" href="favicon.png"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>面试-Java | wxzhou&#39;s blog</title><meta name="description" content="1. Java 语言的特点 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程； 可靠性（具备异常处理和自动内存管理机制）； 安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）； 高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）； 支持网络"><meta property="og:type" content="article"><meta property="og:title" content="面试-Java"><meta property="og:url" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/index.html"><meta property="og:site_name" content="wxzhou&#39;s blog"><meta property="og:description" content="1. Java 语言的特点 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程； 可靠性（具备异常处理和自动内存管理机制）； 安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）； 高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）； 支持网络"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/1.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/2.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/3.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/4.jpg"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/5.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/6.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/7.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/8.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/9.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/10.jpg"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/11.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/12.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/13.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/16.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/14.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/15.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/17.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/18.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/19.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/20.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/22.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/23.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/21.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/24.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/25.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/26.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/27.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/28.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/29.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/30.png"><meta property="og:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/31.png"><meta property="article:published_time" content="2021-06-08T11:50:53.000Z"><meta property="article:modified_time" content="2024-02-12T11:56:31.000Z"><meta property="article:author" content="wxzhou"><meta property="article:tag" content="面试"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/1.png"><link rel="canonical" href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/index.html"><link rel="alternate" href="/atom.xml" title="wxzhou&#39;s blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/wx-zhou" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">wxzhou</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Development</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="Search"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">Home</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">Archives</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">Categories</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">Tags</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">Repository</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">Links</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">About</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/wx-zhou" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/wxzhou" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">Board</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">Categories</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIT/">GIT</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="category-list-count">5</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tags</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Anaconda/" rel="tag">Anaconda</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GIT/" rel="tag">GIT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pycharm/" rel="tag">Pycharm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pytorch/" rel="tag">Pytorch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Server/" rel="tag">Server</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">5</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tag Cloud</h3><div class="widget-body tagcloud"><a href="/tags/Anaconda/" style="font-size:13px">Anaconda</a> <a href="/tags/GIT/" style="font-size:13px">GIT</a> <a href="/tags/GitHub/" style="font-size:13px">GitHub</a> <a href="/tags/Hexo/" style="font-size:13px">Hexo</a> <a href="/tags/IDEA/" style="font-size:13px">IDEA</a> <a href="/tags/Java/" style="font-size:14px">Java</a> <a href="/tags/Linux/" style="font-size:13.25px">Linux</a> <a href="/tags/Pycharm/" style="font-size:13px">Pycharm</a> <a href="/tags/Python/" style="font-size:13.5px">Python</a> <a href="/tags/Pytorch/" style="font-size:13px">Pytorch</a> <a href="/tags/Server/" style="font-size:13.25px">Server</a> <a href="/tags/kafka/" style="font-size:13px">kafka</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size:13.75px">面试</a></div></div><div class="widget"><h3 class="widget-title">Archive</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">24</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Recent Posts</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Linux/">Linux</a></p><p class="item-title"><a href="/2023/08/20/Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5(%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96)/" class="title">Linux云服务器故障排查（内存优化）</a></p><p class="item-date"><time datetime="2023-08-20T07:51:44.000Z" itemprop="datePublished">2023-08-20</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/GIT/">GIT</a></p><p class="item-title"><a href="/2023/07/20/%E8%A7%A3%E5%86%B3IDEA%E9%85%8D%E7%BD%AE-gitignore%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/" class="title">解决IDEA配置.gitignore不生效的问题</a></p><p class="item-date"><time datetime="2023-07-20T11:05:29.000Z" itemprop="datePublished">2023-07-20</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Python/">Python</a></p><p class="item-title"><a href="/2023/02/18/%E6%9F%A5%E7%9C%8B%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%89%80%E6%9C%89%E6%98%BE%E5%8D%A1%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%85%E5%92%8CGPU%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/" class="title">查看一台服务器上所有显卡上的使用者和GPU占用情况</a></p><p class="item-date"><time datetime="2023-02-18T04:34:49.000Z" itemprop="datePublished">2023-02-18</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Linux/">Linux</a></p><p class="item-title"><a href="/2023/02/15/Linux%E4%B8%8B%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/" class="title">Linux下在文件夹所有文件中查找相关内容</a></p><p class="item-date"><time datetime="2023-02-15T07:51:44.000Z" itemprop="datePublished">2023-02-15</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Linux/">Linux</a></p><p class="item-title"><a href="/2023/02/15/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" class="title">Linux服务器环境安装</a></p><p class="item-date"><time datetime="2023-02-15T07:51:44.000Z" itemprop="datePublished">2023-02-15</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-面试-java" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">面试-Java</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2021/06/08/%E9%9D%A2%E8%AF%95-java/" class="article-date"><time datetime="2021-06-08T11:50:53.000Z" itemprop="datePublished">2021-06-08</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/06/08/%E9%9D%A2%E8%AF%95-java/#comments" class="article-comment-link">Comments</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 31k(words)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 120(minutes)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h2 id="1-Java-语言的特点"><a href="#1-Java-语言的特点" class="headerlink" title="1. Java 语言的特点"></a>1. Java 语言的特点</h2><ul><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>支持多线程；</li><li>可靠性（具备异常处理和自动内存管理机制）；</li><li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；</li><li>高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；</li><li>支持网络编程并且很方便；</li><li>编译与解释并存；</li><li>强大的生态；</li></ul><h2 id="2-JVM、-JDK、-JRE"><a href="#2-JVM、-JDK、-JRE" class="headerlink" title="2. JVM、 JDK、 JRE"></a>2. JVM、 JDK、 JRE</h2><h3 id="2-1-JVM：Java-Virtual-Machine，Java虚拟机"><a href="#2-1-JVM：Java-Virtual-Machine，Java虚拟机" class="headerlink" title="2.1 JVM：Java Virtual Machine，Java虚拟机"></a>2.1 JVM：Java Virtual Machine，Java虚拟机</h3><ul><li>JVM是Java程序的运行环境，它能够执行Java程序编译后的字节码文件。JVM是运行Java程序的核心，因为Java程序必须在JVM上运行才能执行。</li><li>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言“一次编译，随处可以运行”(Write Once, Run Anywhere)的关键所在。</li></ul><h3 id="2-1-JDK：Java-Development-Kit"><a href="#2-1-JDK：Java-Development-Kit" class="headerlink" title="2.1 JDK：Java Development Kit"></a>2.1 JDK：Java Development Kit</h3><ul><li>它是功能齐全的 Java SDK，是提供给开发者使用的，能够创建和编译 Java 程序。</li><li>JDK包含了JRE，同时还包含了javac（编译 java 源码的编译器）、javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</li></ul><h3 id="2-3-JRE（Java-Runtime-Environment）"><a href="#2-3-JRE（Java-Runtime-Environment）" class="headerlink" title="2.3 JRE（Java Runtime Environment）"></a>2.3 JRE（Java Runtime Environment）</h3><ul><li>JRE是 Java 运行时环境。</li><li>它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/1.png"></p><h2 id="3-字节码"><a href="#3-字节码" class="headerlink" title="3. 字节码"></a>3. 字节码</h2><ul><li><strong>JVM可以理解的代码</strong>就叫做字节码（即扩展名为 <strong>.class</strong> 的文件），它不面向任何特定的处理器，<strong>只面向虚拟机</strong>。</li><li>Java 语言通过字节码的方式，在一定程度上<strong>解决了传统解释型语言执行效率低</strong>的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的，而且，由于字节码并不针对一种特定的机器，因此，Java 程序<strong>无须重新编译便可在多种不同操作系统的计算机上运行</strong>。</li><li>.class -&gt; 机器码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</span><br><span class="line">而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，</span><br><span class="line">所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。</span><br><span class="line">当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</span><br></pre></td></tr></table></figure><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/2.png"></li></ul><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h2><ul><li>单行注释：通常用于解释方法内某单行代码的作用。</li><li>多行注释：通常用于解释一段代码的作用。</li><li>文档注释：通常用于生成 Java 开发文档。</li></ul><h2 id="5-标识符和关键字"><a href="#5-标识符和关键字" class="headerlink" title="5. 标识符和关键字"></a>5. 标识符和关键字</h2><ul><li>标识符：就是一个名字，比如为程序、类、变量、方法等取名字；</li><li>关键字：被赋予特殊含义的标识符，比如private、protected、public等。</li></ul><h2 id="6-自增自减运算符"><a href="#6-自增自减运算符" class="headerlink" title="6. 自增自减运算符"></a>6. 自增自减运算符</h2><ul><li>自增运算符(++)和自减运算符(–)</li><li>当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。</li></ul><h2 id="7-移位运算符"><a href="#7-移位运算符" class="headerlink" title="7. 移位运算符"></a>7. 移位运算符</h2><ul><li>&lt;&lt; : 左移运算符，向左移若干位，高位丢弃，低位补零。x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下)。</li><li><blockquote><blockquote><p>: 带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x &gt;&gt; 1,相当于 x 除以 2。</p></blockquote></blockquote></li><li><blockquote><blockquote><blockquote><p>: 无符号右移，忽略符号位，空位都以 0 补齐。</p></blockquote></blockquote></blockquote></li></ul><h2 id="8-continue、break-和-return-的区别"><a href="#8-continue、break-和-return-的区别" class="headerlink" title="8. continue、break 和 return 的区别"></a>8. continue、break 和 return 的区别</h2><ul><li>continue：指跳出当前的这一次循环，继续下一次循环。</li><li>break：指跳出整个循环体，继续执行循环下面的语句。</li><li>return：用于跳出所在方法，结束该方法的运行。</li></ul><h2 id="9-基本数据类型"><a href="#9-基本数据类型" class="headerlink" title="9. 基本数据类型"></a>9. 基本数据类型</h2><p><strong>8 种基本数据类型</strong></p><ul><li>6 种数字类型：<ul><li>4 种整数型：byte(1)、short(2)、int(4)、long(8)</li><li>2 种浮点型：float(4)、double(8)</li></ul></li><li>1 种字符类型：char(2)</li><li>1 种布尔型：boolean</li></ul><h2 id="10-基本类型和包装类型的区别"><a href="#10-基本类型和包装类型的区别" class="headerlink" title="10. 基本类型和包装类型的区别"></a>10. 基本类型和包装类型的区别</h2><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型），基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是null。</li><li><strong>比较方式</strong>：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。</li></ul><h2 id="11-包装类型的缓存机制"><a href="#11-包装类型的缓存机制" class="headerlink" title="11. 包装类型的缓存机制"></a>11. 包装类型的缓存机制</h2><ul><li>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</li><li>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据；</li><li>Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False；</li><li>两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。</li></ul><h2 id="12-自动装箱与拆箱是什么，原理是什么"><a href="#12-自动装箱与拆箱是什么，原理是什么" class="headerlink" title="12. 自动装箱与拆箱是什么，原理是什么"></a>12. 自动装箱与拆箱是什么，原理是什么</h2><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 10;  //装箱</span><br><span class="line">int n = i;   //拆箱</span><br></pre></td></tr></table></figure></li><li>原理：从字节码中，我们发现<strong>装箱</strong>其实就是调用了包装类的valueOf()方法，<strong>拆箱</strong>其实就是调用了 xxxValue()方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 10 等价于 Integer i = Integer.valueOf(10)</span><br><span class="line">int n = i 等价于 int n = i.intValue();</span><br></pre></td></tr></table></figure></li><li>注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</li></ul><h2 id="13-为什么浮点数运算的时候会有精度丢失的风险"><a href="#13-为什么浮点数运算的时候会有精度丢失的风险" class="headerlink" title="13. 为什么浮点数运算的时候会有精度丢失的风险"></a>13. 为什么浮点数运算的时候会有精度丢失的风险</h2><p>这个和计算机保存浮点数的机制有很大关系。<br>我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h2 id="14-如何解决浮点数运算的精度丢失问题"><a href="#14-如何解决浮点数运算的精度丢失问题" class="headerlink" title="14. 如何解决浮点数运算的精度丢失问题"></a>14. 如何解决浮点数运算的精度丢失问题</h2><ul><li><p>BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。</p></li><li><p>通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));         <span class="comment">// 1.9</span></span><br><span class="line">System.out.println(a.subtract(b));    <span class="comment">// 0.1</span></span><br><span class="line">System.out.println(a.multiply(b));    <span class="comment">// 0.90</span></span><br><span class="line">System.out.println(a.divide(b));      <span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="15-超过-long-整型的数据应该如何表示"><a href="#15-超过-long-整型的数据应该如何表示" class="headerlink" title="15. 超过 long 整型的数据应该如何表示"></a>15. 超过 long 整型的数据应该如何表示</h2><ul><li>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。在 Java 中，64 位 long 整型是最大的整数类型。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l = Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + 1); // -9223372036854775808</span><br><span class="line">System.out.println(l + 1 == Long.MIN_VALUE); // true</span><br></pre></td></tr></table></figure></li><li>此时要使用BigInteger类进行操作，BigInteger内部使用int[]数组来存储任意大小的整形数据。相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi1 = new BigInteger(&quot;123456789&quot;) ;	// 声明BigInteger对象</span><br><span class="line">Integer bi2 = new BigInteger(&quot;987654321&quot;) ;	// 声明BigInteger对象</span><br><span class="line">tem.out.println(&quot;加法操作：&quot; + bi2.add(bi1)) ;	// 加法操作</span><br><span class="line">System.out.println(&quot;减法操作：&quot; + bi2.subtract(bi1)) ;	// 减法操作</span><br><span class="line">System.out.println(&quot;乘法操作：&quot; + bi2.multiply(bi1)) ;	// 乘法操作</span><br><span class="line">System.out.println(&quot;除法操作：&quot; + bi2.divide(bi1)) ;	// 除法操作</span><br><span class="line">System.out.println(&quot;最大数：&quot; + bi2.max(bi1)) ;	 // 求出最大数</span><br><span class="line">System.out.println(&quot;最小数：&quot; + bi2.min(bi1)) ;	 // 求出最小数</span><br><span class="line">BigInteger result[] = bi2.divideAndRemainder(bi1) ;	// 求出余数的除法操作</span><br><span class="line">System.out.println(&quot;商是：&quot; + result[0] + &quot;；余数是：&quot; + result[1]) ;</span><br></pre></td></tr></table></figure></li></ul><h2 id="16-成员变量与局部变量的区别"><a href="#16-成员变量与局部变量的区别" class="headerlink" title="16. 成员变量与局部变量的区别"></a>16. 成员变量与局部变量的区别</h2><ul><li>语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li>默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h2 id="17-静态变量有什么作用"><a href="#17-静态变量有什么作用" class="headerlink" title="17. 静态变量有什么作用"></a>17. 静态变量有什么作用</h2><ul><li>静态变量也就是被 static 关键字修饰的变量。</li><li>它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。</li><li>也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</li></ul><h2 id="18-字符型常量和字符串常量的区别"><a href="#18-字符型常量和字符串常量的区别" class="headerlink" title="18. 字符型常量和字符串常量的区别"></a>18. 字符型常量和字符串常量的区别</h2><ul><li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li><li><strong>含义</strong> : 字符常量相当于一个整型值(ASCII值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ul><h2 id="19-静态方法为什么不能调用非静态成员"><a href="#19-静态方法为什么不能调用非静态成员" class="headerlink" title="19. 静态方法为什么不能调用非静态成员"></a>19. 静态方法为什么不能调用非静态成员</h2><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul><h2 id="20-静态方法和实例方法有何不同"><a href="#20-静态方法和实例方法有何不同" class="headerlink" title="20. 静态方法和实例方法有何不同"></a>20. 静态方法和实例方法有何不同</h2><h3 id="20-1-调用方式"><a href="#20-1-调用方式" class="headerlink" title="20.1 调用方式"></a>20.1 调用方式</h3><ul><li>在外部调用静态方法时，可以使用<code>类名.方法名</code>的方式，也可以使用<code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>不过，需要注意的是一般不建议使用<code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。因此，一般建议使用<code>类名.方法名</code>的方式来调用静态方法。</li></ul><h3 id="20-2-访问类成员是否存在限制"><a href="#20-2-访问类成员是否存在限制" class="headerlink" title="20.2 访问类成员是否存在限制"></a>20.2 访问类成员是否存在限制</h3><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h2 id="21-重载和重写有什么区别"><a href="#21-重载和重写有什么区别" class="headerlink" title="21. 重载和重写有什么区别"></a>21. 重载和重写有什么区别</h2><ul><li>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</li><li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写，遵循”两同两小一大”<ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul></li></ul><h2 id="22-可变长参数"><a href="#22-可变长参数" class="headerlink" title="22. 可变长参数"></a>22. 可变长参数</h2><ul><li>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void method1(String... args) &#123;</span><br><span class="line">  //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void method2(String arg1, String... args) &#123;</span><br><span class="line">  //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方法重载会优先匹配固定参数的方法，因为固定参数的方法匹配度更高<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class VariableLengthArgument &#123;</span><br><span class="line"></span><br><span class="line">  public static void printVariable(String... args) &#123;</span><br><span class="line">      for (String s : args) &#123;</span><br><span class="line">          System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void printVariable(String arg1, String arg2) &#123;</span><br><span class="line">      System.out.println(arg1 + arg2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      printVariable(&quot;a&quot;, &quot;b&quot;);</span><br><span class="line">      printVariable(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Java 的可变参数编译后实际会被转换成一个数组</li></ul><h2 id="23-面向对象和面向过程的区别"><a href="#23-面向对象和面向过程的区别" class="headerlink" title="23. 面向对象和面向过程的区别"></a>23. 面向对象和面向过程的区别</h2><ul><li>两者的主要区别在于解决问题的方式不同：</li><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li><li>面向对象开发的程序一般更易维护、易复用、易扩展</li></ul><h2 id="24-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#24-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="24. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>24. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><ul><li>new 运算符，new 创建对象实例（对象实例在 内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</li><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li><li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><h2 id="25-对象的相等和引用相等的区别"><a href="#25-对象的相等和引用相等的区别" class="headerlink" title="25. 对象的相等和引用相等的区别"></a>25. 对象的相等和引用相等的区别</h2><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h2 id="26-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#26-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="26. 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>26. 如果一个类没有声明构造方法，该程序能正确执行吗?</h2><ul><li>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</li><li>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li><li>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</li></ul><h2 id="27-构造方法有哪些特点？是否可被-override"><a href="#27-构造方法有哪些特点？是否可被-override" class="headerlink" title="27. 构造方法有哪些特点？是否可被 override"></a>27. 构造方法有哪些特点？是否可被 override</h2><h3 id="27-1-特点："><a href="#27-1-特点：" class="headerlink" title="27.1 特点："></a>27.1 特点：</h3><ul><li>名字与类名相同</li><li>没有返回值，但不能用 void 声明构造函数</li><li>生成类的对象时自动执行，无需调用</li></ul><h3 id="27-2-是否可被重写"><a href="#27-2-是否可被重写" class="headerlink" title="27.2 是否可被重写"></a>27.2 是否可被重写</h3><ul><li>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</li></ul><h2 id="28-面向对象三大特征"><a href="#28-面向对象三大特征" class="headerlink" title="28. 面向对象三大特征"></a>28. 面向对象三大特征</h2><ul><li>封装：一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些可以被外界访问的方法来操作属性。</li><li>继承：通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</li><li>多态：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</li></ul><h2 id="29-接口和抽象类有什么共同点和区别"><a href="#29-接口和抽象类有什么共同点和区别" class="headerlink" title="29. 接口和抽象类有什么共同点和区别"></a>29. 接口和抽象类有什么共同点和区别</h2><h3 id="29-1-共同点："><a href="#29-1-共同点：" class="headerlink" title="29.1 共同点："></a>29.1 共同点：</h3><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</li></ul><h3 id="29-2-区别："><a href="#29-2-区别：" class="headerlink" title="29.2 区别："></a>29.2 区别：</h3><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h2 id="30-深拷贝和浅拷贝区别了解吗？什么是引用拷贝"><a href="#30-深拷贝和浅拷贝区别了解吗？什么是引用拷贝" class="headerlink" title="30. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝"></a>30. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝</h2><ul><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 实现了 Cloneable 接口，并重写了 clone() 方法</span><br><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">  private String name;</span><br><span class="line">  // 省略构造函数、Getter&amp;Setter方法</span><br><span class="line">  @Override</span><br><span class="line">  public Address clone() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          return (Address) super.clone();</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          throw new AssertionError();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">  private Address address;</span><br><span class="line">  // 省略构造函数、Getter&amp;Setter方法</span><br><span class="line">  @Override</span><br><span class="line">  public Person clone() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          Person person = (Person) super.clone();</span><br><span class="line">          return person;</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          throw new AssertionError();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress()); // true</span><br><span class="line">// 从输出结构就可以看出， person1 的克隆对象和 person1 使用的仍然是同一个 Address 对象。</span><br></pre></td></tr></table></figure></li><li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">  private Address address;</span><br><span class="line">  // 省略构造函数、Getter&amp;Setter方法</span><br><span class="line">  @Override</span><br><span class="line">  public Person clone() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          Person person = (Person) super.clone();</span><br><span class="line">          person.setAddress(person.getAddress().clone());</span><br><span class="line">          return person;</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          throw new AssertionError();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person1 = new Person(new Address(&quot;武汉&quot;));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress()); // false</span><br><span class="line">// 从输出结构就可以看出，显然 person1 的克隆对象和 person1 包含的 Address 对象已经是不同的了。</span><br></pre></td></tr></table></figure></li><li>引用拷贝：两个不同的引用指向同一个对象</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/3.png"></p><h2 id="31-Object-类的常见方法有哪些"><a href="#31-Object-类的常见方法有哪些" class="headerlink" title="31. Object 类的常见方法有哪些"></a>31. Object 类的常见方法有哪些</h2><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="32-x3D-x3D-和-equals-的区别"><a href="#32-x3D-x3D-和-equals-的区别" class="headerlink" title="32. &#x3D;&#x3D; 和 equals() 的区别"></a>32. &#x3D;&#x3D; 和 equals() 的区别</h2><h3 id="32-1-x3D-x3D"><a href="#32-1-x3D-x3D" class="headerlink" title="32.1 &#x3D;&#x3D;"></a>32.1 &#x3D;&#x3D;</h3><ul><li>对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。</li><li>对于引用数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。</li></ul><h3 id="32-2-equals"><a href="#32-2-equals" class="headerlink" title="32.2 equals()"></a>32.2 equals()</h3><ul><li>equals()不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。</li><li>equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。</li></ul><h2 id="33-hashCode-有什么用"><a href="#33-hashCode-有什么用" class="headerlink" title="33. hashCode() 有什么用"></a>33. hashCode() 有什么用</h2><ul><li>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</li><li>hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</li><li>另外需要注意的是：Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的。</li></ul><h2 id="34-为什么要有-hashCode"><a href="#34-为什么要有-hashCode" class="headerlink" title="34. 为什么要有 hashCode"></a>34. 为什么要有 hashCode</h2><ul><li>hashCode() 和 equals()都是用于比较两个对象是否相等。</li><li>在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程）</li><li>如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的 hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li><li>如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h2 id="35-为什么重写-equals-时必须重写-hashCode-方法"><a href="#35-为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="35. 为什么重写 equals() 时必须重写 hashCode() 方法"></a>35. 为什么重写 equals() 时必须重写 hashCode() 方法</h2><ul><li>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</li><li>如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。</li></ul><h2 id="36-String、StringBuffer、StringBuilder-的区别"><a href="#36-String、StringBuffer、StringBuilder-的区别" class="headerlink" title="36. String、StringBuffer、StringBuilder 的区别"></a>36. String、StringBuffer、StringBuilder 的区别</h2><h3 id="36-1-可变性"><a href="#36-1-可变性" class="headerlink" title="36.1 可变性"></a>36.1 可变性</h3><ul><li>String 是不可变的。</li><li>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</li></ul><h3 id="36-2-线程安全性"><a href="#36-2-线程安全性" class="headerlink" title="36.2 线程安全性"></a>36.2 线程安全性</h3><ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</li><li>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li></ul><h3 id="36-3-性能"><a href="#36-3-性能" class="headerlink" title="36.3 性能"></a>36.3 性能</h3><ul><li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</li><li>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</li><li>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><h3 id="36-4-总结"><a href="#36-4-总结" class="headerlink" title="36.4 总结"></a>36.4 总结</h3><ul><li>操作少量的数据: 适用 String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ul><h2 id="37-String-为什么是不可变的"><a href="#37-String-为什么是不可变的" class="headerlink" title="37. String 为什么是不可变的"></a>37. String 为什么是不可变的</h2><ul><li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li></ul><h2 id="38-字符串拼接用“-”-还是-StringBuilder"><a href="#38-字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="38. 字符串拼接用“+” 还是 StringBuilder"></a>38. 字符串拼接用“+” 还是 StringBuilder</h2><h3 id="38-1"><a href="#38-1" class="headerlink" title="38.1 +"></a>38.1 +</h3><ul><li>字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;he&quot;;</span><br><span class="line">String str2 = &quot;llo&quot;;</span><br><span class="line">String str3 = &quot;world&quot;;</span><br><span class="line">String str4 = str1 + str2 + str3;</span><br></pre></td></tr></table></figure></li><li>在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;&#125;;</span><br><span class="line">String s = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure></li></ul><h3 id="38-2-StringBuilder"><a href="#38-2-StringBuilder" class="headerlink" title="38.2 StringBuilder"></a>38.2 StringBuilder</h3><ul><li>如果直接使用 StringBuilder 对象进行字符串拼接的话，就不会存在这个问题了。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;&#125;;</span><br><span class="line">StringBuilder s = new StringBuilder();</span><br><span class="line">for (String value : arr) &#123;</span><br><span class="line">  s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure></li></ul><h2 id="39-String-equals-和-Object-equals-有何区别"><a href="#39-String-equals-和-Object-equals-有何区别" class="headerlink" title="39. String#equals() 和 Object#equals() 有何区别"></a>39. String#equals() 和 Object#equals() 有何区别</h2><ul><li>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。</li><li>Object 的 equals 方法是比较的对象的内存地址。</li></ul><h2 id="40-字符串常量池的作用了解吗"><a href="#40-字符串常量池的作用了解吗" class="headerlink" title="40. 字符串常量池的作用了解吗"></a>40. 字符串常量池的作用了解吗</h2><ul><li>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域.</li><li>主要目的是为了避免字符串的重复创建。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在常量池中创建字符串对象”ab“</span><br><span class="line">String aa = &quot;ab&quot;;</span><br><span class="line">// 直接返回常量池中字符串”ab“的引用</span><br><span class="line">String bb = &quot;ab&quot;;</span><br><span class="line">System.out.println(aa==bb); // true</span><br></pre></td></tr></table></figure></li></ul><h2 id="41-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#41-String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="41. String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>41. String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h2><ul><li>会创建 1 或 2 个字符串对象。</li><li>如果字符串常量池中不存在字符串“abc”:<ul><li>首先在字符串常量池中创建一个”abc”对象</li><li>然后在堆内存中创建1个对象指向字符串常量池中的”abc”，因此将创建总共 2 个字符串对象。</li></ul></li><li>如果常量池中已存在字符串“abc”，则只会在堆中创建一个对象指向字符串常量池中的”abc”</li></ul><h2 id="42-String-intern-方法有什么作用"><a href="#42-String-intern-方法有什么作用" class="headerlink" title="42. String#intern 方法有什么作用"></a>42. String#intern 方法有什么作用</h2><ul><li>String.intern() 是一个 native（本地）方法，可以简单分为两种情况：<ul><li>如果字符串常量池中保存了对应的字符串，就直接返回该字符串的引用。</li><li>如果字符串常量池中没有保存对应的字符串，那就在常量池中创建一个该字符串的对象并返回。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 在字符串常量池中创建一个&quot;Java&quot;对象</span><br><span class="line">String s1 = &quot;Java&quot;;</span><br><span class="line">// 直接返回字符串常量池中字符串对象”Java“</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">// 会在堆中在单独创建一个字符串对象，指向常量池中”Java“对象</span><br><span class="line">String s3 = new String(&quot;Java&quot;);</span><br><span class="line">// 直接返回字符串常量池中字符串对象”Java“</span><br><span class="line">String s4 = s3.intern();</span><br><span class="line">// s1 和 s2 指向的是常量池中的同一个对象</span><br><span class="line">System.out.println(s1 == s2); // true</span><br><span class="line">// s3 和 s4 指向的是不同的对象，s3指向的是堆中的一个字符串对象，s4指向的是常量池中的”Java“对象</span><br><span class="line">System.out.println(s3 == s4); // false</span><br><span class="line">// s1 和 s4 指向的是常量池中的同一个”Java“对象</span><br><span class="line">System.out.println(s1 == s4); //true</span><br></pre></td></tr></table></figure><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/4.jpg"></li></ul></li></ul><h2 id="43-Exception-和-Error-有什么区别？"><a href="#43-Exception-和-Error-有什么区别？" class="headerlink" title="43. Exception 和 Error 有什么区别？"></a>43. Exception 和 Error 有什么区别？</h2><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:</p><ul><li>Exception: 程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>Error：Error 属于程序无法处理的错误 ，不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h2 id="44-Checked-Exception-和-Unchecked-Exception-有什么区别"><a href="#44-Checked-Exception-和-Unchecked-Exception-有什么区别" class="headerlink" title="44. Checked Exception 和 Unchecked Exception 有什么区别"></a>44. Checked Exception 和 Unchecked Exception 有什么区别</h2><ul><li>Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。</li><li>Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</li></ul><h2 id="45-Throwable-类常用方法有哪些？"><a href="#45-Throwable-类常用方法有哪些？" class="headerlink" title="45. Throwable 类常用方法有哪些？"></a>45. Throwable 类常用方法有哪些？</h2><ul><li>String getMessage(): 返回异常发生时的简要描述</li><li>String toString(): 返回异常发生时的详细信息</li><li>String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</li><li>void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息</li></ul><h2 id="46-try-catch-finally-如何使用？"><a href="#46-try-catch-finally-如何使用？" class="headerlink" title="46. try-catch-finally 如何使用？"></a>46. try-catch-finally 如何使用？</h2><ul><li>try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li><li>catch块：用于处理 try 捕获到的异常。</li><li>finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;Try to do something&quot;);</span><br><span class="line">    throw new RuntimeException(&quot;RuntimeException&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;Catch Exception -&gt; &quot; + e.getMessage());</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System.out.println(&quot;Finally&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure></li></ul><h2 id="47-finally-中的代码一定会执行吗？"><a href="#47-finally-中的代码一定会执行吗？" class="headerlink" title="47. finally 中的代码一定会执行吗？"></a>47. finally 中的代码一定会执行吗？</h2><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><ul><li>finally执行之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ul><h2 id="48-如何使用-try-with-resources-代替try-catch-finally"><a href="#48-如何使用-try-with-resources-代替try-catch-finally" class="headerlink" title="48. 如何使用 try-with-resources 代替try-catch-finally"></a>48. 如何使用 try-with-resources 代替try-catch-finally</h2><ul><li>Java 中类似于InputStream、OutputStream、Scanner、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//读取文本文件的内容</span><br><span class="line">Scanner scanner = null;</span><br><span class="line">try &#123;</span><br><span class="line">  scanner = new Scanner(new File(&quot;D://read.txt&quot;));</span><br><span class="line">  while (scanner.hasNext()) &#123;</span><br><span class="line">    System.out.println(scanner.nextLine());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  if (scanner != null) &#123;</span><br><span class="line">    scanner.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 Java 7 之后的 try-with-resources 语句改造上面的代码:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try (Scanner scanner = new Scanner(new File(&quot;test.txt&quot;))) &#123;</span><br><span class="line">  while (scanner.hasNext()) &#123;</span><br><span class="line">      System.out.println(scanner.nextLine());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (FileNotFoundException fnfe) &#123;</span><br><span class="line">  fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;)));</span><br><span class="line">     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;</span><br><span class="line">  int b;</span><br><span class="line">  while ((b = bin.read()) != -1) &#123;</span><br><span class="line">      bout.write(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="49-异常使用有哪些需要注意的地方？"><a href="#49-异常使用有哪些需要注意的地方？" class="headerlink" title="49. 异常使用有哪些需要注意的地方？"></a>49. 异常使用有哪些需要注意的地方？</h2><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常，比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。</li><li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）</li></ul><h2 id="50-什么是泛型？有什么作用？"><a href="#50-什么是泛型？有什么作用？" class="headerlink" title="50. 什么是泛型？有什么作用？"></a>50. 什么是泛型？有什么作用？</h2><ul><li>泛型（Generics）是 JDK5 中引入的一个新特性。</li><li>使用泛型参数，可以增强代码的<strong>可读性</strong>以及<strong>稳定性</strong>。</li><li>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList<person>persons &#x3D; new ArrayList<person>() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。</person></person></li></ul><h2 id="51-泛型的使用方式有哪几种？"><a href="#51-泛型的使用方式有哪几种？" class="headerlink" title="51. 泛型的使用方式有哪几种？"></a>51. 泛型的使用方式有哪几种？</h2><ul><li>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</li><li>泛型类：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="line">// 在实例化泛型类时，必须指定T的具体类型</span><br><span class="line">public class Generic&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public Generic(T key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getKey()&#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 实例化泛型类</span><br><span class="line">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</span><br></pre></td></tr></table></figure></li><li>泛型接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">  public T method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 实现泛型接口，不指定类型：</span><br><span class="line">class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public T method() &#123;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现泛型接口，指定类型：</span><br><span class="line">class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public String method() &#123;</span><br><span class="line">      return &quot;hello&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>泛型方法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void printArray(E[] inputArray)&#123;</span><br><span class="line">  for (E element : inputArray )&#123;</span><br><span class="line">    System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="52-何谓注解"><a href="#52-何谓注解" class="headerlink" title="52. 何谓注解"></a>52. 何谓注解</h2><ul><li>Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</li><li>注解本质是一个继承了Annotation 的特殊接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Override extends Annotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="53-注解的解析方法有哪几种"><a href="#53-注解的解析方法有哪几种" class="headerlink" title="53. 注解的解析方法有哪几种"></a>53. 注解的解析方法有哪几种</h2><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li>编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li>运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。</li></ul><h2 id="54-Java-值传递"><a href="#54-Java-值传递" class="headerlink" title="54. Java 值传递"></a>54. Java 值传递</h2><p>Java 中将实参传递给方法（或函数）的方式是值传递：</p><ul><li>如果参数是基本类型：传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型：传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h2 id="55-什么是序列化和反序列化"><a href="#55-什么是序列化和反序列化" class="headerlink" title="55. 什么是序列化和反序列化?"></a>55. 什么是序列化和反序列化?</h2><h3 id="55-1-定义"><a href="#55-1-定义" class="headerlink" title="55.1 定义"></a>55.1 定义</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><h3 id="55-2-区别"><a href="#55-2-区别" class="headerlink" title="55.2 区别"></a>55.2 区别</h3><ul><li>序列化：serialization, 将数据结构或对象转换成二进制字节流的过程，主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h3 id="55-3-应用场景"><a href="#55-3-应用场景" class="headerlink" title="55.3 应用场景"></a>55.3 应用场景</h3><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><h3 id="55-4-序列化协议对应于-TCP-x2F-IP-4-层模型的哪一层"><a href="#55-4-序列化协议对应于-TCP-x2F-IP-4-层模型的哪一层" class="headerlink" title="55.4 序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层"></a>55.4 序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层</h3><ul><li>TCP&#x2F;IP 四层模型是：应用层、传输层、网络层、网络接口层</li><li>序列化协议属于 TCP&#x2F;IP 协议应用层的一部分</li></ul><h2 id="56-常见序列化协议有哪些"><a href="#56-常见序列化协议有哪些" class="headerlink" title="56. 常见序列化协议有哪些"></a>56. 常见序列化协议有哪些</h2><h3 id="56-1-JDK-自带的序列化方式"><a href="#56-1-JDK-自带的序列化方式" class="headerlink" title="56.1 JDK 自带的序列化方式"></a>56.1 JDK 自带的序列化方式</h3><ul><li>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Getter</span><br><span class="line">@Builder</span><br><span class="line">@ToString</span><br><span class="line">public class RpcRequest implements Serializable &#123;</span><br><span class="line">  private static final long serialVersionUID = 1905122041950251207L;</span><br><span class="line">  private String requestId;</span><br><span class="line">  private String interfaceName;</span><br><span class="line">  private String methodName;</span><br><span class="line">  private Object[] parameters;</span><br><span class="line">  private Class&lt;?&gt;[] paramTypes;</span><br><span class="line">  private RpcMessageTypeEnum rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>为什么不推荐使用 JDK 自带的序列化?<ul><li>不支持跨语言调用</li><li>性能差</li><li>存在安全问题</li></ul></li></ul><h3 id="56-2-其他序列化协议"><a href="#56-2-其他序列化协议" class="headerlink" title="56.2 其他序列化协议"></a>56.2 其他序列化协议</h3><ul><li>有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</li></ul><h2 id="57-何为反射？"><a href="#57-何为反射？" class="headerlink" title="57. 何为反射？"></a>57. 何为反射？</h2><ul><li>反射（Reflection） 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查.</li><li>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性</li></ul><h2 id="58-反射的应用场景了解么"><a href="#58-反射的应用场景了解么" class="headerlink" title="58. 反射的应用场景了解么"></a>58. 反射的应用场景了解么</h2><ul><li>平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景;</li><li>像Spring&#x2F;Spring Boot、MyBatis等框架中大量使用了动态代理，而动态代理的实现依赖反射。</li></ul><h2 id="59-反射机制的优缺点"><a href="#59-反射机制的优缺点" class="headerlink" title="59. 反射机制的优缺点"></a>59. 反射机制的优缺点</h2><ul><li>优点：<ul><li>可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li></ul></li><li>缺点：<ul><li>安全问题：比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</li><li>性能问题：反射的性能要稍差点，但是对于框架来说实际是影响不大。</li></ul></li></ul><h2 id="60-获取-Class-对象的四种方式"><a href="#60-获取-Class-对象的四种方式" class="headerlink" title="60. 获取 Class 对象的四种方式"></a>60. 获取 Class 对象的四种方式</h2><ul><li>知道具体类的情况下可以使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;</span><br></pre></td></tr></table></figure></li><li>通过 Class.forName()传入类的全路径获取：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(&quot;cn.javaguide.TargetObject&quot;);</span><br></pre></td></tr></table></figure></li><li>通过对象实例instance.getClass()获取：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TargetObject o = new TargetObject();</span><br><span class="line">Class alunbarClass2 = o.getClass();</span><br></pre></td></tr></table></figure></li><li></li><li>通过类加载器xxxClassLoader.loadClass()传入类路径获取:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(&quot;cn.javaguide.TargetObject&quot;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="61-反射的一些基本操作"><a href="#61-反射的一些基本操作" class="headerlink" title="61. 反射的一些基本操作"></a>61. 反射的一些基本操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个我们要使用反射操作的类 TargetObject</span><br><span class="line">public class TargetObject &#123;</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    public TargetObject() &#123;</span><br><span class="line">        value = &quot;JavaGuide&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void publicMethod(String s) &#123;</span><br><span class="line">        System.out.println(&quot;I love &quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void privateMethod() &#123;</span><br><span class="line">        System.out.println(&quot;value is &quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用反射操作这个类的方法以及参数</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(&quot;cn.javaguide.TargetObject&quot;);</span><br><span class="line">        TargetObject targetObject = (TargetObject) targetClass.newInstance();</span><br><span class="line">        /**</span><br><span class="line">         * 获取 TargetObject 类中定义的所有方法</span><br><span class="line">         */</span><br><span class="line">        Method[] methods = targetClass.getDeclaredMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 获取指定方法并调用</span><br><span class="line">         */</span><br><span class="line">        Method publicMethod = targetClass.getDeclaredMethod(&quot;publicMethod&quot;,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, &quot;JavaGuide&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 获取指定参数并对参数进行修改</span><br><span class="line">         */</span><br><span class="line">        Field field = targetClass.getDeclaredField(&quot;value&quot;);</span><br><span class="line">        //为了对类中的参数进行修改我们取消安全检查</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(targetObject, &quot;JavaGuide&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 调用 private 方法</span><br><span class="line">         */</span><br><span class="line">        Method privateMethod = targetClass.getDeclaredMethod(&quot;privateMethod&quot;);</span><br><span class="line">        //为了调用private方法我们取消安全检查</span><br><span class="line">        privateMethod.setAccessible(true);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure><h2 id="62-代理模式"><a href="#62-代理模式" class="headerlink" title="62. 代理模式"></a>62. 代理模式</h2><h3 id="62-1-概念："><a href="#62-1-概念：" class="headerlink" title="62.1 概念："></a>62.1 概念：</h3><ul><li>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</li><li>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</li></ul><h3 id="62-2-静态代理"><a href="#62-2-静态代理" class="headerlink" title="62.2 静态代理"></a>62.2 静态代理</h3><ul><li>静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改），且麻烦(需要对每个目标类都单独写一个代理类）。</li><li>从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</li><li>实现步骤：<ul><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义发送短信的接口</span><br><span class="line">public interface SmsService &#123;</span><br><span class="line">  String send(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 实现发送短信的接口</span><br><span class="line">public class SmsServiceImpl implements SmsService &#123;</span><br><span class="line">  public String send(String message) &#123;</span><br><span class="line">      System.out.println(&quot;send message:&quot; + message);</span><br><span class="line">      return message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 创建代理类并同样实现发送短信的接口</span><br><span class="line">public class SmsProxy implements SmsService &#123;</span><br><span class="line">  private final SmsService smsService;</span><br><span class="line">  public SmsProxy(SmsService smsService) &#123;</span><br><span class="line">      this.smsService = smsService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String send(String message) &#123;</span><br><span class="line">      //调用方法之前，我们可以添加自己的操作</span><br><span class="line">      System.out.println(&quot;before method send()&quot;);</span><br><span class="line">      smsService.send(message);</span><br><span class="line">      //调用方法之后，我们同样可以添加自己的操作</span><br><span class="line">      System.out.println(&quot;after method send()&quot;);</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 实际使用</span><br><span class="line">public class Main &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      SmsService smsService = new SmsServiceImpl();</span><br><span class="line">      SmsProxy smsProxy = new SmsProxy(smsService);</span><br><span class="line">      smsProxy.send(&quot;java&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5. 运行上述代码之后，控制台打印出：</span><br><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="62-3-动态代理"><a href="#62-3-动态代理" class="headerlink" title="62.3 动态代理"></a>62.3 动态代理</h3><ul><li><p>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p></li><li><p>实现步骤</p><ul><li>定义一个接口及其实现类；</li><li>创建动态代理类，实现InvocationHandler接口，重写invoke方法，在 invoke 方法中调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>创建代理对象的工厂类，通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义发送短信的接口</span><br><span class="line">public interface SmsService &#123;</span><br><span class="line">  String send(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 实现发送短信的接口</span><br><span class="line">public class SmsServiceImpl implements SmsService &#123;</span><br><span class="line">  public String send(String message) &#123;</span><br><span class="line">      System.out.println(&quot;send message:&quot; + message);</span><br><span class="line">      return message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 定义一个 JDK 动态代理类</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class DebugInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">  /**</span><br><span class="line">  * 代理类中的真实对象</span><br><span class="line">  */</span><br><span class="line">  private final Object target;</span><br><span class="line">  public DebugInvocationHandler(Object target) &#123;</span><br><span class="line">    this.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      //调用方法之前，我们可以添加自己的操作</span><br><span class="line">      System.out.println(&quot;before method &quot; + method.getName());</span><br><span class="line">      Object result = method.invoke(target, args);</span><br><span class="line">      //调用方法之后，我们同样可以添加自己的操作</span><br><span class="line">      System.out.println(&quot;after method &quot; + method.getName());</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 获取代理对象的工厂类</span><br><span class="line">public class JdkProxyFactory &#123;</span><br><span class="line">  // 主要通过Proxy.newProxyInstance（）方法获取某个类的代理对象</span><br><span class="line">  public static Object getProxy(Object target) &#123;</span><br><span class="line">      return Proxy.newProxyInstance(</span><br><span class="line">              target.getClass().getClassLoader(), // 目标类的类加载器</span><br><span class="line">              target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个</span><br><span class="line">              new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5. 实际使用</span><br><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());</span><br><span class="line">smsService.send(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">// 6. 运行上述代码之后，控制台打印出：</span><br><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="62-4-静态代理和动态代理的对比"><a href="#62-4-静态代理和动态代理的对比" class="headerlink" title="62.4 静态代理和动态代理的对比"></a>62.4 静态代理和动态代理的对比</h3><ul><li>灵活性：<ul><li>静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，非常麻烦</li><li>动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。</li></ul></li><li>JVM 层面：<ul><li>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</li><li>而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul></li></ul><h2 id="63-SPI"><a href="#63-SPI" class="headerlink" title="63. SPI"></a>63. SPI</h2><h3 id="63-1-SPI和API的区别"><a href="#63-1-SPI和API的区别" class="headerlink" title="63.1 SPI和API的区别"></a>63.1 SPI和API的区别</h3><ul><li>实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</li><li>当接口存在于调用方这边时，就是SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</li><li>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/5.png"></li></ul><h3 id="63-2-应用场景"><a href="#63-2-应用场景" class="headerlink" title="63.2 应用场景"></a>63.2 应用场景</h3><p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p><h2 id="64-语法糖"><a href="#64-语法糖" class="headerlink" title="64. 语法糖"></a>64. 语法糖</h2><h3 id="64-1-定义"><a href="#64-1-定义" class="headerlink" title="64.1 定义"></a>64.1 定义</h3><ul><li>语法糖（Syntactic Sugar） 也称糖衣语法。</li><li>指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。</li><li>简而言之，语法糖让程序更加简洁，有更高的可读性。</li></ul><h3 id="64-2-switch-支持-String"><a href="#64-2-switch-支持-String" class="headerlink" title="64.2 switch 支持 String"></a>64.2 switch 支持 String</h3><ul><li>switch自身<strong>原本</strong>就支持基本类型。比如int、char等。<ul><li>对于int类型，直接进行数值的比较。</li><li>对于char类型则是比较其 ascii 码。</li><li>所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。</li></ul></li><li>Java 7 中switch开始支持String<ul><li>字符串的 switch 是通过equals()和hashCode()方法来实现的</li></ul></li></ul><h3 id="64-3-泛型"><a href="#64-3-泛型" class="headerlink" title="64.3 泛型"></a>64.3 泛型</h3><ul><li>对于JVM来说，他根本不认识Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 原来的代码：</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(&quot;name&quot;, &quot;hollis&quot;);</span><br><span class="line">map.put(&quot;wechat&quot;, &quot;Hollis&quot;);</span><br><span class="line">map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</span><br><span class="line"></span><br><span class="line">// 解语法糖之后会变成：</span><br><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(&quot;name&quot;, &quot;hollis&quot;);</span><br><span class="line">map.put(&quot;wechat&quot;, &quot;Hollis&quot;);</span><br><span class="line">map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="64-4-自动装箱与拆箱"><a href="#64-4-自动装箱与拆箱" class="headerlink" title="64.4 自动装箱与拆箱"></a>64.4 自动装箱与拆箱</h3><ul><li>装箱过程是通过调用包装器的 valueOf 方法实现的，</li><li>拆箱过程是通过调用包装器的 xxxValue 方法实现的。</li></ul><h3 id="64-5-可变长参数"><a href="#64-5-可变长参数" class="headerlink" title="64.5 可变长参数"></a>64.5 可变长参数</h3><p>可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p><h3 id="64-6-断言"><a href="#64-6-断言" class="headerlink" title="64.6 断言"></a>64.6 断言</h3><p>断言的底层实现就是 if 语言，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertionError 来打断程序的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> a == b;</span><br><span class="line">        System.out.println(<span class="string">&quot;公众号：Hollis&quot;</span>);</span><br><span class="line">        <span class="keyword">assert</span> a != b : <span class="string">&quot;Hollis&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="64-7-数值字面量"><a href="#64-7-数值字面量" class="headerlink" title="64.7 数值字面量"></a>64.7 数值字面量</h3><p>编译器并不认识在数字字面量中的_，需要在编译阶段把他去掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。</span></span><br><span class="line"><span class="comment">// 这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10_000</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="64-8-for-each"><a href="#64-8-for-each" class="headerlink" title="64.8 for-each"></a>64.8 for-each</h3><p>for-each 的实现原理其实就是使用了普通的 for 循环和迭代器</p><h3 id="64-9-try-with-resource"><a href="#64-9-try-with-resource" class="headerlink" title="64.9 try-with-resource"></a>64.9 try-with-resource</h3><p>背后的原理很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。</p><h2 id="65-集合概述"><a href="#65-集合概述" class="headerlink" title="65. 集合概述"></a>65. 集合概述</h2><h3 id="65-1-集合概览"><a href="#65-1-集合概览" class="headerlink" title="65.1 集合概览"></a>65.1 集合概览</h3><p>集合，也叫作容器，主要是由两大接口派生而来：</p><ul><li><code>Collection</code>接口，主要用于存放单一元素，包含三个主要子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</li><li><code>Map</code> 接口，主要用于存放键值对。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/6.png" alt="Java 集合框架概览"></p><h3 id="65-2-说说-List-Set-Queue-Map-四者的区别？"><a href="#65-2-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="65.2 说说 List, Set, Queue, Map 四者的区别？"></a>65.2 说说 List, Set, Queue, Map 四者的区别？</h3><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序、可重复、有索引。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序、不可重复、无索引。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="65-3-集合框架底层数据结构总结"><a href="#65-3-集合框架底层数据结构总结" class="headerlink" title="65.3 集合框架底层数据结构总结"></a>65.3 集合框架底层数据结构总结</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li><code>ArrayList</code>：<code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> （JDK8以前：数组+链表，JDK8以后：数组+链表+红黑树）实现的，底层采用 <code>HashMap</code> 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，基于HashMap来实现，每个元素额外多了一个双链表记录前后元素的位置。</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）</li></ul><h3 id="65-4-如何选用集合"><a href="#65-4-如何选用集合" class="headerlink" title="65.4 如何选用集合?"></a>65.4 如何选用集合?</h3><p>我们主要根据集合的特点来选择合适的集合。比如：</p><ul><li>我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，<ul><li>需要排序时选择 <code>TreeMap</code></li><li>不需要排序时就选择 <code>HashMap</code></li><li>需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li></ul></li><li>我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合<ul><li>需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，</li><li>不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code></li></ul></li></ul><h3 id="65-5-为什么要使用集合？"><a href="#65-5-为什么要使用集合？" class="headerlink" title="65.5 为什么要使用集合？"></a>65.5 为什么要使用集合？</h3><ul><li>数组：<ul><li>当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。</li><li>但是，使用数组存储对象存在一些不足：存储类型固定，长度固定。</li></ul></li><li>集合：<ul><li>集合的优势在于它们的大小可变、支持泛型等。</li><li>集合提高了数据的存储和处理灵活性。</li></ul></li></ul><h2 id="66-List"><a href="#66-List" class="headerlink" title="66. List"></a>66. List</h2><h3 id="66-1-ArrayList底层的原理"><a href="#66-1-ArrayList底层的原理" class="headerlink" title="66.1 ArrayList底层的原理"></a>66.1 ArrayList底层的原理</h3><ul><li>利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组</li><li>添加第一个元素时，底层会创建一个新的长度为10的数组</li><li>存满时，会扩容1.5倍</li><li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li></ul><h3 id="66-2-ArrayList-和-Array（数组）的区别？"><a href="#66-2-ArrayList-和-Array（数组）的区别？" class="headerlink" title="66.2 ArrayList 和 Array（数组）的区别？"></a>66.2 ArrayList 和 Array（数组）的区别？</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Array</span><br><span class="line">// 初始化一个 String 类型的数组</span><br><span class="line">String[] stringArr = new String[]&#123;&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;&#125;;</span><br><span class="line">// 修改数组元素的值</span><br><span class="line">stringArr[0] = &quot;goodbye&quot;;</span><br><span class="line">System.out.println(Arrays.toString(stringArr));// [goodbye, world, !]</span><br><span class="line">// 删除数组中的元素，需要手动移动后面的元素</span><br><span class="line">for (int i = 0; i &lt; stringArr.length - 1; i++) &#123;</span><br><span class="line">   stringArr[i] = stringArr[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">stringArr[stringArr.length - 1] = null;</span><br><span class="line">System.out.println(Arrays.toString(stringArr));// [world, !, null]</span><br><span class="line">      </span><br><span class="line">ArrayList</span><br><span class="line">// 初始化一个 String 类型的 ArrayList</span><br><span class="line">ArrayList&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;));</span><br><span class="line">// 添加元素到 ArrayList 中</span><br><span class="line">stringList.add(&quot;goodbye&quot;);</span><br><span class="line">System.out.println(stringList);// [hello, world, !, goodbye]</span><br><span class="line">// 修改 ArrayList 中的元素</span><br><span class="line">stringList.set(0, &quot;hi&quot;);</span><br><span class="line">System.out.println(stringList);// [hi, world, !, goodbye]</span><br><span class="line">// 删除 ArrayList 中的元素</span><br><span class="line">stringList.remove(0);</span><br><span class="line">System.out.println(stringList); // [world, !, goodbye]</span><br></pre></td></tr></table></figure><h3 id="66-3-ArrayList-可以添加-null-值吗？"><a href="#66-3-ArrayList-可以添加-null-值吗？" class="headerlink" title="66.3 ArrayList 可以添加 null 值吗？"></a>66.3 ArrayList 可以添加 null 值吗？</h3><ul><li><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。</li><li>不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; listOfStrings = new ArrayList&lt;&gt;();</span><br><span class="line">listOfStrings.add(null);</span><br><span class="line">listOfStrings.add(&quot;java&quot;);</span><br><span class="line">System.out.println(listOfStrings);</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">[null, java]</span><br></pre></td></tr></table></figure><h3 id="66-4-ArrayList-插入和删除元素的时间复杂度？"><a href="#66-4-ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="66.4 ArrayList 插入和删除元素的时间复杂度？"></a>66.4 ArrayList 插入和删除元素的时间复杂度？</h3><ul><li><p>插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 **O(n)**。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 **O(1)**，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 **O(n)**。</li></ul></li><li><p>删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 **O(n)**。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 **O(1)**。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul></li></ul><h3 id="66-5-LinkedList-插入和删除元素的时间复杂度？"><a href="#66-5-LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="66.5 LinkedList 插入和删除元素的时间复杂度？"></a>66.5 LinkedList 插入和删除元素的时间复杂度？</h3><ul><li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 **O(1)**。</li><li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 **O(1)**。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 **O(n)**。</li></ul><h3 id="66-6-LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#66-6-LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="66.6 LinkedList 为什么不能实现 RandomAccess 接口？"></a>66.6 LinkedList 为什么不能实现 RandomAccess 接口？</h3><ul><li><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。</li><li>由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</li></ul><h3 id="66-7-ArrayList-与-LinkedList-区别"><a href="#66-7-ArrayList-与-LinkedList-区别" class="headerlink" title="66.7 ArrayList 与 LinkedList 区别?"></a>66.7 ArrayList 与 LinkedList 区别?</h3><ul><li><strong>是否保证线程安全：</strong><ul><li><code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，不保证线程安全；</li></ul></li><li><strong>底层数据结构：</strong><ul><li><code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；</li><li><code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</li></ul></li><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响。</li></ul></li><li><strong>是否支持快速随机访问：</strong><ul><li><code>ArrayList</code>实现了 <code>RandomAccess</code> 接口， 支持随机访问。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)</li><li><code>LinkedList</code> 不支持高效的随机元素访问。</li></ul></li><li><strong>内存空间占用：</strong><ul><li><code>ArrayList</code> 的空间浪费主要体现在 list 列表的结尾会预留一定的容量空间;</li><li><code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul></li><li><strong>应用：</strong><ul><li>我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！</li></ul></li></ul><h2 id="67-Set"><a href="#67-Set" class="headerlink" title="67. Set"></a>67. Set</h2><h3 id="67-1-HashSet底层原理"><a href="#67-1-HashSet底层原理" class="headerlink" title="67.1 HashSet底层原理"></a>67.1 HashSet底层原理</h3><ul><li>HashSet集合底层是基于<strong>哈希表</strong>实现的，哈希表根据JDK版本的不同，也是有点区别的</li><li>JDK8以前：哈希表 &#x3D; 数组+链表<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/7.png"></li><li>JDK8以后：哈希表 &#x3D; 数组+链表+红黑树<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/8.png"></li></ul><h3 id="67-2-LinkedHashSet底层原理"><a href="#67-2-LinkedHashSet底层原理" class="headerlink" title="67.2 LinkedHashSet底层原理"></a>67.2 LinkedHashSet底层原理</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/9.png"></p><h3 id="67-3-Comparable-和-Comparator-的区别"><a href="#67-3-Comparable-和-Comparator-的区别" class="headerlink" title="67.3 Comparable 和 Comparator 的区别"></a>67.3 Comparable 和 Comparator 的区别</h3><ul><li><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</li><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包，它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包，它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><h4 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始数组:&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.reverse(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.sort(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后：&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">原始数组:</span><br><span class="line">[-<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, -<span class="number">9</span>, -<span class="number">7</span>]</span><br><span class="line">Collections.reverse(arrayList):</span><br><span class="line">[-<span class="number">7</span>, -<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-<span class="number">9</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line">定制排序后：</span><br><span class="line">[<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">7</span>, -<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h4 id="重写-compareTo-方法实现按年龄来排序"><a href="#重写-compareTo-方法实现按年龄来排序" class="headerlink" title="重写 compareTo 方法实现按年龄来排序"></a>重写 compareTo 方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Person, String&gt;();</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>), <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>), <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">10</span>), <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">5</span>), <span class="string">&quot;xiaohong&quot;</span>);</span><br><span class="line">    <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">    Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Person key : keys) &#123;</span><br><span class="line">        System.out.println(key.getAge() + <span class="string">&quot;-&quot;</span> + key.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output：</span></span><br><span class="line"><span class="number">5</span>-小红</span><br><span class="line"><span class="number">10</span>-王五</span><br><span class="line"><span class="number">20</span>-李四</span><br><span class="line"><span class="number">30</span>-张三</span><br></pre></td></tr></table></figure><h3 id="67-4-无序性和不可重复性的含义是什么"><a href="#67-4-无序性和不可重复性的含义是什么" class="headerlink" title="67.4 无序性和不可重复性的含义是什么"></a>67.4 无序性和不可重复性的含义是什么</h3><ul><li>无序性不等于随机性.</li><li>无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h3 id="67-5-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#67-5-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="67.5 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>67.5 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li>相同点：都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>不同点：主要区别在于底层数据结构不同。<ul><li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li><li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li><li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li></ul></li></ul><h3 id="68-Queue-与-Deque-的区别"><a href="#68-Queue-与-Deque-的区别" class="headerlink" title="68. Queue 与 Deque 的区别"></a>68. Queue 与 Deque 的区别</h3><ul><li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，遵循 <strong>先进先出（FIFO）</strong> 规则。</li><li><code>Deque</code> (Double Ended Queue)是双端队列，在队列的两端均可以插入或删除元素。</li></ul><h3 id="69-集合判空"><a href="#69-集合判空" class="headerlink" title="69. 集合判空"></a>69. 集合判空</h3><ul><li><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></li><li>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</li></ul><h2 id="80-集合遍历"><a href="#80-集合遍历" class="headerlink" title="80. 集合遍历"></a>80. 集合遍历</h2><ul><li><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></li></ul><h2 id="81-集合数组互转"><a href="#81-集合数组互转" class="headerlink" title="81. 集合数组互转"></a>81. 集合数组互转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 数组转集合</span><br><span class="line">String[] myArray = &#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line">//上面两个语句等价于下面一条语句</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(&quot;Apple&quot;,&quot;Banana&quot;, &quot;Orange&quot;);</span><br><span class="line"></span><br><span class="line">// 集合转数组（没有指定类型的话会报错）</span><br><span class="line">String[] s = list.toArray(new String[0]);</span><br></pre></td></tr></table></figure><h2 id="82-乐观锁和悲观锁"><a href="#82-乐观锁和悲观锁" class="headerlink" title="82. 乐观锁和悲观锁"></a>82. 乐观锁和悲观锁</h2><h3 id="82-1-基本概念"><a href="#82-1-基本概念" class="headerlink" title="82.1 基本概念"></a>82.1 基本概念</h3><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><ul><li>乐观锁：在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li><li>悲观锁：在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其它线程阻塞，其他人不能修改数据。</li></ul><h3 id="83-2-实现方式"><a href="#83-2-实现方式" class="headerlink" title="83.2 实现方式"></a>83.2 实现方式</h3><ul><li>乐观锁的实现方式主要有两种：版本号机制和CAS机制<ul><li><p>版本号机制：一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**举一个简单的例子**：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ `balance` ）为 \$100 。</span><br><span class="line"></span><br><span class="line">1. 操作员 A 此时将其读出（ `version`=1 ），并从其帐户余额中扣除 $50（ $100-\$50 ）。</span><br><span class="line">2. 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ `version`=1 ），并从其帐户余额中扣除 $20 （ $100-\$20 ）。</span><br><span class="line">3. 操作员 A 完成了修改工作，将数据版本号（ `version`=1 ），连同帐户扣除后余额（ `balance`=\$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 `version` 更新为 2 。</span><br><span class="line">4. 操作员 B 完成了操作，也将版本号（ `version`=1 ）试图向数据库提交数据（ `balance`=\$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</span><br><span class="line"></span><br><span class="line">这样就避免了操作员 B 用基于 `version`=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</span><br></pre></td></tr></table></figure></li><li><p>CAS 算法：</p><ul><li>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</li><li>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。（<strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。）</li><li>CAS 涉及到三个操作数：V、E、N。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。<ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**举一个简单的例子**：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</span><br><span class="line">1. i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</span><br><span class="line">2. i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</span><br><span class="line">当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。</li></ul><h3 id="83-3-优缺点和应用场景"><a href="#83-3-优缺点和应用场景" class="headerlink" title="83.3 优缺点和应用场景"></a>83.3 优缺点和应用场景</h3><ul><li>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。</li><li>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</li></ul><h3 id="83-4-乐观锁加锁吗"><a href="#83-4-乐观锁加锁吗" class="headerlink" title="83.4 乐观锁加锁吗"></a>83.4 乐观锁加锁吗</h3><ul><li>乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子。</li><li>有时乐观锁可能与加锁操作合作，但是不能改变“乐观锁本身不加锁”这一事实。</li></ul><h3 id="83-4-CAS有哪些缺点"><a href="#83-4-CAS有哪些缺点" class="headerlink" title="83.4 CAS有哪些缺点"></a>83.4 CAS有哪些缺点</h3><ul><li>ABA问题：<ul><li>定义：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></li><li>解决思路：ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。</li></ul></li><li>高竞争下的开销问题：<ul><li>定义：在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。</li><li>解决思路：针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。</li></ul></li><li>功能限制：<ul><li>例如CAS只能保证单个变量（或者说单个内存值）操作的原子性，当操作涉及跨多个共享变量时 CAS 无效。</li></ul></li></ul><h3 id="83-5-总结"><a href="#83-5-总结" class="headerlink" title="83.5 总结"></a>83.5 总结</h3><ul><li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</li><li>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。</li><li>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</li><li>乐观锁的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。</li></ul><h2 id="84-JMM-Java-Memory-Model"><a href="#84-JMM-Java-Memory-Model" class="headerlink" title="84. JMM(Java Memory Model)"></a>84. JMM(Java Memory Model)</h2><h3 id="84-1-什么是-JMM？为什么需要-JMM？"><a href="#84-1-什么是-JMM？为什么需要-JMM？" class="headerlink" title="84.1 什么是 JMM？为什么需要 JMM？"></a>84.1 什么是 JMM？为什么需要 JMM？</h3><ul><li>Java内存模型即Java Memory Model，简称JMM。用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能够达到一致的内存访问效果。</li><li>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/10.jpg"></p><h3 id="84-2-多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。"><a href="#84-2-多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。" class="headerlink" title="84.2 多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。"></a>84.2 多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。</h3><ol><li><p>线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。</p></li><li><p>线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。</p></li></ol><h3 id="84-3-Java-内存区域和-JMM-有何区别？"><a href="#84-3-Java-内存区域和-JMM-有何区别？" class="headerlink" title="84.3 Java 内存区域和 JMM 有何区别？"></a>84.3 Java 内存区域和 JMM 有何区别？</h3><ul><li><strong>Java 内存区域和内存模型是完全不一样的两个东西</strong>：</li><li>Java 内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分，就比如说堆主要用于存放对象实例。</li><li>Java 内存模型抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</li></ul><h3 id="84-4-happens-before-是什么？"><a href="#84-4-happens-before-是什么？" class="headerlink" title="84.4 happens-before 是什么？"></a>84.4 happens-before 是什么？</h3><ul><li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见（保障可见性），并且第一个操作的执行顺序排在第二个操作之前（JMM对程序员做出的一个逻辑保障，并不是代码真正的执行保障）。</li><li>即使两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。只要不改变程序的执行结果，编译器、处理器怎么优化都可以。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int userNum = getUserNum(); 	        // 1</span><br><span class="line">int teacherNum = getTeacherNum();	    // 2</span><br><span class="line">int totalNum = userNum + teacherNum;	// 3</span><br><span class="line"></span><br><span class="line">- 1 happens-before 2</span><br><span class="line">- 2 happens-before 3</span><br><span class="line">- 1 happens-before 3</span><br></pre></td></tr></table></figure><p>虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</p><p><strong>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></p><h3 id="84-5-happens-before-原则：（一共8条，重点是下面5条）"><a href="#84-5-happens-before-原则：（一共8条，重点是下面5条）" class="headerlink" title="84.5 happens-before 原则：（一共8条，重点是下面5条）"></a>84.5 happens-before 原则：（一共8条，重点是下面5条）</h3><ol><li><strong>程序顺序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</li><li><strong>解锁规则</strong>：解锁 happens-before 于加锁；</li><li><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</li><li><strong>传递规则</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li><li><strong>线程启动规则</strong>：Thread 对象的 <code>start()</code>方法 happens-before 于此线程的每一个动作。</li></ol><h3 id="84-6-并发编程三个重要特性"><a href="#84-6-并发编程三个重要特性" class="headerlink" title="84.6 并发编程三个重要特性"></a>84.6 并发编程三个重要特性</h3><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="84-7-volatile关键字"><a href="#84-7-volatile关键字" class="headerlink" title="84.7 volatile关键字"></a>84.7 volatile关键字</h3><ul><li>在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li><li>防止 JVM 的指令重排序。如果将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</li><li>volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</li></ul><h3 id="84-8-synchronized关键字"><a href="#84-8-synchronized关键字" class="headerlink" title="84.8 synchronized关键字"></a>84.8 synchronized关键字</h3><ul><li><p>概念：</p><ul><li>synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</li></ul></li><li><p>使用：</p><ul><li>修饰实例方法 （锁当前对象实例）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized void method() &#123;</span><br><span class="line">  //业务代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>修饰静态方法 （锁当前类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized static void method() &#123;</span><br><span class="line">  //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 定义类</span><br><span class="line">class SyncThread implements Runnable &#123;</span><br><span class="line">  private static int count;</span><br><span class="line"></span><br><span class="line">  public SyncThread() &#123;</span><br><span class="line">    count = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized static void method() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void run() &#123;</span><br><span class="line">    method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 代码调用</span><br><span class="line">SyncThread syncThread1 = new SyncThread();</span><br><span class="line">SyncThread syncThread2 = new SyncThread();</span><br><span class="line">Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);</span><br><span class="line">Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"></span><br><span class="line">// 结果如下：</span><br><span class="line">SyncThread1:0</span><br><span class="line">SyncThread1:1</span><br><span class="line">SyncThread1:2</span><br><span class="line">SyncThread1:3</span><br><span class="line">SyncThread1:4</span><br><span class="line">SyncThread2:5</span><br><span class="line">SyncThread2:6</span><br><span class="line">SyncThread2:7</span><br><span class="line">SyncThread2:8</span><br><span class="line">SyncThread2:9</span><br></pre></td></tr></table></figure></li><li>修饰代码块 （锁指定对象&#x2F;类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(this) &#123;</span><br><span class="line">  //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>底层原理：</p><ul><li>javac在编译时，会生成对应的<code>monitorenter</code>和<code>monitorexit</code>指令分别对应<code>synchronized</code>同步块的进入和退出.</li><li>有两个<code>monitorexit</code>指令的原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用<code>monitorexit</code>命令释放锁。</li></ul></li><li><p>构造方法可以用 synchronized 修饰么?</p><ul><li>构造方法不能使用 synchronized 关键字修饰。</li><li>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</li></ul></li><li><p>synchronized 和 volatile 有什么区别？</p><ul><li>volatile 关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好。</li><li>volatile 关键字只能用于变量，而 synchronized 关键字可以修饰方法以及代码块。</li><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul></li></ul><h2 id="85-线程"><a href="#85-线程" class="headerlink" title="85. 线程"></a>85. 线程</h2><h3 id="85-1-创建线程的方式（三种）"><a href="#85-1-创建线程的方式（三种）" class="headerlink" title="85.1 创建线程的方式（三种）"></a>85.1 创建线程的方式（三种）</h3><ul><li><code>Thread</code><ul><li>继承<code>Thread</code>类，重写<code>run</code>方法，run方法代表线程要完成的任务，</li><li>调用线程实例对象的<code>start()</code>方法来启动该线程.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo1 extends Thread&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run()&#123;</span><br><span class="line">      System.out.println(&quot;线程的第一种创建方式&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main方法调用</span><br><span class="line">ThreadDemo1 demo1 = new ThreadDemo1();</span><br><span class="line">demo1.start();</span><br></pre></td></tr></table></figure></li></ul></li><li><code>runnable</code><ul><li>实现<code>runnable</code>接口，重写该接口的<code>run()</code>方法，run方法代表线程要完成的任务，调用线程实例对象的start()方法来启动该线程</li><li>创建<code>Runnable</code>实现类的实例，并依此实例作为Thread的target来创建Thread对象，该<code>Thread</code>对象才是真正的线程对象。</li><li>调用<code>Thread</code>线程对象的start()方法来启动该线程。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo2 implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      System.out.println(&quot;线程的第二种创建方式-实现runnable接口&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// main方法调用</span><br><span class="line">ThreadDemo2 demo2 = new ThreadDemo2();</span><br><span class="line">new Thread(demo2).start();</span><br></pre></td></tr></table></figure></li></ul></li><li><code>Callable</code><ul><li>实现<code>Callable</code>接口，重写<code>call()</code>方法，该<code>call()</code>方法将作为线程执行体，并且有返回值；</li><li>创建<code>Callable</code>实现类的实例对象，使用<code>FutureTask</code>类来包装<code>Callable</code>对象，该<code>FutureTask</code>对象封装了该<code>Callable</code>对象的<code>call()</code>方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo3 implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">  private int i =0;</span><br><span class="line">  @Override</span><br><span class="line">  public Integer call() throws Exception &#123;</span><br><span class="line">      for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">          this.i+=i;</span><br><span class="line">      &#125;</span><br><span class="line">      return i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//main调用</span><br><span class="line">ThreadDemo3 demo3 = new ThreadDemo3();</span><br><span class="line">FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(demo3);</span><br><span class="line">new Thread(task).start();</span><br><span class="line">try &#123;</span><br><span class="line">  System.out.println(task.get());</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="85-2-Java对象引用级别"><a href="#85-2-Java对象引用级别" class="headerlink" title="85.2 Java对象引用级别"></a>85.2 Java对象引用级别</h3><ul><li>JDK把对象的引用级别由高到低分为强引用、软引用、弱引用、虚引用四种级别<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/11.png"></li><li>强引用 StrongReference：属于不可回收资源，GC绝对不会回收它，即使是内存不足，JVM宁愿抛出OutOfMemoryError异常，使程序终止，也不会来回收强引用对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure></li><li>软引用 SoftReference：它的性质属于可有可无，因为内存空间充足的情况下，GC不会回收它，但是内存空间紧张，GC发现它仅有软引用，就会回收该对象，所以软引用对象适合作为内存敏感的缓存对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;User&gt; soft = new SoftReference&lt;&gt;(new User(&quot;Tom&quot;));</span><br></pre></td></tr></table></figure></li><li>弱引用 WeakReference：弱引用对象相对软引用对象具有更短暂的生命周期，只要GC发现它仅有弱引用，不管内存空间是否充足，都会回收它，不过GC是一个优先级很低的线程，因此不一定会很快发现那些仅有弱引用的对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weak = new WeakReference&lt;&gt;(new User(&quot;Tom&quot;));</span><br></pre></td></tr></table></figure></li></ul><h3 id="85-3-ThreadLocal"><a href="#85-3-ThreadLocal" class="headerlink" title="85.3 ThreadLocal"></a>85.3 ThreadLocal</h3><ul><li><p>概念：创建了一个ThreadLocal变量，它是线程隔离的，访问这个变量的每个线程都会有这个变量的本地副本。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p></li><li><p>使用：</p><ul><li>get()</li><li>set()</li><li>remove()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class ThreadLocalExample implements Runnable&#123;</span><br><span class="line">  // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span><br><span class="line">  private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;));</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">      ThreadLocalExample obj = new ThreadLocalExample();</span><br><span class="line">      for(int i=0 ; i&lt;10; i++)&#123;</span><br><span class="line">          Thread t = new Thread(obj, &quot;&quot;+i);</span><br><span class="line">          Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">          t.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; default Formatter = &quot;+formatter.get().toPattern());</span><br><span class="line">      try &#123;</span><br><span class="line">          Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      //formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span><br><span class="line">      formatter.set(new SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Thread Name= &quot;+Thread.currentThread().getName()+&quot; formatter = &quot;+formatter.get().toPattern());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">Thread Name= 0 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 0 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 1 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 2 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 1 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 3 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 2 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 4 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 3 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 4 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 5 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 5 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 6 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 6 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 7 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 7 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 8 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 9 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 8 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 9 formatter = yy-M-d ah:mm</span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理：</p><ul><li>ThreadLocal底层是ThreadLocalMap。 每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key ，Object对象为 value 的键值对。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">  // 与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br><span class="line">  ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ThreadLocal的set()方法：调用的是ThreadLocalMap的set方法将(ThreadLocal, value)存储到ThreadLocalMap<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">  //获取当前请求的线程</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  //取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  if (map != null)&#123;</span><br><span class="line">    // 将需要存储的值放入到这个哈希表中</span><br><span class="line">    map.set(this, value);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/12.png"></p></li><li><p>内存泄露问题是怎么导致的？</p><ul><li><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用，所以在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li>这样，<code>ThreadLocalMap</code> 中就会出现 <code>key</code> 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</li><li>解决方案：使用完<code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</li></ul></li></ul><h3 id="85-4-线程池"><a href="#85-4-线程池" class="headerlink" title="85.4 线程池"></a>85.4 线程池</h3><ul><li><p>概念：为了避免频繁重复的创建和销毁线程，我们可以让这些线程进行复用。而线程池是将创建的线程存储到一个池中，在需要使用时从池中去拿，使用完之后再将线程归还到池中，下一次接着使用。</p></li><li><p>如何创建线程池：通过<code>ThreadPoolExecutor</code>构造函数来创建</p></li><li><p>线程池常见参数有哪些？如何解释？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="line">*/</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量</span><br><span class="line">                          int maximumPoolSize,//线程池的最大线程数</span><br><span class="line">                          long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="line">                          TimeUnit unit,//时间单位</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="line">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="line">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="line">                           ) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul></li><li><code>ThreadPoolExecutor</code>其他常见参数 :<ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/13.png"></li></ul></li></ul></li><li><p>线程池的饱和策略有哪些？</p><ul><li>接口<code>RejectedExecutionHandler</code>定义了饱和策略，所有的饱和策略都需要实现该接口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RejectedExecutionHandler &#123;</span><br><span class="line">  void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 拒绝处理，抛出<code>RejectedExecutionException</code>异常</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 由创建该线程的线程（main）执行</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 丢弃，不抛出异常</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 和最早创建的线程进行竞争，不抛出异常</li></ul></li></ul><h2 id="86-AQS"><a href="#86-AQS" class="headerlink" title="86. AQS"></a>86. AQS</h2><h3 id="86-1-概述"><a href="#86-1-概述" class="headerlink" title="86.1 概述"></a>86.1 概述</h3><ul><li>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。</li><li>这个类在 <code>java.util.concurrent.locks</code> 包下面。</li><li>AQS 是一个抽象类，主要用来构建<strong>锁</strong>和<strong>同步器</strong>。</li></ul><h3 id="86-2-自旋锁和非自旋锁"><a href="#86-2-自旋锁和非自旋锁" class="headerlink" title="86.2 自旋锁和非自旋锁"></a>86.2 自旋锁和非自旋锁</h3><ul><li>什么是自旋锁：<ul><li>它并不会放弃CPU时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止；</li></ul></li><li>什么是非自旋锁：<ul><li>如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁</li><li>非自旋锁和自旋锁最大的区别，在非自旋锁遇到拿不到锁的情况，它会把线程阻塞，直到被唤醒。而自旋锁会不停地尝试。</li></ul></li></ul><h3 id="86-3-CLH锁"><a href="#86-3-CLH锁" class="headerlink" title="86.3 CLH锁"></a>86.3 CLH锁</h3><ul><li>CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。</li><li>在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</li><li>CLH 队列结构如下图所示：<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/16.png"></li></ul><h3 id="86-4-AQS原理"><a href="#86-4-AQS原理" class="headerlink" title="86.4 AQS原理"></a>86.4 AQS原理</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。</p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/14.png"></p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/15.png"></p><h2 id="87-IO"><a href="#87-IO" class="headerlink" title="87. IO"></a>87. IO</h2><h3 id="87-1-IO流简介"><a href="#87-1-IO流简介" class="headerlink" title="87.1 IO流简介"></a>87.1 IO流简介</h3><ul><li>概念：IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</li><li>分类：IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</li><li>4个抽象类基类：Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。<ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul></li></ul><h3 id="87-2-字节流"><a href="#87-2-字节流" class="headerlink" title="87.2 字节流"></a>87.2 字节流</h3><ul><li><p>InputStream（字节输入流）（抽象类）</p><ul><li>FileInputStream（子类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 目标：掌握文件字节输入流，每次读取一个字节。</span><br><span class="line">*/</span><br><span class="line">public class FileInputStreamTest1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       // 1、创建文件字节输入流管道，与源文件接通。</span><br><span class="line">       InputStream is = new FileInputStream((&quot;file-io-app\\src\\itheima01.txt&quot;));</span><br><span class="line">  </span><br><span class="line">       // 2、开始读取文件的字节数据。</span><br><span class="line">       // public int read():每次读取一个字节返回，如果没有数据了，返回-1.</span><br><span class="line">       int b; // 用于记住读取的字节。</span><br><span class="line">       while ((b = is.read()) != -1)&#123;</span><br><span class="line">           System.out.print((char) b);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //3、流使用完毕之后，必须关闭！释放系统资源！</span><br><span class="line">       is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>BufferedInputStream（字节缓冲输入流）：缓冲流的底层自己封装了一个长度为<strong>8KB（8129byte）的字节数组</strong>，但是缓冲流不能单独使用，它需要依赖于原始流。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedInputStreamTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            InputStream is = new FileInputStream(&quot;io-app2/src/itheima01.txt&quot;);</span><br><span class="line">            // 1、定义一个字节缓冲输入流包装原始的字节输入流</span><br><span class="line">            InputStream bis = new BufferedInputStream(is);</span><br><span class="line">            </span><br><span class="line">            OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima01_bak.txt&quot;);</span><br><span class="line">            // 2、定义一个字节缓冲输出流包装原始的字节输出流</span><br><span class="line">            OutputStream bos = new BufferedOutputStream(os);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            byte[] buffer = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line">            while ((len = bis.read(buffer)) != -1)&#123;</span><br><span class="line">                bos.write(buffer, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;复制完成！！&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>OutputStream（字节输出流）（抽象类）</p><ul><li>FileOutputStream（子类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 目标：掌握文件字节输出流FileOutputStream的使用。</span><br><span class="line">*/</span><br><span class="line">public class FileOutputStreamTest4 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">         // 1、创建一个字节输出流管道与目标文件接通。</span><br><span class="line">         // 覆盖管道：覆盖之前的数据</span><br><span class="line">         //  OutputStream os = new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;);</span><br><span class="line">         // 追加数据的管道</span><br><span class="line">         OutputStream os = new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;, true);</span><br><span class="line">    </span><br><span class="line">         // 2、开始写字节数据出去了</span><br><span class="line">         os.write(97);         // 97就是一个字节，代表a</span><br><span class="line">         os.write(&#x27;b&#x27;);       // &#x27;b&#x27;也是一个字节</span><br><span class="line">         // os.write(&#x27;磊&#x27;);   // [ooo] 默认只能写出去一个字节</span><br><span class="line">    </span><br><span class="line">         byte[] bytes = &quot;我爱你中国abc&quot;.getBytes();</span><br><span class="line">         os.write(bytes);</span><br><span class="line">    </span><br><span class="line">         os.write(bytes, 0, 15);</span><br><span class="line">    </span><br><span class="line">         // 换行符</span><br><span class="line">         os.write(&quot;\r\n&quot;.getBytes());</span><br><span class="line">    </span><br><span class="line">         os.close(); // 关闭流</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>BufferedOutputStream（字节缓冲输出流）</li></ul></li></ul><h3 id="87-3-字符流"><a href="#87-3-字符流" class="headerlink" title="87.3 字符流"></a>87.3 字符流</h3><ul><li><p>Reader（字符输入流）（抽象类）</p><ul><li>FileReader（子类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 目标：掌握文件字符输入流。</span><br><span class="line">*/</span><br><span class="line">public class FileReaderTest1 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个文件字符输入流管道与源文件接通</span><br><span class="line">            Reader fr = new FileReader(&quot;io-app2\\src\\itheima01.txt&quot;);</span><br><span class="line">        )&#123;</span><br><span class="line">            // 2、每次读取多个字符。</span><br><span class="line">            char[] buffer = new char[3];</span><br><span class="line">            int len; // 记住每次读取了多少个字符。</span><br><span class="line">            while ((len = fr.read(buffer)) != -1)&#123;</span><br><span class="line">                // 读取多少倒出多少</span><br><span class="line">                System.out.print(new String(buffer, 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BufferedReader（字符缓冲输入流）：它底层也会有一个<strong>8KB的字符数组</strong>。字符缓冲流也不能单独使用，它需要依赖于原始字符流一起使用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedReaderTest2 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        try (</span><br><span class="line">            Reader fr = new FileReader(&quot;io-app2\\src\\itheima04.txt&quot;);</span><br><span class="line">            // 创建一个字符缓冲输入流包装原始的字符输入流</span><br><span class="line">            BufferedReader br = new BufferedReader(fr);</span><br><span class="line">        )&#123;</span><br><span class="line">            String line; // 记住每次读取的一行数据</span><br><span class="line">            while ((line = br.readLine()) != null)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>InputStreamReader（转换流）：<ul><li>FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码。转换流可以将字节流转换为字符流，并且可以指定编码方案。</li><li>InputStreamReader类表示可以把InputStream转换为Reader，它是字符输入流。</li><li>InputStreamReader也是不能单独使用的，它内部需要封装一个InputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InputStreamReaderTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、得到文件的原始字节流（GBK的字节流形式）</span><br><span class="line">            InputStream is = new FileInputStream(&quot;io-app2/src/itheima06.txt&quot;);</span><br><span class="line">            // 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流</span><br><span class="line">            Reader isr = new InputStreamReader(is, &quot;GBK&quot;);</span><br><span class="line">            // 3、把字符输入流包装成缓冲字符输入流</span><br><span class="line">            BufferedReader br = new BufferedReader(isr);</span><br><span class="line">        )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = br.readLine()) != null)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>Writer（字符输出流）（抽象类）</p><ul><li>FileWriter（子类）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 目标：掌握文件字符输出流：写字符数据出去</span><br><span class="line">*/</span><br><span class="line">public class FileWriterTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 0、创建一个文件字符输出流管道与目标文件接通。</span><br><span class="line">            // 覆盖管道</span><br><span class="line">            // Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;);</span><br><span class="line">            // 追加数据的管道</span><br><span class="line">            Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;, true);</span><br><span class="line">        )&#123;</span><br><span class="line">            // 1、public void write(int c): 写一个字符出去</span><br><span class="line">            fw.write(&#x27;a&#x27;);</span><br><span class="line">            fw.write(97);</span><br><span class="line">            fw.write(&#x27;磊&#x27;);        // 写一个字符出去</span><br><span class="line">            fw.write(&quot;\r\n&quot;);     // 换行    </span><br><span class="line">            // 2、public void write(String c): 写一个字符串出去</span><br><span class="line">            fw.write(&quot;我爱你中国abc&quot;);</span><br><span class="line">            fw.write(&quot;\r\n&quot;);    </span><br><span class="line">            // 3、public void write(String c ,int pos ,int len): 写字符串的一部分出去</span><br><span class="line">            fw.write(&quot;我爱你中国abc&quot;, 0, 5);</span><br><span class="line">            fw.write(&quot;\r\n&quot;);    </span><br><span class="line">            // 4、public void write(char[] buffer): 写一个字符数组出去</span><br><span class="line">            char[] buffer = &#123;&#x27;黑&#x27;, &#x27;马&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span><br><span class="line">            fw.write(buffer);</span><br><span class="line">            fw.write(&quot;\r\n&quot;);    </span><br><span class="line">            // 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span><br><span class="line">            fw.write(buffer, 0, 2);</span><br><span class="line">            fw.write(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>BufferedWriter（字符缓冲输出流）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedWriterTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            Writer fw = new FileWriter(&quot;io-app2/src/itheima05out.txt&quot;, true);</span><br><span class="line">            // 创建一个字符缓冲输出流管道包装原始的字符输出流</span><br><span class="line">            BufferedWriter bw = new BufferedWriter(fw);</span><br><span class="line">        )&#123;</span><br><span class="line">            bw.write(&#x27;a&#x27;);</span><br><span class="line">            bw.write(97);</span><br><span class="line">            bw.write(&#x27;磊&#x27;);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">            bw.write(&quot;我爱你中国abc&quot;);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>OutputStreamWriter（转换流）<ul><li>OutputStreamWriter类表示可以把OutputStream转换为Writer，它是字符输出流。</li><li>OutputStreamReader也是不能单独使用的，它内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class OutputStreamWriterTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 指定写出去的字符编码。</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个文件字节输出流</span><br><span class="line">            OutputStream os = new FileOutputStream(&quot;io-app2/src/itheima07out.txt&quot;);</span><br><span class="line">            // 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。</span><br><span class="line">            Writer osw = new OutputStreamWriter(os, &quot;GBK&quot;);</span><br><span class="line">            // 3、把字符输出流包装成缓冲字符输出流</span><br><span class="line">            BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line">        )&#123;</span><br><span class="line">            bw.write(&quot;我是中国人abc&quot;);</span><br><span class="line">            bw.write(&quot;我爱你中国123&quot;);</span><br><span class="line">    </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="87-4-打印流"><a href="#87-4-打印流" class="headerlink" title="87.4 打印流"></a>87.4 打印流</h3><ul><li>PrintStream：字节打印流<ul><li>System.out 实际是用于获取一个 PrintStream 对象，print方法实际调用的是 PrintStream 对象的 write 方法。</li><li>PrintStream 是 OutputStream 的子类</li></ul></li><li>PrintWriter：字符打印流<ul><li>PrintWriter 是 Writer 的子类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class PrintTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个打印流管道</span><br><span class="line">            // PrintStream ps = new PrintStream(&quot;io-app2/src/itheima08.txt&quot;, Charset.forName(&quot;GBK&quot;));</span><br><span class="line">            // PrintStream ps = new PrintStream(&quot;io-app2/src/itheima08.txt&quot;);</span><br><span class="line">            PrintWriter ps = new PrintWriter(new FileOutputStream(&quot;io-app2/src/itheima08.txt&quot;, true));</span><br><span class="line">        )&#123;</span><br><span class="line">            ps.print(97);	//文件中显示的就是:97</span><br><span class="line">            ps.print(&#x27;a&#x27;); //文件中显示的就是:a</span><br><span class="line">            ps.println(&quot;我爱你中国abc&quot;);	//文件中显示的就是:我爱你中国abc</span><br><span class="line">            ps.println(true);//文件中显示的就是:true</span><br><span class="line">            ps.println(99.5);//文件中显示的就是99.5</span><br><span class="line">            </span><br><span class="line">            ps.write(97); //文件中显示a，发现和前面println方法的区别了吗？</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="87-5-序列化流"><a href="#87-5-序列化流" class="headerlink" title="87.5 序列化流"></a>87.5 序列化流</h3><ul><li><p>ObjectInputStream</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 注意：对象如果需要序列化，必须实现序列化接口。</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private String loginName;</span><br><span class="line">    private String userName;</span><br><span class="line">    private int age;</span><br><span class="line">    // transient 这个成员变量将不参与序列化。</span><br><span class="line">    private transient String passWord;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String loginName, String userName, int age, String passWord) &#123;</span><br><span class="line">        this.loginName = loginName;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;loginName=&#x27;&quot; + loginName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, userName=&#x27;&quot; + userName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, passWord=&#x27;&quot; + passWord + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test2ObjectInputStream &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个对象字节输入流管道，包装 低级的字节输入流与源文件接通</span><br><span class="line">            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;io-app2/src/itheima11out.txt&quot;));</span><br><span class="line">        )&#123;</span><br><span class="line">            // 2. 读取object对象</span><br><span class="line">            User u = (User) input.readObject();</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ObjectOutputStream</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test1ObjectOutputStream &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (</span><br><span class="line">            // 1、创建一个对象字节输出流包装原始的字节 输出流。</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;io-app2/src/itheima11out.txt&quot;));</span><br><span class="line">                )&#123;</span><br><span class="line">            // 2、创建一个Java对象。</span><br><span class="line">            User u = new User(&quot;admin&quot;, &quot;张三&quot;, 32, &quot;666888xyz&quot;);</span><br><span class="line"></span><br><span class="line">            // 3、序列化对象到文件中去</span><br><span class="line">            oos.writeObject(u);</span><br><span class="line">            System.out.println(&quot;序列化对象成功！！&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="87-6-IO-设计模式"><a href="#87-6-IO-设计模式" class="headerlink" title="87.6 IO 设计模式"></a>87.6 IO 设计模式</h3><ul><li><p>装饰器模式：</p><ul><li>概念：Decorator Pattern，可以在不改变原有对象的情况下拓展其功能。装饰器模式通过组合，替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 例子：</span><br><span class="line">try (BufferedInputStream input = new BufferedInputStream(new FileInputStream(&quot;input.txt&quot;))) &#123;</span><br><span class="line">  int content;</span><br><span class="line">  long skip = input.skip(2);</span><br><span class="line">  while ((content = input.read()) != -1) &#123;</span><br><span class="line">      System.out.print((char) content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思考：为什么不直接弄一个<code>BufferedFileInputStream</code>（字符缓冲文件输入流）呢？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedFileInputStream bfis = new BufferedFileInputStream(&quot;input.txt&quot;);</span><br></pre></td></tr></table></figure><ul><li>InputStream的子类实在太多，继承关系也非常复杂。如果为每一个子类都定制一个对应的缓冲输入流，非常麻烦。</li><li>通过装饰器模式代替继承可以扩展原始类的功能。</li></ul></li></ul></li><li><p>适配器模式：</p><ul><li>概念：Adapter Pattern，主要用于接口互不兼容的类的协调工作。被适配的对象或者类称为适配者(Adaptee)，作用于适配者的对象或者类称为适配器(Adapter) 。</li><li>适配器：<code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 就是两个适配器(Adapter)，它们两个也是字节流和字符流之间的桥梁。<code>InputStreamReader</code> 使用 <code>StreamDecoder</code>（流解码器）对字节进行解码，实现字节流到字符流的转换， <code>OutputStreamWriter</code> 使用<code>StreamEncoder</code>（流编码器）对字符进行编码，实现字符流到字节流的转换。</li><li>适配者：InputStream 和 OutputStream 的子类是适配者。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span><br><span class="line">InputStreamReader input = new InputStreamReader(new FileInputStream(fileName), &quot;UTF-8&quot;);</span><br><span class="line">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span><br><span class="line">BufferedReader bufferedReader = new BufferedReader(input);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="88-IO模型"><a href="#88-IO模型" class="headerlink" title="88. IO模型"></a>88. IO模型</h2><h3 id="88-1-BIO-Blocking-I-x2F-O"><a href="#88-1-BIO-Blocking-I-x2F-O" class="headerlink" title="88.1 BIO (Blocking I&#x2F;O)"></a>88.1 BIO (Blocking I&#x2F;O)</h3><ul><li>定义：<ul><li>BIO 属于同步阻塞 IO 模型 。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</li></ul></li><li>缺点：<ul><li>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</li></ul></li></ul><h3 id="88-2-NIO-Non-blocking-x2F-New-I-x2F-O"><a href="#88-2-NIO-Non-blocking-x2F-New-I-x2F-O" class="headerlink" title="88.2 NIO (Non-blocking&#x2F;New I&#x2F;O)"></a>88.2 NIO (Non-blocking&#x2F;New I&#x2F;O)</h3><ul><li>定义：<ul><li>NIO 属于同步非阻塞 IO 模型。同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</li></ul></li></ul><h3 id="88-3-AIO-Asynchronous-I-x2F-O"><a href="#88-3-AIO-Asynchronous-I-x2F-O" class="headerlink" title="88.3 AIO (Asynchronous I&#x2F;O)"></a>88.3 AIO (Asynchronous I&#x2F;O)</h3><ul><li>定义：<ul><li>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是异步 IO 模型。</li></ul></li></ul><h2 id="89-JVM-内存区域"><a href="#89-JVM-内存区域" class="headerlink" title="89. JVM 内存区域"></a>89. JVM 内存区域</h2><h3 id="89-1-概述"><a href="#89-1-概述" class="headerlink" title="89.1 概述"></a>89.1 概述</h3><ul><li>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</li><li>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/17.png"></p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/18.png"></p><ul><li><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul></li></ul><h3 id="89-2-线程私有：程序计数器-Program-Counter-Register"><a href="#89-2-线程私有：程序计数器-Program-Counter-Register" class="headerlink" title="89.2 线程私有：程序计数器(Program Counter Register)"></a>89.2 线程私有：程序计数器(Program Counter Register)</h3><ul><li>概念：<ul><li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li></ul></li><li>特点：<ul><li>线程私有</li><li>生命周期：与线程共存亡</li><li>一块较小的内存空间,存储字节码行号；</li><li>是唯一一块不会出现OutOfMemoryError的内存区域；</li></ul></li><li>作用：<ul><li>字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，从而实现代码的流程控制；</li><li>多线程情况下，用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了。</li></ul></li></ul><h3 id="89-3-线程私有：Java-虚拟机栈"><a href="#89-3-线程私有：Java-虚拟机栈" class="headerlink" title="89.3 线程私有：Java 虚拟机栈"></a>89.3 线程私有：Java 虚拟机栈</h3><ul><li>概念：<ul><li>描述的是Java方法执行的线程内存模型：每个方法被执行时，Java虚拟机都会同步创建一个栈帧（用于存储局部变量表、操作数栈、动态链接、方法返回地址），每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/19.png"></li></ul></li><li>特点：<ul><li>线程私有</li><li>生命周期：与线程共存亡</li><li>栈帧中存储局部变量表、操作数栈、动态链接、方法返回地址</li><li>会出现两种错误：<ul><li>StackOverFlowError：（stack内存不允许动态扩展时）当线程请求的栈的深度超过当前Java虚拟机栈的最大深度时报错；</li><li>OutOfMemoryError：（stack内存允许动态扩展时）如果虚拟机的动态扩展栈时无法申请到足够的空间，则报异常。(HotSpot虚拟机是不支持动态扩展的，但如果是手动申请栈空间失败了也会报OOM异常)</li></ul></li></ul></li></ul><h3 id="89-4-线程私有：本地方法栈"><a href="#89-4-线程私有：本地方法栈" class="headerlink" title="89.4 线程私有：本地方法栈"></a>89.4 线程私有：本地方法栈</h3><ul><li>概念：<ul><li>基本功能和Java虚拟机栈基本一样。</li></ul></li><li>和Java虚拟机栈的区别是：<ul><li>Java虚拟机栈描述Java方法的执行；</li><li>本地方法栈描述Native方法的执行。</li></ul></li></ul><h3 id="89-5-线程共享：堆"><a href="#89-5-线程共享：堆" class="headerlink" title="89.5 线程共享：堆"></a>89.5 线程共享：堆</h3><ul><li><p>特点：</p><ul><li>唯一目的：存放实例对象（几乎所有的实例对象和数组都在这里分配内存）</li><li>线程共享</li><li>生命周期：与虚拟机共存亡</li><li>Java虚拟机所管制内存中最大的一块</li><li>GC的主要区域</li><li>最容易出现OutOfMemoryError错误</li></ul></li><li><p>堆内存划分：</p><ul><li>更好地回收内存，更快的分配内存。</li><li>不同版本堆内存划分：<ul><li>在 JDK 7 版本及之前版本，堆内存被通常分为下面三部分：<ul><li>新生代内存(Young Generation)(Eden 区、两个 Survivor 区 S0 和 S1 )</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ul></li><li>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/20.png"></li></ul></li></ul></li><li><p>年轻代（Eden、S0、S1）、老年代</p><ul><li>默认情况下，年轻代与老年代比例为1:2，可以通过参数 -xx:NewRatio 修改，NewRatio默认值是2</li><li>默认情况下Eden、S0、S1的比例是8:1:1，可以通过参数 -xx:SurvivorRatio 修改，SurvivorRatio默认值是8<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/22.png"></li></ul></li></ul><h3 id="89-6-线程共享：方法区"><a href="#89-6-线程共享：方法区" class="headerlink" title="89.6 线程共享：方法区"></a>89.6 线程共享：方法区</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/23.png"></p><ul><li><p>概念：</p><ul><li>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</li></ul></li><li><p>特点：</p><ul><li>线程共享</li><li>存储：已被虚拟机加载的类信息、静态变量、常量、即时编译器编译后的代码等数据</li><li>GC较少出现，但并非不出现</li></ul></li><li><p>方法区和永久代的关系</p><ul><li>方法区：是一个概念，并没有具体的实现（类似于接口）</li><li>永久代：是HotSpot虚拟机中对方法区的一种实现方式 （类似于接口的实现类）<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/21.png"></li></ul></li><li><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><ul><li>永久代有JVM本身设置的固定内存大小上限，而元空间使用直接内存，受本机可用内存的限制，使得溢出的几率减小。</li><li>Java虚拟机能够加载多少类可直接由系统的实际可用空间来控制，使得能够加载更多的类。</li></ul></li></ul><h3 id="89-7-线程共享：运行时常量池"><a href="#89-7-线程共享：运行时常量池" class="headerlink" title="89.7 线程共享：运行时常量池"></a>89.7 线程共享：运行时常量池</h3><ul><li><p>特点：</p><ul><li>方法区的一部分；</li><li>常量池将在类加载后存放到方法区的运行时常量池中；</li><li>当常量池无法再申请到内存时会抛出OutOfMemoryError错误</li></ul></li><li><p>方法区的Class文件信息，Class常量池和运行时常量池的三者关系</p></li></ul><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/24.png"></p><h3 id="89-8-线程共享：字符串常量池"><a href="#89-8-线程共享：字符串常量池" class="headerlink" title="89.8 线程共享：字符串常量池"></a>89.8 线程共享：字符串常量池</h3><ul><li><p>概念：</p><ul><li><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在堆中创建字符串对象”ab“</span><br><span class="line">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="line">String aa = &quot;ab&quot;;</span><br><span class="line">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="line">String bb = &quot;ab&quot;;</span><br><span class="line">System.out.println(aa==bb); // true</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><ul><li>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</li></ul></li></ul><h3 id="89-9-线程共享：直接内存"><a href="#89-9-线程共享：直接内存" class="headerlink" title="89.9 线程共享：直接内存"></a>89.9 线程共享：直接内存</h3><ul><li>不是虚拟机运行时数据区的一部分</li><li>会导致OutOfMemoryError错误出现</li><li>本机直接内存的分配不会受到Java堆的限制，但是既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</li></ul><h2 id="90-HotSpot虚拟机对象"><a href="#90-HotSpot虚拟机对象" class="headerlink" title="90. HotSpot虚拟机对象"></a>90. HotSpot虚拟机对象</h2><h3 id="90-1-对象的创建"><a href="#90-1-对象的创建" class="headerlink" title="90.1 对象的创建"></a>90.1 对象的创建</h3><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/25.png"></p><p><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/26.png"></p><ul><li><p>Step1:类加载检查</p><ul><li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li></ul></li><li><p>Step2:分配内存</p><ul><li><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p></li><li><p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li><ol><li>指针碰撞：</li></ol><ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li><ol start="2"><li>空闲列表：</li></ol><ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul></li><li><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p></li><li><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><ul><li>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</li><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul></li></ul></li><li><p>Step3:初始化零值</p><ul><li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li></ul></li><li><p>Step4:设置对象头</p><ul><li>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li></ul></li><li><p>Step5:执行 init 方法</p><ul><li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul></li></ul><h3 id="90-2-对象的访问定位"><a href="#90-2-对象的访问定位" class="headerlink" title="90.2 对象的访问定位"></a>90.2 对象的访问定位</h3><ul><li>概念：<ul><li>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</li></ul></li><li>分类：<ul><li>句柄：<ul><li>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li></ul></li><li>直接指针<ul><li>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</li></ul></li></ul></li><li>两种分类的优缺点：<ul><li>这两种对象访问方式各有优势。</li><li>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li><li>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</li></ul></li></ul><h2 id="90-JVM垃圾回收"><a href="#90-JVM垃圾回收" class="headerlink" title="90. JVM垃圾回收"></a>90. JVM垃圾回收</h2><h3 id="90-1-垃圾回收机制"><a href="#90-1-垃圾回收机制" class="headerlink" title="90.1 垃圾回收机制"></a>90.1 垃圾回收机制</h3><ul><li><ol><li>所有的对象首先会在Eden区进行分配，当Eden区满了之后会进行第1次Minor GC；</li></ol></li><li><ol start="2"><li>第1次GC之后仍然存活的对象，会复制到Survivor S0，同时对象年龄+1(此时年龄&#x3D;1)，然后清理其之前占用的内存；</li></ol></li><li><ol start="3"><li>第2次会对Eden+S0同时进行GC，仍然存活的对象会复制到Survivor S1，年龄+1，同时清理之前占用的内存(此时S0区会变成空)；</li></ol></li><li><ol start="4"><li>以此类推，每次都有一个Survivor区是空的；</li></ol></li><li><ol start="5"><li>当Survivor区域对象的年龄达到 -xx:MaxTenuringThreshold 设定的值(默认15)，会将此对象移到老年代，同时清空他们在年轻代占用的内存空间；</li></ol></li><li><ol start="6"><li>当老年代空间不够用了，会发生Full GC (回收整个堆内存)；</li></ol></li><li><ol start="7"><li>当某些大对象需要分配一块较大的连续空间时会直接进入老年代，而不会经过以上步骤。</li></ol></li></ul><h3 id="90-2-死亡对象判断方法"><a href="#90-2-死亡对象判断方法" class="headerlink" title="90.2 死亡对象判断方法"></a>90.2 死亡对象判断方法</h3><ul><li><p>引用计数法：</p><ul><li>概念：给对象中添加一个引用计数器：每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</li><li>缺点：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</li></ul></li><li><p>可达性分析算法：</p><ul><li>概念：目前的主流算法。这个算法的基本思想就是通过一系列被称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/27.png"></li><li>对象可以被回收，就代表一定会被回收吗？<ul><li>被判定为需要回收的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</li></ul></li></ul></li></ul><h3 id="90-3-垃圾回收算法"><a href="#90-3-垃圾回收算法" class="headerlink" title="90.3 垃圾回收算法"></a>90.3 垃圾回收算法</h3><ul><li>标记-清除算法<ul><li>它的思想就是先标记（两次标记），再清除。</li><li>缺点：<ul><li>效率不高（标记和清除两个过程效率都不高。）</li><li>会产生大量内存碎片（内存碎片是指内存的空间比较零碎，缺少大段的连续空间。这样假如突然来了一个大对象，会找不到足够大的连续空间来存放，于是不得不再触发一次gc。）<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/28.png"></li></ul></li></ul></li><li>复制算法<ul><li>概念：为了解决标记-清除算法的效率和内存碎片问题，复制算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</li><li>缺点：<ul><li>可用内存变小：可用内存缩小为原来的一半。</li><li>不适合老年代：如果存活对象数量比较大，复制性能会变得很差。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/29.png"></li></ul></li></ul></li><li>标记-整理算法<ul><li>概念：标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</li><li>缺点：<ul><li>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</li></ul></li></ul></li><li>分代回收算法<ul><li>概念：当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li></ul></li></ul><h2 id="91-类加载器"><a href="#91-类加载器" class="headerlink" title="91. 类加载器"></a>91. 类加载器</h2><h3 id="91-1-类加载过程"><a href="#91-1-类加载过程" class="headerlink" title="91.1 类加载过程"></a>91.1 类加载过程</h3><ul><li><p>类的生命周期：</p><ul><li>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：<ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）（验证、准备和解析这三个阶段可以统称为连接（Linking））</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/30.png"></li></ul></li></ul></li><li><p>类加载过程：</p><ul><li>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。<br><img src="/2021/06/08/%E9%9D%A2%E8%AF%95-java/31.png"></li></ul></li></ul><h3 id="91-1-类加载器"><a href="#91-1-类加载器" class="headerlink" title="91.1 类加载器"></a>91.1 类加载器</h3><ul><li><p>作用：</p><ul><li><strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序（<code>.java</code>文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</li><li>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。</li></ul></li><li><p>类加载器加载规则</p><ul><li>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</li><li>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</li></ul></li><li><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ul><li>**<code>Bootstrap ClassLoader</code>(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li>**<code>Extension ClassLoader</code>(扩展类加载器)**：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li>**<code>Application Classloader</code>(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ul></li></ul><h3 id="91-2-双亲委派模型"><a href="#91-2-双亲委派模型" class="headerlink" title="91.2 双亲委派模型"></a>91.2 双亲委派模型</h3><ul><li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li></ul><h3 id="91-3-双亲委派模型的好处"><a href="#91-3-双亲委派模型的好处" class="headerlink" title="91.3 双亲委派模型的好处"></a>91.3 双亲委派模型的好处</h3><ul><li>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</li><li>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</li></ul><h2 id="92-排查-OOM"><a href="#92-排查-OOM" class="headerlink" title="92. 排查 OOM"></a>92. 排查 OOM</h2><h3 id="92-1-常见的-OOM-异常情况有两种"><a href="#92-1-常见的-OOM-异常情况有两种" class="headerlink" title="92.1 常见的 OOM 异常情况有两种"></a>92.1 常见的 OOM 异常情况有两种</h3><ul><li>堆内存溢出</li><li>方法区溢出</li></ul><h3 id="92-2-堆内存溢出"><a href="#92-2-堆内存溢出" class="headerlink" title="92.2 堆内存溢出"></a>92.2 堆内存溢出</h3><ul><li>java.lang.OutOfMemoryError: Java heap space ——&gt;java 堆内存溢出，</li><li>此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。</li><li>对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx 来修改。</li></ul><h3 id="92-3-方法区溢出"><a href="#92-3-方法区溢出" class="headerlink" title="92.3 方法区溢出"></a>92.3 方法区溢出</h3><ul><li>java.lang.OutOfMemoryError: PermGen space 或 java.lang.OutOfMemoryError：MetaSpace ——&gt;java 方法区溢出</li><li>一般出现在大量 Class、或者采用 cglib 等反射机制的情况，因为这些情况会产生大量的 Class 信息存储于方法区。过多的常量尤其是字符串也会导致方法区溢出。</li><li>这种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m -XX:MaxPermSize&#x3D;256m 的形式修改。</li></ul><h3 id="92-4-排查方式："><a href="#92-4-排查方式：" class="headerlink" title="92.4 排查方式："></a>92.4 排查方式：</h3><ul><li>先获取内存的 Dump 文件，Dump 文件有两种方式来生成：<ul><li>第一种是配置 JVM 启动参数，当触发了 OOM 异常的时候自动生成，</li><li>第二种是使用 jmap 工具来生成。</li></ul></li><li>然后使用 MAT 工具来分析 Dump 文件。<ul><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类信息和 GC Roots 引用链的信息，就可以比较准确地定位泄漏代码的位置。</li><li>如果是普通的内存溢出，确实有很多占用内存的对象，那就只需要提升堆内存空间即可。</li></ul></li></ul></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://wxzhou.top/2021/06/08/%E9%9D%A2%E8%AF%95-java/" title="面试-Java" target="_blank" rel="external">https://wxzhou.top/2021/06/08/面试-java/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/wx-zhou" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/wx-zhou" target="_blank"><span class="text-dark">wxzhou</span><small class="ml-1x">Java Development</small></a></h3><div>个人简介。</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2021/06/08/%E9%9D%A2%E8%AF%95-kafka/" title="面试-kafka"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a></li><li class="next"><a href="/2021/06/08/%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/" title="面试-算法"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>Maybe you could buy me a cup of coffee.</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan"></div><p class="text-muted mv">Scan this qrcode</p><p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan"></div><p class="text-muted mv">Scan this qrcode</p><p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/wx-zhou" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/wxzhou" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2020-2024 <a href="https://wxzhou.top/" target="_blank">wxzhou</a><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"fPfDFgAyNvmw7q4OorZQyteK-gzGzoHsz",appKey:"4DRPTMYndqchd1TRUdHRcz6Q",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html>